/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const VULKAN_H_: u32 = 1;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const VULKAN_CORE_H_: u32 = 1;
pub const VK_VERSION_1_0: u32 = 1;
pub const VK_USE_64_BIT_PTR_DEFINES: u32 = 1;
pub const VK_HEADER_VERSION: u32 = 236;
pub const VK_ATTACHMENT_UNUSED: i32 = -1;
pub const VK_FALSE: u32 = 0;
pub const VK_LOD_CLAMP_NONE: f64 = 1000.0;
pub const VK_QUEUE_FAMILY_IGNORED: i32 = -1;
pub const VK_REMAINING_ARRAY_LAYERS: i32 = -1;
pub const VK_REMAINING_MIP_LEVELS: i32 = -1;
pub const VK_SUBPASS_EXTERNAL: i32 = -1;
pub const VK_TRUE: u32 = 1;
pub const VK_WHOLE_SIZE: i32 = -1;
pub const VK_MAX_MEMORY_TYPES: u32 = 32;
pub const VK_MAX_PHYSICAL_DEVICE_NAME_SIZE: u32 = 256;
pub const VK_UUID_SIZE: u32 = 16;
pub const VK_MAX_EXTENSION_NAME_SIZE: u32 = 256;
pub const VK_MAX_DESCRIPTION_SIZE: u32 = 256;
pub const VK_MAX_MEMORY_HEAPS: u32 = 16;
pub const VK_VERSION_1_1: u32 = 1;
pub const VK_MAX_DEVICE_GROUP_SIZE: u32 = 32;
pub const VK_LUID_SIZE: u32 = 8;
pub const VK_QUEUE_FAMILY_EXTERNAL: i32 = -2;
pub const VK_VERSION_1_2: u32 = 1;
pub const VK_MAX_DRIVER_NAME_SIZE: u32 = 256;
pub const VK_MAX_DRIVER_INFO_SIZE: u32 = 256;
pub const VK_VERSION_1_3: u32 = 1;
pub const VK_KHR_surface: u32 = 1;
pub const VK_KHR_SURFACE_SPEC_VERSION: u32 = 25;
pub const VK_KHR_SURFACE_EXTENSION_NAME: &[u8; 15usize] = b"VK_KHR_surface\0";
pub const VK_KHR_swapchain: u32 = 1;
pub const VK_KHR_SWAPCHAIN_SPEC_VERSION: u32 = 70;
pub const VK_KHR_SWAPCHAIN_EXTENSION_NAME: &[u8; 17usize] = b"VK_KHR_swapchain\0";
pub const VK_KHR_display: u32 = 1;
pub const VK_KHR_DISPLAY_SPEC_VERSION: u32 = 23;
pub const VK_KHR_DISPLAY_EXTENSION_NAME: &[u8; 15usize] = b"VK_KHR_display\0";
pub const VK_KHR_display_swapchain: u32 = 1;
pub const VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION: u32 = 10;
pub const VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME: &[u8; 25usize] = b"VK_KHR_display_swapchain\0";
pub const VK_KHR_sampler_mirror_clamp_to_edge: u32 = 1;
pub const VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION: u32 = 3;
pub const VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME: &[u8; 36usize] =
    b"VK_KHR_sampler_mirror_clamp_to_edge\0";
pub const VK_KHR_dynamic_rendering: u32 = 1;
pub const VK_KHR_DYNAMIC_RENDERING_SPEC_VERSION: u32 = 1;
pub const VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME: &[u8; 25usize] = b"VK_KHR_dynamic_rendering\0";
pub const VK_KHR_multiview: u32 = 1;
pub const VK_KHR_MULTIVIEW_SPEC_VERSION: u32 = 1;
pub const VK_KHR_MULTIVIEW_EXTENSION_NAME: &[u8; 17usize] = b"VK_KHR_multiview\0";
pub const VK_KHR_get_physical_device_properties2: u32 = 1;
pub const VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION: u32 = 2;
pub const VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME: &[u8; 39usize] =
    b"VK_KHR_get_physical_device_properties2\0";
pub const VK_KHR_device_group: u32 = 1;
pub const VK_KHR_DEVICE_GROUP_SPEC_VERSION: u32 = 4;
pub const VK_KHR_DEVICE_GROUP_EXTENSION_NAME: &[u8; 20usize] = b"VK_KHR_device_group\0";
pub const VK_KHR_shader_draw_parameters: u32 = 1;
pub const VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_KHR_shader_draw_parameters\0";
pub const VK_KHR_maintenance1: u32 = 1;
pub const VK_KHR_MAINTENANCE_1_SPEC_VERSION: u32 = 2;
pub const VK_KHR_MAINTENANCE_1_EXTENSION_NAME: &[u8; 20usize] = b"VK_KHR_maintenance1\0";
pub const VK_KHR_MAINTENANCE1_SPEC_VERSION: u32 = 2;
pub const VK_KHR_MAINTENANCE1_EXTENSION_NAME: &[u8; 20usize] = b"VK_KHR_maintenance1\0";
pub const VK_KHR_device_group_creation: u32 = 1;
pub const VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION: u32 = 1;
pub const VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_KHR_device_group_creation\0";
pub const VK_MAX_DEVICE_GROUP_SIZE_KHR: u32 = 32;
pub const VK_KHR_external_memory_capabilities: u32 = 1;
pub const VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME: &[u8; 36usize] =
    b"VK_KHR_external_memory_capabilities\0";
pub const VK_LUID_SIZE_KHR: u32 = 8;
pub const VK_KHR_external_memory: u32 = 1;
pub const VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME: &[u8; 23usize] = b"VK_KHR_external_memory\0";
pub const VK_QUEUE_FAMILY_EXTERNAL_KHR: i32 = -2;
pub const VK_KHR_external_memory_fd: u32 = 1;
pub const VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME: &[u8; 26usize] = b"VK_KHR_external_memory_fd\0";
pub const VK_KHR_external_semaphore_capabilities: u32 = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME: &[u8; 39usize] =
    b"VK_KHR_external_semaphore_capabilities\0";
pub const VK_KHR_external_semaphore: u32 = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME: &[u8; 26usize] = b"VK_KHR_external_semaphore\0";
pub const VK_KHR_external_semaphore_fd: u32 = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_KHR_external_semaphore_fd\0";
pub const VK_KHR_push_descriptor: u32 = 1;
pub const VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION: u32 = 2;
pub const VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME: &[u8; 23usize] = b"VK_KHR_push_descriptor\0";
pub const VK_KHR_shader_float16_int8: u32 = 1;
pub const VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_KHR_shader_float16_int8\0";
pub const VK_KHR_16bit_storage: u32 = 1;
pub const VK_KHR_16BIT_STORAGE_SPEC_VERSION: u32 = 1;
pub const VK_KHR_16BIT_STORAGE_EXTENSION_NAME: &[u8; 21usize] = b"VK_KHR_16bit_storage\0";
pub const VK_KHR_incremental_present: u32 = 1;
pub const VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION: u32 = 2;
pub const VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_KHR_incremental_present\0";
pub const VK_KHR_descriptor_update_template: u32 = 1;
pub const VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION: u32 = 1;
pub const VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME: &[u8; 34usize] =
    b"VK_KHR_descriptor_update_template\0";
pub const VK_KHR_imageless_framebuffer: u32 = 1;
pub const VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION: u32 = 1;
pub const VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_KHR_imageless_framebuffer\0";
pub const VK_KHR_create_renderpass2: u32 = 1;
pub const VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION: u32 = 1;
pub const VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME: &[u8; 26usize] =
    b"VK_KHR_create_renderpass2\0";
pub const VK_KHR_shared_presentable_image: u32 = 1;
pub const VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_KHR_shared_presentable_image\0";
pub const VK_KHR_external_fence_capabilities: u32 = 1;
pub const VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME: &[u8; 35usize] =
    b"VK_KHR_external_fence_capabilities\0";
pub const VK_KHR_external_fence: u32 = 1;
pub const VK_KHR_EXTERNAL_FENCE_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME: &[u8; 22usize] = b"VK_KHR_external_fence\0";
pub const VK_KHR_external_fence_fd: u32 = 1;
pub const VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION: u32 = 1;
pub const VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME: &[u8; 25usize] = b"VK_KHR_external_fence_fd\0";
pub const VK_KHR_performance_query: u32 = 1;
pub const VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION: u32 = 1;
pub const VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME: &[u8; 25usize] = b"VK_KHR_performance_query\0";
pub const VK_KHR_maintenance2: u32 = 1;
pub const VK_KHR_MAINTENANCE_2_SPEC_VERSION: u32 = 1;
pub const VK_KHR_MAINTENANCE_2_EXTENSION_NAME: &[u8; 20usize] = b"VK_KHR_maintenance2\0";
pub const VK_KHR_MAINTENANCE2_SPEC_VERSION: u32 = 1;
pub const VK_KHR_MAINTENANCE2_EXTENSION_NAME: &[u8; 20usize] = b"VK_KHR_maintenance2\0";
pub const VK_KHR_get_surface_capabilities2: u32 = 1;
pub const VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION: u32 = 1;
pub const VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME: &[u8; 33usize] =
    b"VK_KHR_get_surface_capabilities2\0";
pub const VK_KHR_variable_pointers: u32 = 1;
pub const VK_KHR_VARIABLE_POINTERS_SPEC_VERSION: u32 = 1;
pub const VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME: &[u8; 25usize] = b"VK_KHR_variable_pointers\0";
pub const VK_KHR_get_display_properties2: u32 = 1;
pub const VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION: u32 = 1;
pub const VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME: &[u8; 31usize] =
    b"VK_KHR_get_display_properties2\0";
pub const VK_KHR_dedicated_allocation: u32 = 1;
pub const VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION: u32 = 3;
pub const VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME: &[u8; 28usize] =
    b"VK_KHR_dedicated_allocation\0";
pub const VK_KHR_storage_buffer_storage_class: u32 = 1;
pub const VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION: u32 = 1;
pub const VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME: &[u8; 36usize] =
    b"VK_KHR_storage_buffer_storage_class\0";
pub const VK_KHR_relaxed_block_layout: u32 = 1;
pub const VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION: u32 = 1;
pub const VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME: &[u8; 28usize] =
    b"VK_KHR_relaxed_block_layout\0";
pub const VK_KHR_get_memory_requirements2: u32 = 1;
pub const VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION: u32 = 1;
pub const VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_KHR_get_memory_requirements2\0";
pub const VK_KHR_image_format_list: u32 = 1;
pub const VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION: u32 = 1;
pub const VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME: &[u8; 25usize] = b"VK_KHR_image_format_list\0";
pub const VK_KHR_sampler_ycbcr_conversion: u32 = 1;
pub const VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION: u32 = 14;
pub const VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_KHR_sampler_ycbcr_conversion\0";
pub const VK_KHR_bind_memory2: u32 = 1;
pub const VK_KHR_BIND_MEMORY_2_SPEC_VERSION: u32 = 1;
pub const VK_KHR_BIND_MEMORY_2_EXTENSION_NAME: &[u8; 20usize] = b"VK_KHR_bind_memory2\0";
pub const VK_KHR_maintenance3: u32 = 1;
pub const VK_KHR_MAINTENANCE_3_SPEC_VERSION: u32 = 1;
pub const VK_KHR_MAINTENANCE_3_EXTENSION_NAME: &[u8; 20usize] = b"VK_KHR_maintenance3\0";
pub const VK_KHR_MAINTENANCE3_SPEC_VERSION: u32 = 1;
pub const VK_KHR_MAINTENANCE3_EXTENSION_NAME: &[u8; 20usize] = b"VK_KHR_maintenance3\0";
pub const VK_KHR_draw_indirect_count: u32 = 1;
pub const VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION: u32 = 1;
pub const VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_KHR_draw_indirect_count\0";
pub const VK_KHR_shader_subgroup_extended_types: u32 = 1;
pub const VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME: &[u8; 38usize] =
    b"VK_KHR_shader_subgroup_extended_types\0";
pub const VK_KHR_8bit_storage: u32 = 1;
pub const VK_KHR_8BIT_STORAGE_SPEC_VERSION: u32 = 1;
pub const VK_KHR_8BIT_STORAGE_EXTENSION_NAME: &[u8; 20usize] = b"VK_KHR_8bit_storage\0";
pub const VK_KHR_shader_atomic_int64: u32 = 1;
pub const VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_KHR_shader_atomic_int64\0";
pub const VK_KHR_shader_clock: u32 = 1;
pub const VK_KHR_SHADER_CLOCK_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SHADER_CLOCK_EXTENSION_NAME: &[u8; 20usize] = b"VK_KHR_shader_clock\0";
pub const VK_KHR_global_priority: u32 = 1;
pub const VK_MAX_GLOBAL_PRIORITY_SIZE_KHR: u32 = 16;
pub const VK_KHR_GLOBAL_PRIORITY_SPEC_VERSION: u32 = 1;
pub const VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME: &[u8; 23usize] = b"VK_KHR_global_priority\0";
pub const VK_KHR_driver_properties: u32 = 1;
pub const VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION: u32 = 1;
pub const VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME: &[u8; 25usize] = b"VK_KHR_driver_properties\0";
pub const VK_MAX_DRIVER_NAME_SIZE_KHR: u32 = 256;
pub const VK_MAX_DRIVER_INFO_SIZE_KHR: u32 = 256;
pub const VK_KHR_shader_float_controls: u32 = 1;
pub const VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION: u32 = 4;
pub const VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_KHR_shader_float_controls\0";
pub const VK_KHR_depth_stencil_resolve: u32 = 1;
pub const VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION: u32 = 1;
pub const VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_KHR_depth_stencil_resolve\0";
pub const VK_KHR_swapchain_mutable_format: u32 = 1;
pub const VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_KHR_swapchain_mutable_format\0";
pub const VK_KHR_timeline_semaphore: u32 = 1;
pub const VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION: u32 = 2;
pub const VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME: &[u8; 26usize] = b"VK_KHR_timeline_semaphore\0";
pub const VK_KHR_vulkan_memory_model: u32 = 1;
pub const VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION: u32 = 3;
pub const VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_KHR_vulkan_memory_model\0";
pub const VK_KHR_shader_terminate_invocation: u32 = 1;
pub const VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME: &[u8; 35usize] =
    b"VK_KHR_shader_terminate_invocation\0";
pub const VK_KHR_fragment_shading_rate: u32 = 1;
pub const VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION: u32 = 2;
pub const VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_KHR_fragment_shading_rate\0";
pub const VK_KHR_spirv_1_4: u32 = 1;
pub const VK_KHR_SPIRV_1_4_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SPIRV_1_4_EXTENSION_NAME: &[u8; 17usize] = b"VK_KHR_spirv_1_4\0";
pub const VK_KHR_surface_protected_capabilities: u32 = 1;
pub const VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME: &[u8; 38usize] =
    b"VK_KHR_surface_protected_capabilities\0";
pub const VK_KHR_separate_depth_stencil_layouts: u32 = 1;
pub const VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME: &[u8; 38usize] =
    b"VK_KHR_separate_depth_stencil_layouts\0";
pub const VK_KHR_present_wait: u32 = 1;
pub const VK_KHR_PRESENT_WAIT_SPEC_VERSION: u32 = 1;
pub const VK_KHR_PRESENT_WAIT_EXTENSION_NAME: &[u8; 20usize] = b"VK_KHR_present_wait\0";
pub const VK_KHR_uniform_buffer_standard_layout: u32 = 1;
pub const VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION: u32 = 1;
pub const VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME: &[u8; 38usize] =
    b"VK_KHR_uniform_buffer_standard_layout\0";
pub const VK_KHR_buffer_device_address: u32 = 1;
pub const VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION: u32 = 1;
pub const VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_KHR_buffer_device_address\0";
pub const VK_KHR_deferred_host_operations: u32 = 1;
pub const VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION: u32 = 4;
pub const VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_KHR_deferred_host_operations\0";
pub const VK_KHR_pipeline_executable_properties: u32 = 1;
pub const VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION: u32 = 1;
pub const VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME: &[u8; 38usize] =
    b"VK_KHR_pipeline_executable_properties\0";
pub const VK_KHR_shader_integer_dot_product: u32 = 1;
pub const VK_KHR_SHADER_INTEGER_DOT_PRODUCT_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME: &[u8; 34usize] =
    b"VK_KHR_shader_integer_dot_product\0";
pub const VK_KHR_pipeline_library: u32 = 1;
pub const VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION: u32 = 1;
pub const VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME: &[u8; 24usize] = b"VK_KHR_pipeline_library\0";
pub const VK_KHR_shader_non_semantic_info: u32 = 1;
pub const VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_KHR_shader_non_semantic_info\0";
pub const VK_KHR_present_id: u32 = 1;
pub const VK_KHR_PRESENT_ID_SPEC_VERSION: u32 = 1;
pub const VK_KHR_PRESENT_ID_EXTENSION_NAME: &[u8; 18usize] = b"VK_KHR_present_id\0";
pub const VK_KHR_synchronization2: u32 = 1;
pub const VK_KHR_SYNCHRONIZATION_2_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME: &[u8; 24usize] = b"VK_KHR_synchronization2\0";
pub const VK_KHR_fragment_shader_barycentric: u32 = 1;
pub const VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION: u32 = 1;
pub const VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME: &[u8; 35usize] =
    b"VK_KHR_fragment_shader_barycentric\0";
pub const VK_KHR_shader_subgroup_uniform_control_flow: u32 = 1;
pub const VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_SPEC_VERSION: u32 = 1;
pub const VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME: &[u8; 44usize] =
    b"VK_KHR_shader_subgroup_uniform_control_flow\0";
pub const VK_KHR_zero_initialize_workgroup_memory: u32 = 1;
pub const VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_SPEC_VERSION: u32 = 1;
pub const VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME: &[u8; 40usize] =
    b"VK_KHR_zero_initialize_workgroup_memory\0";
pub const VK_KHR_workgroup_memory_explicit_layout: u32 = 1;
pub const VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_SPEC_VERSION: u32 = 1;
pub const VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME: &[u8; 40usize] =
    b"VK_KHR_workgroup_memory_explicit_layout\0";
pub const VK_KHR_copy_commands2: u32 = 1;
pub const VK_KHR_COPY_COMMANDS_2_SPEC_VERSION: u32 = 1;
pub const VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME: &[u8; 22usize] = b"VK_KHR_copy_commands2\0";
pub const VK_KHR_format_feature_flags2: u32 = 1;
pub const VK_KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION: u32 = 2;
pub const VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_KHR_format_feature_flags2\0";
pub const VK_KHR_ray_tracing_maintenance1: u32 = 1;
pub const VK_KHR_RAY_TRACING_MAINTENANCE_1_SPEC_VERSION: u32 = 1;
pub const VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_KHR_ray_tracing_maintenance1\0";
pub const VK_KHR_portability_enumeration: u32 = 1;
pub const VK_KHR_PORTABILITY_ENUMERATION_SPEC_VERSION: u32 = 1;
pub const VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME: &[u8; 31usize] =
    b"VK_KHR_portability_enumeration\0";
pub const VK_KHR_maintenance4: u32 = 1;
pub const VK_KHR_MAINTENANCE_4_SPEC_VERSION: u32 = 2;
pub const VK_KHR_MAINTENANCE_4_EXTENSION_NAME: &[u8; 20usize] = b"VK_KHR_maintenance4\0";
pub const VK_EXT_debug_report: u32 = 1;
pub const VK_EXT_DEBUG_REPORT_SPEC_VERSION: u32 = 10;
pub const VK_EXT_DEBUG_REPORT_EXTENSION_NAME: &[u8; 20usize] = b"VK_EXT_debug_report\0";
pub const VK_NV_glsl_shader: u32 = 1;
pub const VK_NV_GLSL_SHADER_SPEC_VERSION: u32 = 1;
pub const VK_NV_GLSL_SHADER_EXTENSION_NAME: &[u8; 18usize] = b"VK_NV_glsl_shader\0";
pub const VK_EXT_depth_range_unrestricted: u32 = 1;
pub const VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_EXT_depth_range_unrestricted\0";
pub const VK_IMG_filter_cubic: u32 = 1;
pub const VK_IMG_FILTER_CUBIC_SPEC_VERSION: u32 = 1;
pub const VK_IMG_FILTER_CUBIC_EXTENSION_NAME: &[u8; 20usize] = b"VK_IMG_filter_cubic\0";
pub const VK_AMD_rasterization_order: u32 = 1;
pub const VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION: u32 = 1;
pub const VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_AMD_rasterization_order\0";
pub const VK_AMD_shader_trinary_minmax: u32 = 1;
pub const VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION: u32 = 1;
pub const VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_AMD_shader_trinary_minmax\0";
pub const VK_AMD_shader_explicit_vertex_parameter: u32 = 1;
pub const VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION: u32 = 1;
pub const VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME: &[u8; 40usize] =
    b"VK_AMD_shader_explicit_vertex_parameter\0";
pub const VK_EXT_debug_marker: u32 = 1;
pub const VK_EXT_DEBUG_MARKER_SPEC_VERSION: u32 = 4;
pub const VK_EXT_DEBUG_MARKER_EXTENSION_NAME: &[u8; 20usize] = b"VK_EXT_debug_marker\0";
pub const VK_AMD_gcn_shader: u32 = 1;
pub const VK_AMD_GCN_SHADER_SPEC_VERSION: u32 = 1;
pub const VK_AMD_GCN_SHADER_EXTENSION_NAME: &[u8; 18usize] = b"VK_AMD_gcn_shader\0";
pub const VK_NV_dedicated_allocation: u32 = 1;
pub const VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION: u32 = 1;
pub const VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_NV_dedicated_allocation\0";
pub const VK_EXT_transform_feedback: u32 = 1;
pub const VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION: u32 = 1;
pub const VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME: &[u8; 26usize] = b"VK_EXT_transform_feedback\0";
pub const VK_NVX_binary_import: u32 = 1;
pub const VK_NVX_BINARY_IMPORT_SPEC_VERSION: u32 = 1;
pub const VK_NVX_BINARY_IMPORT_EXTENSION_NAME: &[u8; 21usize] = b"VK_NVX_binary_import\0";
pub const VK_NVX_image_view_handle: u32 = 1;
pub const VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION: u32 = 2;
pub const VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME: &[u8; 25usize] = b"VK_NVX_image_view_handle\0";
pub const VK_AMD_draw_indirect_count: u32 = 1;
pub const VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION: u32 = 2;
pub const VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_AMD_draw_indirect_count\0";
pub const VK_AMD_negative_viewport_height: u32 = 1;
pub const VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION: u32 = 1;
pub const VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_AMD_negative_viewport_height\0";
pub const VK_AMD_gpu_shader_half_float: u32 = 1;
pub const VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION: u32 = 2;
pub const VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_AMD_gpu_shader_half_float\0";
pub const VK_AMD_shader_ballot: u32 = 1;
pub const VK_AMD_SHADER_BALLOT_SPEC_VERSION: u32 = 1;
pub const VK_AMD_SHADER_BALLOT_EXTENSION_NAME: &[u8; 21usize] = b"VK_AMD_shader_ballot\0";
pub const VK_AMD_texture_gather_bias_lod: u32 = 1;
pub const VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION: u32 = 1;
pub const VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME: &[u8; 31usize] =
    b"VK_AMD_texture_gather_bias_lod\0";
pub const VK_AMD_shader_info: u32 = 1;
pub const VK_AMD_SHADER_INFO_SPEC_VERSION: u32 = 1;
pub const VK_AMD_SHADER_INFO_EXTENSION_NAME: &[u8; 19usize] = b"VK_AMD_shader_info\0";
pub const VK_AMD_shader_image_load_store_lod: u32 = 1;
pub const VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION: u32 = 1;
pub const VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME: &[u8; 35usize] =
    b"VK_AMD_shader_image_load_store_lod\0";
pub const VK_NV_corner_sampled_image: u32 = 1;
pub const VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION: u32 = 2;
pub const VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_NV_corner_sampled_image\0";
pub const VK_IMG_format_pvrtc: u32 = 1;
pub const VK_IMG_FORMAT_PVRTC_SPEC_VERSION: u32 = 1;
pub const VK_IMG_FORMAT_PVRTC_EXTENSION_NAME: &[u8; 20usize] = b"VK_IMG_format_pvrtc\0";
pub const VK_NV_external_memory_capabilities: u32 = 1;
pub const VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION: u32 = 1;
pub const VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME: &[u8; 35usize] =
    b"VK_NV_external_memory_capabilities\0";
pub const VK_NV_external_memory: u32 = 1;
pub const VK_NV_EXTERNAL_MEMORY_SPEC_VERSION: u32 = 1;
pub const VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME: &[u8; 22usize] = b"VK_NV_external_memory\0";
pub const VK_EXT_validation_flags: u32 = 1;
pub const VK_EXT_VALIDATION_FLAGS_SPEC_VERSION: u32 = 2;
pub const VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME: &[u8; 24usize] = b"VK_EXT_validation_flags\0";
pub const VK_EXT_shader_subgroup_ballot: u32 = 1;
pub const VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_EXT_shader_subgroup_ballot\0";
pub const VK_EXT_shader_subgroup_vote: u32 = 1;
pub const VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME: &[u8; 28usize] =
    b"VK_EXT_shader_subgroup_vote\0";
pub const VK_EXT_texture_compression_astc_hdr: u32 = 1;
pub const VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION: u32 = 1;
pub const VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME: &[u8; 36usize] =
    b"VK_EXT_texture_compression_astc_hdr\0";
pub const VK_EXT_astc_decode_mode: u32 = 1;
pub const VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME: &[u8; 24usize] = b"VK_EXT_astc_decode_mode\0";
pub const VK_EXT_pipeline_robustness: u32 = 1;
pub const VK_EXT_PIPELINE_ROBUSTNESS_SPEC_VERSION: u32 = 1;
pub const VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_EXT_pipeline_robustness\0";
pub const VK_EXT_conditional_rendering: u32 = 1;
pub const VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION: u32 = 2;
pub const VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_EXT_conditional_rendering\0";
pub const VK_NV_clip_space_w_scaling: u32 = 1;
pub const VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION: u32 = 1;
pub const VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_NV_clip_space_w_scaling\0";
pub const VK_EXT_direct_mode_display: u32 = 1;
pub const VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_EXT_direct_mode_display\0";
pub const VK_EXT_display_surface_counter: u32 = 1;
pub const VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME: &[u8; 31usize] =
    b"VK_EXT_display_surface_counter\0";
pub const VK_EXT_display_control: u32 = 1;
pub const VK_EXT_DISPLAY_CONTROL_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME: &[u8; 23usize] = b"VK_EXT_display_control\0";
pub const VK_GOOGLE_display_timing: u32 = 1;
pub const VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION: u32 = 1;
pub const VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME: &[u8; 25usize] = b"VK_GOOGLE_display_timing\0";
pub const VK_NV_sample_mask_override_coverage: u32 = 1;
pub const VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION: u32 = 1;
pub const VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME: &[u8; 36usize] =
    b"VK_NV_sample_mask_override_coverage\0";
pub const VK_NV_geometry_shader_passthrough: u32 = 1;
pub const VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION: u32 = 1;
pub const VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME: &[u8; 34usize] =
    b"VK_NV_geometry_shader_passthrough\0";
pub const VK_NV_viewport_array2: u32 = 1;
pub const VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION: u32 = 1;
pub const VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME: &[u8; 22usize] = b"VK_NV_viewport_array2\0";
pub const VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION: u32 = 1;
pub const VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME: &[u8; 22usize] = b"VK_NV_viewport_array2\0";
pub const VK_NVX_multiview_per_view_attributes: u32 = 1;
pub const VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION: u32 = 1;
pub const VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME: &[u8; 37usize] =
    b"VK_NVX_multiview_per_view_attributes\0";
pub const VK_NV_viewport_swizzle: u32 = 1;
pub const VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION: u32 = 1;
pub const VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME: &[u8; 23usize] = b"VK_NV_viewport_swizzle\0";
pub const VK_EXT_discard_rectangles: u32 = 1;
pub const VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME: &[u8; 26usize] = b"VK_EXT_discard_rectangles\0";
pub const VK_EXT_conservative_rasterization: u32 = 1;
pub const VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION: u32 = 1;
pub const VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME: &[u8; 34usize] =
    b"VK_EXT_conservative_rasterization\0";
pub const VK_EXT_depth_clip_enable: u32 = 1;
pub const VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME: &[u8; 25usize] = b"VK_EXT_depth_clip_enable\0";
pub const VK_EXT_swapchain_colorspace: u32 = 1;
pub const VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION: u32 = 4;
pub const VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME: &[u8; 28usize] =
    b"VK_EXT_swapchain_colorspace\0";
pub const VK_EXT_hdr_metadata: u32 = 1;
pub const VK_EXT_HDR_METADATA_SPEC_VERSION: u32 = 2;
pub const VK_EXT_HDR_METADATA_EXTENSION_NAME: &[u8; 20usize] = b"VK_EXT_hdr_metadata\0";
pub const VK_EXT_external_memory_dma_buf: u32 = 1;
pub const VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION: u32 = 1;
pub const VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME: &[u8; 31usize] =
    b"VK_EXT_external_memory_dma_buf\0";
pub const VK_EXT_queue_family_foreign: u32 = 1;
pub const VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION: u32 = 1;
pub const VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME: &[u8; 28usize] =
    b"VK_EXT_queue_family_foreign\0";
pub const VK_QUEUE_FAMILY_FOREIGN_EXT: i32 = -3;
pub const VK_EXT_debug_utils: u32 = 1;
pub const VK_EXT_DEBUG_UTILS_SPEC_VERSION: u32 = 2;
pub const VK_EXT_DEBUG_UTILS_EXTENSION_NAME: &[u8; 19usize] = b"VK_EXT_debug_utils\0";
pub const VK_EXT_sampler_filter_minmax: u32 = 1;
pub const VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION: u32 = 2;
pub const VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_EXT_sampler_filter_minmax\0";
pub const VK_AMD_gpu_shader_int16: u32 = 1;
pub const VK_AMD_GPU_SHADER_INT16_SPEC_VERSION: u32 = 2;
pub const VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME: &[u8; 24usize] = b"VK_AMD_gpu_shader_int16\0";
pub const VK_AMD_mixed_attachment_samples: u32 = 1;
pub const VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION: u32 = 1;
pub const VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_AMD_mixed_attachment_samples\0";
pub const VK_AMD_shader_fragment_mask: u32 = 1;
pub const VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION: u32 = 1;
pub const VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME: &[u8; 28usize] =
    b"VK_AMD_shader_fragment_mask\0";
pub const VK_EXT_inline_uniform_block: u32 = 1;
pub const VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION: u32 = 1;
pub const VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME: &[u8; 28usize] =
    b"VK_EXT_inline_uniform_block\0";
pub const VK_EXT_shader_stencil_export: u32 = 1;
pub const VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_EXT_shader_stencil_export\0";
pub const VK_EXT_sample_locations: u32 = 1;
pub const VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME: &[u8; 24usize] = b"VK_EXT_sample_locations\0";
pub const VK_EXT_blend_operation_advanced: u32 = 1;
pub const VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION: u32 = 2;
pub const VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_EXT_blend_operation_advanced\0";
pub const VK_NV_fragment_coverage_to_color: u32 = 1;
pub const VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION: u32 = 1;
pub const VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME: &[u8; 33usize] =
    b"VK_NV_fragment_coverage_to_color\0";
pub const VK_NV_framebuffer_mixed_samples: u32 = 1;
pub const VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION: u32 = 1;
pub const VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_NV_framebuffer_mixed_samples\0";
pub const VK_NV_fill_rectangle: u32 = 1;
pub const VK_NV_FILL_RECTANGLE_SPEC_VERSION: u32 = 1;
pub const VK_NV_FILL_RECTANGLE_EXTENSION_NAME: &[u8; 21usize] = b"VK_NV_fill_rectangle\0";
pub const VK_NV_shader_sm_builtins: u32 = 1;
pub const VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION: u32 = 1;
pub const VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME: &[u8; 25usize] = b"VK_NV_shader_sm_builtins\0";
pub const VK_EXT_post_depth_coverage: u32 = 1;
pub const VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_EXT_post_depth_coverage\0";
pub const VK_EXT_image_drm_format_modifier: u32 = 1;
pub const VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION: u32 = 2;
pub const VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME: &[u8; 33usize] =
    b"VK_EXT_image_drm_format_modifier\0";
pub const VK_EXT_validation_cache: u32 = 1;
pub const VK_EXT_VALIDATION_CACHE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_VALIDATION_CACHE_EXTENSION_NAME: &[u8; 24usize] = b"VK_EXT_validation_cache\0";
pub const VK_EXT_descriptor_indexing: u32 = 1;
pub const VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION: u32 = 2;
pub const VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_EXT_descriptor_indexing\0";
pub const VK_EXT_shader_viewport_index_layer: u32 = 1;
pub const VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME: &[u8; 35usize] =
    b"VK_EXT_shader_viewport_index_layer\0";
pub const VK_NV_shading_rate_image: u32 = 1;
pub const VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION: u32 = 3;
pub const VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME: &[u8; 25usize] = b"VK_NV_shading_rate_image\0";
pub const VK_NV_ray_tracing: u32 = 1;
pub const VK_NV_RAY_TRACING_SPEC_VERSION: u32 = 3;
pub const VK_NV_RAY_TRACING_EXTENSION_NAME: &[u8; 18usize] = b"VK_NV_ray_tracing\0";
pub const VK_SHADER_UNUSED_KHR: i32 = -1;
pub const VK_SHADER_UNUSED_NV: i32 = -1;
pub const VK_NV_representative_fragment_test: u32 = 1;
pub const VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION: u32 = 2;
pub const VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME: &[u8; 35usize] =
    b"VK_NV_representative_fragment_test\0";
pub const VK_EXT_filter_cubic: u32 = 1;
pub const VK_EXT_FILTER_CUBIC_SPEC_VERSION: u32 = 3;
pub const VK_EXT_FILTER_CUBIC_EXTENSION_NAME: &[u8; 20usize] = b"VK_EXT_filter_cubic\0";
pub const VK_QCOM_render_pass_shader_resolve: u32 = 1;
pub const VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION: u32 = 4;
pub const VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME: &[u8; 35usize] =
    b"VK_QCOM_render_pass_shader_resolve\0";
pub const VK_EXT_global_priority: u32 = 1;
pub const VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION: u32 = 2;
pub const VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME: &[u8; 23usize] = b"VK_EXT_global_priority\0";
pub const VK_EXT_external_memory_host: u32 = 1;
pub const VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION: u32 = 1;
pub const VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME: &[u8; 28usize] =
    b"VK_EXT_external_memory_host\0";
pub const VK_AMD_buffer_marker: u32 = 1;
pub const VK_AMD_BUFFER_MARKER_SPEC_VERSION: u32 = 1;
pub const VK_AMD_BUFFER_MARKER_EXTENSION_NAME: &[u8; 21usize] = b"VK_AMD_buffer_marker\0";
pub const VK_AMD_pipeline_compiler_control: u32 = 1;
pub const VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION: u32 = 1;
pub const VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME: &[u8; 33usize] =
    b"VK_AMD_pipeline_compiler_control\0";
pub const VK_EXT_calibrated_timestamps: u32 = 1;
pub const VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION: u32 = 2;
pub const VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_EXT_calibrated_timestamps\0";
pub const VK_AMD_shader_core_properties: u32 = 1;
pub const VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION: u32 = 2;
pub const VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_AMD_shader_core_properties\0";
pub const VK_AMD_memory_overallocation_behavior: u32 = 1;
pub const VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION: u32 = 1;
pub const VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME: &[u8; 38usize] =
    b"VK_AMD_memory_overallocation_behavior\0";
pub const VK_EXT_vertex_attribute_divisor: u32 = 1;
pub const VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION: u32 = 3;
pub const VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_EXT_vertex_attribute_divisor\0";
pub const VK_EXT_pipeline_creation_feedback: u32 = 1;
pub const VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION: u32 = 1;
pub const VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME: &[u8; 34usize] =
    b"VK_EXT_pipeline_creation_feedback\0";
pub const VK_NV_shader_subgroup_partitioned: u32 = 1;
pub const VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION: u32 = 1;
pub const VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME: &[u8; 34usize] =
    b"VK_NV_shader_subgroup_partitioned\0";
pub const VK_NV_compute_shader_derivatives: u32 = 1;
pub const VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION: u32 = 1;
pub const VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME: &[u8; 33usize] =
    b"VK_NV_compute_shader_derivatives\0";
pub const VK_NV_mesh_shader: u32 = 1;
pub const VK_NV_MESH_SHADER_SPEC_VERSION: u32 = 1;
pub const VK_NV_MESH_SHADER_EXTENSION_NAME: &[u8; 18usize] = b"VK_NV_mesh_shader\0";
pub const VK_NV_fragment_shader_barycentric: u32 = 1;
pub const VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION: u32 = 1;
pub const VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME: &[u8; 34usize] =
    b"VK_NV_fragment_shader_barycentric\0";
pub const VK_NV_shader_image_footprint: u32 = 1;
pub const VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION: u32 = 2;
pub const VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_NV_shader_image_footprint\0";
pub const VK_NV_scissor_exclusive: u32 = 1;
pub const VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION: u32 = 1;
pub const VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME: &[u8; 24usize] = b"VK_NV_scissor_exclusive\0";
pub const VK_NV_device_diagnostic_checkpoints: u32 = 1;
pub const VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION: u32 = 2;
pub const VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME: &[u8; 36usize] =
    b"VK_NV_device_diagnostic_checkpoints\0";
pub const VK_INTEL_shader_integer_functions2: u32 = 1;
pub const VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION: u32 = 1;
pub const VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME: &[u8; 35usize] =
    b"VK_INTEL_shader_integer_functions2\0";
pub const VK_INTEL_performance_query: u32 = 1;
pub const VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION: u32 = 2;
pub const VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_INTEL_performance_query\0";
pub const VK_EXT_pci_bus_info: u32 = 1;
pub const VK_EXT_PCI_BUS_INFO_SPEC_VERSION: u32 = 2;
pub const VK_EXT_PCI_BUS_INFO_EXTENSION_NAME: &[u8; 20usize] = b"VK_EXT_pci_bus_info\0";
pub const VK_AMD_display_native_hdr: u32 = 1;
pub const VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION: u32 = 1;
pub const VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME: &[u8; 26usize] = b"VK_AMD_display_native_hdr\0";
pub const VK_EXT_fragment_density_map: u32 = 1;
pub const VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION: u32 = 2;
pub const VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME: &[u8; 28usize] =
    b"VK_EXT_fragment_density_map\0";
pub const VK_EXT_scalar_block_layout: u32 = 1;
pub const VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_EXT_scalar_block_layout\0";
pub const VK_GOOGLE_hlsl_functionality1: u32 = 1;
pub const VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION: u32 = 1;
pub const VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_GOOGLE_hlsl_functionality1\0";
pub const VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION: u32 = 1;
pub const VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_GOOGLE_hlsl_functionality1\0";
pub const VK_GOOGLE_decorate_string: u32 = 1;
pub const VK_GOOGLE_DECORATE_STRING_SPEC_VERSION: u32 = 1;
pub const VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME: &[u8; 26usize] = b"VK_GOOGLE_decorate_string\0";
pub const VK_EXT_subgroup_size_control: u32 = 1;
pub const VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION: u32 = 2;
pub const VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_EXT_subgroup_size_control\0";
pub const VK_AMD_shader_core_properties2: u32 = 1;
pub const VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION: u32 = 1;
pub const VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME: &[u8; 31usize] =
    b"VK_AMD_shader_core_properties2\0";
pub const VK_AMD_device_coherent_memory: u32 = 1;
pub const VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION: u32 = 1;
pub const VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_AMD_device_coherent_memory\0";
pub const VK_EXT_shader_image_atomic_int64: u32 = 1;
pub const VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME: &[u8; 33usize] =
    b"VK_EXT_shader_image_atomic_int64\0";
pub const VK_EXT_memory_budget: u32 = 1;
pub const VK_EXT_MEMORY_BUDGET_SPEC_VERSION: u32 = 1;
pub const VK_EXT_MEMORY_BUDGET_EXTENSION_NAME: &[u8; 21usize] = b"VK_EXT_memory_budget\0";
pub const VK_EXT_memory_priority: u32 = 1;
pub const VK_EXT_MEMORY_PRIORITY_SPEC_VERSION: u32 = 1;
pub const VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME: &[u8; 23usize] = b"VK_EXT_memory_priority\0";
pub const VK_NV_dedicated_allocation_image_aliasing: u32 = 1;
pub const VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION: u32 = 1;
pub const VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME: &[u8; 42usize] =
    b"VK_NV_dedicated_allocation_image_aliasing\0";
pub const VK_EXT_buffer_device_address: u32 = 1;
pub const VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION: u32 = 2;
pub const VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_EXT_buffer_device_address\0";
pub const VK_EXT_tooling_info: u32 = 1;
pub const VK_EXT_TOOLING_INFO_SPEC_VERSION: u32 = 1;
pub const VK_EXT_TOOLING_INFO_EXTENSION_NAME: &[u8; 20usize] = b"VK_EXT_tooling_info\0";
pub const VK_EXT_separate_stencil_usage: u32 = 1;
pub const VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_EXT_separate_stencil_usage\0";
pub const VK_EXT_validation_features: u32 = 1;
pub const VK_EXT_VALIDATION_FEATURES_SPEC_VERSION: u32 = 5;
pub const VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_EXT_validation_features\0";
pub const VK_NV_cooperative_matrix: u32 = 1;
pub const VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION: u32 = 1;
pub const VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME: &[u8; 25usize] = b"VK_NV_cooperative_matrix\0";
pub const VK_NV_coverage_reduction_mode: u32 = 1;
pub const VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION: u32 = 1;
pub const VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_NV_coverage_reduction_mode\0";
pub const VK_EXT_fragment_shader_interlock: u32 = 1;
pub const VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION: u32 = 1;
pub const VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME: &[u8; 33usize] =
    b"VK_EXT_fragment_shader_interlock\0";
pub const VK_EXT_ycbcr_image_arrays: u32 = 1;
pub const VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION: u32 = 1;
pub const VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME: &[u8; 26usize] = b"VK_EXT_ycbcr_image_arrays\0";
pub const VK_EXT_provoking_vertex: u32 = 1;
pub const VK_EXT_PROVOKING_VERTEX_SPEC_VERSION: u32 = 1;
pub const VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME: &[u8; 24usize] = b"VK_EXT_provoking_vertex\0";
pub const VK_EXT_headless_surface: u32 = 1;
pub const VK_EXT_HEADLESS_SURFACE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME: &[u8; 24usize] = b"VK_EXT_headless_surface\0";
pub const VK_EXT_line_rasterization: u32 = 1;
pub const VK_EXT_LINE_RASTERIZATION_SPEC_VERSION: u32 = 1;
pub const VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME: &[u8; 26usize] = b"VK_EXT_line_rasterization\0";
pub const VK_EXT_shader_atomic_float: u32 = 1;
pub const VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_EXT_shader_atomic_float\0";
pub const VK_EXT_host_query_reset: u32 = 1;
pub const VK_EXT_HOST_QUERY_RESET_SPEC_VERSION: u32 = 1;
pub const VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME: &[u8; 24usize] = b"VK_EXT_host_query_reset\0";
pub const VK_EXT_index_type_uint8: u32 = 1;
pub const VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION: u32 = 1;
pub const VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME: &[u8; 24usize] = b"VK_EXT_index_type_uint8\0";
pub const VK_EXT_extended_dynamic_state: u32 = 1;
pub const VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_EXT_extended_dynamic_state\0";
pub const VK_EXT_shader_atomic_float2: u32 = 1;
pub const VK_EXT_SHADER_ATOMIC_FLOAT_2_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME: &[u8; 28usize] =
    b"VK_EXT_shader_atomic_float2\0";
pub const VK_EXT_shader_demote_to_helper_invocation: u32 = 1;
pub const VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME: &[u8; 42usize] =
    b"VK_EXT_shader_demote_to_helper_invocation\0";
pub const VK_NV_device_generated_commands: u32 = 1;
pub const VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION: u32 = 3;
pub const VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_NV_device_generated_commands\0";
pub const VK_NV_inherited_viewport_scissor: u32 = 1;
pub const VK_NV_INHERITED_VIEWPORT_SCISSOR_SPEC_VERSION: u32 = 1;
pub const VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME: &[u8; 33usize] =
    b"VK_NV_inherited_viewport_scissor\0";
pub const VK_EXT_texel_buffer_alignment: u32 = 1;
pub const VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION: u32 = 1;
pub const VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_EXT_texel_buffer_alignment\0";
pub const VK_QCOM_render_pass_transform: u32 = 1;
pub const VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION: u32 = 3;
pub const VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_QCOM_render_pass_transform\0";
pub const VK_EXT_device_memory_report: u32 = 1;
pub const VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION: u32 = 2;
pub const VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME: &[u8; 28usize] =
    b"VK_EXT_device_memory_report\0";
pub const VK_EXT_acquire_drm_display: u32 = 1;
pub const VK_EXT_ACQUIRE_DRM_DISPLAY_SPEC_VERSION: u32 = 1;
pub const VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_EXT_acquire_drm_display\0";
pub const VK_EXT_robustness2: u32 = 1;
pub const VK_EXT_ROBUSTNESS_2_SPEC_VERSION: u32 = 1;
pub const VK_EXT_ROBUSTNESS_2_EXTENSION_NAME: &[u8; 19usize] = b"VK_EXT_robustness2\0";
pub const VK_EXT_custom_border_color: u32 = 1;
pub const VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION: u32 = 12;
pub const VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_EXT_custom_border_color\0";
pub const VK_GOOGLE_user_type: u32 = 1;
pub const VK_GOOGLE_USER_TYPE_SPEC_VERSION: u32 = 1;
pub const VK_GOOGLE_USER_TYPE_EXTENSION_NAME: &[u8; 20usize] = b"VK_GOOGLE_user_type\0";
pub const VK_NV_present_barrier: u32 = 1;
pub const VK_NV_PRESENT_BARRIER_SPEC_VERSION: u32 = 1;
pub const VK_NV_PRESENT_BARRIER_EXTENSION_NAME: &[u8; 22usize] = b"VK_NV_present_barrier\0";
pub const VK_EXT_private_data: u32 = 1;
pub const VK_EXT_PRIVATE_DATA_SPEC_VERSION: u32 = 1;
pub const VK_EXT_PRIVATE_DATA_EXTENSION_NAME: &[u8; 20usize] = b"VK_EXT_private_data\0";
pub const VK_EXT_pipeline_creation_cache_control: u32 = 1;
pub const VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION: u32 = 3;
pub const VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME: &[u8; 39usize] =
    b"VK_EXT_pipeline_creation_cache_control\0";
pub const VK_NV_device_diagnostics_config: u32 = 1;
pub const VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION: u32 = 2;
pub const VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_NV_device_diagnostics_config\0";
pub const VK_QCOM_render_pass_store_ops: u32 = 1;
pub const VK_QCOM_RENDER_PASS_STORE_OPS_SPEC_VERSION: u32 = 2;
pub const VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_QCOM_render_pass_store_ops\0";
pub const VK_EXT_descriptor_buffer: u32 = 1;
pub const VK_EXT_DESCRIPTOR_BUFFER_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME: &[u8; 25usize] = b"VK_EXT_descriptor_buffer\0";
pub const VK_EXT_graphics_pipeline_library: u32 = 1;
pub const VK_EXT_GRAPHICS_PIPELINE_LIBRARY_SPEC_VERSION: u32 = 1;
pub const VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME: &[u8; 33usize] =
    b"VK_EXT_graphics_pipeline_library\0";
pub const VK_AMD_shader_early_and_late_fragment_tests: u32 = 1;
pub const VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_SPEC_VERSION: u32 = 1;
pub const VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME: &[u8; 44usize] =
    b"VK_AMD_shader_early_and_late_fragment_tests\0";
pub const VK_NV_fragment_shading_rate_enums: u32 = 1;
pub const VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION: u32 = 1;
pub const VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME: &[u8; 34usize] =
    b"VK_NV_fragment_shading_rate_enums\0";
pub const VK_NV_ray_tracing_motion_blur: u32 = 1;
pub const VK_NV_RAY_TRACING_MOTION_BLUR_SPEC_VERSION: u32 = 1;
pub const VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_NV_ray_tracing_motion_blur\0";
pub const VK_EXT_ycbcr_2plane_444_formats: u32 = 1;
pub const VK_EXT_YCBCR_2PLANE_444_FORMATS_SPEC_VERSION: u32 = 1;
pub const VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_EXT_ycbcr_2plane_444_formats\0";
pub const VK_EXT_fragment_density_map2: u32 = 1;
pub const VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION: u32 = 1;
pub const VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_EXT_fragment_density_map2\0";
pub const VK_QCOM_rotated_copy_commands: u32 = 1;
pub const VK_QCOM_ROTATED_COPY_COMMANDS_SPEC_VERSION: u32 = 1;
pub const VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_QCOM_rotated_copy_commands\0";
pub const VK_EXT_image_robustness: u32 = 1;
pub const VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION: u32 = 1;
pub const VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME: &[u8; 24usize] = b"VK_EXT_image_robustness\0";
pub const VK_EXT_image_compression_control: u32 = 1;
pub const VK_EXT_IMAGE_COMPRESSION_CONTROL_SPEC_VERSION: u32 = 1;
pub const VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME: &[u8; 33usize] =
    b"VK_EXT_image_compression_control\0";
pub const VK_EXT_attachment_feedback_loop_layout: u32 = 1;
pub const VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_SPEC_VERSION: u32 = 2;
pub const VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME: &[u8; 39usize] =
    b"VK_EXT_attachment_feedback_loop_layout\0";
pub const VK_EXT_4444_formats: u32 = 1;
pub const VK_EXT_4444_FORMATS_SPEC_VERSION: u32 = 1;
pub const VK_EXT_4444_FORMATS_EXTENSION_NAME: &[u8; 20usize] = b"VK_EXT_4444_formats\0";
pub const VK_EXT_device_fault: u32 = 1;
pub const VK_EXT_DEVICE_FAULT_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DEVICE_FAULT_EXTENSION_NAME: &[u8; 20usize] = b"VK_EXT_device_fault\0";
pub const VK_ARM_rasterization_order_attachment_access: u32 = 1;
pub const VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION: u32 = 1;
pub const VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME: &[u8; 45usize] =
    b"VK_ARM_rasterization_order_attachment_access\0";
pub const VK_EXT_rgba10x6_formats: u32 = 1;
pub const VK_EXT_RGBA10X6_FORMATS_SPEC_VERSION: u32 = 1;
pub const VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME: &[u8; 24usize] = b"VK_EXT_rgba10x6_formats\0";
pub const VK_VALVE_mutable_descriptor_type: u32 = 1;
pub const VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION: u32 = 1;
pub const VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME: &[u8; 33usize] =
    b"VK_VALVE_mutable_descriptor_type\0";
pub const VK_EXT_vertex_input_dynamic_state: u32 = 1;
pub const VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_SPEC_VERSION: u32 = 2;
pub const VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME: &[u8; 34usize] =
    b"VK_EXT_vertex_input_dynamic_state\0";
pub const VK_EXT_physical_device_drm: u32 = 1;
pub const VK_EXT_PHYSICAL_DEVICE_DRM_SPEC_VERSION: u32 = 1;
pub const VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_EXT_physical_device_drm\0";
pub const VK_EXT_device_address_binding_report: u32 = 1;
pub const VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME: &[u8; 37usize] =
    b"VK_EXT_device_address_binding_report\0";
pub const VK_EXT_depth_clip_control: u32 = 1;
pub const VK_EXT_DEPTH_CLIP_CONTROL_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME: &[u8; 26usize] = b"VK_EXT_depth_clip_control\0";
pub const VK_EXT_primitive_topology_list_restart: u32 = 1;
pub const VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_SPEC_VERSION: u32 = 1;
pub const VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME: &[u8; 39usize] =
    b"VK_EXT_primitive_topology_list_restart\0";
pub const VK_HUAWEI_subpass_shading: u32 = 1;
pub const VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION: u32 = 2;
pub const VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME: &[u8; 26usize] = b"VK_HUAWEI_subpass_shading\0";
pub const VK_HUAWEI_invocation_mask: u32 = 1;
pub const VK_HUAWEI_INVOCATION_MASK_SPEC_VERSION: u32 = 1;
pub const VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME: &[u8; 26usize] = b"VK_HUAWEI_invocation_mask\0";
pub const VK_NV_external_memory_rdma: u32 = 1;
pub const VK_NV_EXTERNAL_MEMORY_RDMA_SPEC_VERSION: u32 = 1;
pub const VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_NV_external_memory_rdma\0";
pub const VK_EXT_pipeline_properties: u32 = 1;
pub const VK_EXT_PIPELINE_PROPERTIES_SPEC_VERSION: u32 = 1;
pub const VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_EXT_pipeline_properties\0";
pub const VK_EXT_multisampled_render_to_single_sampled: u32 = 1;
pub const VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_SPEC_VERSION: u32 = 1;
pub const VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME: &[u8; 45usize] =
    b"VK_EXT_multisampled_render_to_single_sampled\0";
pub const VK_EXT_extended_dynamic_state2: u32 = 1;
pub const VK_EXT_EXTENDED_DYNAMIC_STATE_2_SPEC_VERSION: u32 = 1;
pub const VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME: &[u8; 31usize] =
    b"VK_EXT_extended_dynamic_state2\0";
pub const VK_EXT_color_write_enable: u32 = 1;
pub const VK_EXT_COLOR_WRITE_ENABLE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME: &[u8; 26usize] = b"VK_EXT_color_write_enable\0";
pub const VK_EXT_primitives_generated_query: u32 = 1;
pub const VK_EXT_PRIMITIVES_GENERATED_QUERY_SPEC_VERSION: u32 = 1;
pub const VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME: &[u8; 34usize] =
    b"VK_EXT_primitives_generated_query\0";
pub const VK_EXT_global_priority_query: u32 = 1;
pub const VK_EXT_GLOBAL_PRIORITY_QUERY_SPEC_VERSION: u32 = 1;
pub const VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_EXT_global_priority_query\0";
pub const VK_MAX_GLOBAL_PRIORITY_SIZE_EXT: u32 = 16;
pub const VK_EXT_image_view_min_lod: u32 = 1;
pub const VK_EXT_IMAGE_VIEW_MIN_LOD_SPEC_VERSION: u32 = 1;
pub const VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME: &[u8; 26usize] = b"VK_EXT_image_view_min_lod\0";
pub const VK_EXT_multi_draw: u32 = 1;
pub const VK_EXT_MULTI_DRAW_SPEC_VERSION: u32 = 1;
pub const VK_EXT_MULTI_DRAW_EXTENSION_NAME: &[u8; 18usize] = b"VK_EXT_multi_draw\0";
pub const VK_EXT_image_2d_view_of_3d: u32 = 1;
pub const VK_EXT_IMAGE_2D_VIEW_OF_3D_SPEC_VERSION: u32 = 1;
pub const VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_EXT_image_2d_view_of_3d\0";
pub const VK_EXT_opacity_micromap: u32 = 1;
pub const VK_EXT_OPACITY_MICROMAP_SPEC_VERSION: u32 = 2;
pub const VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME: &[u8; 24usize] = b"VK_EXT_opacity_micromap\0";
pub const VK_EXT_load_store_op_none: u32 = 1;
pub const VK_EXT_LOAD_STORE_OP_NONE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME: &[u8; 26usize] = b"VK_EXT_load_store_op_none\0";
pub const VK_EXT_border_color_swizzle: u32 = 1;
pub const VK_EXT_BORDER_COLOR_SWIZZLE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME: &[u8; 28usize] =
    b"VK_EXT_border_color_swizzle\0";
pub const VK_EXT_pageable_device_local_memory: u32 = 1;
pub const VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_SPEC_VERSION: u32 = 1;
pub const VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME: &[u8; 36usize] =
    b"VK_EXT_pageable_device_local_memory\0";
pub const VK_VALVE_descriptor_set_host_mapping: u32 = 1;
pub const VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_SPEC_VERSION: u32 = 1;
pub const VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME: &[u8; 37usize] =
    b"VK_VALVE_descriptor_set_host_mapping\0";
pub const VK_EXT_depth_clamp_zero_one: u32 = 1;
pub const VK_EXT_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME: &[u8; 28usize] =
    b"VK_EXT_depth_clamp_zero_one\0";
pub const VK_EXT_non_seamless_cube_map: u32 = 1;
pub const VK_EXT_NON_SEAMLESS_CUBE_MAP_SPEC_VERSION: u32 = 1;
pub const VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME: &[u8; 29usize] =
    b"VK_EXT_non_seamless_cube_map\0";
pub const VK_QCOM_fragment_density_map_offset: u32 = 1;
pub const VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION: u32 = 1;
pub const VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME: &[u8; 36usize] =
    b"VK_QCOM_fragment_density_map_offset\0";
pub const VK_NV_copy_memory_indirect: u32 = 1;
pub const VK_NV_COPY_MEMORY_INDIRECT_SPEC_VERSION: u32 = 1;
pub const VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_NV_copy_memory_indirect\0";
pub const VK_NV_memory_decompression: u32 = 1;
pub const VK_NV_MEMORY_DECOMPRESSION_SPEC_VERSION: u32 = 1;
pub const VK_NV_MEMORY_DECOMPRESSION_EXTENSION_NAME: &[u8; 27usize] =
    b"VK_NV_memory_decompression\0";
pub const VK_NV_linear_color_attachment: u32 = 1;
pub const VK_NV_LINEAR_COLOR_ATTACHMENT_SPEC_VERSION: u32 = 1;
pub const VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_NV_linear_color_attachment\0";
pub const VK_GOOGLE_surfaceless_query: u32 = 1;
pub const VK_GOOGLE_SURFACELESS_QUERY_SPEC_VERSION: u32 = 2;
pub const VK_GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME: &[u8; 28usize] =
    b"VK_GOOGLE_surfaceless_query\0";
pub const VK_EXT_image_compression_control_swapchain: u32 = 1;
pub const VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_SPEC_VERSION: u32 = 1;
pub const VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME: &[u8; 43usize] =
    b"VK_EXT_image_compression_control_swapchain\0";
pub const VK_QCOM_image_processing: u32 = 1;
pub const VK_QCOM_IMAGE_PROCESSING_SPEC_VERSION: u32 = 1;
pub const VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME: &[u8; 25usize] = b"VK_QCOM_image_processing\0";
pub const VK_EXT_extended_dynamic_state3: u32 = 1;
pub const VK_EXT_EXTENDED_DYNAMIC_STATE_3_SPEC_VERSION: u32 = 2;
pub const VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME: &[u8; 31usize] =
    b"VK_EXT_extended_dynamic_state3\0";
pub const VK_EXT_subpass_merge_feedback: u32 = 1;
pub const VK_EXT_SUBPASS_MERGE_FEEDBACK_SPEC_VERSION: u32 = 2;
pub const VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_EXT_subpass_merge_feedback\0";
pub const VK_LUNARG_direct_driver_loading: u32 = 1;
pub const VK_LUNARG_DIRECT_DRIVER_LOADING_SPEC_VERSION: u32 = 1;
pub const VK_LUNARG_DIRECT_DRIVER_LOADING_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_LUNARG_direct_driver_loading\0";
pub const VK_EXT_shader_module_identifier: u32 = 1;
pub const VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT: u32 = 32;
pub const VK_EXT_SHADER_MODULE_IDENTIFIER_SPEC_VERSION: u32 = 1;
pub const VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME: &[u8; 32usize] =
    b"VK_EXT_shader_module_identifier\0";
pub const VK_EXT_rasterization_order_attachment_access: u32 = 1;
pub const VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION: u32 = 1;
pub const VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME: &[u8; 45usize] =
    b"VK_EXT_rasterization_order_attachment_access\0";
pub const VK_NV_optical_flow: u32 = 1;
pub const VK_NV_OPTICAL_FLOW_SPEC_VERSION: u32 = 1;
pub const VK_NV_OPTICAL_FLOW_EXTENSION_NAME: &[u8; 19usize] = b"VK_NV_optical_flow\0";
pub const VK_EXT_legacy_dithering: u32 = 1;
pub const VK_EXT_LEGACY_DITHERING_SPEC_VERSION: u32 = 1;
pub const VK_EXT_LEGACY_DITHERING_EXTENSION_NAME: &[u8; 24usize] = b"VK_EXT_legacy_dithering\0";
pub const VK_EXT_pipeline_protected_access: u32 = 1;
pub const VK_EXT_PIPELINE_PROTECTED_ACCESS_SPEC_VERSION: u32 = 1;
pub const VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME: &[u8; 33usize] =
    b"VK_EXT_pipeline_protected_access\0";
pub const VK_QCOM_tile_properties: u32 = 1;
pub const VK_QCOM_TILE_PROPERTIES_SPEC_VERSION: u32 = 1;
pub const VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME: &[u8; 24usize] = b"VK_QCOM_tile_properties\0";
pub const VK_SEC_amigo_profiling: u32 = 1;
pub const VK_SEC_AMIGO_PROFILING_SPEC_VERSION: u32 = 1;
pub const VK_SEC_AMIGO_PROFILING_EXTENSION_NAME: &[u8; 23usize] = b"VK_SEC_amigo_profiling\0";
pub const VK_QCOM_multiview_per_view_viewports: u32 = 1;
pub const VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_SPEC_VERSION: u32 = 1;
pub const VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME: &[u8; 37usize] =
    b"VK_QCOM_multiview_per_view_viewports\0";
pub const VK_NV_ray_tracing_invocation_reorder: u32 = 1;
pub const VK_NV_RAY_TRACING_INVOCATION_REORDER_SPEC_VERSION: u32 = 1;
pub const VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME: &[u8; 37usize] =
    b"VK_NV_ray_tracing_invocation_reorder\0";
pub const VK_EXT_mutable_descriptor_type: u32 = 1;
pub const VK_EXT_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION: u32 = 1;
pub const VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME: &[u8; 31usize] =
    b"VK_EXT_mutable_descriptor_type\0";
pub const VK_ARM_shader_core_builtins: u32 = 1;
pub const VK_ARM_SHADER_CORE_BUILTINS_SPEC_VERSION: u32 = 2;
pub const VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME: &[u8; 28usize] =
    b"VK_ARM_shader_core_builtins\0";
pub const VK_KHR_acceleration_structure: u32 = 1;
pub const VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION: u32 = 13;
pub const VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME: &[u8; 30usize] =
    b"VK_KHR_acceleration_structure\0";
pub const VK_KHR_ray_tracing_pipeline: u32 = 1;
pub const VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION: u32 = 1;
pub const VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME: &[u8; 28usize] =
    b"VK_KHR_ray_tracing_pipeline\0";
pub const VK_KHR_ray_query: u32 = 1;
pub const VK_KHR_RAY_QUERY_SPEC_VERSION: u32 = 1;
pub const VK_KHR_RAY_QUERY_EXTENSION_NAME: &[u8; 17usize] = b"VK_KHR_ray_query\0";
pub const VK_EXT_mesh_shader: u32 = 1;
pub const VK_EXT_MESH_SHADER_SPEC_VERSION: u32 = 1;
pub const VK_EXT_MESH_SHADER_EXTENSION_NAME: &[u8; 19usize] = b"VK_EXT_mesh_shader\0";
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type VkBool32 = u32;
pub type VkDeviceAddress = u64;
pub type VkDeviceSize = u64;
pub type VkFlags = u32;
pub type VkSampleMask = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBuffer_T {
    _unused: [u8; 0],
}
pub type VkBuffer = *mut VkBuffer_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImage_T {
    _unused: [u8; 0],
}
pub type VkImage = *mut VkImage_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkInstance_T {
    _unused: [u8; 0],
}
pub type VkInstance = *mut VkInstance_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevice_T {
    _unused: [u8; 0],
}
pub type VkPhysicalDevice = *mut VkPhysicalDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDevice_T {
    _unused: [u8; 0],
}
pub type VkDevice = *mut VkDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueue_T {
    _unused: [u8; 0],
}
pub type VkQueue = *mut VkQueue_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSemaphore_T {
    _unused: [u8; 0],
}
pub type VkSemaphore = *mut VkSemaphore_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBuffer_T {
    _unused: [u8; 0],
}
pub type VkCommandBuffer = *mut VkCommandBuffer_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFence_T {
    _unused: [u8; 0],
}
pub type VkFence = *mut VkFence_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceMemory_T {
    _unused: [u8; 0],
}
pub type VkDeviceMemory = *mut VkDeviceMemory_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkEvent_T {
    _unused: [u8; 0],
}
pub type VkEvent = *mut VkEvent_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueryPool_T {
    _unused: [u8; 0],
}
pub type VkQueryPool = *mut VkQueryPool_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferView_T {
    _unused: [u8; 0],
}
pub type VkBufferView = *mut VkBufferView_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageView_T {
    _unused: [u8; 0],
}
pub type VkImageView = *mut VkImageView_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkShaderModule_T {
    _unused: [u8; 0],
}
pub type VkShaderModule = *mut VkShaderModule_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCache_T {
    _unused: [u8; 0],
}
pub type VkPipelineCache = *mut VkPipelineCache_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineLayout_T {
    _unused: [u8; 0],
}
pub type VkPipelineLayout = *mut VkPipelineLayout_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipeline_T {
    _unused: [u8; 0],
}
pub type VkPipeline = *mut VkPipeline_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPass_T {
    _unused: [u8; 0],
}
pub type VkRenderPass = *mut VkRenderPass_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetLayout_T {
    _unused: [u8; 0],
}
pub type VkDescriptorSetLayout = *mut VkDescriptorSetLayout_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSampler_T {
    _unused: [u8; 0],
}
pub type VkSampler = *mut VkSampler_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSet_T {
    _unused: [u8; 0],
}
pub type VkDescriptorSet = *mut VkDescriptorSet_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorPool_T {
    _unused: [u8; 0],
}
pub type VkDescriptorPool = *mut VkDescriptorPool_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFramebuffer_T {
    _unused: [u8; 0],
}
pub type VkFramebuffer = *mut VkFramebuffer_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandPool_T {
    _unused: [u8; 0],
}
pub type VkCommandPool = *mut VkCommandPool_T;
impl VkResult {
    pub const VK_ERROR_OUT_OF_POOL_MEMORY_KHR: VkResult = VkResult::VK_ERROR_OUT_OF_POOL_MEMORY;
}
impl VkResult {
    pub const VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR: VkResult =
        VkResult::VK_ERROR_INVALID_EXTERNAL_HANDLE;
}
impl VkResult {
    pub const VK_ERROR_FRAGMENTATION_EXT: VkResult = VkResult::VK_ERROR_FRAGMENTATION;
}
impl VkResult {
    pub const VK_ERROR_NOT_PERMITTED_EXT: VkResult = VkResult::VK_ERROR_NOT_PERMITTED_KHR;
}
impl VkResult {
    pub const VK_ERROR_INVALID_DEVICE_ADDRESS_EXT: VkResult =
        VkResult::VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
}
impl VkResult {
    pub const VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR: VkResult =
        VkResult::VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS;
}
impl VkResult {
    pub const VK_PIPELINE_COMPILE_REQUIRED_EXT: VkResult = VkResult::VK_PIPELINE_COMPILE_REQUIRED;
}
impl VkResult {
    pub const VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT: VkResult =
        VkResult::VK_PIPELINE_COMPILE_REQUIRED;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VkResult {
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_FRAGMENTED_POOL = -12,
    VK_ERROR_UNKNOWN = -13,
    VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
    VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
    VK_ERROR_FRAGMENTATION = -1000161000,
    VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
    VK_PIPELINE_COMPILE_REQUIRED = 1000297000,
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    VK_SUBOPTIMAL_KHR = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
    VK_ERROR_INVALID_SHADER_NV = -1000012000,
    VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
    VK_ERROR_NOT_PERMITTED_KHR = -1000174001,
    VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
    VK_THREAD_IDLE_KHR = 1000268000,
    VK_THREAD_DONE_KHR = 1000268001,
    VK_OPERATION_DEFERRED_KHR = 1000268002,
    VK_OPERATION_NOT_DEFERRED_KHR = 1000268003,
    VK_ERROR_COMPRESSION_EXHAUSTED_EXT = -1000338000,
    VK_RESULT_MAX_ENUM = 2147483647,
}
pub const VK_STRUCTURE_TYPE_APPLICATION_INFO: VkStructureType = 0;
pub const VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO: VkStructureType = 1;
pub const VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO: VkStructureType = 2;
pub const VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO: VkStructureType = 3;
pub const VK_STRUCTURE_TYPE_SUBMIT_INFO: VkStructureType = 4;
pub const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO: VkStructureType = 5;
pub const VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE: VkStructureType = 6;
pub const VK_STRUCTURE_TYPE_BIND_SPARSE_INFO: VkStructureType = 7;
pub const VK_STRUCTURE_TYPE_FENCE_CREATE_INFO: VkStructureType = 8;
pub const VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO: VkStructureType = 9;
pub const VK_STRUCTURE_TYPE_EVENT_CREATE_INFO: VkStructureType = 10;
pub const VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO: VkStructureType = 11;
pub const VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO: VkStructureType = 12;
pub const VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO: VkStructureType = 13;
pub const VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO: VkStructureType = 14;
pub const VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO: VkStructureType = 15;
pub const VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO: VkStructureType = 16;
pub const VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO: VkStructureType = 17;
pub const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO: VkStructureType = 18;
pub const VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO: VkStructureType = 19;
pub const VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO: VkStructureType = 20;
pub const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO: VkStructureType = 21;
pub const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO: VkStructureType = 22;
pub const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO: VkStructureType = 23;
pub const VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO: VkStructureType = 24;
pub const VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO: VkStructureType = 25;
pub const VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO: VkStructureType = 26;
pub const VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO: VkStructureType = 27;
pub const VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO: VkStructureType = 28;
pub const VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO: VkStructureType = 29;
pub const VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO: VkStructureType = 30;
pub const VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO: VkStructureType = 31;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO: VkStructureType = 32;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO: VkStructureType = 33;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO: VkStructureType = 34;
pub const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET: VkStructureType = 35;
pub const VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET: VkStructureType = 36;
pub const VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO: VkStructureType = 37;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO: VkStructureType = 38;
pub const VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO: VkStructureType = 39;
pub const VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO: VkStructureType = 40;
pub const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO: VkStructureType = 41;
pub const VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO: VkStructureType = 42;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO: VkStructureType = 43;
pub const VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER: VkStructureType = 44;
pub const VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER: VkStructureType = 45;
pub const VK_STRUCTURE_TYPE_MEMORY_BARRIER: VkStructureType = 46;
pub const VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO: VkStructureType = 47;
pub const VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO: VkStructureType = 48;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES: VkStructureType = 1000094000;
pub const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO: VkStructureType = 1000157000;
pub const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO: VkStructureType = 1000157001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES: VkStructureType = 1000083000;
pub const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS: VkStructureType = 1000127000;
pub const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: VkStructureType = 1000127001;
pub const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: VkStructureType = 1000060000;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO: VkStructureType = 1000060003;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO: VkStructureType = 1000060004;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: VkStructureType = 1000060005;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO: VkStructureType = 1000060006;
pub const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO: VkStructureType = 1000060013;
pub const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO: VkStructureType = 1000060014;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES: VkStructureType = 1000070000;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: VkStructureType = 1000070001;
pub const VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2: VkStructureType = 1000146000;
pub const VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2: VkStructureType = 1000146001;
pub const VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2: VkStructureType = 1000146002;
pub const VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2: VkStructureType = 1000146003;
pub const VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2: VkStructureType = 1000146004;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2: VkStructureType = 1000059000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2: VkStructureType = 1000059001;
pub const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2: VkStructureType = 1000059002;
pub const VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2: VkStructureType = 1000059003;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2: VkStructureType = 1000059004;
pub const VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2: VkStructureType = 1000059005;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2: VkStructureType = 1000059006;
pub const VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2: VkStructureType = 1000059007;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2: VkStructureType =
    1000059008;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES: VkStructureType = 1000117000;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO: VkStructureType =
    1000117001;
pub const VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO: VkStructureType = 1000117002;
pub const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO: VkStructureType =
    1000117003;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO: VkStructureType = 1000053000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES: VkStructureType = 1000053001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES: VkStructureType = 1000053002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES: VkStructureType =
    1000120000;
pub const VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: VkStructureType = 1000145000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES: VkStructureType = 1000145001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES: VkStructureType =
    1000145002;
pub const VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2: VkStructureType = 1000145003;
pub const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO: VkStructureType = 1000156000;
pub const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO: VkStructureType = 1000156001;
pub const VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO: VkStructureType = 1000156002;
pub const VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO: VkStructureType = 1000156003;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES: VkStructureType =
    1000156004;
pub const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: VkStructureType =
    1000156005;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO: VkStructureType = 1000085000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO: VkStructureType =
    1000071000;
pub const VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES: VkStructureType = 1000071001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO: VkStructureType = 1000071002;
pub const VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES: VkStructureType = 1000071003;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES: VkStructureType = 1000071004;
pub const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO: VkStructureType = 1000072000;
pub const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO: VkStructureType = 1000072001;
pub const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO: VkStructureType = 1000072002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO: VkStructureType = 1000112000;
pub const VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES: VkStructureType = 1000112001;
pub const VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO: VkStructureType = 1000113000;
pub const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO: VkStructureType = 1000077000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO: VkStructureType = 1000076000;
pub const VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES: VkStructureType = 1000076001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES: VkStructureType = 1000168000;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT: VkStructureType = 1000168001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES: VkStructureType =
    1000063000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES: VkStructureType = 49;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES: VkStructureType = 50;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES: VkStructureType = 51;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES: VkStructureType = 52;
pub const VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: VkStructureType = 1000147000;
pub const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2: VkStructureType = 1000109000;
pub const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2: VkStructureType = 1000109001;
pub const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2: VkStructureType = 1000109002;
pub const VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2: VkStructureType = 1000109003;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2: VkStructureType = 1000109004;
pub const VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO: VkStructureType = 1000109005;
pub const VK_STRUCTURE_TYPE_SUBPASS_END_INFO: VkStructureType = 1000109006;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES: VkStructureType = 1000177000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES: VkStructureType = 1000196000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES: VkStructureType =
    1000180000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES: VkStructureType =
    1000082000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES: VkStructureType = 1000197000;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO: VkStructureType =
    1000161000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES: VkStructureType =
    1000161001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES: VkStructureType =
    1000161002;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
    VkStructureType = 1000161003;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
    VkStructureType = 1000161004;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES: VkStructureType =
    1000199000;
pub const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE: VkStructureType = 1000199001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES: VkStructureType =
    1000221000;
pub const VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: VkStructureType = 1000246000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES: VkStructureType =
    1000130000;
pub const VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO: VkStructureType = 1000130001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES: VkStructureType =
    1000211000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES: VkStructureType =
    1000108000;
pub const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: VkStructureType = 1000108001;
pub const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO: VkStructureType = 1000108002;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: VkStructureType = 1000108003;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
    VkStructureType = 1000253000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
    VkStructureType = 1000175000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
    VkStructureType = 1000241000;
pub const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT: VkStructureType = 1000241001;
pub const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT: VkStructureType = 1000241002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES: VkStructureType = 1000261000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES: VkStructureType =
    1000207000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES: VkStructureType =
    1000207001;
pub const VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: VkStructureType = 1000207002;
pub const VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: VkStructureType = 1000207003;
pub const VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO: VkStructureType = 1000207004;
pub const VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO: VkStructureType = 1000207005;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES: VkStructureType =
    1000257000;
pub const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO: VkStructureType = 1000244001;
pub const VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: VkStructureType = 1000257002;
pub const VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: VkStructureType =
    1000257003;
pub const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO: VkStructureType = 1000257004;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES: VkStructureType = 53;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES: VkStructureType = 54;
pub const VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO: VkStructureType = 1000192000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES: VkStructureType =
    1000215000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES: VkStructureType = 1000245000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
    VkStructureType = 1000276000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES: VkStructureType = 1000295000;
pub const VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO: VkStructureType = 1000295001;
pub const VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO: VkStructureType = 1000295002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
    VkStructureType = 1000297000;
pub const VK_STRUCTURE_TYPE_MEMORY_BARRIER_2: VkStructureType = 1000314000;
pub const VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2: VkStructureType = 1000314001;
pub const VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2: VkStructureType = 1000314002;
pub const VK_STRUCTURE_TYPE_DEPENDENCY_INFO: VkStructureType = 1000314003;
pub const VK_STRUCTURE_TYPE_SUBMIT_INFO_2: VkStructureType = 1000314004;
pub const VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO: VkStructureType = 1000314005;
pub const VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO: VkStructureType = 1000314006;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES: VkStructureType =
    1000314007;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
    VkStructureType = 1000325000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES: VkStructureType = 1000335000;
pub const VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2: VkStructureType = 1000337000;
pub const VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2: VkStructureType = 1000337001;
pub const VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2: VkStructureType = 1000337002;
pub const VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2: VkStructureType = 1000337003;
pub const VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2: VkStructureType = 1000337004;
pub const VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2: VkStructureType = 1000337005;
pub const VK_STRUCTURE_TYPE_BUFFER_COPY_2: VkStructureType = 1000337006;
pub const VK_STRUCTURE_TYPE_IMAGE_COPY_2: VkStructureType = 1000337007;
pub const VK_STRUCTURE_TYPE_IMAGE_BLIT_2: VkStructureType = 1000337008;
pub const VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2: VkStructureType = 1000337009;
pub const VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2: VkStructureType = 1000337010;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES: VkStructureType =
    1000225000;
pub const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:
    VkStructureType = 1000225001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES: VkStructureType =
    1000225002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES: VkStructureType =
    1000138000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES: VkStructureType =
    1000138001;
pub const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK: VkStructureType = 1000138002;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO: VkStructureType =
    1000138003;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES: VkStructureType =
    1000066000;
pub const VK_STRUCTURE_TYPE_RENDERING_INFO: VkStructureType = 1000044000;
pub const VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO: VkStructureType = 1000044001;
pub const VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO: VkStructureType = 1000044002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES: VkStructureType =
    1000044003;
pub const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO: VkStructureType = 1000044004;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES: VkStructureType =
    1000280000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES: VkStructureType =
    1000280001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES: VkStructureType =
    1000281001;
pub const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3: VkStructureType = 1000360000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES: VkStructureType = 1000413000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES: VkStructureType = 1000413001;
pub const VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS: VkStructureType = 1000413002;
pub const VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS: VkStructureType = 1000413003;
pub const VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR: VkStructureType = 1000001000;
pub const VK_STRUCTURE_TYPE_PRESENT_INFO_KHR: VkStructureType = 1000001001;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR: VkStructureType = 1000060007;
pub const VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: VkStructureType = 1000060008;
pub const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR: VkStructureType = 1000060009;
pub const VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR: VkStructureType = 1000060010;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR: VkStructureType = 1000060011;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR: VkStructureType = 1000060012;
pub const VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR: VkStructureType = 1000002000;
pub const VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR: VkStructureType = 1000002001;
pub const VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR: VkStructureType = 1000003000;
pub const VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR: VkStructureType = 1000004000;
pub const VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR: VkStructureType = 1000005000;
pub const VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR: VkStructureType = 1000006000;
pub const VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR: VkStructureType = 1000008000;
pub const VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR: VkStructureType = 1000009000;
pub const VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT: VkStructureType = 1000011000;
pub const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD: VkStructureType =
    1000018000;
pub const VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT: VkStructureType = 1000022000;
pub const VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT: VkStructureType = 1000022001;
pub const VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT: VkStructureType = 1000022002;
pub const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: VkStructureType = 1000026000;
pub const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: VkStructureType =
    1000026001;
pub const VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: VkStructureType =
    1000026002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT: VkStructureType =
    1000028000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT: VkStructureType =
    1000028001;
pub const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT: VkStructureType =
    1000028002;
pub const VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX: VkStructureType = 1000029000;
pub const VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX: VkStructureType = 1000029001;
pub const VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX: VkStructureType = 1000029002;
pub const VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX: VkStructureType = 1000030000;
pub const VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX: VkStructureType = 1000030001;
pub const VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: VkStructureType = 1000041000;
pub const VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: VkStructureType =
    1000044006;
pub const VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT: VkStructureType =
    1000044007;
pub const VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD: VkStructureType = 1000044008;
pub const VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX: VkStructureType = 1000044009;
pub const VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP: VkStructureType = 1000049000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV: VkStructureType =
    1000050000;
pub const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV: VkStructureType = 1000056000;
pub const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV: VkStructureType = 1000056001;
pub const VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV: VkStructureType = 1000057000;
pub const VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV: VkStructureType = 1000057001;
pub const VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV: VkStructureType = 1000058000;
pub const VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT: VkStructureType = 1000061000;
pub const VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN: VkStructureType = 1000062000;
pub const VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT: VkStructureType = 1000067000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT: VkStructureType = 1000067001;
pub const VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT: VkStructureType = 1000068000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT: VkStructureType =
    1000068001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT: VkStructureType =
    1000068002;
pub const VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: VkStructureType = 1000073000;
pub const VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR: VkStructureType = 1000073001;
pub const VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR: VkStructureType = 1000073002;
pub const VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR: VkStructureType = 1000073003;
pub const VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR: VkStructureType = 1000074000;
pub const VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR: VkStructureType = 1000074001;
pub const VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR: VkStructureType = 1000074002;
pub const VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: VkStructureType =
    1000075000;
pub const VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: VkStructureType = 1000078000;
pub const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR: VkStructureType = 1000078001;
pub const VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR: VkStructureType = 1000078002;
pub const VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR: VkStructureType = 1000078003;
pub const VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR: VkStructureType = 1000079000;
pub const VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR: VkStructureType = 1000079001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR: VkStructureType =
    1000080000;
pub const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
    VkStructureType = 1000081000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT: VkStructureType =
    1000081001;
pub const VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT: VkStructureType = 1000081002;
pub const VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR: VkStructureType = 1000084000;
pub const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV: VkStructureType =
    1000087000;
pub const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT: VkStructureType = 1000090000;
pub const VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT: VkStructureType = 1000091000;
pub const VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT: VkStructureType = 1000091001;
pub const VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT: VkStructureType = 1000091002;
pub const VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT: VkStructureType = 1000091003;
pub const VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE: VkStructureType = 1000092000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
    VkStructureType = 1000097000;
pub const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV: VkStructureType =
    1000098000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT: VkStructureType =
    1000099000;
pub const VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT: VkStructureType =
    1000099001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
    VkStructureType = 1000101000;
pub const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000101001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT: VkStructureType =
    1000102000;
pub const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000102001;
pub const VK_STRUCTURE_TYPE_HDR_METADATA_EXT: VkStructureType = 1000105000;
pub const VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR: VkStructureType = 1000111000;
pub const VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR: VkStructureType = 1000114000;
pub const VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR: VkStructureType = 1000114001;
pub const VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR: VkStructureType = 1000114002;
pub const VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR: VkStructureType = 1000115000;
pub const VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR: VkStructureType = 1000115001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR: VkStructureType =
    1000116000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR: VkStructureType =
    1000116001;
pub const VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR: VkStructureType = 1000116002;
pub const VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR: VkStructureType = 1000116003;
pub const VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR: VkStructureType = 1000116004;
pub const VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR: VkStructureType = 1000116005;
pub const VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR: VkStructureType = 1000116006;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR: VkStructureType = 1000119000;
pub const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR: VkStructureType = 1000119001;
pub const VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR: VkStructureType = 1000119002;
pub const VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR: VkStructureType = 1000121000;
pub const VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR: VkStructureType = 1000121001;
pub const VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR: VkStructureType = 1000121002;
pub const VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR: VkStructureType = 1000121003;
pub const VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR: VkStructureType = 1000121004;
pub const VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK: VkStructureType = 1000122000;
pub const VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK: VkStructureType = 1000123000;
pub const VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT: VkStructureType = 1000128000;
pub const VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT: VkStructureType = 1000128001;
pub const VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT: VkStructureType = 1000128002;
pub const VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT: VkStructureType = 1000128003;
pub const VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT: VkStructureType = 1000128004;
pub const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID: VkStructureType = 1000129000;
pub const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID: VkStructureType =
    1000129001;
pub const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID: VkStructureType =
    1000129002;
pub const VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: VkStructureType =
    1000129003;
pub const VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID: VkStructureType =
    1000129004;
pub const VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID: VkStructureType = 1000129005;
pub const VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID: VkStructureType =
    1000129006;
pub const VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT: VkStructureType = 1000143000;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT: VkStructureType =
    1000143001;
pub const VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT: VkStructureType =
    1000143002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT: VkStructureType =
    1000143003;
pub const VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT: VkStructureType = 1000143004;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT: VkStructureType =
    1000148000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
    VkStructureType = 1000148001;
pub const VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT: VkStructureType =
    1000148002;
pub const VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV: VkStructureType =
    1000149000;
pub const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR: VkStructureType =
    1000150007;
pub const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR: VkStructureType =
    1000150000;
pub const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR: VkStructureType =
    1000150002;
pub const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR: VkStructureType =
    1000150003;
pub const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR: VkStructureType =
    1000150004;
pub const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR: VkStructureType =
    1000150005;
pub const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR: VkStructureType = 1000150006;
pub const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR: VkStructureType = 1000150009;
pub const VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR: VkStructureType = 1000150010;
pub const VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR: VkStructureType =
    1000150011;
pub const VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR: VkStructureType =
    1000150012;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR: VkStructureType =
    1000150013;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR: VkStructureType =
    1000150014;
pub const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR: VkStructureType = 1000150017;
pub const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR: VkStructureType =
    1000150020;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR: VkStructureType =
    1000347000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR: VkStructureType =
    1000347001;
pub const VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR: VkStructureType = 1000150015;
pub const VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR: VkStructureType = 1000150016;
pub const VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR: VkStructureType =
    1000150018;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR: VkStructureType = 1000348013;
pub const VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV: VkStructureType =
    1000152000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV: VkStructureType =
    1000154000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV: VkStructureType =
    1000154001;
pub const VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT: VkStructureType = 1000158000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT: VkStructureType =
    1000158002;
pub const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT: VkStructureType =
    1000158003;
pub const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT: VkStructureType =
    1000158004;
pub const VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT: VkStructureType = 1000158005;
pub const VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT: VkStructureType = 1000158006;
pub const VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT: VkStructureType = 1000160000;
pub const VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT: VkStructureType =
    1000160001;
pub const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
    VkStructureType = 1000164000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV: VkStructureType =
    1000164001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV: VkStructureType =
    1000164002;
pub const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
    VkStructureType = 1000164005;
pub const VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV: VkStructureType = 1000165000;
pub const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV: VkStructureType = 1000165001;
pub const VK_STRUCTURE_TYPE_GEOMETRY_NV: VkStructureType = 1000165003;
pub const VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV: VkStructureType = 1000165004;
pub const VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV: VkStructureType = 1000165005;
pub const VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV: VkStructureType =
    1000165006;
pub const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV: VkStructureType =
    1000165007;
pub const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV: VkStructureType =
    1000165008;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV: VkStructureType = 1000165009;
pub const VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV: VkStructureType = 1000165011;
pub const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV: VkStructureType = 1000165012;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
    VkStructureType = 1000166000;
pub const VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
    VkStructureType = 1000166001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: VkStructureType =
    1000170000;
pub const VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT: VkStructureType =
    1000170001;
pub const VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT: VkStructureType = 1000178000;
pub const VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT: VkStructureType = 1000178001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT: VkStructureType =
    1000178002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR: VkStructureType = 1000181000;
pub const VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD: VkStructureType = 1000183000;
pub const VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT: VkStructureType = 1000184000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD: VkStructureType =
    1000185000;
pub const VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR: VkStructureType =
    1000174000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR: VkStructureType =
    1000388000;
pub const VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR: VkStructureType =
    1000388001;
pub const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD: VkStructureType =
    1000189000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
    VkStructureType = 1000190000;
pub const VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT: VkStructureType =
    1000190001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT: VkStructureType =
    1000190002;
pub const VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP: VkStructureType = 1000191000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
    VkStructureType = 1000201000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV: VkStructureType = 1000202000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV: VkStructureType = 1000202001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV: VkStructureType =
    1000204000;
pub const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
    VkStructureType = 1000205000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV: VkStructureType =
    1000205002;
pub const VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV: VkStructureType = 1000206000;
pub const VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV: VkStructureType = 1000206001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
    VkStructureType = 1000209000;
pub const VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL: VkStructureType =
    1000210000;
pub const VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL: VkStructureType = 1000210001;
pub const VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL: VkStructureType = 1000210002;
pub const VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL: VkStructureType = 1000210003;
pub const VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL: VkStructureType = 1000210004;
pub const VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL: VkStructureType =
    1000210005;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT: VkStructureType =
    1000212000;
pub const VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD: VkStructureType =
    1000213000;
pub const VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD: VkStructureType =
    1000213001;
pub const VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA: VkStructureType = 1000214000;
pub const VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT: VkStructureType = 1000217000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT: VkStructureType =
    1000218000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT: VkStructureType =
    1000218001;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT: VkStructureType =
    1000218002;
pub const VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR: VkStructureType = 1000226000;
pub const VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR: VkStructureType =
    1000226001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR: VkStructureType =
    1000226002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR: VkStructureType =
    1000226003;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR: VkStructureType = 1000226004;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD: VkStructureType =
    1000227000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD: VkStructureType =
    1000229000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
    VkStructureType = 1000234000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT: VkStructureType =
    1000237000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT: VkStructureType =
    1000238000;
pub const VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT: VkStructureType = 1000238001;
pub const VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR: VkStructureType = 1000239000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
    VkStructureType = 1000240000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT: VkStructureType =
    1000244000;
pub const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: VkStructureType = 1000244002;
pub const VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT: VkStructureType = 1000247000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR: VkStructureType = 1000248000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV: VkStructureType =
    1000249000;
pub const VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV: VkStructureType = 1000249001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV: VkStructureType =
    1000249002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV: VkStructureType =
    1000250000;
pub const VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV: VkStructureType =
    1000250001;
pub const VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV: VkStructureType = 1000250002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
    VkStructureType = 1000251000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT: VkStructureType =
    1000252000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT: VkStructureType =
    1000254000;
pub const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT:
    VkStructureType = 1000254001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT: VkStructureType =
    1000254002;
pub const VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT: VkStructureType = 1000255000;
pub const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT: VkStructureType =
    1000255002;
pub const VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT: VkStructureType =
    1000255001;
pub const VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT: VkStructureType = 1000256000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT: VkStructureType =
    1000259000;
pub const VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT: VkStructureType =
    1000259001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT: VkStructureType =
    1000259002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT: VkStructureType =
    1000260000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT: VkStructureType =
    1000265000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT: VkStructureType =
    1000267000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
    VkStructureType = 1000269000;
pub const VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR: VkStructureType = 1000269001;
pub const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR: VkStructureType = 1000269002;
pub const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR: VkStructureType = 1000269003;
pub const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR: VkStructureType = 1000269004;
pub const VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR: VkStructureType =
    1000269005;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT: VkStructureType =
    1000273000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
    VkStructureType = 1000277000;
pub const VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV: VkStructureType = 1000277001;
pub const VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV: VkStructureType =
    1000277002;
pub const VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV: VkStructureType = 1000277003;
pub const VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV: VkStructureType = 1000277004;
pub const VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV: VkStructureType = 1000277005;
pub const VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV: VkStructureType =
    1000277006;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV: VkStructureType =
    1000277007;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
    VkStructureType = 1000278000;
pub const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV: VkStructureType =
    1000278001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT: VkStructureType =
    1000281000;
pub const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
    VkStructureType = 1000282000;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM: VkStructureType = 1000282001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT: VkStructureType =
    1000284000;
pub const VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT: VkStructureType =
    1000284001;
pub const VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT: VkStructureType = 1000284002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT: VkStructureType = 1000286000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT: VkStructureType =
    1000286001;
pub const VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT: VkStructureType =
    1000287000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT: VkStructureType =
    1000287001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT: VkStructureType =
    1000287002;
pub const VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR: VkStructureType = 1000290000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV: VkStructureType =
    1000292000;
pub const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV: VkStructureType = 1000292001;
pub const VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV: VkStructureType = 1000292002;
pub const VK_STRUCTURE_TYPE_PRESENT_ID_KHR: VkStructureType = 1000294000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR: VkStructureType = 1000294001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV: VkStructureType =
    1000300000;
pub const VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV: VkStructureType = 1000300001;
pub const VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT: VkStructureType = 1000311000;
pub const VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT: VkStructureType = 1000311001;
pub const VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT: VkStructureType = 1000311002;
pub const VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT: VkStructureType = 1000311003;
pub const VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT: VkStructureType = 1000311004;
pub const VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT: VkStructureType = 1000311005;
pub const VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT: VkStructureType = 1000311006;
pub const VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT: VkStructureType = 1000311007;
pub const VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT: VkStructureType = 1000311008;
pub const VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT: VkStructureType = 1000311009;
pub const VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT: VkStructureType = 1000311010;
pub const VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT: VkStructureType = 1000311011;
pub const VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV: VkStructureType = 1000314008;
pub const VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV: VkStructureType = 1000314009;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT: VkStructureType =
    1000316000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT:
    VkStructureType = 1000316001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT: VkStructureType =
    1000316002;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT: VkStructureType = 1000316003;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT: VkStructureType = 1000316004;
pub const VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT: VkStructureType = 1000316005;
pub const VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT: VkStructureType = 1000316006;
pub const VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT: VkStructureType =
    1000316007;
pub const VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT: VkStructureType = 1000316008;
pub const VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: VkStructureType =
    1000316010;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT: VkStructureType = 1000316011;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT:
    VkStructureType = 1000316012;
pub const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:
    VkStructureType = 1000316009;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
    VkStructureType = 1000320000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT:
    VkStructureType = 1000320001;
pub const VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT: VkStructureType = 1000320002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD:
    VkStructureType = 1000321000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR:
    VkStructureType = 1000203000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR:
    VkStructureType = 1000322000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
    VkStructureType = 1000323000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
    VkStructureType = 1000326000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
    VkStructureType = 1000326001;
pub const VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
    VkStructureType = 1000326002;
pub const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV:
    VkStructureType = 1000327000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV: VkStructureType =
    1000327001;
pub const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV: VkStructureType = 1000327002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT: VkStructureType = 1000328000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT: VkStructureType =
    1000328001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
    VkStructureType = 1000330000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT: VkStructureType =
    1000332000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT: VkStructureType =
    1000332001;
pub const VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM: VkStructureType = 1000333000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
    VkStructureType = 1000336000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT:
    VkStructureType = 1000338000;
pub const VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT: VkStructureType = 1000338001;
pub const VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT: VkStructureType = 1000338002;
pub const VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT: VkStructureType = 1000338003;
pub const VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT: VkStructureType = 1000338004;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
    VkStructureType = 1000339000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT: VkStructureType = 1000340000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT: VkStructureType = 1000341000;
pub const VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT: VkStructureType = 1000341001;
pub const VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT: VkStructureType = 1000341002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT: VkStructureType =
    1000344000;
pub const VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT: VkStructureType = 1000346000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
    VkStructureType = 1000352000;
pub const VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT: VkStructureType = 1000352001;
pub const VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT: VkStructureType = 1000352002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT: VkStructureType = 1000353000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT: VkStructureType =
    1000354000;
pub const VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT: VkStructureType = 1000354001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT: VkStructureType =
    1000355000;
pub const VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT: VkStructureType =
    1000355001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
    VkStructureType = 1000356000;
pub const VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA: VkStructureType = 1000364000;
pub const VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA: VkStructureType = 1000364001;
pub const VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA: VkStructureType = 1000364002;
pub const VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA: VkStructureType =
    1000365000;
pub const VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA: VkStructureType = 1000365001;
pub const VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA: VkStructureType = 1000366000;
pub const VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA: VkStructureType = 1000366001;
pub const VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA: VkStructureType =
    1000366002;
pub const VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA: VkStructureType = 1000366003;
pub const VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA: VkStructureType = 1000366004;
pub const VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA: VkStructureType =
    1000366005;
pub const VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA: VkStructureType = 1000366006;
pub const VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA: VkStructureType = 1000366007;
pub const VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA: VkStructureType = 1000366008;
pub const VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA: VkStructureType =
    1000366009;
pub const VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI: VkStructureType =
    1000369000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI: VkStructureType =
    1000369001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI: VkStructureType =
    1000369002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI: VkStructureType =
    1000370000;
pub const VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV: VkStructureType = 1000371000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV: VkStructureType =
    1000371001;
pub const VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT: VkStructureType = 1000372000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT: VkStructureType =
    1000372001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT:
    VkStructureType = 1000376000;
pub const VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT: VkStructureType = 1000376001;
pub const VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT: VkStructureType =
    1000376002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT: VkStructureType =
    1000377000;
pub const VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX: VkStructureType = 1000378000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT: VkStructureType =
    1000381000;
pub const VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT: VkStructureType = 1000381001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT:
    VkStructureType = 1000382000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:
    VkStructureType = 1000386000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT: VkStructureType =
    1000391000;
pub const VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT: VkStructureType = 1000391001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT: VkStructureType = 1000392000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT: VkStructureType = 1000392001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT: VkStructureType =
    1000393000;
pub const VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT: VkStructureType = 1000396000;
pub const VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT: VkStructureType = 1000396001;
pub const VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT: VkStructureType = 1000396002;
pub const VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT: VkStructureType = 1000396003;
pub const VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT: VkStructureType = 1000396004;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT: VkStructureType =
    1000396005;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT: VkStructureType =
    1000396006;
pub const VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT: VkStructureType = 1000396007;
pub const VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT: VkStructureType = 1000396008;
pub const VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT: VkStructureType =
    1000396009;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT: VkStructureType =
    1000411000;
pub const VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT:
    VkStructureType = 1000411001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
    VkStructureType = 1000412000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE:
    VkStructureType = 1000420000;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE: VkStructureType = 1000420001;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE: VkStructureType =
    1000420002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT: VkStructureType =
    1000421000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT: VkStructureType =
    1000422000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM:
    VkStructureType = 1000425000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM:
    VkStructureType = 1000425001;
pub const VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM: VkStructureType =
    1000425002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV: VkStructureType =
    1000426000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV: VkStructureType =
    1000426001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV: VkStructureType =
    1000427000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV: VkStructureType =
    1000427001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV: VkStructureType =
    1000430000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT:
    VkStructureType = 1000437000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM: VkStructureType =
    1000440000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM: VkStructureType =
    1000440001;
pub const VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM: VkStructureType = 1000440002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT: VkStructureType =
    1000455000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT:
    VkStructureType = 1000455001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT: VkStructureType =
    1000458000;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT: VkStructureType = 1000458001;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT: VkStructureType =
    1000458002;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT: VkStructureType =
    1000458003;
pub const VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG: VkStructureType = 1000459000;
pub const VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG: VkStructureType = 1000459001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT: VkStructureType =
    1000462000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT:
    VkStructureType = 1000462001;
pub const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT:
    VkStructureType = 1000462002;
pub const VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT: VkStructureType = 1000462003;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT:
    VkStructureType = 1000342000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV: VkStructureType = 1000464000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV: VkStructureType =
    1000464001;
pub const VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV: VkStructureType = 1000464002;
pub const VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV: VkStructureType = 1000464003;
pub const VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV: VkStructureType = 1000464004;
pub const VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV: VkStructureType = 1000464005;
pub const VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV: VkStructureType =
    1000464010;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT: VkStructureType =
    1000465000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT:
    VkStructureType = 1000466000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM: VkStructureType =
    1000484000;
pub const VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM: VkStructureType = 1000484001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC: VkStructureType =
    1000485000;
pub const VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC: VkStructureType = 1000485001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM:
    VkStructureType = 1000488000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV:
    VkStructureType = 1000490000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV:
    VkStructureType = 1000490001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT: VkStructureType =
    1000351000;
pub const VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT: VkStructureType = 1000351002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM: VkStructureType =
    1000497000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM: VkStructureType =
    1000497001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES: VkStructureType = 1000120000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES: VkStructureType =
    1000063000;
pub const VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT: VkStructureType = 1000011000;
pub const VK_STRUCTURE_TYPE_RENDERING_INFO_KHR: VkStructureType = 1000044000;
pub const VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR: VkStructureType = 1000044001;
pub const VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR: VkStructureType = 1000044002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR: VkStructureType =
    1000044003;
pub const VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR: VkStructureType =
    1000044004;
pub const VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV: VkStructureType = 1000044008;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR: VkStructureType = 1000053000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR: VkStructureType = 1000053001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR: VkStructureType = 1000053002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR: VkStructureType = 1000059000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR: VkStructureType = 1000059001;
pub const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR: VkStructureType = 1000059002;
pub const VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR: VkStructureType = 1000059003;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR: VkStructureType = 1000059004;
pub const VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR: VkStructureType = 1000059005;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR: VkStructureType = 1000059006;
pub const VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR: VkStructureType = 1000059007;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR: VkStructureType =
    1000059008;
pub const VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR: VkStructureType = 1000060000;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR: VkStructureType = 1000060003;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR: VkStructureType =
    1000060004;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR: VkStructureType = 1000060005;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR: VkStructureType = 1000060006;
pub const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR: VkStructureType = 1000060013;
pub const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR: VkStructureType = 1000060014;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT:
    VkStructureType = 1000066000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR: VkStructureType = 1000070000;
pub const VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR: VkStructureType = 1000070001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR: VkStructureType =
    1000071000;
pub const VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR: VkStructureType = 1000071001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR: VkStructureType = 1000071002;
pub const VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR: VkStructureType = 1000071003;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR: VkStructureType = 1000071004;
pub const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR: VkStructureType = 1000072000;
pub const VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR: VkStructureType = 1000072001;
pub const VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR: VkStructureType = 1000072002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR: VkStructureType =
    1000076000;
pub const VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR: VkStructureType = 1000076001;
pub const VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR: VkStructureType = 1000077000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR: VkStructureType =
    1000082000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR: VkStructureType = 1000082000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR: VkStructureType =
    1000083000;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR: VkStructureType =
    1000085000;
pub const VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT: VkStructureType = 1000090000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR: VkStructureType =
    1000108000;
pub const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR: VkStructureType = 1000108001;
pub const VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR: VkStructureType = 1000108002;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR: VkStructureType = 1000108003;
pub const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR: VkStructureType = 1000109000;
pub const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR: VkStructureType = 1000109001;
pub const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR: VkStructureType = 1000109002;
pub const VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR: VkStructureType = 1000109003;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR: VkStructureType = 1000109004;
pub const VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR: VkStructureType = 1000109005;
pub const VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR: VkStructureType = 1000109006;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR: VkStructureType = 1000112000;
pub const VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR: VkStructureType = 1000112001;
pub const VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR: VkStructureType = 1000113000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR: VkStructureType =
    1000117000;
pub const VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR: VkStructureType =
    1000117001;
pub const VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR: VkStructureType = 1000117002;
pub const VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR:
    VkStructureType = 1000117003;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR: VkStructureType =
    1000120000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR: VkStructureType =
    1000120000;
pub const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR: VkStructureType = 1000127000;
pub const VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR: VkStructureType = 1000127001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT: VkStructureType =
    1000130000;
pub const VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT: VkStructureType = 1000130001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT: VkStructureType =
    1000138000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT: VkStructureType =
    1000138001;
pub const VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT: VkStructureType =
    1000138002;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT: VkStructureType =
    1000138003;
pub const VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType = 1000146000;
pub const VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType = 1000146001;
pub const VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR: VkStructureType =
    1000146002;
pub const VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR: VkStructureType = 1000146003;
pub const VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR: VkStructureType = 1000146004;
pub const VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR: VkStructureType = 1000147000;
pub const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR: VkStructureType = 1000156000;
pub const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR: VkStructureType = 1000156001;
pub const VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR: VkStructureType = 1000156002;
pub const VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR: VkStructureType = 1000156003;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR: VkStructureType =
    1000156004;
pub const VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR: VkStructureType =
    1000156005;
pub const VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR: VkStructureType = 1000157000;
pub const VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR: VkStructureType = 1000157001;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT: VkStructureType =
    1000161000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT: VkStructureType =
    1000161001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT: VkStructureType =
    1000161002;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT:
    VkStructureType = 1000161003;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT:
    VkStructureType = 1000161004;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR: VkStructureType =
    1000168000;
pub const VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR: VkStructureType = 1000168001;
pub const VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT: VkStructureType =
    1000174000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR:
    VkStructureType = 1000175000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR: VkStructureType = 1000177000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR: VkStructureType =
    1000180000;
pub const VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT: VkStructureType =
    1000192000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR: VkStructureType = 1000196000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR: VkStructureType =
    1000197000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR: VkStructureType =
    1000199000;
pub const VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR: VkStructureType =
    1000199001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV:
    VkStructureType = 1000203000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR: VkStructureType =
    1000207000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR: VkStructureType =
    1000207001;
pub const VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR: VkStructureType = 1000207002;
pub const VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR: VkStructureType = 1000207003;
pub const VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR: VkStructureType = 1000207004;
pub const VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR: VkStructureType = 1000207005;
pub const VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL: VkStructureType = 1000210000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR: VkStructureType =
    1000211000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR:
    VkStructureType = 1000215000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT: VkStructureType =
    1000221000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT: VkStructureType =
    1000225000;
pub const VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT:
    VkStructureType = 1000225001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT: VkStructureType =
    1000225002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR:
    VkStructureType = 1000241000;
pub const VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR: VkStructureType = 1000241001;
pub const VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR: VkStructureType = 1000241002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT: VkStructureType =
    1000244000;
pub const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT: VkStructureType = 1000244001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT: VkStructureType = 1000245000;
pub const VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT: VkStructureType = 1000246000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR:
    VkStructureType = 1000253000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR: VkStructureType =
    1000257000;
pub const VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR: VkStructureType = 1000244001;
pub const VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR: VkStructureType =
    1000257002;
pub const VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR: VkStructureType =
    1000257003;
pub const VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR: VkStructureType =
    1000257004;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT: VkStructureType =
    1000261000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT:
    VkStructureType = 1000276000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR:
    VkStructureType = 1000280000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR:
    VkStructureType = 1000280001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT: VkStructureType =
    1000281001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT: VkStructureType = 1000295000;
pub const VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT: VkStructureType = 1000295001;
pub const VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT: VkStructureType = 1000295002;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT:
    VkStructureType = 1000297000;
pub const VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR: VkStructureType = 1000314000;
pub const VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR: VkStructureType = 1000314001;
pub const VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR: VkStructureType = 1000314002;
pub const VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR: VkStructureType = 1000314003;
pub const VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR: VkStructureType = 1000314004;
pub const VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR: VkStructureType = 1000314005;
pub const VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR: VkStructureType = 1000314006;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR: VkStructureType =
    1000314007;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR:
    VkStructureType = 1000325000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT: VkStructureType =
    1000335000;
pub const VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR: VkStructureType = 1000337000;
pub const VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR: VkStructureType = 1000337001;
pub const VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR: VkStructureType = 1000337002;
pub const VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR: VkStructureType = 1000337003;
pub const VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR: VkStructureType = 1000337004;
pub const VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR: VkStructureType = 1000337005;
pub const VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR: VkStructureType = 1000337006;
pub const VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR: VkStructureType = 1000337007;
pub const VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR: VkStructureType = 1000337008;
pub const VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR: VkStructureType = 1000337009;
pub const VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR: VkStructureType = 1000337010;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM:
    VkStructureType = 1000342000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE:
    VkStructureType = 1000351000;
pub const VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE: VkStructureType = 1000351002;
pub const VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR: VkStructureType = 1000360000;
pub const VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT: VkStructureType = 1000269001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT: VkStructureType =
    1000388000;
pub const VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT: VkStructureType =
    1000388001;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR: VkStructureType =
    1000413000;
pub const VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR: VkStructureType =
    1000413001;
pub const VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR: VkStructureType = 1000413002;
pub const VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR: VkStructureType = 1000413003;
pub const VK_STRUCTURE_TYPE_MAX_ENUM: VkStructureType = 2147483647;
pub type VkStructureType = ::std::os::raw::c_int;
pub const VK_PIPELINE_CACHE_HEADER_VERSION_ONE: VkPipelineCacheHeaderVersion = 1;
pub const VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM: VkPipelineCacheHeaderVersion = 2147483647;
pub type VkPipelineCacheHeaderVersion = ::std::os::raw::c_int;
pub const VK_IMAGE_LAYOUT_UNDEFINED: VkImageLayout = 0;
pub const VK_IMAGE_LAYOUT_GENERAL: VkImageLayout = 1;
pub const VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL: VkImageLayout = 2;
pub const VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout = 3;
pub const VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout = 4;
pub const VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL: VkImageLayout = 5;
pub const VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL: VkImageLayout = 6;
pub const VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL: VkImageLayout = 7;
pub const VK_IMAGE_LAYOUT_PREINITIALIZED: VkImageLayout = 8;
pub const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout = 1000117000;
pub const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout = 1000117001;
pub const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL: VkImageLayout = 1000241000;
pub const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL: VkImageLayout = 1000241001;
pub const VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL: VkImageLayout = 1000241002;
pub const VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL: VkImageLayout = 1000241003;
pub const VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL: VkImageLayout = 1000314000;
pub const VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL: VkImageLayout = 1000314001;
pub const VK_IMAGE_LAYOUT_PRESENT_SRC_KHR: VkImageLayout = 1000001002;
pub const VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR: VkImageLayout = 1000111000;
pub const VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT: VkImageLayout = 1000218000;
pub const VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = 1000164003;
pub const VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT: VkImageLayout = 1000339000;
pub const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR: VkImageLayout =
    1000117000;
pub const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR: VkImageLayout =
    1000117001;
pub const VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV: VkImageLayout = 1000164003;
pub const VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = 1000241000;
pub const VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR: VkImageLayout = 1000241001;
pub const VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = 1000241002;
pub const VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR: VkImageLayout = 1000241003;
pub const VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR: VkImageLayout = 1000314000;
pub const VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR: VkImageLayout = 1000314001;
pub const VK_IMAGE_LAYOUT_MAX_ENUM: VkImageLayout = 2147483647;
pub type VkImageLayout = ::std::os::raw::c_int;
pub const VK_OBJECT_TYPE_UNKNOWN: VkObjectType = 0;
pub const VK_OBJECT_TYPE_INSTANCE: VkObjectType = 1;
pub const VK_OBJECT_TYPE_PHYSICAL_DEVICE: VkObjectType = 2;
pub const VK_OBJECT_TYPE_DEVICE: VkObjectType = 3;
pub const VK_OBJECT_TYPE_QUEUE: VkObjectType = 4;
pub const VK_OBJECT_TYPE_SEMAPHORE: VkObjectType = 5;
pub const VK_OBJECT_TYPE_COMMAND_BUFFER: VkObjectType = 6;
pub const VK_OBJECT_TYPE_FENCE: VkObjectType = 7;
pub const VK_OBJECT_TYPE_DEVICE_MEMORY: VkObjectType = 8;
pub const VK_OBJECT_TYPE_BUFFER: VkObjectType = 9;
pub const VK_OBJECT_TYPE_IMAGE: VkObjectType = 10;
pub const VK_OBJECT_TYPE_EVENT: VkObjectType = 11;
pub const VK_OBJECT_TYPE_QUERY_POOL: VkObjectType = 12;
pub const VK_OBJECT_TYPE_BUFFER_VIEW: VkObjectType = 13;
pub const VK_OBJECT_TYPE_IMAGE_VIEW: VkObjectType = 14;
pub const VK_OBJECT_TYPE_SHADER_MODULE: VkObjectType = 15;
pub const VK_OBJECT_TYPE_PIPELINE_CACHE: VkObjectType = 16;
pub const VK_OBJECT_TYPE_PIPELINE_LAYOUT: VkObjectType = 17;
pub const VK_OBJECT_TYPE_RENDER_PASS: VkObjectType = 18;
pub const VK_OBJECT_TYPE_PIPELINE: VkObjectType = 19;
pub const VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT: VkObjectType = 20;
pub const VK_OBJECT_TYPE_SAMPLER: VkObjectType = 21;
pub const VK_OBJECT_TYPE_DESCRIPTOR_POOL: VkObjectType = 22;
pub const VK_OBJECT_TYPE_DESCRIPTOR_SET: VkObjectType = 23;
pub const VK_OBJECT_TYPE_FRAMEBUFFER: VkObjectType = 24;
pub const VK_OBJECT_TYPE_COMMAND_POOL: VkObjectType = 25;
pub const VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION: VkObjectType = 1000156000;
pub const VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE: VkObjectType = 1000085000;
pub const VK_OBJECT_TYPE_PRIVATE_DATA_SLOT: VkObjectType = 1000295000;
pub const VK_OBJECT_TYPE_SURFACE_KHR: VkObjectType = 1000000000;
pub const VK_OBJECT_TYPE_SWAPCHAIN_KHR: VkObjectType = 1000001000;
pub const VK_OBJECT_TYPE_DISPLAY_KHR: VkObjectType = 1000002000;
pub const VK_OBJECT_TYPE_DISPLAY_MODE_KHR: VkObjectType = 1000002001;
pub const VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT: VkObjectType = 1000011000;
pub const VK_OBJECT_TYPE_CU_MODULE_NVX: VkObjectType = 1000029000;
pub const VK_OBJECT_TYPE_CU_FUNCTION_NVX: VkObjectType = 1000029001;
pub const VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT: VkObjectType = 1000128000;
pub const VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR: VkObjectType = 1000150000;
pub const VK_OBJECT_TYPE_VALIDATION_CACHE_EXT: VkObjectType = 1000160000;
pub const VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV: VkObjectType = 1000165000;
pub const VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL: VkObjectType = 1000210000;
pub const VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR: VkObjectType = 1000268000;
pub const VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV: VkObjectType = 1000277000;
pub const VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA: VkObjectType = 1000366000;
pub const VK_OBJECT_TYPE_MICROMAP_EXT: VkObjectType = 1000396000;
pub const VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV: VkObjectType = 1000464000;
pub const VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR: VkObjectType = 1000085000;
pub const VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR: VkObjectType = 1000156000;
pub const VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT: VkObjectType = 1000295000;
pub const VK_OBJECT_TYPE_MAX_ENUM: VkObjectType = 2147483647;
pub type VkObjectType = ::std::os::raw::c_int;
pub const VK_VENDOR_ID_VIV: VkVendorId = 65537;
pub const VK_VENDOR_ID_VSI: VkVendorId = 65538;
pub const VK_VENDOR_ID_KAZAN: VkVendorId = 65539;
pub const VK_VENDOR_ID_CODEPLAY: VkVendorId = 65540;
pub const VK_VENDOR_ID_MESA: VkVendorId = 65541;
pub const VK_VENDOR_ID_POCL: VkVendorId = 65542;
pub const VK_VENDOR_ID_MAX_ENUM: VkVendorId = 2147483647;
pub type VkVendorId = ::std::os::raw::c_int;
pub const VK_SYSTEM_ALLOCATION_SCOPE_COMMAND: VkSystemAllocationScope = 0;
pub const VK_SYSTEM_ALLOCATION_SCOPE_OBJECT: VkSystemAllocationScope = 1;
pub const VK_SYSTEM_ALLOCATION_SCOPE_CACHE: VkSystemAllocationScope = 2;
pub const VK_SYSTEM_ALLOCATION_SCOPE_DEVICE: VkSystemAllocationScope = 3;
pub const VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE: VkSystemAllocationScope = 4;
pub const VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM: VkSystemAllocationScope = 2147483647;
pub type VkSystemAllocationScope = ::std::os::raw::c_int;
pub const VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE: VkInternalAllocationType = 0;
pub const VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM: VkInternalAllocationType = 2147483647;
pub type VkInternalAllocationType = ::std::os::raw::c_int;
pub const VK_FORMAT_UNDEFINED: VkFormat = 0;
pub const VK_FORMAT_R4G4_UNORM_PACK8: VkFormat = 1;
pub const VK_FORMAT_R4G4B4A4_UNORM_PACK16: VkFormat = 2;
pub const VK_FORMAT_B4G4R4A4_UNORM_PACK16: VkFormat = 3;
pub const VK_FORMAT_R5G6B5_UNORM_PACK16: VkFormat = 4;
pub const VK_FORMAT_B5G6R5_UNORM_PACK16: VkFormat = 5;
pub const VK_FORMAT_R5G5B5A1_UNORM_PACK16: VkFormat = 6;
pub const VK_FORMAT_B5G5R5A1_UNORM_PACK16: VkFormat = 7;
pub const VK_FORMAT_A1R5G5B5_UNORM_PACK16: VkFormat = 8;
pub const VK_FORMAT_R8_UNORM: VkFormat = 9;
pub const VK_FORMAT_R8_SNORM: VkFormat = 10;
pub const VK_FORMAT_R8_USCALED: VkFormat = 11;
pub const VK_FORMAT_R8_SSCALED: VkFormat = 12;
pub const VK_FORMAT_R8_UINT: VkFormat = 13;
pub const VK_FORMAT_R8_SINT: VkFormat = 14;
pub const VK_FORMAT_R8_SRGB: VkFormat = 15;
pub const VK_FORMAT_R8G8_UNORM: VkFormat = 16;
pub const VK_FORMAT_R8G8_SNORM: VkFormat = 17;
pub const VK_FORMAT_R8G8_USCALED: VkFormat = 18;
pub const VK_FORMAT_R8G8_SSCALED: VkFormat = 19;
pub const VK_FORMAT_R8G8_UINT: VkFormat = 20;
pub const VK_FORMAT_R8G8_SINT: VkFormat = 21;
pub const VK_FORMAT_R8G8_SRGB: VkFormat = 22;
pub const VK_FORMAT_R8G8B8_UNORM: VkFormat = 23;
pub const VK_FORMAT_R8G8B8_SNORM: VkFormat = 24;
pub const VK_FORMAT_R8G8B8_USCALED: VkFormat = 25;
pub const VK_FORMAT_R8G8B8_SSCALED: VkFormat = 26;
pub const VK_FORMAT_R8G8B8_UINT: VkFormat = 27;
pub const VK_FORMAT_R8G8B8_SINT: VkFormat = 28;
pub const VK_FORMAT_R8G8B8_SRGB: VkFormat = 29;
pub const VK_FORMAT_B8G8R8_UNORM: VkFormat = 30;
pub const VK_FORMAT_B8G8R8_SNORM: VkFormat = 31;
pub const VK_FORMAT_B8G8R8_USCALED: VkFormat = 32;
pub const VK_FORMAT_B8G8R8_SSCALED: VkFormat = 33;
pub const VK_FORMAT_B8G8R8_UINT: VkFormat = 34;
pub const VK_FORMAT_B8G8R8_SINT: VkFormat = 35;
pub const VK_FORMAT_B8G8R8_SRGB: VkFormat = 36;
pub const VK_FORMAT_R8G8B8A8_UNORM: VkFormat = 37;
pub const VK_FORMAT_R8G8B8A8_SNORM: VkFormat = 38;
pub const VK_FORMAT_R8G8B8A8_USCALED: VkFormat = 39;
pub const VK_FORMAT_R8G8B8A8_SSCALED: VkFormat = 40;
pub const VK_FORMAT_R8G8B8A8_UINT: VkFormat = 41;
pub const VK_FORMAT_R8G8B8A8_SINT: VkFormat = 42;
pub const VK_FORMAT_R8G8B8A8_SRGB: VkFormat = 43;
pub const VK_FORMAT_B8G8R8A8_UNORM: VkFormat = 44;
pub const VK_FORMAT_B8G8R8A8_SNORM: VkFormat = 45;
pub const VK_FORMAT_B8G8R8A8_USCALED: VkFormat = 46;
pub const VK_FORMAT_B8G8R8A8_SSCALED: VkFormat = 47;
pub const VK_FORMAT_B8G8R8A8_UINT: VkFormat = 48;
pub const VK_FORMAT_B8G8R8A8_SINT: VkFormat = 49;
pub const VK_FORMAT_B8G8R8A8_SRGB: VkFormat = 50;
pub const VK_FORMAT_A8B8G8R8_UNORM_PACK32: VkFormat = 51;
pub const VK_FORMAT_A8B8G8R8_SNORM_PACK32: VkFormat = 52;
pub const VK_FORMAT_A8B8G8R8_USCALED_PACK32: VkFormat = 53;
pub const VK_FORMAT_A8B8G8R8_SSCALED_PACK32: VkFormat = 54;
pub const VK_FORMAT_A8B8G8R8_UINT_PACK32: VkFormat = 55;
pub const VK_FORMAT_A8B8G8R8_SINT_PACK32: VkFormat = 56;
pub const VK_FORMAT_A8B8G8R8_SRGB_PACK32: VkFormat = 57;
pub const VK_FORMAT_A2R10G10B10_UNORM_PACK32: VkFormat = 58;
pub const VK_FORMAT_A2R10G10B10_SNORM_PACK32: VkFormat = 59;
pub const VK_FORMAT_A2R10G10B10_USCALED_PACK32: VkFormat = 60;
pub const VK_FORMAT_A2R10G10B10_SSCALED_PACK32: VkFormat = 61;
pub const VK_FORMAT_A2R10G10B10_UINT_PACK32: VkFormat = 62;
pub const VK_FORMAT_A2R10G10B10_SINT_PACK32: VkFormat = 63;
pub const VK_FORMAT_A2B10G10R10_UNORM_PACK32: VkFormat = 64;
pub const VK_FORMAT_A2B10G10R10_SNORM_PACK32: VkFormat = 65;
pub const VK_FORMAT_A2B10G10R10_USCALED_PACK32: VkFormat = 66;
pub const VK_FORMAT_A2B10G10R10_SSCALED_PACK32: VkFormat = 67;
pub const VK_FORMAT_A2B10G10R10_UINT_PACK32: VkFormat = 68;
pub const VK_FORMAT_A2B10G10R10_SINT_PACK32: VkFormat = 69;
pub const VK_FORMAT_R16_UNORM: VkFormat = 70;
pub const VK_FORMAT_R16_SNORM: VkFormat = 71;
pub const VK_FORMAT_R16_USCALED: VkFormat = 72;
pub const VK_FORMAT_R16_SSCALED: VkFormat = 73;
pub const VK_FORMAT_R16_UINT: VkFormat = 74;
pub const VK_FORMAT_R16_SINT: VkFormat = 75;
pub const VK_FORMAT_R16_SFLOAT: VkFormat = 76;
pub const VK_FORMAT_R16G16_UNORM: VkFormat = 77;
pub const VK_FORMAT_R16G16_SNORM: VkFormat = 78;
pub const VK_FORMAT_R16G16_USCALED: VkFormat = 79;
pub const VK_FORMAT_R16G16_SSCALED: VkFormat = 80;
pub const VK_FORMAT_R16G16_UINT: VkFormat = 81;
pub const VK_FORMAT_R16G16_SINT: VkFormat = 82;
pub const VK_FORMAT_R16G16_SFLOAT: VkFormat = 83;
pub const VK_FORMAT_R16G16B16_UNORM: VkFormat = 84;
pub const VK_FORMAT_R16G16B16_SNORM: VkFormat = 85;
pub const VK_FORMAT_R16G16B16_USCALED: VkFormat = 86;
pub const VK_FORMAT_R16G16B16_SSCALED: VkFormat = 87;
pub const VK_FORMAT_R16G16B16_UINT: VkFormat = 88;
pub const VK_FORMAT_R16G16B16_SINT: VkFormat = 89;
pub const VK_FORMAT_R16G16B16_SFLOAT: VkFormat = 90;
pub const VK_FORMAT_R16G16B16A16_UNORM: VkFormat = 91;
pub const VK_FORMAT_R16G16B16A16_SNORM: VkFormat = 92;
pub const VK_FORMAT_R16G16B16A16_USCALED: VkFormat = 93;
pub const VK_FORMAT_R16G16B16A16_SSCALED: VkFormat = 94;
pub const VK_FORMAT_R16G16B16A16_UINT: VkFormat = 95;
pub const VK_FORMAT_R16G16B16A16_SINT: VkFormat = 96;
pub const VK_FORMAT_R16G16B16A16_SFLOAT: VkFormat = 97;
pub const VK_FORMAT_R32_UINT: VkFormat = 98;
pub const VK_FORMAT_R32_SINT: VkFormat = 99;
pub const VK_FORMAT_R32_SFLOAT: VkFormat = 100;
pub const VK_FORMAT_R32G32_UINT: VkFormat = 101;
pub const VK_FORMAT_R32G32_SINT: VkFormat = 102;
pub const VK_FORMAT_R32G32_SFLOAT: VkFormat = 103;
pub const VK_FORMAT_R32G32B32_UINT: VkFormat = 104;
pub const VK_FORMAT_R32G32B32_SINT: VkFormat = 105;
pub const VK_FORMAT_R32G32B32_SFLOAT: VkFormat = 106;
pub const VK_FORMAT_R32G32B32A32_UINT: VkFormat = 107;
pub const VK_FORMAT_R32G32B32A32_SINT: VkFormat = 108;
pub const VK_FORMAT_R32G32B32A32_SFLOAT: VkFormat = 109;
pub const VK_FORMAT_R64_UINT: VkFormat = 110;
pub const VK_FORMAT_R64_SINT: VkFormat = 111;
pub const VK_FORMAT_R64_SFLOAT: VkFormat = 112;
pub const VK_FORMAT_R64G64_UINT: VkFormat = 113;
pub const VK_FORMAT_R64G64_SINT: VkFormat = 114;
pub const VK_FORMAT_R64G64_SFLOAT: VkFormat = 115;
pub const VK_FORMAT_R64G64B64_UINT: VkFormat = 116;
pub const VK_FORMAT_R64G64B64_SINT: VkFormat = 117;
pub const VK_FORMAT_R64G64B64_SFLOAT: VkFormat = 118;
pub const VK_FORMAT_R64G64B64A64_UINT: VkFormat = 119;
pub const VK_FORMAT_R64G64B64A64_SINT: VkFormat = 120;
pub const VK_FORMAT_R64G64B64A64_SFLOAT: VkFormat = 121;
pub const VK_FORMAT_B10G11R11_UFLOAT_PACK32: VkFormat = 122;
pub const VK_FORMAT_E5B9G9R9_UFLOAT_PACK32: VkFormat = 123;
pub const VK_FORMAT_D16_UNORM: VkFormat = 124;
pub const VK_FORMAT_X8_D24_UNORM_PACK32: VkFormat = 125;
pub const VK_FORMAT_D32_SFLOAT: VkFormat = 126;
pub const VK_FORMAT_S8_UINT: VkFormat = 127;
pub const VK_FORMAT_D16_UNORM_S8_UINT: VkFormat = 128;
pub const VK_FORMAT_D24_UNORM_S8_UINT: VkFormat = 129;
pub const VK_FORMAT_D32_SFLOAT_S8_UINT: VkFormat = 130;
pub const VK_FORMAT_BC1_RGB_UNORM_BLOCK: VkFormat = 131;
pub const VK_FORMAT_BC1_RGB_SRGB_BLOCK: VkFormat = 132;
pub const VK_FORMAT_BC1_RGBA_UNORM_BLOCK: VkFormat = 133;
pub const VK_FORMAT_BC1_RGBA_SRGB_BLOCK: VkFormat = 134;
pub const VK_FORMAT_BC2_UNORM_BLOCK: VkFormat = 135;
pub const VK_FORMAT_BC2_SRGB_BLOCK: VkFormat = 136;
pub const VK_FORMAT_BC3_UNORM_BLOCK: VkFormat = 137;
pub const VK_FORMAT_BC3_SRGB_BLOCK: VkFormat = 138;
pub const VK_FORMAT_BC4_UNORM_BLOCK: VkFormat = 139;
pub const VK_FORMAT_BC4_SNORM_BLOCK: VkFormat = 140;
pub const VK_FORMAT_BC5_UNORM_BLOCK: VkFormat = 141;
pub const VK_FORMAT_BC5_SNORM_BLOCK: VkFormat = 142;
pub const VK_FORMAT_BC6H_UFLOAT_BLOCK: VkFormat = 143;
pub const VK_FORMAT_BC6H_SFLOAT_BLOCK: VkFormat = 144;
pub const VK_FORMAT_BC7_UNORM_BLOCK: VkFormat = 145;
pub const VK_FORMAT_BC7_SRGB_BLOCK: VkFormat = 146;
pub const VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK: VkFormat = 147;
pub const VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK: VkFormat = 148;
pub const VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK: VkFormat = 149;
pub const VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK: VkFormat = 150;
pub const VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK: VkFormat = 151;
pub const VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK: VkFormat = 152;
pub const VK_FORMAT_EAC_R11_UNORM_BLOCK: VkFormat = 153;
pub const VK_FORMAT_EAC_R11_SNORM_BLOCK: VkFormat = 154;
pub const VK_FORMAT_EAC_R11G11_UNORM_BLOCK: VkFormat = 155;
pub const VK_FORMAT_EAC_R11G11_SNORM_BLOCK: VkFormat = 156;
pub const VK_FORMAT_ASTC_4x4_UNORM_BLOCK: VkFormat = 157;
pub const VK_FORMAT_ASTC_4x4_SRGB_BLOCK: VkFormat = 158;
pub const VK_FORMAT_ASTC_5x4_UNORM_BLOCK: VkFormat = 159;
pub const VK_FORMAT_ASTC_5x4_SRGB_BLOCK: VkFormat = 160;
pub const VK_FORMAT_ASTC_5x5_UNORM_BLOCK: VkFormat = 161;
pub const VK_FORMAT_ASTC_5x5_SRGB_BLOCK: VkFormat = 162;
pub const VK_FORMAT_ASTC_6x5_UNORM_BLOCK: VkFormat = 163;
pub const VK_FORMAT_ASTC_6x5_SRGB_BLOCK: VkFormat = 164;
pub const VK_FORMAT_ASTC_6x6_UNORM_BLOCK: VkFormat = 165;
pub const VK_FORMAT_ASTC_6x6_SRGB_BLOCK: VkFormat = 166;
pub const VK_FORMAT_ASTC_8x5_UNORM_BLOCK: VkFormat = 167;
pub const VK_FORMAT_ASTC_8x5_SRGB_BLOCK: VkFormat = 168;
pub const VK_FORMAT_ASTC_8x6_UNORM_BLOCK: VkFormat = 169;
pub const VK_FORMAT_ASTC_8x6_SRGB_BLOCK: VkFormat = 170;
pub const VK_FORMAT_ASTC_8x8_UNORM_BLOCK: VkFormat = 171;
pub const VK_FORMAT_ASTC_8x8_SRGB_BLOCK: VkFormat = 172;
pub const VK_FORMAT_ASTC_10x5_UNORM_BLOCK: VkFormat = 173;
pub const VK_FORMAT_ASTC_10x5_SRGB_BLOCK: VkFormat = 174;
pub const VK_FORMAT_ASTC_10x6_UNORM_BLOCK: VkFormat = 175;
pub const VK_FORMAT_ASTC_10x6_SRGB_BLOCK: VkFormat = 176;
pub const VK_FORMAT_ASTC_10x8_UNORM_BLOCK: VkFormat = 177;
pub const VK_FORMAT_ASTC_10x8_SRGB_BLOCK: VkFormat = 178;
pub const VK_FORMAT_ASTC_10x10_UNORM_BLOCK: VkFormat = 179;
pub const VK_FORMAT_ASTC_10x10_SRGB_BLOCK: VkFormat = 180;
pub const VK_FORMAT_ASTC_12x10_UNORM_BLOCK: VkFormat = 181;
pub const VK_FORMAT_ASTC_12x10_SRGB_BLOCK: VkFormat = 182;
pub const VK_FORMAT_ASTC_12x12_UNORM_BLOCK: VkFormat = 183;
pub const VK_FORMAT_ASTC_12x12_SRGB_BLOCK: VkFormat = 184;
pub const VK_FORMAT_G8B8G8R8_422_UNORM: VkFormat = 1000156000;
pub const VK_FORMAT_B8G8R8G8_422_UNORM: VkFormat = 1000156001;
pub const VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM: VkFormat = 1000156002;
pub const VK_FORMAT_G8_B8R8_2PLANE_420_UNORM: VkFormat = 1000156003;
pub const VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM: VkFormat = 1000156004;
pub const VK_FORMAT_G8_B8R8_2PLANE_422_UNORM: VkFormat = 1000156005;
pub const VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM: VkFormat = 1000156006;
pub const VK_FORMAT_R10X6_UNORM_PACK16: VkFormat = 1000156007;
pub const VK_FORMAT_R10X6G10X6_UNORM_2PACK16: VkFormat = 1000156008;
pub const VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16: VkFormat = 1000156009;
pub const VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16: VkFormat = 1000156010;
pub const VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16: VkFormat = 1000156011;
pub const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16: VkFormat = 1000156012;
pub const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16: VkFormat = 1000156013;
pub const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16: VkFormat = 1000156014;
pub const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16: VkFormat = 1000156015;
pub const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16: VkFormat = 1000156016;
pub const VK_FORMAT_R12X4_UNORM_PACK16: VkFormat = 1000156017;
pub const VK_FORMAT_R12X4G12X4_UNORM_2PACK16: VkFormat = 1000156018;
pub const VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16: VkFormat = 1000156019;
pub const VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16: VkFormat = 1000156020;
pub const VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16: VkFormat = 1000156021;
pub const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16: VkFormat = 1000156022;
pub const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16: VkFormat = 1000156023;
pub const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16: VkFormat = 1000156024;
pub const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16: VkFormat = 1000156025;
pub const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16: VkFormat = 1000156026;
pub const VK_FORMAT_G16B16G16R16_422_UNORM: VkFormat = 1000156027;
pub const VK_FORMAT_B16G16R16G16_422_UNORM: VkFormat = 1000156028;
pub const VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM: VkFormat = 1000156029;
pub const VK_FORMAT_G16_B16R16_2PLANE_420_UNORM: VkFormat = 1000156030;
pub const VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM: VkFormat = 1000156031;
pub const VK_FORMAT_G16_B16R16_2PLANE_422_UNORM: VkFormat = 1000156032;
pub const VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM: VkFormat = 1000156033;
pub const VK_FORMAT_G8_B8R8_2PLANE_444_UNORM: VkFormat = 1000330000;
pub const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16: VkFormat = 1000330001;
pub const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16: VkFormat = 1000330002;
pub const VK_FORMAT_G16_B16R16_2PLANE_444_UNORM: VkFormat = 1000330003;
pub const VK_FORMAT_A4R4G4B4_UNORM_PACK16: VkFormat = 1000340000;
pub const VK_FORMAT_A4B4G4R4_UNORM_PACK16: VkFormat = 1000340001;
pub const VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK: VkFormat = 1000066000;
pub const VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK: VkFormat = 1000066001;
pub const VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK: VkFormat = 1000066002;
pub const VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK: VkFormat = 1000066003;
pub const VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK: VkFormat = 1000066004;
pub const VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK: VkFormat = 1000066005;
pub const VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK: VkFormat = 1000066006;
pub const VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK: VkFormat = 1000066007;
pub const VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK: VkFormat = 1000066008;
pub const VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK: VkFormat = 1000066009;
pub const VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK: VkFormat = 1000066010;
pub const VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK: VkFormat = 1000066011;
pub const VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK: VkFormat = 1000066012;
pub const VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK: VkFormat = 1000066013;
pub const VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG: VkFormat = 1000054000;
pub const VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG: VkFormat = 1000054001;
pub const VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG: VkFormat = 1000054002;
pub const VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG: VkFormat = 1000054003;
pub const VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG: VkFormat = 1000054004;
pub const VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG: VkFormat = 1000054005;
pub const VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG: VkFormat = 1000054006;
pub const VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG: VkFormat = 1000054007;
pub const VK_FORMAT_R16G16_S10_5_NV: VkFormat = 1000464000;
pub const VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT: VkFormat = 1000066000;
pub const VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT: VkFormat = 1000066001;
pub const VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066002;
pub const VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066003;
pub const VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT: VkFormat = 1000066004;
pub const VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066005;
pub const VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT: VkFormat = 1000066006;
pub const VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT: VkFormat = 1000066007;
pub const VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT: VkFormat = 1000066008;
pub const VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT: VkFormat = 1000066009;
pub const VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT: VkFormat = 1000066010;
pub const VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT: VkFormat = 1000066011;
pub const VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT: VkFormat = 1000066012;
pub const VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT: VkFormat = 1000066013;
pub const VK_FORMAT_G8B8G8R8_422_UNORM_KHR: VkFormat = 1000156000;
pub const VK_FORMAT_B8G8R8G8_422_UNORM_KHR: VkFormat = 1000156001;
pub const VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR: VkFormat = 1000156002;
pub const VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR: VkFormat = 1000156003;
pub const VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR: VkFormat = 1000156004;
pub const VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR: VkFormat = 1000156005;
pub const VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR: VkFormat = 1000156006;
pub const VK_FORMAT_R10X6_UNORM_PACK16_KHR: VkFormat = 1000156007;
pub const VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR: VkFormat = 1000156008;
pub const VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR: VkFormat = 1000156009;
pub const VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR: VkFormat = 1000156010;
pub const VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR: VkFormat = 1000156011;
pub const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156012;
pub const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156013;
pub const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156014;
pub const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156015;
pub const VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR: VkFormat = 1000156016;
pub const VK_FORMAT_R12X4_UNORM_PACK16_KHR: VkFormat = 1000156017;
pub const VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR: VkFormat = 1000156018;
pub const VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR: VkFormat = 1000156019;
pub const VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR: VkFormat = 1000156020;
pub const VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR: VkFormat = 1000156021;
pub const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156022;
pub const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR: VkFormat = 1000156023;
pub const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156024;
pub const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR: VkFormat = 1000156025;
pub const VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR: VkFormat = 1000156026;
pub const VK_FORMAT_G16B16G16R16_422_UNORM_KHR: VkFormat = 1000156027;
pub const VK_FORMAT_B16G16R16G16_422_UNORM_KHR: VkFormat = 1000156028;
pub const VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR: VkFormat = 1000156029;
pub const VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR: VkFormat = 1000156030;
pub const VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR: VkFormat = 1000156031;
pub const VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR: VkFormat = 1000156032;
pub const VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR: VkFormat = 1000156033;
pub const VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT: VkFormat = 1000330000;
pub const VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT: VkFormat = 1000330001;
pub const VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT: VkFormat = 1000330002;
pub const VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT: VkFormat = 1000330003;
pub const VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT: VkFormat = 1000340000;
pub const VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT: VkFormat = 1000340001;
pub const VK_FORMAT_MAX_ENUM: VkFormat = 2147483647;
pub type VkFormat = ::std::os::raw::c_int;
pub const VK_IMAGE_TILING_OPTIMAL: VkImageTiling = 0;
pub const VK_IMAGE_TILING_LINEAR: VkImageTiling = 1;
pub const VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT: VkImageTiling = 1000158000;
pub const VK_IMAGE_TILING_MAX_ENUM: VkImageTiling = 2147483647;
pub type VkImageTiling = ::std::os::raw::c_int;
pub const VK_IMAGE_TYPE_1D: VkImageType = 0;
pub const VK_IMAGE_TYPE_2D: VkImageType = 1;
pub const VK_IMAGE_TYPE_3D: VkImageType = 2;
pub const VK_IMAGE_TYPE_MAX_ENUM: VkImageType = 2147483647;
pub type VkImageType = ::std::os::raw::c_int;
pub const VK_PHYSICAL_DEVICE_TYPE_OTHER: VkPhysicalDeviceType = 0;
pub const VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU: VkPhysicalDeviceType = 1;
pub const VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU: VkPhysicalDeviceType = 2;
pub const VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU: VkPhysicalDeviceType = 3;
pub const VK_PHYSICAL_DEVICE_TYPE_CPU: VkPhysicalDeviceType = 4;
pub const VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM: VkPhysicalDeviceType = 2147483647;
pub type VkPhysicalDeviceType = ::std::os::raw::c_int;
pub const VK_QUERY_TYPE_OCCLUSION: VkQueryType = 0;
pub const VK_QUERY_TYPE_PIPELINE_STATISTICS: VkQueryType = 1;
pub const VK_QUERY_TYPE_TIMESTAMP: VkQueryType = 2;
pub const VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT: VkQueryType = 1000028004;
pub const VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR: VkQueryType = 1000116000;
pub const VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR: VkQueryType = 1000150000;
pub const VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR: VkQueryType = 1000150001;
pub const VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV: VkQueryType = 1000165000;
pub const VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL: VkQueryType = 1000210000;
pub const VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT: VkQueryType = 1000328000;
pub const VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT: VkQueryType = 1000382000;
pub const VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR:
    VkQueryType = 1000386000;
pub const VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR: VkQueryType = 1000386001;
pub const VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT: VkQueryType = 1000396000;
pub const VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT: VkQueryType = 1000396001;
pub const VK_QUERY_TYPE_MAX_ENUM: VkQueryType = 2147483647;
pub type VkQueryType = ::std::os::raw::c_int;
pub const VK_SHARING_MODE_EXCLUSIVE: VkSharingMode = 0;
pub const VK_SHARING_MODE_CONCURRENT: VkSharingMode = 1;
pub const VK_SHARING_MODE_MAX_ENUM: VkSharingMode = 2147483647;
pub type VkSharingMode = ::std::os::raw::c_int;
pub const VK_COMPONENT_SWIZZLE_IDENTITY: VkComponentSwizzle = 0;
pub const VK_COMPONENT_SWIZZLE_ZERO: VkComponentSwizzle = 1;
pub const VK_COMPONENT_SWIZZLE_ONE: VkComponentSwizzle = 2;
pub const VK_COMPONENT_SWIZZLE_R: VkComponentSwizzle = 3;
pub const VK_COMPONENT_SWIZZLE_G: VkComponentSwizzle = 4;
pub const VK_COMPONENT_SWIZZLE_B: VkComponentSwizzle = 5;
pub const VK_COMPONENT_SWIZZLE_A: VkComponentSwizzle = 6;
pub const VK_COMPONENT_SWIZZLE_MAX_ENUM: VkComponentSwizzle = 2147483647;
pub type VkComponentSwizzle = ::std::os::raw::c_int;
pub const VK_IMAGE_VIEW_TYPE_1D: VkImageViewType = 0;
pub const VK_IMAGE_VIEW_TYPE_2D: VkImageViewType = 1;
pub const VK_IMAGE_VIEW_TYPE_3D: VkImageViewType = 2;
pub const VK_IMAGE_VIEW_TYPE_CUBE: VkImageViewType = 3;
pub const VK_IMAGE_VIEW_TYPE_1D_ARRAY: VkImageViewType = 4;
pub const VK_IMAGE_VIEW_TYPE_2D_ARRAY: VkImageViewType = 5;
pub const VK_IMAGE_VIEW_TYPE_CUBE_ARRAY: VkImageViewType = 6;
pub const VK_IMAGE_VIEW_TYPE_MAX_ENUM: VkImageViewType = 2147483647;
pub type VkImageViewType = ::std::os::raw::c_int;
pub const VK_BLEND_FACTOR_ZERO: VkBlendFactor = 0;
pub const VK_BLEND_FACTOR_ONE: VkBlendFactor = 1;
pub const VK_BLEND_FACTOR_SRC_COLOR: VkBlendFactor = 2;
pub const VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR: VkBlendFactor = 3;
pub const VK_BLEND_FACTOR_DST_COLOR: VkBlendFactor = 4;
pub const VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR: VkBlendFactor = 5;
pub const VK_BLEND_FACTOR_SRC_ALPHA: VkBlendFactor = 6;
pub const VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA: VkBlendFactor = 7;
pub const VK_BLEND_FACTOR_DST_ALPHA: VkBlendFactor = 8;
pub const VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA: VkBlendFactor = 9;
pub const VK_BLEND_FACTOR_CONSTANT_COLOR: VkBlendFactor = 10;
pub const VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR: VkBlendFactor = 11;
pub const VK_BLEND_FACTOR_CONSTANT_ALPHA: VkBlendFactor = 12;
pub const VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA: VkBlendFactor = 13;
pub const VK_BLEND_FACTOR_SRC_ALPHA_SATURATE: VkBlendFactor = 14;
pub const VK_BLEND_FACTOR_SRC1_COLOR: VkBlendFactor = 15;
pub const VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR: VkBlendFactor = 16;
pub const VK_BLEND_FACTOR_SRC1_ALPHA: VkBlendFactor = 17;
pub const VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA: VkBlendFactor = 18;
pub const VK_BLEND_FACTOR_MAX_ENUM: VkBlendFactor = 2147483647;
pub type VkBlendFactor = ::std::os::raw::c_int;
pub const VK_BLEND_OP_ADD: VkBlendOp = 0;
pub const VK_BLEND_OP_SUBTRACT: VkBlendOp = 1;
pub const VK_BLEND_OP_REVERSE_SUBTRACT: VkBlendOp = 2;
pub const VK_BLEND_OP_MIN: VkBlendOp = 3;
pub const VK_BLEND_OP_MAX: VkBlendOp = 4;
pub const VK_BLEND_OP_ZERO_EXT: VkBlendOp = 1000148000;
pub const VK_BLEND_OP_SRC_EXT: VkBlendOp = 1000148001;
pub const VK_BLEND_OP_DST_EXT: VkBlendOp = 1000148002;
pub const VK_BLEND_OP_SRC_OVER_EXT: VkBlendOp = 1000148003;
pub const VK_BLEND_OP_DST_OVER_EXT: VkBlendOp = 1000148004;
pub const VK_BLEND_OP_SRC_IN_EXT: VkBlendOp = 1000148005;
pub const VK_BLEND_OP_DST_IN_EXT: VkBlendOp = 1000148006;
pub const VK_BLEND_OP_SRC_OUT_EXT: VkBlendOp = 1000148007;
pub const VK_BLEND_OP_DST_OUT_EXT: VkBlendOp = 1000148008;
pub const VK_BLEND_OP_SRC_ATOP_EXT: VkBlendOp = 1000148009;
pub const VK_BLEND_OP_DST_ATOP_EXT: VkBlendOp = 1000148010;
pub const VK_BLEND_OP_XOR_EXT: VkBlendOp = 1000148011;
pub const VK_BLEND_OP_MULTIPLY_EXT: VkBlendOp = 1000148012;
pub const VK_BLEND_OP_SCREEN_EXT: VkBlendOp = 1000148013;
pub const VK_BLEND_OP_OVERLAY_EXT: VkBlendOp = 1000148014;
pub const VK_BLEND_OP_DARKEN_EXT: VkBlendOp = 1000148015;
pub const VK_BLEND_OP_LIGHTEN_EXT: VkBlendOp = 1000148016;
pub const VK_BLEND_OP_COLORDODGE_EXT: VkBlendOp = 1000148017;
pub const VK_BLEND_OP_COLORBURN_EXT: VkBlendOp = 1000148018;
pub const VK_BLEND_OP_HARDLIGHT_EXT: VkBlendOp = 1000148019;
pub const VK_BLEND_OP_SOFTLIGHT_EXT: VkBlendOp = 1000148020;
pub const VK_BLEND_OP_DIFFERENCE_EXT: VkBlendOp = 1000148021;
pub const VK_BLEND_OP_EXCLUSION_EXT: VkBlendOp = 1000148022;
pub const VK_BLEND_OP_INVERT_EXT: VkBlendOp = 1000148023;
pub const VK_BLEND_OP_INVERT_RGB_EXT: VkBlendOp = 1000148024;
pub const VK_BLEND_OP_LINEARDODGE_EXT: VkBlendOp = 1000148025;
pub const VK_BLEND_OP_LINEARBURN_EXT: VkBlendOp = 1000148026;
pub const VK_BLEND_OP_VIVIDLIGHT_EXT: VkBlendOp = 1000148027;
pub const VK_BLEND_OP_LINEARLIGHT_EXT: VkBlendOp = 1000148028;
pub const VK_BLEND_OP_PINLIGHT_EXT: VkBlendOp = 1000148029;
pub const VK_BLEND_OP_HARDMIX_EXT: VkBlendOp = 1000148030;
pub const VK_BLEND_OP_HSL_HUE_EXT: VkBlendOp = 1000148031;
pub const VK_BLEND_OP_HSL_SATURATION_EXT: VkBlendOp = 1000148032;
pub const VK_BLEND_OP_HSL_COLOR_EXT: VkBlendOp = 1000148033;
pub const VK_BLEND_OP_HSL_LUMINOSITY_EXT: VkBlendOp = 1000148034;
pub const VK_BLEND_OP_PLUS_EXT: VkBlendOp = 1000148035;
pub const VK_BLEND_OP_PLUS_CLAMPED_EXT: VkBlendOp = 1000148036;
pub const VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT: VkBlendOp = 1000148037;
pub const VK_BLEND_OP_PLUS_DARKER_EXT: VkBlendOp = 1000148038;
pub const VK_BLEND_OP_MINUS_EXT: VkBlendOp = 1000148039;
pub const VK_BLEND_OP_MINUS_CLAMPED_EXT: VkBlendOp = 1000148040;
pub const VK_BLEND_OP_CONTRAST_EXT: VkBlendOp = 1000148041;
pub const VK_BLEND_OP_INVERT_OVG_EXT: VkBlendOp = 1000148042;
pub const VK_BLEND_OP_RED_EXT: VkBlendOp = 1000148043;
pub const VK_BLEND_OP_GREEN_EXT: VkBlendOp = 1000148044;
pub const VK_BLEND_OP_BLUE_EXT: VkBlendOp = 1000148045;
pub const VK_BLEND_OP_MAX_ENUM: VkBlendOp = 2147483647;
pub type VkBlendOp = ::std::os::raw::c_int;
pub const VK_COMPARE_OP_NEVER: VkCompareOp = 0;
pub const VK_COMPARE_OP_LESS: VkCompareOp = 1;
pub const VK_COMPARE_OP_EQUAL: VkCompareOp = 2;
pub const VK_COMPARE_OP_LESS_OR_EQUAL: VkCompareOp = 3;
pub const VK_COMPARE_OP_GREATER: VkCompareOp = 4;
pub const VK_COMPARE_OP_NOT_EQUAL: VkCompareOp = 5;
pub const VK_COMPARE_OP_GREATER_OR_EQUAL: VkCompareOp = 6;
pub const VK_COMPARE_OP_ALWAYS: VkCompareOp = 7;
pub const VK_COMPARE_OP_MAX_ENUM: VkCompareOp = 2147483647;
pub type VkCompareOp = ::std::os::raw::c_int;
pub const VK_DYNAMIC_STATE_VIEWPORT: VkDynamicState = 0;
pub const VK_DYNAMIC_STATE_SCISSOR: VkDynamicState = 1;
pub const VK_DYNAMIC_STATE_LINE_WIDTH: VkDynamicState = 2;
pub const VK_DYNAMIC_STATE_DEPTH_BIAS: VkDynamicState = 3;
pub const VK_DYNAMIC_STATE_BLEND_CONSTANTS: VkDynamicState = 4;
pub const VK_DYNAMIC_STATE_DEPTH_BOUNDS: VkDynamicState = 5;
pub const VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK: VkDynamicState = 6;
pub const VK_DYNAMIC_STATE_STENCIL_WRITE_MASK: VkDynamicState = 7;
pub const VK_DYNAMIC_STATE_STENCIL_REFERENCE: VkDynamicState = 8;
pub const VK_DYNAMIC_STATE_CULL_MODE: VkDynamicState = 1000267000;
pub const VK_DYNAMIC_STATE_FRONT_FACE: VkDynamicState = 1000267001;
pub const VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY: VkDynamicState = 1000267002;
pub const VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT: VkDynamicState = 1000267003;
pub const VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT: VkDynamicState = 1000267004;
pub const VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE: VkDynamicState = 1000267005;
pub const VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE: VkDynamicState = 1000267006;
pub const VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE: VkDynamicState = 1000267007;
pub const VK_DYNAMIC_STATE_DEPTH_COMPARE_OP: VkDynamicState = 1000267008;
pub const VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE: VkDynamicState = 1000267009;
pub const VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE: VkDynamicState = 1000267010;
pub const VK_DYNAMIC_STATE_STENCIL_OP: VkDynamicState = 1000267011;
pub const VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE: VkDynamicState = 1000377001;
pub const VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE: VkDynamicState = 1000377002;
pub const VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE: VkDynamicState = 1000377004;
pub const VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV: VkDynamicState = 1000087000;
pub const VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT: VkDynamicState = 1000099000;
pub const VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT: VkDynamicState = 1000143000;
pub const VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR: VkDynamicState = 1000347000;
pub const VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV: VkDynamicState = 1000164004;
pub const VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV: VkDynamicState = 1000164006;
pub const VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV: VkDynamicState = 1000205001;
pub const VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR: VkDynamicState = 1000226000;
pub const VK_DYNAMIC_STATE_LINE_STIPPLE_EXT: VkDynamicState = 1000259000;
pub const VK_DYNAMIC_STATE_VERTEX_INPUT_EXT: VkDynamicState = 1000352000;
pub const VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT: VkDynamicState = 1000377000;
pub const VK_DYNAMIC_STATE_LOGIC_OP_EXT: VkDynamicState = 1000377003;
pub const VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT: VkDynamicState = 1000381000;
pub const VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT: VkDynamicState = 1000455002;
pub const VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT: VkDynamicState = 1000455003;
pub const VK_DYNAMIC_STATE_POLYGON_MODE_EXT: VkDynamicState = 1000455004;
pub const VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT: VkDynamicState = 1000455005;
pub const VK_DYNAMIC_STATE_SAMPLE_MASK_EXT: VkDynamicState = 1000455006;
pub const VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT: VkDynamicState = 1000455007;
pub const VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT: VkDynamicState = 1000455008;
pub const VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT: VkDynamicState = 1000455009;
pub const VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT: VkDynamicState = 1000455010;
pub const VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT: VkDynamicState = 1000455011;
pub const VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT: VkDynamicState = 1000455012;
pub const VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT: VkDynamicState = 1000455013;
pub const VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT: VkDynamicState = 1000455014;
pub const VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT: VkDynamicState = 1000455015;
pub const VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT: VkDynamicState = 1000455016;
pub const VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT: VkDynamicState = 1000455017;
pub const VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT: VkDynamicState = 1000455018;
pub const VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT: VkDynamicState = 1000455019;
pub const VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT: VkDynamicState = 1000455020;
pub const VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT: VkDynamicState = 1000455021;
pub const VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT: VkDynamicState = 1000455022;
pub const VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV: VkDynamicState = 1000455023;
pub const VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV: VkDynamicState = 1000455024;
pub const VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV: VkDynamicState = 1000455025;
pub const VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV: VkDynamicState = 1000455026;
pub const VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV: VkDynamicState = 1000455027;
pub const VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV: VkDynamicState = 1000455028;
pub const VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV: VkDynamicState = 1000455029;
pub const VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV: VkDynamicState = 1000455030;
pub const VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV: VkDynamicState = 1000455031;
pub const VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV: VkDynamicState = 1000455032;
pub const VK_DYNAMIC_STATE_CULL_MODE_EXT: VkDynamicState = 1000267000;
pub const VK_DYNAMIC_STATE_FRONT_FACE_EXT: VkDynamicState = 1000267001;
pub const VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT: VkDynamicState = 1000267002;
pub const VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT: VkDynamicState = 1000267003;
pub const VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT: VkDynamicState = 1000267004;
pub const VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT: VkDynamicState = 1000267005;
pub const VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT: VkDynamicState = 1000267006;
pub const VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT: VkDynamicState = 1000267007;
pub const VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT: VkDynamicState = 1000267008;
pub const VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT: VkDynamicState = 1000267009;
pub const VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT: VkDynamicState = 1000267010;
pub const VK_DYNAMIC_STATE_STENCIL_OP_EXT: VkDynamicState = 1000267011;
pub const VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT: VkDynamicState = 1000377001;
pub const VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT: VkDynamicState = 1000377002;
pub const VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT: VkDynamicState = 1000377004;
pub const VK_DYNAMIC_STATE_MAX_ENUM: VkDynamicState = 2147483647;
pub type VkDynamicState = ::std::os::raw::c_int;
pub const VK_FRONT_FACE_COUNTER_CLOCKWISE: VkFrontFace = 0;
pub const VK_FRONT_FACE_CLOCKWISE: VkFrontFace = 1;
pub const VK_FRONT_FACE_MAX_ENUM: VkFrontFace = 2147483647;
pub type VkFrontFace = ::std::os::raw::c_int;
pub const VK_VERTEX_INPUT_RATE_VERTEX: VkVertexInputRate = 0;
pub const VK_VERTEX_INPUT_RATE_INSTANCE: VkVertexInputRate = 1;
pub const VK_VERTEX_INPUT_RATE_MAX_ENUM: VkVertexInputRate = 2147483647;
pub type VkVertexInputRate = ::std::os::raw::c_int;
pub const VK_PRIMITIVE_TOPOLOGY_POINT_LIST: VkPrimitiveTopology = 0;
pub const VK_PRIMITIVE_TOPOLOGY_LINE_LIST: VkPrimitiveTopology = 1;
pub const VK_PRIMITIVE_TOPOLOGY_LINE_STRIP: VkPrimitiveTopology = 2;
pub const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST: VkPrimitiveTopology = 3;
pub const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP: VkPrimitiveTopology = 4;
pub const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN: VkPrimitiveTopology = 5;
pub const VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY: VkPrimitiveTopology = 6;
pub const VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY: VkPrimitiveTopology = 7;
pub const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY: VkPrimitiveTopology = 8;
pub const VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY: VkPrimitiveTopology = 9;
pub const VK_PRIMITIVE_TOPOLOGY_PATCH_LIST: VkPrimitiveTopology = 10;
pub const VK_PRIMITIVE_TOPOLOGY_MAX_ENUM: VkPrimitiveTopology = 2147483647;
pub type VkPrimitiveTopology = ::std::os::raw::c_int;
pub const VK_POLYGON_MODE_FILL: VkPolygonMode = 0;
pub const VK_POLYGON_MODE_LINE: VkPolygonMode = 1;
pub const VK_POLYGON_MODE_POINT: VkPolygonMode = 2;
pub const VK_POLYGON_MODE_FILL_RECTANGLE_NV: VkPolygonMode = 1000153000;
pub const VK_POLYGON_MODE_MAX_ENUM: VkPolygonMode = 2147483647;
pub type VkPolygonMode = ::std::os::raw::c_int;
pub const VK_STENCIL_OP_KEEP: VkStencilOp = 0;
pub const VK_STENCIL_OP_ZERO: VkStencilOp = 1;
pub const VK_STENCIL_OP_REPLACE: VkStencilOp = 2;
pub const VK_STENCIL_OP_INCREMENT_AND_CLAMP: VkStencilOp = 3;
pub const VK_STENCIL_OP_DECREMENT_AND_CLAMP: VkStencilOp = 4;
pub const VK_STENCIL_OP_INVERT: VkStencilOp = 5;
pub const VK_STENCIL_OP_INCREMENT_AND_WRAP: VkStencilOp = 6;
pub const VK_STENCIL_OP_DECREMENT_AND_WRAP: VkStencilOp = 7;
pub const VK_STENCIL_OP_MAX_ENUM: VkStencilOp = 2147483647;
pub type VkStencilOp = ::std::os::raw::c_int;
pub const VK_LOGIC_OP_CLEAR: VkLogicOp = 0;
pub const VK_LOGIC_OP_AND: VkLogicOp = 1;
pub const VK_LOGIC_OP_AND_REVERSE: VkLogicOp = 2;
pub const VK_LOGIC_OP_COPY: VkLogicOp = 3;
pub const VK_LOGIC_OP_AND_INVERTED: VkLogicOp = 4;
pub const VK_LOGIC_OP_NO_OP: VkLogicOp = 5;
pub const VK_LOGIC_OP_XOR: VkLogicOp = 6;
pub const VK_LOGIC_OP_OR: VkLogicOp = 7;
pub const VK_LOGIC_OP_NOR: VkLogicOp = 8;
pub const VK_LOGIC_OP_EQUIVALENT: VkLogicOp = 9;
pub const VK_LOGIC_OP_INVERT: VkLogicOp = 10;
pub const VK_LOGIC_OP_OR_REVERSE: VkLogicOp = 11;
pub const VK_LOGIC_OP_COPY_INVERTED: VkLogicOp = 12;
pub const VK_LOGIC_OP_OR_INVERTED: VkLogicOp = 13;
pub const VK_LOGIC_OP_NAND: VkLogicOp = 14;
pub const VK_LOGIC_OP_SET: VkLogicOp = 15;
pub const VK_LOGIC_OP_MAX_ENUM: VkLogicOp = 2147483647;
pub type VkLogicOp = ::std::os::raw::c_int;
pub const VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK: VkBorderColor = 0;
pub const VK_BORDER_COLOR_INT_TRANSPARENT_BLACK: VkBorderColor = 1;
pub const VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK: VkBorderColor = 2;
pub const VK_BORDER_COLOR_INT_OPAQUE_BLACK: VkBorderColor = 3;
pub const VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE: VkBorderColor = 4;
pub const VK_BORDER_COLOR_INT_OPAQUE_WHITE: VkBorderColor = 5;
pub const VK_BORDER_COLOR_FLOAT_CUSTOM_EXT: VkBorderColor = 1000287003;
pub const VK_BORDER_COLOR_INT_CUSTOM_EXT: VkBorderColor = 1000287004;
pub const VK_BORDER_COLOR_MAX_ENUM: VkBorderColor = 2147483647;
pub type VkBorderColor = ::std::os::raw::c_int;
pub const VK_FILTER_NEAREST: VkFilter = 0;
pub const VK_FILTER_LINEAR: VkFilter = 1;
pub const VK_FILTER_CUBIC_EXT: VkFilter = 1000015000;
pub const VK_FILTER_CUBIC_IMG: VkFilter = 1000015000;
pub const VK_FILTER_MAX_ENUM: VkFilter = 2147483647;
pub type VkFilter = ::std::os::raw::c_int;
pub const VK_SAMPLER_ADDRESS_MODE_REPEAT: VkSamplerAddressMode = 0;
pub const VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT: VkSamplerAddressMode = 1;
pub const VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE: VkSamplerAddressMode = 2;
pub const VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER: VkSamplerAddressMode = 3;
pub const VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE: VkSamplerAddressMode = 4;
pub const VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR: VkSamplerAddressMode = 4;
pub const VK_SAMPLER_ADDRESS_MODE_MAX_ENUM: VkSamplerAddressMode = 2147483647;
pub type VkSamplerAddressMode = ::std::os::raw::c_int;
pub const VK_SAMPLER_MIPMAP_MODE_NEAREST: VkSamplerMipmapMode = 0;
pub const VK_SAMPLER_MIPMAP_MODE_LINEAR: VkSamplerMipmapMode = 1;
pub const VK_SAMPLER_MIPMAP_MODE_MAX_ENUM: VkSamplerMipmapMode = 2147483647;
pub type VkSamplerMipmapMode = ::std::os::raw::c_int;
pub const VK_DESCRIPTOR_TYPE_SAMPLER: VkDescriptorType = 0;
pub const VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER: VkDescriptorType = 1;
pub const VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE: VkDescriptorType = 2;
pub const VK_DESCRIPTOR_TYPE_STORAGE_IMAGE: VkDescriptorType = 3;
pub const VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER: VkDescriptorType = 4;
pub const VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: VkDescriptorType = 5;
pub const VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER: VkDescriptorType = 6;
pub const VK_DESCRIPTOR_TYPE_STORAGE_BUFFER: VkDescriptorType = 7;
pub const VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC: VkDescriptorType = 8;
pub const VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: VkDescriptorType = 9;
pub const VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: VkDescriptorType = 10;
pub const VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK: VkDescriptorType = 1000138000;
pub const VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR: VkDescriptorType = 1000150000;
pub const VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV: VkDescriptorType = 1000165000;
pub const VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM: VkDescriptorType = 1000440000;
pub const VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM: VkDescriptorType = 1000440001;
pub const VK_DESCRIPTOR_TYPE_MUTABLE_EXT: VkDescriptorType = 1000351000;
pub const VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT: VkDescriptorType = 1000138000;
pub const VK_DESCRIPTOR_TYPE_MUTABLE_VALVE: VkDescriptorType = 1000351000;
pub const VK_DESCRIPTOR_TYPE_MAX_ENUM: VkDescriptorType = 2147483647;
pub type VkDescriptorType = ::std::os::raw::c_int;
pub const VK_ATTACHMENT_LOAD_OP_LOAD: VkAttachmentLoadOp = 0;
pub const VK_ATTACHMENT_LOAD_OP_CLEAR: VkAttachmentLoadOp = 1;
pub const VK_ATTACHMENT_LOAD_OP_DONT_CARE: VkAttachmentLoadOp = 2;
pub const VK_ATTACHMENT_LOAD_OP_NONE_EXT: VkAttachmentLoadOp = 1000400000;
pub const VK_ATTACHMENT_LOAD_OP_MAX_ENUM: VkAttachmentLoadOp = 2147483647;
pub type VkAttachmentLoadOp = ::std::os::raw::c_int;
pub const VK_ATTACHMENT_STORE_OP_STORE: VkAttachmentStoreOp = 0;
pub const VK_ATTACHMENT_STORE_OP_DONT_CARE: VkAttachmentStoreOp = 1;
pub const VK_ATTACHMENT_STORE_OP_NONE: VkAttachmentStoreOp = 1000301000;
pub const VK_ATTACHMENT_STORE_OP_NONE_KHR: VkAttachmentStoreOp = 1000301000;
pub const VK_ATTACHMENT_STORE_OP_NONE_QCOM: VkAttachmentStoreOp = 1000301000;
pub const VK_ATTACHMENT_STORE_OP_NONE_EXT: VkAttachmentStoreOp = 1000301000;
pub const VK_ATTACHMENT_STORE_OP_MAX_ENUM: VkAttachmentStoreOp = 2147483647;
pub type VkAttachmentStoreOp = ::std::os::raw::c_int;
pub const VK_PIPELINE_BIND_POINT_GRAPHICS: VkPipelineBindPoint = 0;
pub const VK_PIPELINE_BIND_POINT_COMPUTE: VkPipelineBindPoint = 1;
pub const VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR: VkPipelineBindPoint = 1000165000;
pub const VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI: VkPipelineBindPoint = 1000369003;
pub const VK_PIPELINE_BIND_POINT_RAY_TRACING_NV: VkPipelineBindPoint = 1000165000;
pub const VK_PIPELINE_BIND_POINT_MAX_ENUM: VkPipelineBindPoint = 2147483647;
pub type VkPipelineBindPoint = ::std::os::raw::c_int;
pub const VK_COMMAND_BUFFER_LEVEL_PRIMARY: VkCommandBufferLevel = 0;
pub const VK_COMMAND_BUFFER_LEVEL_SECONDARY: VkCommandBufferLevel = 1;
pub const VK_COMMAND_BUFFER_LEVEL_MAX_ENUM: VkCommandBufferLevel = 2147483647;
pub type VkCommandBufferLevel = ::std::os::raw::c_int;
pub const VK_INDEX_TYPE_UINT16: VkIndexType = 0;
pub const VK_INDEX_TYPE_UINT32: VkIndexType = 1;
pub const VK_INDEX_TYPE_NONE_KHR: VkIndexType = 1000165000;
pub const VK_INDEX_TYPE_UINT8_EXT: VkIndexType = 1000265000;
pub const VK_INDEX_TYPE_NONE_NV: VkIndexType = 1000165000;
pub const VK_INDEX_TYPE_MAX_ENUM: VkIndexType = 2147483647;
pub type VkIndexType = ::std::os::raw::c_int;
pub const VK_SUBPASS_CONTENTS_INLINE: VkSubpassContents = 0;
pub const VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS: VkSubpassContents = 1;
pub const VK_SUBPASS_CONTENTS_MAX_ENUM: VkSubpassContents = 2147483647;
pub type VkSubpassContents = ::std::os::raw::c_int;
pub const VK_ACCESS_INDIRECT_COMMAND_READ_BIT: VkAccessFlagBits = 1;
pub const VK_ACCESS_INDEX_READ_BIT: VkAccessFlagBits = 2;
pub const VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT: VkAccessFlagBits = 4;
pub const VK_ACCESS_UNIFORM_READ_BIT: VkAccessFlagBits = 8;
pub const VK_ACCESS_INPUT_ATTACHMENT_READ_BIT: VkAccessFlagBits = 16;
pub const VK_ACCESS_SHADER_READ_BIT: VkAccessFlagBits = 32;
pub const VK_ACCESS_SHADER_WRITE_BIT: VkAccessFlagBits = 64;
pub const VK_ACCESS_COLOR_ATTACHMENT_READ_BIT: VkAccessFlagBits = 128;
pub const VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT: VkAccessFlagBits = 256;
pub const VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT: VkAccessFlagBits = 512;
pub const VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: VkAccessFlagBits = 1024;
pub const VK_ACCESS_TRANSFER_READ_BIT: VkAccessFlagBits = 2048;
pub const VK_ACCESS_TRANSFER_WRITE_BIT: VkAccessFlagBits = 4096;
pub const VK_ACCESS_HOST_READ_BIT: VkAccessFlagBits = 8192;
pub const VK_ACCESS_HOST_WRITE_BIT: VkAccessFlagBits = 16384;
pub const VK_ACCESS_MEMORY_READ_BIT: VkAccessFlagBits = 32768;
pub const VK_ACCESS_MEMORY_WRITE_BIT: VkAccessFlagBits = 65536;
pub const VK_ACCESS_NONE: VkAccessFlagBits = 0;
pub const VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT: VkAccessFlagBits = 33554432;
pub const VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT: VkAccessFlagBits = 67108864;
pub const VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT: VkAccessFlagBits = 134217728;
pub const VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT: VkAccessFlagBits = 1048576;
pub const VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT: VkAccessFlagBits = 524288;
pub const VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR: VkAccessFlagBits = 2097152;
pub const VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR: VkAccessFlagBits = 4194304;
pub const VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT: VkAccessFlagBits = 16777216;
pub const VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR: VkAccessFlagBits = 8388608;
pub const VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV: VkAccessFlagBits = 131072;
pub const VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV: VkAccessFlagBits = 262144;
pub const VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV: VkAccessFlagBits = 8388608;
pub const VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV: VkAccessFlagBits = 2097152;
pub const VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV: VkAccessFlagBits = 4194304;
pub const VK_ACCESS_NONE_KHR: VkAccessFlagBits = 0;
pub const VK_ACCESS_FLAG_BITS_MAX_ENUM: VkAccessFlagBits = 2147483647;
pub type VkAccessFlagBits = ::std::os::raw::c_int;
pub type VkAccessFlags = VkFlags;
pub const VK_IMAGE_ASPECT_COLOR_BIT: VkImageAspectFlagBits = 1;
pub const VK_IMAGE_ASPECT_DEPTH_BIT: VkImageAspectFlagBits = 2;
pub const VK_IMAGE_ASPECT_STENCIL_BIT: VkImageAspectFlagBits = 4;
pub const VK_IMAGE_ASPECT_METADATA_BIT: VkImageAspectFlagBits = 8;
pub const VK_IMAGE_ASPECT_PLANE_0_BIT: VkImageAspectFlagBits = 16;
pub const VK_IMAGE_ASPECT_PLANE_1_BIT: VkImageAspectFlagBits = 32;
pub const VK_IMAGE_ASPECT_PLANE_2_BIT: VkImageAspectFlagBits = 64;
pub const VK_IMAGE_ASPECT_NONE: VkImageAspectFlagBits = 0;
pub const VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT: VkImageAspectFlagBits = 128;
pub const VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT: VkImageAspectFlagBits = 256;
pub const VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT: VkImageAspectFlagBits = 512;
pub const VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT: VkImageAspectFlagBits = 1024;
pub const VK_IMAGE_ASPECT_PLANE_0_BIT_KHR: VkImageAspectFlagBits = 16;
pub const VK_IMAGE_ASPECT_PLANE_1_BIT_KHR: VkImageAspectFlagBits = 32;
pub const VK_IMAGE_ASPECT_PLANE_2_BIT_KHR: VkImageAspectFlagBits = 64;
pub const VK_IMAGE_ASPECT_NONE_KHR: VkImageAspectFlagBits = 0;
pub const VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM: VkImageAspectFlagBits = 2147483647;
pub type VkImageAspectFlagBits = ::std::os::raw::c_int;
pub type VkImageAspectFlags = VkFlags;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT: VkFormatFeatureFlagBits = 1;
pub const VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT: VkFormatFeatureFlagBits = 2;
pub const VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT: VkFormatFeatureFlagBits = 4;
pub const VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT: VkFormatFeatureFlagBits = 8;
pub const VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT: VkFormatFeatureFlagBits = 16;
pub const VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT: VkFormatFeatureFlagBits = 32;
pub const VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT: VkFormatFeatureFlagBits = 64;
pub const VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT: VkFormatFeatureFlagBits = 128;
pub const VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT: VkFormatFeatureFlagBits = 256;
pub const VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT: VkFormatFeatureFlagBits = 512;
pub const VK_FORMAT_FEATURE_BLIT_SRC_BIT: VkFormatFeatureFlagBits = 1024;
pub const VK_FORMAT_FEATURE_BLIT_DST_BIT: VkFormatFeatureFlagBits = 2048;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT: VkFormatFeatureFlagBits = 4096;
pub const VK_FORMAT_FEATURE_TRANSFER_SRC_BIT: VkFormatFeatureFlagBits = 16384;
pub const VK_FORMAT_FEATURE_TRANSFER_DST_BIT: VkFormatFeatureFlagBits = 32768;
pub const VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT: VkFormatFeatureFlagBits = 131072;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT:
    VkFormatFeatureFlagBits = 262144;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT:
    VkFormatFeatureFlagBits = 524288;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT:
    VkFormatFeatureFlagBits = 1048576;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT : VkFormatFeatureFlagBits = 2097152 ;
pub const VK_FORMAT_FEATURE_DISJOINT_BIT: VkFormatFeatureFlagBits = 4194304;
pub const VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT: VkFormatFeatureFlagBits = 8388608;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT: VkFormatFeatureFlagBits = 65536;
pub const VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR: VkFormatFeatureFlagBits =
    536870912;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT: VkFormatFeatureFlagBits = 8192;
pub const VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT: VkFormatFeatureFlagBits = 16777216;
pub const VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: VkFormatFeatureFlagBits =
    1073741824;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG: VkFormatFeatureFlagBits = 8192;
pub const VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR: VkFormatFeatureFlagBits = 16384;
pub const VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR: VkFormatFeatureFlagBits = 32768;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT: VkFormatFeatureFlagBits = 65536;
pub const VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR: VkFormatFeatureFlagBits = 131072;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR:
    VkFormatFeatureFlagBits = 262144;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR : VkFormatFeatureFlagBits = 524288 ;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR : VkFormatFeatureFlagBits = 1048576 ;
pub const VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR : VkFormatFeatureFlagBits = 2097152 ;
pub const VK_FORMAT_FEATURE_DISJOINT_BIT_KHR: VkFormatFeatureFlagBits = 4194304;
pub const VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR: VkFormatFeatureFlagBits = 8388608;
pub const VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM: VkFormatFeatureFlagBits = 2147483647;
pub type VkFormatFeatureFlagBits = ::std::os::raw::c_int;
pub type VkFormatFeatureFlags = VkFlags;
pub const VK_IMAGE_CREATE_SPARSE_BINDING_BIT: VkImageCreateFlagBits = 1;
pub const VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT: VkImageCreateFlagBits = 2;
pub const VK_IMAGE_CREATE_SPARSE_ALIASED_BIT: VkImageCreateFlagBits = 4;
pub const VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT: VkImageCreateFlagBits = 8;
pub const VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT: VkImageCreateFlagBits = 16;
pub const VK_IMAGE_CREATE_ALIAS_BIT: VkImageCreateFlagBits = 1024;
pub const VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT: VkImageCreateFlagBits = 64;
pub const VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT: VkImageCreateFlagBits = 32;
pub const VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT: VkImageCreateFlagBits = 128;
pub const VK_IMAGE_CREATE_EXTENDED_USAGE_BIT: VkImageCreateFlagBits = 256;
pub const VK_IMAGE_CREATE_PROTECTED_BIT: VkImageCreateFlagBits = 2048;
pub const VK_IMAGE_CREATE_DISJOINT_BIT: VkImageCreateFlagBits = 512;
pub const VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV: VkImageCreateFlagBits = 8192;
pub const VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT: VkImageCreateFlagBits = 4096;
pub const VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT: VkImageCreateFlagBits = 16384;
pub const VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT: VkImageCreateFlagBits = 65536;
pub const VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT: VkImageCreateFlagBits =
    262144;
pub const VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT: VkImageCreateFlagBits = 131072;
pub const VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM: VkImageCreateFlagBits = 32768;
pub const VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR: VkImageCreateFlagBits = 64;
pub const VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR: VkImageCreateFlagBits = 32;
pub const VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR: VkImageCreateFlagBits = 128;
pub const VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR: VkImageCreateFlagBits = 256;
pub const VK_IMAGE_CREATE_DISJOINT_BIT_KHR: VkImageCreateFlagBits = 512;
pub const VK_IMAGE_CREATE_ALIAS_BIT_KHR: VkImageCreateFlagBits = 1024;
pub const VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM: VkImageCreateFlagBits = 2147483647;
pub type VkImageCreateFlagBits = ::std::os::raw::c_int;
pub type VkImageCreateFlags = VkFlags;
pub const VK_SAMPLE_COUNT_1_BIT: VkSampleCountFlagBits = 1;
pub const VK_SAMPLE_COUNT_2_BIT: VkSampleCountFlagBits = 2;
pub const VK_SAMPLE_COUNT_4_BIT: VkSampleCountFlagBits = 4;
pub const VK_SAMPLE_COUNT_8_BIT: VkSampleCountFlagBits = 8;
pub const VK_SAMPLE_COUNT_16_BIT: VkSampleCountFlagBits = 16;
pub const VK_SAMPLE_COUNT_32_BIT: VkSampleCountFlagBits = 32;
pub const VK_SAMPLE_COUNT_64_BIT: VkSampleCountFlagBits = 64;
pub const VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM: VkSampleCountFlagBits = 2147483647;
pub type VkSampleCountFlagBits = ::std::os::raw::c_int;
pub type VkSampleCountFlags = VkFlags;
pub const VK_IMAGE_USAGE_TRANSFER_SRC_BIT: VkImageUsageFlagBits = 1;
pub const VK_IMAGE_USAGE_TRANSFER_DST_BIT: VkImageUsageFlagBits = 2;
pub const VK_IMAGE_USAGE_SAMPLED_BIT: VkImageUsageFlagBits = 4;
pub const VK_IMAGE_USAGE_STORAGE_BIT: VkImageUsageFlagBits = 8;
pub const VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT: VkImageUsageFlagBits = 16;
pub const VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT: VkImageUsageFlagBits = 32;
pub const VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT: VkImageUsageFlagBits = 64;
pub const VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT: VkImageUsageFlagBits = 128;
pub const VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT: VkImageUsageFlagBits = 512;
pub const VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: VkImageUsageFlagBits = 256;
pub const VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT: VkImageUsageFlagBits = 524288;
pub const VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI: VkImageUsageFlagBits = 262144;
pub const VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM: VkImageUsageFlagBits = 1048576;
pub const VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM: VkImageUsageFlagBits = 2097152;
pub const VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV: VkImageUsageFlagBits = 256;
pub const VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM: VkImageUsageFlagBits = 2147483647;
pub type VkImageUsageFlagBits = ::std::os::raw::c_int;
pub type VkImageUsageFlags = VkFlags;
pub const VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR: VkInstanceCreateFlagBits = 1;
pub const VK_INSTANCE_CREATE_FLAG_BITS_MAX_ENUM: VkInstanceCreateFlagBits = 2147483647;
pub type VkInstanceCreateFlagBits = ::std::os::raw::c_int;
pub type VkInstanceCreateFlags = VkFlags;
pub const VK_MEMORY_HEAP_DEVICE_LOCAL_BIT: VkMemoryHeapFlagBits = 1;
pub const VK_MEMORY_HEAP_MULTI_INSTANCE_BIT: VkMemoryHeapFlagBits = 2;
pub const VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR: VkMemoryHeapFlagBits = 2;
pub const VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM: VkMemoryHeapFlagBits = 2147483647;
pub type VkMemoryHeapFlagBits = ::std::os::raw::c_int;
pub type VkMemoryHeapFlags = VkFlags;
pub const VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT: VkMemoryPropertyFlagBits = 1;
pub const VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT: VkMemoryPropertyFlagBits = 2;
pub const VK_MEMORY_PROPERTY_HOST_COHERENT_BIT: VkMemoryPropertyFlagBits = 4;
pub const VK_MEMORY_PROPERTY_HOST_CACHED_BIT: VkMemoryPropertyFlagBits = 8;
pub const VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT: VkMemoryPropertyFlagBits = 16;
pub const VK_MEMORY_PROPERTY_PROTECTED_BIT: VkMemoryPropertyFlagBits = 32;
pub const VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD: VkMemoryPropertyFlagBits = 64;
pub const VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD: VkMemoryPropertyFlagBits = 128;
pub const VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV: VkMemoryPropertyFlagBits = 256;
pub const VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM: VkMemoryPropertyFlagBits = 2147483647;
pub type VkMemoryPropertyFlagBits = ::std::os::raw::c_int;
pub type VkMemoryPropertyFlags = VkFlags;
pub const VK_QUEUE_GRAPHICS_BIT: VkQueueFlagBits = 1;
pub const VK_QUEUE_COMPUTE_BIT: VkQueueFlagBits = 2;
pub const VK_QUEUE_TRANSFER_BIT: VkQueueFlagBits = 4;
pub const VK_QUEUE_SPARSE_BINDING_BIT: VkQueueFlagBits = 8;
pub const VK_QUEUE_PROTECTED_BIT: VkQueueFlagBits = 16;
pub const VK_QUEUE_OPTICAL_FLOW_BIT_NV: VkQueueFlagBits = 256;
pub const VK_QUEUE_FLAG_BITS_MAX_ENUM: VkQueueFlagBits = 2147483647;
pub type VkQueueFlagBits = ::std::os::raw::c_int;
pub type VkQueueFlags = VkFlags;
pub type VkDeviceCreateFlags = VkFlags;
pub const VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT: VkDeviceQueueCreateFlagBits = 1;
pub const VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM: VkDeviceQueueCreateFlagBits = 2147483647;
pub type VkDeviceQueueCreateFlagBits = ::std::os::raw::c_int;
pub type VkDeviceQueueCreateFlags = VkFlags;
pub const VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT: VkPipelineStageFlagBits = 1;
pub const VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT: VkPipelineStageFlagBits = 2;
pub const VK_PIPELINE_STAGE_VERTEX_INPUT_BIT: VkPipelineStageFlagBits = 4;
pub const VK_PIPELINE_STAGE_VERTEX_SHADER_BIT: VkPipelineStageFlagBits = 8;
pub const VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT: VkPipelineStageFlagBits = 16;
pub const VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT: VkPipelineStageFlagBits = 32;
pub const VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT: VkPipelineStageFlagBits = 64;
pub const VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT: VkPipelineStageFlagBits = 128;
pub const VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT: VkPipelineStageFlagBits = 256;
pub const VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT: VkPipelineStageFlagBits = 512;
pub const VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT: VkPipelineStageFlagBits = 1024;
pub const VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT: VkPipelineStageFlagBits = 2048;
pub const VK_PIPELINE_STAGE_TRANSFER_BIT: VkPipelineStageFlagBits = 4096;
pub const VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT: VkPipelineStageFlagBits = 8192;
pub const VK_PIPELINE_STAGE_HOST_BIT: VkPipelineStageFlagBits = 16384;
pub const VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT: VkPipelineStageFlagBits = 32768;
pub const VK_PIPELINE_STAGE_ALL_COMMANDS_BIT: VkPipelineStageFlagBits = 65536;
pub const VK_PIPELINE_STAGE_NONE: VkPipelineStageFlagBits = 0;
pub const VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT: VkPipelineStageFlagBits = 16777216;
pub const VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT: VkPipelineStageFlagBits = 262144;
pub const VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR: VkPipelineStageFlagBits =
    33554432;
pub const VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR: VkPipelineStageFlagBits = 2097152;
pub const VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT: VkPipelineStageFlagBits = 8388608;
pub const VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: VkPipelineStageFlagBits =
    4194304;
pub const VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV: VkPipelineStageFlagBits = 131072;
pub const VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT: VkPipelineStageFlagBits = 524288;
pub const VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT: VkPipelineStageFlagBits = 1048576;
pub const VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV: VkPipelineStageFlagBits = 4194304;
pub const VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV: VkPipelineStageFlagBits = 2097152;
pub const VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV: VkPipelineStageFlagBits = 33554432;
pub const VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV: VkPipelineStageFlagBits = 524288;
pub const VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV: VkPipelineStageFlagBits = 1048576;
pub const VK_PIPELINE_STAGE_NONE_KHR: VkPipelineStageFlagBits = 0;
pub const VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM: VkPipelineStageFlagBits = 2147483647;
pub type VkPipelineStageFlagBits = ::std::os::raw::c_int;
pub type VkPipelineStageFlags = VkFlags;
pub type VkMemoryMapFlags = VkFlags;
pub const VK_SPARSE_MEMORY_BIND_METADATA_BIT: VkSparseMemoryBindFlagBits = 1;
pub const VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM: VkSparseMemoryBindFlagBits = 2147483647;
pub type VkSparseMemoryBindFlagBits = ::std::os::raw::c_int;
pub type VkSparseMemoryBindFlags = VkFlags;
pub const VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT: VkSparseImageFormatFlagBits = 1;
pub const VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT: VkSparseImageFormatFlagBits = 2;
pub const VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT: VkSparseImageFormatFlagBits = 4;
pub const VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM: VkSparseImageFormatFlagBits = 2147483647;
pub type VkSparseImageFormatFlagBits = ::std::os::raw::c_int;
pub type VkSparseImageFormatFlags = VkFlags;
pub const VK_FENCE_CREATE_SIGNALED_BIT: VkFenceCreateFlagBits = 1;
pub const VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM: VkFenceCreateFlagBits = 2147483647;
pub type VkFenceCreateFlagBits = ::std::os::raw::c_int;
pub type VkFenceCreateFlags = VkFlags;
pub type VkSemaphoreCreateFlags = VkFlags;
pub const VK_EVENT_CREATE_DEVICE_ONLY_BIT: VkEventCreateFlagBits = 1;
pub const VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR: VkEventCreateFlagBits = 1;
pub const VK_EVENT_CREATE_FLAG_BITS_MAX_ENUM: VkEventCreateFlagBits = 2147483647;
pub type VkEventCreateFlagBits = ::std::os::raw::c_int;
pub type VkEventCreateFlags = VkFlags;
pub const VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT:
    VkQueryPipelineStatisticFlagBits = 1;
pub const VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT:
    VkQueryPipelineStatisticFlagBits = 2;
pub const VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT:
    VkQueryPipelineStatisticFlagBits = 4;
pub const VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT:
    VkQueryPipelineStatisticFlagBits = 8;
pub const VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT:
    VkQueryPipelineStatisticFlagBits = 16;
pub const VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT: VkQueryPipelineStatisticFlagBits =
    32;
pub const VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT: VkQueryPipelineStatisticFlagBits =
    64;
pub const VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT:
    VkQueryPipelineStatisticFlagBits = 128;
pub const VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT:
    VkQueryPipelineStatisticFlagBits = 256;
pub const VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT:
    VkQueryPipelineStatisticFlagBits = 512;
pub const VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT:
    VkQueryPipelineStatisticFlagBits = 1024;
pub const VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT:
    VkQueryPipelineStatisticFlagBits = 2048;
pub const VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT:
    VkQueryPipelineStatisticFlagBits = 4096;
pub const VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM: VkQueryPipelineStatisticFlagBits =
    2147483647;
pub type VkQueryPipelineStatisticFlagBits = ::std::os::raw::c_int;
pub type VkQueryPipelineStatisticFlags = VkFlags;
pub type VkQueryPoolCreateFlags = VkFlags;
pub const VK_QUERY_RESULT_64_BIT: VkQueryResultFlagBits = 1;
pub const VK_QUERY_RESULT_WAIT_BIT: VkQueryResultFlagBits = 2;
pub const VK_QUERY_RESULT_WITH_AVAILABILITY_BIT: VkQueryResultFlagBits = 4;
pub const VK_QUERY_RESULT_PARTIAL_BIT: VkQueryResultFlagBits = 8;
pub const VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM: VkQueryResultFlagBits = 2147483647;
pub type VkQueryResultFlagBits = ::std::os::raw::c_int;
pub type VkQueryResultFlags = VkFlags;
pub const VK_BUFFER_CREATE_SPARSE_BINDING_BIT: VkBufferCreateFlagBits = 1;
pub const VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT: VkBufferCreateFlagBits = 2;
pub const VK_BUFFER_CREATE_SPARSE_ALIASED_BIT: VkBufferCreateFlagBits = 4;
pub const VK_BUFFER_CREATE_PROTECTED_BIT: VkBufferCreateFlagBits = 8;
pub const VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: VkBufferCreateFlagBits = 16;
pub const VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT: VkBufferCreateFlagBits = 32;
pub const VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT: VkBufferCreateFlagBits = 16;
pub const VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR: VkBufferCreateFlagBits = 16;
pub const VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM: VkBufferCreateFlagBits = 2147483647;
pub type VkBufferCreateFlagBits = ::std::os::raw::c_int;
pub type VkBufferCreateFlags = VkFlags;
pub const VK_BUFFER_USAGE_TRANSFER_SRC_BIT: VkBufferUsageFlagBits = 1;
pub const VK_BUFFER_USAGE_TRANSFER_DST_BIT: VkBufferUsageFlagBits = 2;
pub const VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT: VkBufferUsageFlagBits = 4;
pub const VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT: VkBufferUsageFlagBits = 8;
pub const VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT: VkBufferUsageFlagBits = 16;
pub const VK_BUFFER_USAGE_STORAGE_BUFFER_BIT: VkBufferUsageFlagBits = 32;
pub const VK_BUFFER_USAGE_INDEX_BUFFER_BIT: VkBufferUsageFlagBits = 64;
pub const VK_BUFFER_USAGE_VERTEX_BUFFER_BIT: VkBufferUsageFlagBits = 128;
pub const VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT: VkBufferUsageFlagBits = 256;
pub const VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT: VkBufferUsageFlagBits = 131072;
pub const VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT: VkBufferUsageFlagBits = 2048;
pub const VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT: VkBufferUsageFlagBits = 4096;
pub const VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT: VkBufferUsageFlagBits = 512;
pub const VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR:
    VkBufferUsageFlagBits = 524288;
pub const VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR: VkBufferUsageFlagBits = 1048576;
pub const VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR: VkBufferUsageFlagBits = 1024;
pub const VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT: VkBufferUsageFlagBits = 2097152;
pub const VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT: VkBufferUsageFlagBits = 4194304;
pub const VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT: VkBufferUsageFlagBits =
    67108864;
pub const VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT: VkBufferUsageFlagBits = 8388608;
pub const VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT: VkBufferUsageFlagBits = 16777216;
pub const VK_BUFFER_USAGE_RAY_TRACING_BIT_NV: VkBufferUsageFlagBits = 1024;
pub const VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT: VkBufferUsageFlagBits = 131072;
pub const VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR: VkBufferUsageFlagBits = 131072;
pub const VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM: VkBufferUsageFlagBits = 2147483647;
pub type VkBufferUsageFlagBits = ::std::os::raw::c_int;
pub type VkBufferUsageFlags = VkFlags;
pub type VkBufferViewCreateFlags = VkFlags;
pub const VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT: VkImageViewCreateFlagBits = 1;
pub const VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT: VkImageViewCreateFlagBits =
    4;
pub const VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT: VkImageViewCreateFlagBits = 2;
pub const VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM: VkImageViewCreateFlagBits = 2147483647;
pub type VkImageViewCreateFlagBits = ::std::os::raw::c_int;
pub type VkImageViewCreateFlags = VkFlags;
pub type VkShaderModuleCreateFlags = VkFlags;
pub const VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT: VkPipelineCacheCreateFlagBits = 1;
pub const VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT: VkPipelineCacheCreateFlagBits =
    1;
pub const VK_PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM: VkPipelineCacheCreateFlagBits = 2147483647;
pub type VkPipelineCacheCreateFlagBits = ::std::os::raw::c_int;
pub type VkPipelineCacheCreateFlags = VkFlags;
pub const VK_COLOR_COMPONENT_R_BIT: VkColorComponentFlagBits = 1;
pub const VK_COLOR_COMPONENT_G_BIT: VkColorComponentFlagBits = 2;
pub const VK_COLOR_COMPONENT_B_BIT: VkColorComponentFlagBits = 4;
pub const VK_COLOR_COMPONENT_A_BIT: VkColorComponentFlagBits = 8;
pub const VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM: VkColorComponentFlagBits = 2147483647;
pub type VkColorComponentFlagBits = ::std::os::raw::c_int;
pub type VkColorComponentFlags = VkFlags;
pub const VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT: VkPipelineCreateFlagBits = 1;
pub const VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT: VkPipelineCreateFlagBits = 2;
pub const VK_PIPELINE_CREATE_DERIVATIVE_BIT: VkPipelineCreateFlagBits = 4;
pub const VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT: VkPipelineCreateFlagBits = 8;
pub const VK_PIPELINE_CREATE_DISPATCH_BASE_BIT: VkPipelineCreateFlagBits = 16;
pub const VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT: VkPipelineCreateFlagBits = 256;
pub const VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT: VkPipelineCreateFlagBits = 512;
pub const VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR:
    VkPipelineCreateFlagBits = 2097152;
pub const VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT:
    VkPipelineCreateFlagBits = 4194304;
pub const VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR: VkPipelineCreateFlagBits =
    16384;
pub const VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR:
    VkPipelineCreateFlagBits = 32768;
pub const VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR: VkPipelineCreateFlagBits =
    65536;
pub const VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR:
    VkPipelineCreateFlagBits = 131072;
pub const VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR: VkPipelineCreateFlagBits = 4096;
pub const VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR: VkPipelineCreateFlagBits = 8192;
pub const VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR:
    VkPipelineCreateFlagBits = 524288;
pub const VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV: VkPipelineCreateFlagBits = 32;
pub const VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR: VkPipelineCreateFlagBits = 64;
pub const VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR: VkPipelineCreateFlagBits =
    128;
pub const VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV: VkPipelineCreateFlagBits = 262144;
pub const VK_PIPELINE_CREATE_LIBRARY_BIT_KHR: VkPipelineCreateFlagBits = 2048;
pub const VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT: VkPipelineCreateFlagBits = 536870912;
pub const VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT: VkPipelineCreateFlagBits =
    8388608;
pub const VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT: VkPipelineCreateFlagBits = 1024;
pub const VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV: VkPipelineCreateFlagBits = 1048576;
pub const VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT: VkPipelineCreateFlagBits =
    33554432;
pub const VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT:
    VkPipelineCreateFlagBits = 67108864;
pub const VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT: VkPipelineCreateFlagBits =
    16777216;
pub const VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT: VkPipelineCreateFlagBits = 134217728;
pub const VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT: VkPipelineCreateFlagBits = 1073741824;
pub const VK_PIPELINE_CREATE_DISPATCH_BASE: VkPipelineCreateFlagBits = 16;
pub const VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR:
    VkPipelineCreateFlagBits = 2097152;
pub const VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT:
    VkPipelineCreateFlagBits = 4194304;
pub const VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR: VkPipelineCreateFlagBits = 8;
pub const VK_PIPELINE_CREATE_DISPATCH_BASE_KHR: VkPipelineCreateFlagBits = 16;
pub const VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT: VkPipelineCreateFlagBits =
    256;
pub const VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT: VkPipelineCreateFlagBits = 512;
pub const VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM: VkPipelineCreateFlagBits = 2147483647;
pub type VkPipelineCreateFlagBits = ::std::os::raw::c_int;
pub type VkPipelineCreateFlags = VkFlags;
pub const VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT:
    VkPipelineShaderStageCreateFlagBits = 1;
pub const VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT:
    VkPipelineShaderStageCreateFlagBits = 2;
pub const VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT:
    VkPipelineShaderStageCreateFlagBits = 1;
pub const VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT:
    VkPipelineShaderStageCreateFlagBits = 2;
pub const VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM: VkPipelineShaderStageCreateFlagBits =
    2147483647;
pub type VkPipelineShaderStageCreateFlagBits = ::std::os::raw::c_int;
pub type VkPipelineShaderStageCreateFlags = VkFlags;
pub const VK_SHADER_STAGE_VERTEX_BIT: VkShaderStageFlagBits = 1;
pub const VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT: VkShaderStageFlagBits = 2;
pub const VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT: VkShaderStageFlagBits = 4;
pub const VK_SHADER_STAGE_GEOMETRY_BIT: VkShaderStageFlagBits = 8;
pub const VK_SHADER_STAGE_FRAGMENT_BIT: VkShaderStageFlagBits = 16;
pub const VK_SHADER_STAGE_COMPUTE_BIT: VkShaderStageFlagBits = 32;
pub const VK_SHADER_STAGE_ALL_GRAPHICS: VkShaderStageFlagBits = 31;
pub const VK_SHADER_STAGE_ALL: VkShaderStageFlagBits = 2147483647;
pub const VK_SHADER_STAGE_RAYGEN_BIT_KHR: VkShaderStageFlagBits = 256;
pub const VK_SHADER_STAGE_ANY_HIT_BIT_KHR: VkShaderStageFlagBits = 512;
pub const VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR: VkShaderStageFlagBits = 1024;
pub const VK_SHADER_STAGE_MISS_BIT_KHR: VkShaderStageFlagBits = 2048;
pub const VK_SHADER_STAGE_INTERSECTION_BIT_KHR: VkShaderStageFlagBits = 4096;
pub const VK_SHADER_STAGE_CALLABLE_BIT_KHR: VkShaderStageFlagBits = 8192;
pub const VK_SHADER_STAGE_TASK_BIT_EXT: VkShaderStageFlagBits = 64;
pub const VK_SHADER_STAGE_MESH_BIT_EXT: VkShaderStageFlagBits = 128;
pub const VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI: VkShaderStageFlagBits = 16384;
pub const VK_SHADER_STAGE_RAYGEN_BIT_NV: VkShaderStageFlagBits = 256;
pub const VK_SHADER_STAGE_ANY_HIT_BIT_NV: VkShaderStageFlagBits = 512;
pub const VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV: VkShaderStageFlagBits = 1024;
pub const VK_SHADER_STAGE_MISS_BIT_NV: VkShaderStageFlagBits = 2048;
pub const VK_SHADER_STAGE_INTERSECTION_BIT_NV: VkShaderStageFlagBits = 4096;
pub const VK_SHADER_STAGE_CALLABLE_BIT_NV: VkShaderStageFlagBits = 8192;
pub const VK_SHADER_STAGE_TASK_BIT_NV: VkShaderStageFlagBits = 64;
pub const VK_SHADER_STAGE_MESH_BIT_NV: VkShaderStageFlagBits = 128;
pub const VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM: VkShaderStageFlagBits = 2147483647;
pub type VkShaderStageFlagBits = ::std::os::raw::c_int;
pub const VK_CULL_MODE_NONE: VkCullModeFlagBits = 0;
pub const VK_CULL_MODE_FRONT_BIT: VkCullModeFlagBits = 1;
pub const VK_CULL_MODE_BACK_BIT: VkCullModeFlagBits = 2;
pub const VK_CULL_MODE_FRONT_AND_BACK: VkCullModeFlagBits = 3;
pub const VK_CULL_MODE_FLAG_BITS_MAX_ENUM: VkCullModeFlagBits = 2147483647;
pub type VkCullModeFlagBits = ::std::os::raw::c_int;
pub type VkCullModeFlags = VkFlags;
pub type VkPipelineVertexInputStateCreateFlags = VkFlags;
pub type VkPipelineInputAssemblyStateCreateFlags = VkFlags;
pub type VkPipelineTessellationStateCreateFlags = VkFlags;
pub type VkPipelineViewportStateCreateFlags = VkFlags;
pub type VkPipelineRasterizationStateCreateFlags = VkFlags;
pub type VkPipelineMultisampleStateCreateFlags = VkFlags;
pub const VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT : VkPipelineDepthStencilStateCreateFlagBits = 1 ;
pub const VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT : VkPipelineDepthStencilStateCreateFlagBits = 2 ;
pub const VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM : VkPipelineDepthStencilStateCreateFlagBits = 1 ;
pub const VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM : VkPipelineDepthStencilStateCreateFlagBits = 2 ;
pub const VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_FLAG_BITS_MAX_ENUM:
    VkPipelineDepthStencilStateCreateFlagBits = 2147483647;
pub type VkPipelineDepthStencilStateCreateFlagBits = ::std::os::raw::c_int;
pub type VkPipelineDepthStencilStateCreateFlags = VkFlags;
pub const VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT:
    VkPipelineColorBlendStateCreateFlagBits = 1;
pub const VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM:
    VkPipelineColorBlendStateCreateFlagBits = 1;
pub const VK_PIPELINE_COLOR_BLEND_STATE_CREATE_FLAG_BITS_MAX_ENUM:
    VkPipelineColorBlendStateCreateFlagBits = 2147483647;
pub type VkPipelineColorBlendStateCreateFlagBits = ::std::os::raw::c_int;
pub type VkPipelineColorBlendStateCreateFlags = VkFlags;
pub type VkPipelineDynamicStateCreateFlags = VkFlags;
pub const VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT: VkPipelineLayoutCreateFlagBits = 2;
pub const VK_PIPELINE_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM: VkPipelineLayoutCreateFlagBits = 2147483647;
pub type VkPipelineLayoutCreateFlagBits = ::std::os::raw::c_int;
pub type VkPipelineLayoutCreateFlags = VkFlags;
pub type VkShaderStageFlags = VkFlags;
pub const VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT: VkSamplerCreateFlagBits = 1;
pub const VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT: VkSamplerCreateFlagBits = 2;
pub const VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT: VkSamplerCreateFlagBits = 8;
pub const VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT: VkSamplerCreateFlagBits = 4;
pub const VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM: VkSamplerCreateFlagBits = 16;
pub const VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM: VkSamplerCreateFlagBits = 2147483647;
pub type VkSamplerCreateFlagBits = ::std::os::raw::c_int;
pub type VkSamplerCreateFlags = VkFlags;
pub const VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT: VkDescriptorPoolCreateFlagBits = 1;
pub const VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT: VkDescriptorPoolCreateFlagBits = 2;
pub const VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT: VkDescriptorPoolCreateFlagBits = 4;
pub const VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT: VkDescriptorPoolCreateFlagBits = 2;
pub const VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE: VkDescriptorPoolCreateFlagBits = 4;
pub const VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM: VkDescriptorPoolCreateFlagBits = 2147483647;
pub type VkDescriptorPoolCreateFlagBits = ::std::os::raw::c_int;
pub type VkDescriptorPoolCreateFlags = VkFlags;
pub type VkDescriptorPoolResetFlags = VkFlags;
pub const VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT:
    VkDescriptorSetLayoutCreateFlagBits = 2;
pub const VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR:
    VkDescriptorSetLayoutCreateFlagBits = 1;
pub const VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT:
    VkDescriptorSetLayoutCreateFlagBits = 16;
pub const VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT:
    VkDescriptorSetLayoutCreateFlagBits = 32;
pub const VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT:
    VkDescriptorSetLayoutCreateFlagBits = 4;
pub const VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT:
    VkDescriptorSetLayoutCreateFlagBits = 2;
pub const VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE:
    VkDescriptorSetLayoutCreateFlagBits = 4;
pub const VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM: VkDescriptorSetLayoutCreateFlagBits =
    2147483647;
pub type VkDescriptorSetLayoutCreateFlagBits = ::std::os::raw::c_int;
pub type VkDescriptorSetLayoutCreateFlags = VkFlags;
pub const VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT: VkAttachmentDescriptionFlagBits = 1;
pub const VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM: VkAttachmentDescriptionFlagBits =
    2147483647;
pub type VkAttachmentDescriptionFlagBits = ::std::os::raw::c_int;
pub type VkAttachmentDescriptionFlags = VkFlags;
pub const VK_DEPENDENCY_BY_REGION_BIT: VkDependencyFlagBits = 1;
pub const VK_DEPENDENCY_DEVICE_GROUP_BIT: VkDependencyFlagBits = 4;
pub const VK_DEPENDENCY_VIEW_LOCAL_BIT: VkDependencyFlagBits = 2;
pub const VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT: VkDependencyFlagBits = 8;
pub const VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR: VkDependencyFlagBits = 2;
pub const VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR: VkDependencyFlagBits = 4;
pub const VK_DEPENDENCY_FLAG_BITS_MAX_ENUM: VkDependencyFlagBits = 2147483647;
pub type VkDependencyFlagBits = ::std::os::raw::c_int;
pub type VkDependencyFlags = VkFlags;
pub const VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT: VkFramebufferCreateFlagBits = 1;
pub const VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR: VkFramebufferCreateFlagBits = 1;
pub const VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM: VkFramebufferCreateFlagBits = 2147483647;
pub type VkFramebufferCreateFlagBits = ::std::os::raw::c_int;
pub type VkFramebufferCreateFlags = VkFlags;
pub const VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM: VkRenderPassCreateFlagBits = 2;
pub const VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM: VkRenderPassCreateFlagBits = 2147483647;
pub type VkRenderPassCreateFlagBits = ::std::os::raw::c_int;
pub type VkRenderPassCreateFlags = VkFlags;
pub const VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX: VkSubpassDescriptionFlagBits = 1;
pub const VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX: VkSubpassDescriptionFlagBits = 2;
pub const VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM: VkSubpassDescriptionFlagBits = 4;
pub const VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM: VkSubpassDescriptionFlagBits = 8;
pub const VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT:
    VkSubpassDescriptionFlagBits = 16;
pub const VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT:
    VkSubpassDescriptionFlagBits = 32;
pub const VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT:
    VkSubpassDescriptionFlagBits = 64;
pub const VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT: VkSubpassDescriptionFlagBits =
    128;
pub const VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM:
    VkSubpassDescriptionFlagBits = 16;
pub const VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM:
    VkSubpassDescriptionFlagBits = 32;
pub const VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM:
    VkSubpassDescriptionFlagBits = 64;
pub const VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM: VkSubpassDescriptionFlagBits = 2147483647;
pub type VkSubpassDescriptionFlagBits = ::std::os::raw::c_int;
pub type VkSubpassDescriptionFlags = VkFlags;
pub const VK_COMMAND_POOL_CREATE_TRANSIENT_BIT: VkCommandPoolCreateFlagBits = 1;
pub const VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT: VkCommandPoolCreateFlagBits = 2;
pub const VK_COMMAND_POOL_CREATE_PROTECTED_BIT: VkCommandPoolCreateFlagBits = 4;
pub const VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM: VkCommandPoolCreateFlagBits = 2147483647;
pub type VkCommandPoolCreateFlagBits = ::std::os::raw::c_int;
pub type VkCommandPoolCreateFlags = VkFlags;
pub const VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT: VkCommandPoolResetFlagBits = 1;
pub const VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM: VkCommandPoolResetFlagBits = 2147483647;
pub type VkCommandPoolResetFlagBits = ::std::os::raw::c_int;
pub type VkCommandPoolResetFlags = VkFlags;
pub const VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT: VkCommandBufferUsageFlagBits = 1;
pub const VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT: VkCommandBufferUsageFlagBits = 2;
pub const VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT: VkCommandBufferUsageFlagBits = 4;
pub const VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM: VkCommandBufferUsageFlagBits = 2147483647;
pub type VkCommandBufferUsageFlagBits = ::std::os::raw::c_int;
pub type VkCommandBufferUsageFlags = VkFlags;
pub const VK_QUERY_CONTROL_PRECISE_BIT: VkQueryControlFlagBits = 1;
pub const VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM: VkQueryControlFlagBits = 2147483647;
pub type VkQueryControlFlagBits = ::std::os::raw::c_int;
pub type VkQueryControlFlags = VkFlags;
pub const VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT: VkCommandBufferResetFlagBits = 1;
pub const VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM: VkCommandBufferResetFlagBits = 2147483647;
pub type VkCommandBufferResetFlagBits = ::std::os::raw::c_int;
pub type VkCommandBufferResetFlags = VkFlags;
pub const VK_STENCIL_FACE_FRONT_BIT: VkStencilFaceFlagBits = 1;
pub const VK_STENCIL_FACE_BACK_BIT: VkStencilFaceFlagBits = 2;
pub const VK_STENCIL_FACE_FRONT_AND_BACK: VkStencilFaceFlagBits = 3;
pub const VK_STENCIL_FRONT_AND_BACK: VkStencilFaceFlagBits = 3;
pub const VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM: VkStencilFaceFlagBits = 2147483647;
pub type VkStencilFaceFlagBits = ::std::os::raw::c_int;
pub type VkStencilFaceFlags = VkFlags;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkExtent2D {
    pub width: u32,
    pub height: u32,
}
#[test]
fn bindgen_test_layout_VkExtent2D() {
    assert_eq!(
        ::std::mem::size_of::<VkExtent2D>(),
        8usize,
        concat!("Size of: ", stringify!(VkExtent2D))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExtent2D>(),
        4usize,
        concat!("Alignment of ", stringify!(VkExtent2D))
    );
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExtent2D>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExtent2D),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExtent2D>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExtent2D),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkExtent3D {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
#[test]
fn bindgen_test_layout_VkExtent3D() {
    assert_eq!(
        ::std::mem::size_of::<VkExtent3D>(),
        12usize,
        concat!("Size of: ", stringify!(VkExtent3D))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExtent3D>(),
        4usize,
        concat!("Alignment of ", stringify!(VkExtent3D))
    );
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExtent3D>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExtent3D),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExtent3D>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExtent3D),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExtent3D>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExtent3D),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkOffset2D {
    pub x: i32,
    pub y: i32,
}
#[test]
fn bindgen_test_layout_VkOffset2D() {
    assert_eq!(
        ::std::mem::size_of::<VkOffset2D>(),
        8usize,
        concat!("Size of: ", stringify!(VkOffset2D))
    );
    assert_eq!(
        ::std::mem::align_of::<VkOffset2D>(),
        4usize,
        concat!("Alignment of ", stringify!(VkOffset2D))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOffset2D>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOffset2D),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOffset2D>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOffset2D),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkOffset3D {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
#[test]
fn bindgen_test_layout_VkOffset3D() {
    assert_eq!(
        ::std::mem::size_of::<VkOffset3D>(),
        12usize,
        concat!("Size of: ", stringify!(VkOffset3D))
    );
    assert_eq!(
        ::std::mem::align_of::<VkOffset3D>(),
        4usize,
        concat!("Alignment of ", stringify!(VkOffset3D))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOffset3D>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOffset3D),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOffset3D>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOffset3D),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOffset3D>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOffset3D),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkRect2D {
    pub offset: VkOffset2D,
    pub extent: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkRect2D() {
    assert_eq!(
        ::std::mem::size_of::<VkRect2D>(),
        16usize,
        concat!("Size of: ", stringify!(VkRect2D))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRect2D>(),
        4usize,
        concat!("Alignment of ", stringify!(VkRect2D))
    );
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRect2D>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRect2D),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRect2D>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRect2D),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBaseInStructure {
    pub sType: VkStructureType,
    pub pNext: *const VkBaseInStructure,
}
#[test]
fn bindgen_test_layout_VkBaseInStructure() {
    assert_eq!(
        ::std::mem::size_of::<VkBaseInStructure>(),
        16usize,
        concat!("Size of: ", stringify!(VkBaseInStructure))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBaseInStructure>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBaseInStructure))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBaseInStructure>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBaseInStructure),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBaseInStructure>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBaseInStructure),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
}
impl Default for VkBaseInStructure {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBaseOutStructure {
    pub sType: VkStructureType,
    pub pNext: *mut VkBaseOutStructure,
}
#[test]
fn bindgen_test_layout_VkBaseOutStructure() {
    assert_eq!(
        ::std::mem::size_of::<VkBaseOutStructure>(),
        16usize,
        concat!("Size of: ", stringify!(VkBaseOutStructure))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBaseOutStructure>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBaseOutStructure))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBaseOutStructure>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBaseOutStructure),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBaseOutStructure>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBaseOutStructure),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
}
impl Default for VkBaseOutStructure {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub srcQueueFamilyIndex: u32,
    pub dstQueueFamilyIndex: u32,
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBufferMemoryBarrier() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferMemoryBarrier>(),
        56usize,
        concat!("Size of: ", stringify!(VkBufferMemoryBarrier))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferMemoryBarrier>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferMemoryBarrier))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcAccessMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcAccessMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier),
                "::",
                stringify!(srcAccessMask)
            )
        );
    }
    test_field_srcAccessMask();
    fn test_field_dstAccessMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstAccessMask) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier),
                "::",
                stringify!(dstAccessMask)
            )
        );
    }
    test_field_dstAccessMask();
    fn test_field_srcQueueFamilyIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcQueueFamilyIndex) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier),
                "::",
                stringify!(srcQueueFamilyIndex)
            )
        );
    }
    test_field_srcQueueFamilyIndex();
    fn test_field_dstQueueFamilyIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstQueueFamilyIndex) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier),
                "::",
                stringify!(dstQueueFamilyIndex)
            )
        );
    }
    test_field_dstQueueFamilyIndex();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
impl Default for VkBufferMemoryBarrier {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkDispatchIndirectCommand {
    pub x: u32,
    pub y: u32,
    pub z: u32,
}
#[test]
fn bindgen_test_layout_VkDispatchIndirectCommand() {
    assert_eq!(
        ::std::mem::size_of::<VkDispatchIndirectCommand>(),
        12usize,
        concat!("Size of: ", stringify!(VkDispatchIndirectCommand))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDispatchIndirectCommand>(),
        4usize,
        concat!("Alignment of ", stringify!(VkDispatchIndirectCommand))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDispatchIndirectCommand>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDispatchIndirectCommand),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDispatchIndirectCommand>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDispatchIndirectCommand),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDispatchIndirectCommand>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDispatchIndirectCommand),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkDrawIndexedIndirectCommand {
    pub indexCount: u32,
    pub instanceCount: u32,
    pub firstIndex: u32,
    pub vertexOffset: i32,
    pub firstInstance: u32,
}
#[test]
fn bindgen_test_layout_VkDrawIndexedIndirectCommand() {
    assert_eq!(
        ::std::mem::size_of::<VkDrawIndexedIndirectCommand>(),
        20usize,
        concat!("Size of: ", stringify!(VkDrawIndexedIndirectCommand))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDrawIndexedIndirectCommand>(),
        4usize,
        concat!("Alignment of ", stringify!(VkDrawIndexedIndirectCommand))
    );
    fn test_field_indexCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrawIndexedIndirectCommand>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indexCount) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrawIndexedIndirectCommand),
                "::",
                stringify!(indexCount)
            )
        );
    }
    test_field_indexCount();
    fn test_field_instanceCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrawIndexedIndirectCommand>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).instanceCount) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrawIndexedIndirectCommand),
                "::",
                stringify!(instanceCount)
            )
        );
    }
    test_field_instanceCount();
    fn test_field_firstIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrawIndexedIndirectCommand>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstIndex) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrawIndexedIndirectCommand),
                "::",
                stringify!(firstIndex)
            )
        );
    }
    test_field_firstIndex();
    fn test_field_vertexOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrawIndexedIndirectCommand>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexOffset) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrawIndexedIndirectCommand),
                "::",
                stringify!(vertexOffset)
            )
        );
    }
    test_field_vertexOffset();
    fn test_field_firstInstance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrawIndexedIndirectCommand>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstInstance) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrawIndexedIndirectCommand),
                "::",
                stringify!(firstInstance)
            )
        );
    }
    test_field_firstInstance();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkDrawIndirectCommand {
    pub vertexCount: u32,
    pub instanceCount: u32,
    pub firstVertex: u32,
    pub firstInstance: u32,
}
#[test]
fn bindgen_test_layout_VkDrawIndirectCommand() {
    assert_eq!(
        ::std::mem::size_of::<VkDrawIndirectCommand>(),
        16usize,
        concat!("Size of: ", stringify!(VkDrawIndirectCommand))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDrawIndirectCommand>(),
        4usize,
        concat!("Alignment of ", stringify!(VkDrawIndirectCommand))
    );
    fn test_field_vertexCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrawIndirectCommand>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexCount) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrawIndirectCommand),
                "::",
                stringify!(vertexCount)
            )
        );
    }
    test_field_vertexCount();
    fn test_field_instanceCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrawIndirectCommand>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).instanceCount) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrawIndirectCommand),
                "::",
                stringify!(instanceCount)
            )
        );
    }
    test_field_instanceCount();
    fn test_field_firstVertex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrawIndirectCommand>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstVertex) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrawIndirectCommand),
                "::",
                stringify!(firstVertex)
            )
        );
    }
    test_field_firstVertex();
    fn test_field_firstInstance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrawIndirectCommand>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstInstance) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrawIndirectCommand),
                "::",
                stringify!(firstInstance)
            )
        );
    }
    test_field_firstInstance();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkImageSubresourceRange {
    pub aspectMask: VkImageAspectFlags,
    pub baseMipLevel: u32,
    pub levelCount: u32,
    pub baseArrayLayer: u32,
    pub layerCount: u32,
}
#[test]
fn bindgen_test_layout_VkImageSubresourceRange() {
    assert_eq!(
        ::std::mem::size_of::<VkImageSubresourceRange>(),
        20usize,
        concat!("Size of: ", stringify!(VkImageSubresourceRange))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageSubresourceRange>(),
        4usize,
        concat!("Alignment of ", stringify!(VkImageSubresourceRange))
    );
    fn test_field_aspectMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSubresourceRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aspectMask) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSubresourceRange),
                "::",
                stringify!(aspectMask)
            )
        );
    }
    test_field_aspectMask();
    fn test_field_baseMipLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSubresourceRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).baseMipLevel) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSubresourceRange),
                "::",
                stringify!(baseMipLevel)
            )
        );
    }
    test_field_baseMipLevel();
    fn test_field_levelCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSubresourceRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).levelCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSubresourceRange),
                "::",
                stringify!(levelCount)
            )
        );
    }
    test_field_levelCount();
    fn test_field_baseArrayLayer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSubresourceRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).baseArrayLayer) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSubresourceRange),
                "::",
                stringify!(baseArrayLayer)
            )
        );
    }
    test_field_baseArrayLayer();
    fn test_field_layerCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSubresourceRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layerCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSubresourceRange),
                "::",
                stringify!(layerCount)
            )
        );
    }
    test_field_layerCount();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub oldLayout: VkImageLayout,
    pub newLayout: VkImageLayout,
    pub srcQueueFamilyIndex: u32,
    pub dstQueueFamilyIndex: u32,
    pub image: VkImage,
    pub subresourceRange: VkImageSubresourceRange,
}
#[test]
fn bindgen_test_layout_VkImageMemoryBarrier() {
    assert_eq!(
        ::std::mem::size_of::<VkImageMemoryBarrier>(),
        72usize,
        concat!("Size of: ", stringify!(VkImageMemoryBarrier))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageMemoryBarrier>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageMemoryBarrier))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcAccessMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcAccessMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier),
                "::",
                stringify!(srcAccessMask)
            )
        );
    }
    test_field_srcAccessMask();
    fn test_field_dstAccessMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstAccessMask) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier),
                "::",
                stringify!(dstAccessMask)
            )
        );
    }
    test_field_dstAccessMask();
    fn test_field_oldLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).oldLayout) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier),
                "::",
                stringify!(oldLayout)
            )
        );
    }
    test_field_oldLayout();
    fn test_field_newLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).newLayout) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier),
                "::",
                stringify!(newLayout)
            )
        );
    }
    test_field_newLayout();
    fn test_field_srcQueueFamilyIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcQueueFamilyIndex) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier),
                "::",
                stringify!(srcQueueFamilyIndex)
            )
        );
    }
    test_field_srcQueueFamilyIndex();
    fn test_field_dstQueueFamilyIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstQueueFamilyIndex) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier),
                "::",
                stringify!(dstQueueFamilyIndex)
            )
        );
    }
    test_field_dstQueueFamilyIndex();
    fn test_field_image() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier),
                "::",
                stringify!(image)
            )
        );
    }
    test_field_image();
    fn test_field_subresourceRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subresourceRange) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier),
                "::",
                stringify!(subresourceRange)
            )
        );
    }
    test_field_subresourceRange();
}
impl Default for VkImageMemoryBarrier {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
}
#[test]
fn bindgen_test_layout_VkMemoryBarrier() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryBarrier>(),
        24usize,
        concat!("Size of: ", stringify!(VkMemoryBarrier))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryBarrier>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryBarrier))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryBarrier),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryBarrier),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcAccessMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcAccessMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryBarrier),
                "::",
                stringify!(srcAccessMask)
            )
        );
    }
    test_field_srcAccessMask();
    fn test_field_dstAccessMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryBarrier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstAccessMask) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryBarrier),
                "::",
                stringify!(dstAccessMask)
            )
        );
    }
    test_field_dstAccessMask();
}
impl Default for VkMemoryBarrier {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCacheHeaderVersionOne {
    pub headerSize: u32,
    pub headerVersion: VkPipelineCacheHeaderVersion,
    pub vendorID: u32,
    pub deviceID: u32,
    pub pipelineCacheUUID: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_VkPipelineCacheHeaderVersionOne() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineCacheHeaderVersionOne>(),
        32usize,
        concat!("Size of: ", stringify!(VkPipelineCacheHeaderVersionOne))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineCacheHeaderVersionOne>(),
        4usize,
        concat!("Alignment of ", stringify!(VkPipelineCacheHeaderVersionOne))
    );
    fn test_field_headerSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineCacheHeaderVersionOne>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).headerSize) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCacheHeaderVersionOne),
                "::",
                stringify!(headerSize)
            )
        );
    }
    test_field_headerSize();
    fn test_field_headerVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineCacheHeaderVersionOne>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).headerVersion) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCacheHeaderVersionOne),
                "::",
                stringify!(headerVersion)
            )
        );
    }
    test_field_headerVersion();
    fn test_field_vendorID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineCacheHeaderVersionOne>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vendorID) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCacheHeaderVersionOne),
                "::",
                stringify!(vendorID)
            )
        );
    }
    test_field_vendorID();
    fn test_field_deviceID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineCacheHeaderVersionOne>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceID) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCacheHeaderVersionOne),
                "::",
                stringify!(deviceID)
            )
        );
    }
    test_field_deviceID();
    fn test_field_pipelineCacheUUID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineCacheHeaderVersionOne>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineCacheUUID) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCacheHeaderVersionOne),
                "::",
                stringify!(pipelineCacheUUID)
            )
        );
    }
    test_field_pipelineCacheUUID();
}
impl Default for VkPipelineCacheHeaderVersionOne {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkAllocationFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        size: usize,
        alignment: usize,
        allocationScope: VkSystemAllocationScope,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type PFN_vkFreeFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        pMemory: *mut ::std::os::raw::c_void,
    ),
>;
pub type PFN_vkInternalAllocationNotification = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        size: usize,
        allocationType: VkInternalAllocationType,
        allocationScope: VkSystemAllocationScope,
    ),
>;
pub type PFN_vkInternalFreeNotification = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        size: usize,
        allocationType: VkInternalAllocationType,
        allocationScope: VkSystemAllocationScope,
    ),
>;
pub type PFN_vkReallocationFunction = ::std::option::Option<
    unsafe extern "C" fn(
        pUserData: *mut ::std::os::raw::c_void,
        pOriginal: *mut ::std::os::raw::c_void,
        size: usize,
        alignment: usize,
        allocationScope: VkSystemAllocationScope,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type PFN_vkVoidFunction = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAllocationCallbacks {
    pub pUserData: *mut ::std::os::raw::c_void,
    pub pfnAllocation: PFN_vkAllocationFunction,
    pub pfnReallocation: PFN_vkReallocationFunction,
    pub pfnFree: PFN_vkFreeFunction,
    pub pfnInternalAllocation: PFN_vkInternalAllocationNotification,
    pub pfnInternalFree: PFN_vkInternalFreeNotification,
}
#[test]
fn bindgen_test_layout_VkAllocationCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<VkAllocationCallbacks>(),
        48usize,
        concat!("Size of: ", stringify!(VkAllocationCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAllocationCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAllocationCallbacks))
    );
    fn test_field_pUserData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAllocationCallbacks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAllocationCallbacks),
                "::",
                stringify!(pUserData)
            )
        );
    }
    test_field_pUserData();
    fn test_field_pfnAllocation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAllocationCallbacks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pfnAllocation) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAllocationCallbacks),
                "::",
                stringify!(pfnAllocation)
            )
        );
    }
    test_field_pfnAllocation();
    fn test_field_pfnReallocation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAllocationCallbacks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pfnReallocation) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAllocationCallbacks),
                "::",
                stringify!(pfnReallocation)
            )
        );
    }
    test_field_pfnReallocation();
    fn test_field_pfnFree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAllocationCallbacks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pfnFree) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAllocationCallbacks),
                "::",
                stringify!(pfnFree)
            )
        );
    }
    test_field_pfnFree();
    fn test_field_pfnInternalAllocation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAllocationCallbacks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pfnInternalAllocation) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAllocationCallbacks),
                "::",
                stringify!(pfnInternalAllocation)
            )
        );
    }
    test_field_pfnInternalAllocation();
    fn test_field_pfnInternalFree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAllocationCallbacks>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pfnInternalFree) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAllocationCallbacks),
                "::",
                stringify!(pfnInternalFree)
            )
        );
    }
    test_field_pfnInternalFree();
}
impl Default for VkAllocationCallbacks {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkApplicationInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pApplicationName: *const ::std::os::raw::c_char,
    pub applicationVersion: u32,
    pub pEngineName: *const ::std::os::raw::c_char,
    pub engineVersion: u32,
    pub apiVersion: u32,
}
#[test]
fn bindgen_test_layout_VkApplicationInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkApplicationInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VkApplicationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkApplicationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkApplicationInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkApplicationInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkApplicationInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkApplicationInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkApplicationInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pApplicationName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkApplicationInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pApplicationName) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkApplicationInfo),
                "::",
                stringify!(pApplicationName)
            )
        );
    }
    test_field_pApplicationName();
    fn test_field_applicationVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkApplicationInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).applicationVersion) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkApplicationInfo),
                "::",
                stringify!(applicationVersion)
            )
        );
    }
    test_field_applicationVersion();
    fn test_field_pEngineName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkApplicationInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pEngineName) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkApplicationInfo),
                "::",
                stringify!(pEngineName)
            )
        );
    }
    test_field_pEngineName();
    fn test_field_engineVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkApplicationInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).engineVersion) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkApplicationInfo),
                "::",
                stringify!(engineVersion)
            )
        );
    }
    test_field_engineVersion();
    fn test_field_apiVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkApplicationInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).apiVersion) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkApplicationInfo),
                "::",
                stringify!(apiVersion)
            )
        );
    }
    test_field_apiVersion();
}
impl Default for VkApplicationInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkFormatProperties {
    pub linearTilingFeatures: VkFormatFeatureFlags,
    pub optimalTilingFeatures: VkFormatFeatureFlags,
    pub bufferFeatures: VkFormatFeatureFlags,
}
#[test]
fn bindgen_test_layout_VkFormatProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkFormatProperties>(),
        12usize,
        concat!("Size of: ", stringify!(VkFormatProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkFormatProperties>(),
        4usize,
        concat!("Alignment of ", stringify!(VkFormatProperties))
    );
    fn test_field_linearTilingFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFormatProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).linearTilingFeatures) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFormatProperties),
                "::",
                stringify!(linearTilingFeatures)
            )
        );
    }
    test_field_linearTilingFeatures();
    fn test_field_optimalTilingFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFormatProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).optimalTilingFeatures) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFormatProperties),
                "::",
                stringify!(optimalTilingFeatures)
            )
        );
    }
    test_field_optimalTilingFeatures();
    fn test_field_bufferFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFormatProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferFeatures) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFormatProperties),
                "::",
                stringify!(bufferFeatures)
            )
        );
    }
    test_field_bufferFeatures();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkImageFormatProperties {
    pub maxExtent: VkExtent3D,
    pub maxMipLevels: u32,
    pub maxArrayLayers: u32,
    pub sampleCounts: VkSampleCountFlags,
    pub maxResourceSize: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkImageFormatProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkImageFormatProperties>(),
        32usize,
        concat!("Size of: ", stringify!(VkImageFormatProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageFormatProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageFormatProperties))
    );
    fn test_field_maxExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageFormatProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxExtent) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageFormatProperties),
                "::",
                stringify!(maxExtent)
            )
        );
    }
    test_field_maxExtent();
    fn test_field_maxMipLevels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageFormatProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMipLevels) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageFormatProperties),
                "::",
                stringify!(maxMipLevels)
            )
        );
    }
    test_field_maxMipLevels();
    fn test_field_maxArrayLayers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageFormatProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxArrayLayers) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageFormatProperties),
                "::",
                stringify!(maxArrayLayers)
            )
        );
    }
    test_field_maxArrayLayers();
    fn test_field_sampleCounts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageFormatProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleCounts) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageFormatProperties),
                "::",
                stringify!(sampleCounts)
            )
        );
    }
    test_field_sampleCounts();
    fn test_field_maxResourceSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageFormatProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxResourceSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageFormatProperties),
                "::",
                stringify!(maxResourceSize)
            )
        );
    }
    test_field_maxResourceSize();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkInstanceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkInstanceCreateFlags,
    pub pApplicationInfo: *const VkApplicationInfo,
    pub enabledLayerCount: u32,
    pub ppEnabledLayerNames: *const *const ::std::os::raw::c_char,
    pub enabledExtensionCount: u32,
    pub ppEnabledExtensionNames: *const *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VkInstanceCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkInstanceCreateInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VkInstanceCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkInstanceCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkInstanceCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkInstanceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkInstanceCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkInstanceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkInstanceCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkInstanceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkInstanceCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_pApplicationInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkInstanceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pApplicationInfo) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkInstanceCreateInfo),
                "::",
                stringify!(pApplicationInfo)
            )
        );
    }
    test_field_pApplicationInfo();
    fn test_field_enabledLayerCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkInstanceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enabledLayerCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkInstanceCreateInfo),
                "::",
                stringify!(enabledLayerCount)
            )
        );
    }
    test_field_enabledLayerCount();
    fn test_field_ppEnabledLayerNames() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkInstanceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ppEnabledLayerNames) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkInstanceCreateInfo),
                "::",
                stringify!(ppEnabledLayerNames)
            )
        );
    }
    test_field_ppEnabledLayerNames();
    fn test_field_enabledExtensionCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkInstanceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enabledExtensionCount) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkInstanceCreateInfo),
                "::",
                stringify!(enabledExtensionCount)
            )
        );
    }
    test_field_enabledExtensionCount();
    fn test_field_ppEnabledExtensionNames() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkInstanceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ppEnabledExtensionNames) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkInstanceCreateInfo),
                "::",
                stringify!(ppEnabledExtensionNames)
            )
        );
    }
    test_field_ppEnabledExtensionNames();
}
impl Default for VkInstanceCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkMemoryHeap {
    pub size: VkDeviceSize,
    pub flags: VkMemoryHeapFlags,
}
#[test]
fn bindgen_test_layout_VkMemoryHeap() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryHeap>(),
        16usize,
        concat!("Size of: ", stringify!(VkMemoryHeap))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryHeap>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryHeap))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryHeap>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryHeap),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryHeap>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryHeap),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkMemoryType {
    pub propertyFlags: VkMemoryPropertyFlags,
    pub heapIndex: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryType() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryType>(),
        8usize,
        concat!("Size of: ", stringify!(VkMemoryType))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryType>(),
        4usize,
        concat!("Alignment of ", stringify!(VkMemoryType))
    );
    fn test_field_propertyFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryType>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).propertyFlags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryType),
                "::",
                stringify!(propertyFlags)
            )
        );
    }
    test_field_propertyFlags();
    fn test_field_heapIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryType>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).heapIndex) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryType),
                "::",
                stringify!(heapIndex)
            )
        );
    }
    test_field_heapIndex();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkPhysicalDeviceFeatures {
    pub robustBufferAccess: VkBool32,
    pub fullDrawIndexUint32: VkBool32,
    pub imageCubeArray: VkBool32,
    pub independentBlend: VkBool32,
    pub geometryShader: VkBool32,
    pub tessellationShader: VkBool32,
    pub sampleRateShading: VkBool32,
    pub dualSrcBlend: VkBool32,
    pub logicOp: VkBool32,
    pub multiDrawIndirect: VkBool32,
    pub drawIndirectFirstInstance: VkBool32,
    pub depthClamp: VkBool32,
    pub depthBiasClamp: VkBool32,
    pub fillModeNonSolid: VkBool32,
    pub depthBounds: VkBool32,
    pub wideLines: VkBool32,
    pub largePoints: VkBool32,
    pub alphaToOne: VkBool32,
    pub multiViewport: VkBool32,
    pub samplerAnisotropy: VkBool32,
    pub textureCompressionETC2: VkBool32,
    pub textureCompressionASTC_LDR: VkBool32,
    pub textureCompressionBC: VkBool32,
    pub occlusionQueryPrecise: VkBool32,
    pub pipelineStatisticsQuery: VkBool32,
    pub vertexPipelineStoresAndAtomics: VkBool32,
    pub fragmentStoresAndAtomics: VkBool32,
    pub shaderTessellationAndGeometryPointSize: VkBool32,
    pub shaderImageGatherExtended: VkBool32,
    pub shaderStorageImageExtendedFormats: VkBool32,
    pub shaderStorageImageMultisample: VkBool32,
    pub shaderStorageImageReadWithoutFormat: VkBool32,
    pub shaderStorageImageWriteWithoutFormat: VkBool32,
    pub shaderUniformBufferArrayDynamicIndexing: VkBool32,
    pub shaderSampledImageArrayDynamicIndexing: VkBool32,
    pub shaderStorageBufferArrayDynamicIndexing: VkBool32,
    pub shaderStorageImageArrayDynamicIndexing: VkBool32,
    pub shaderClipDistance: VkBool32,
    pub shaderCullDistance: VkBool32,
    pub shaderFloat64: VkBool32,
    pub shaderInt64: VkBool32,
    pub shaderInt16: VkBool32,
    pub shaderResourceResidency: VkBool32,
    pub shaderResourceMinLod: VkBool32,
    pub sparseBinding: VkBool32,
    pub sparseResidencyBuffer: VkBool32,
    pub sparseResidencyImage2D: VkBool32,
    pub sparseResidencyImage3D: VkBool32,
    pub sparseResidency2Samples: VkBool32,
    pub sparseResidency4Samples: VkBool32,
    pub sparseResidency8Samples: VkBool32,
    pub sparseResidency16Samples: VkBool32,
    pub sparseResidencyAliased: VkBool32,
    pub variableMultisampleRate: VkBool32,
    pub inheritedQueries: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFeatures>(),
        220usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceFeatures))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFeatures>(),
        4usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceFeatures))
    );
    fn test_field_robustBufferAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).robustBufferAccess) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(robustBufferAccess)
            )
        );
    }
    test_field_robustBufferAccess();
    fn test_field_fullDrawIndexUint32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fullDrawIndexUint32) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(fullDrawIndexUint32)
            )
        );
    }
    test_field_fullDrawIndexUint32();
    fn test_field_imageCubeArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageCubeArray) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(imageCubeArray)
            )
        );
    }
    test_field_imageCubeArray();
    fn test_field_independentBlend() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).independentBlend) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(independentBlend)
            )
        );
    }
    test_field_independentBlend();
    fn test_field_geometryShader() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).geometryShader) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(geometryShader)
            )
        );
    }
    test_field_geometryShader();
    fn test_field_tessellationShader() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tessellationShader) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(tessellationShader)
            )
        );
    }
    test_field_tessellationShader();
    fn test_field_sampleRateShading() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleRateShading) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(sampleRateShading)
            )
        );
    }
    test_field_sampleRateShading();
    fn test_field_dualSrcBlend() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dualSrcBlend) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(dualSrcBlend)
            )
        );
    }
    test_field_dualSrcBlend();
    fn test_field_logicOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).logicOp) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(logicOp)
            )
        );
    }
    test_field_logicOp();
    fn test_field_multiDrawIndirect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiDrawIndirect) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(multiDrawIndirect)
            )
        );
    }
    test_field_multiDrawIndirect();
    fn test_field_drawIndirectFirstInstance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drawIndirectFirstInstance) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(drawIndirectFirstInstance)
            )
        );
    }
    test_field_drawIndirectFirstInstance();
    fn test_field_depthClamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthClamp) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(depthClamp)
            )
        );
    }
    test_field_depthClamp();
    fn test_field_depthBiasClamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthBiasClamp) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(depthBiasClamp)
            )
        );
    }
    test_field_depthBiasClamp();
    fn test_field_fillModeNonSolid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fillModeNonSolid) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(fillModeNonSolid)
            )
        );
    }
    test_field_fillModeNonSolid();
    fn test_field_depthBounds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthBounds) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(depthBounds)
            )
        );
    }
    test_field_depthBounds();
    fn test_field_wideLines() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wideLines) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(wideLines)
            )
        );
    }
    test_field_wideLines();
    fn test_field_largePoints() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).largePoints) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(largePoints)
            )
        );
    }
    test_field_largePoints();
    fn test_field_alphaToOne() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alphaToOne) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(alphaToOne)
            )
        );
    }
    test_field_alphaToOne();
    fn test_field_multiViewport() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiViewport) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(multiViewport)
            )
        );
    }
    test_field_multiViewport();
    fn test_field_samplerAnisotropy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samplerAnisotropy) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(samplerAnisotropy)
            )
        );
    }
    test_field_samplerAnisotropy();
    fn test_field_textureCompressionETC2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).textureCompressionETC2) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(textureCompressionETC2)
            )
        );
    }
    test_field_textureCompressionETC2();
    fn test_field_textureCompressionASTC_LDR() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).textureCompressionASTC_LDR) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(textureCompressionASTC_LDR)
            )
        );
    }
    test_field_textureCompressionASTC_LDR();
    fn test_field_textureCompressionBC() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).textureCompressionBC) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(textureCompressionBC)
            )
        );
    }
    test_field_textureCompressionBC();
    fn test_field_occlusionQueryPrecise() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).occlusionQueryPrecise) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(occlusionQueryPrecise)
            )
        );
    }
    test_field_occlusionQueryPrecise();
    fn test_field_pipelineStatisticsQuery() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineStatisticsQuery) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(pipelineStatisticsQuery)
            )
        );
    }
    test_field_pipelineStatisticsQuery();
    fn test_field_vertexPipelineStoresAndAtomics() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexPipelineStoresAndAtomics) as usize - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(vertexPipelineStoresAndAtomics)
            )
        );
    }
    test_field_vertexPipelineStoresAndAtomics();
    fn test_field_fragmentStoresAndAtomics() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentStoresAndAtomics) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(fragmentStoresAndAtomics)
            )
        );
    }
    test_field_fragmentStoresAndAtomics();
    fn test_field_shaderTessellationAndGeometryPointSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderTessellationAndGeometryPointSize) as usize
                    - ptr as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderTessellationAndGeometryPointSize)
            )
        );
    }
    test_field_shaderTessellationAndGeometryPointSize();
    fn test_field_shaderImageGatherExtended() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderImageGatherExtended) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderImageGatherExtended)
            )
        );
    }
    test_field_shaderImageGatherExtended();
    fn test_field_shaderStorageImageExtendedFormats() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageImageExtendedFormats) as usize
                    - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderStorageImageExtendedFormats)
            )
        );
    }
    test_field_shaderStorageImageExtendedFormats();
    fn test_field_shaderStorageImageMultisample() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageImageMultisample) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderStorageImageMultisample)
            )
        );
    }
    test_field_shaderStorageImageMultisample();
    fn test_field_shaderStorageImageReadWithoutFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageImageReadWithoutFormat) as usize
                    - ptr as usize
            },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderStorageImageReadWithoutFormat)
            )
        );
    }
    test_field_shaderStorageImageReadWithoutFormat();
    fn test_field_shaderStorageImageWriteWithoutFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageImageWriteWithoutFormat) as usize
                    - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderStorageImageWriteWithoutFormat)
            )
        );
    }
    test_field_shaderStorageImageWriteWithoutFormat();
    fn test_field_shaderUniformBufferArrayDynamicIndexing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderUniformBufferArrayDynamicIndexing) as usize
                    - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderUniformBufferArrayDynamicIndexing)
            )
        );
    }
    test_field_shaderUniformBufferArrayDynamicIndexing();
    fn test_field_shaderSampledImageArrayDynamicIndexing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSampledImageArrayDynamicIndexing) as usize
                    - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderSampledImageArrayDynamicIndexing)
            )
        );
    }
    test_field_shaderSampledImageArrayDynamicIndexing();
    fn test_field_shaderStorageBufferArrayDynamicIndexing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageBufferArrayDynamicIndexing) as usize
                    - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderStorageBufferArrayDynamicIndexing)
            )
        );
    }
    test_field_shaderStorageBufferArrayDynamicIndexing();
    fn test_field_shaderStorageImageArrayDynamicIndexing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageImageArrayDynamicIndexing) as usize
                    - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderStorageImageArrayDynamicIndexing)
            )
        );
    }
    test_field_shaderStorageImageArrayDynamicIndexing();
    fn test_field_shaderClipDistance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderClipDistance) as usize - ptr as usize
            },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderClipDistance)
            )
        );
    }
    test_field_shaderClipDistance();
    fn test_field_shaderCullDistance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderCullDistance) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderCullDistance)
            )
        );
    }
    test_field_shaderCullDistance();
    fn test_field_shaderFloat64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderFloat64) as usize - ptr as usize
            },
            156usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderFloat64)
            )
        );
    }
    test_field_shaderFloat64();
    fn test_field_shaderInt64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderInt64) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderInt64)
            )
        );
    }
    test_field_shaderInt64();
    fn test_field_shaderInt16() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderInt16) as usize - ptr as usize
            },
            164usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderInt16)
            )
        );
    }
    test_field_shaderInt16();
    fn test_field_shaderResourceResidency() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderResourceResidency) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderResourceResidency)
            )
        );
    }
    test_field_shaderResourceResidency();
    fn test_field_shaderResourceMinLod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderResourceMinLod) as usize - ptr as usize
            },
            172usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(shaderResourceMinLod)
            )
        );
    }
    test_field_shaderResourceMinLod();
    fn test_field_sparseBinding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseBinding) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(sparseBinding)
            )
        );
    }
    test_field_sparseBinding();
    fn test_field_sparseResidencyBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseResidencyBuffer) as usize - ptr as usize
            },
            180usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(sparseResidencyBuffer)
            )
        );
    }
    test_field_sparseResidencyBuffer();
    fn test_field_sparseResidencyImage2D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseResidencyImage2D) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(sparseResidencyImage2D)
            )
        );
    }
    test_field_sparseResidencyImage2D();
    fn test_field_sparseResidencyImage3D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseResidencyImage3D) as usize - ptr as usize
            },
            188usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(sparseResidencyImage3D)
            )
        );
    }
    test_field_sparseResidencyImage3D();
    fn test_field_sparseResidency2Samples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseResidency2Samples) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(sparseResidency2Samples)
            )
        );
    }
    test_field_sparseResidency2Samples();
    fn test_field_sparseResidency4Samples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseResidency4Samples) as usize - ptr as usize
            },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(sparseResidency4Samples)
            )
        );
    }
    test_field_sparseResidency4Samples();
    fn test_field_sparseResidency8Samples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseResidency8Samples) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(sparseResidency8Samples)
            )
        );
    }
    test_field_sparseResidency8Samples();
    fn test_field_sparseResidency16Samples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseResidency16Samples) as usize - ptr as usize
            },
            204usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(sparseResidency16Samples)
            )
        );
    }
    test_field_sparseResidency16Samples();
    fn test_field_sparseResidencyAliased() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseResidencyAliased) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(sparseResidencyAliased)
            )
        );
    }
    test_field_sparseResidencyAliased();
    fn test_field_variableMultisampleRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).variableMultisampleRate) as usize - ptr as usize
            },
            212usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(variableMultisampleRate)
            )
        );
    }
    test_field_variableMultisampleRate();
    fn test_field_inheritedQueries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inheritedQueries) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures),
                "::",
                stringify!(inheritedQueries)
            )
        );
    }
    test_field_inheritedQueries();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkPhysicalDeviceLimits {
    pub maxImageDimension1D: u32,
    pub maxImageDimension2D: u32,
    pub maxImageDimension3D: u32,
    pub maxImageDimensionCube: u32,
    pub maxImageArrayLayers: u32,
    pub maxTexelBufferElements: u32,
    pub maxUniformBufferRange: u32,
    pub maxStorageBufferRange: u32,
    pub maxPushConstantsSize: u32,
    pub maxMemoryAllocationCount: u32,
    pub maxSamplerAllocationCount: u32,
    pub bufferImageGranularity: VkDeviceSize,
    pub sparseAddressSpaceSize: VkDeviceSize,
    pub maxBoundDescriptorSets: u32,
    pub maxPerStageDescriptorSamplers: u32,
    pub maxPerStageDescriptorUniformBuffers: u32,
    pub maxPerStageDescriptorStorageBuffers: u32,
    pub maxPerStageDescriptorSampledImages: u32,
    pub maxPerStageDescriptorStorageImages: u32,
    pub maxPerStageDescriptorInputAttachments: u32,
    pub maxPerStageResources: u32,
    pub maxDescriptorSetSamplers: u32,
    pub maxDescriptorSetUniformBuffers: u32,
    pub maxDescriptorSetUniformBuffersDynamic: u32,
    pub maxDescriptorSetStorageBuffers: u32,
    pub maxDescriptorSetStorageBuffersDynamic: u32,
    pub maxDescriptorSetSampledImages: u32,
    pub maxDescriptorSetStorageImages: u32,
    pub maxDescriptorSetInputAttachments: u32,
    pub maxVertexInputAttributes: u32,
    pub maxVertexInputBindings: u32,
    pub maxVertexInputAttributeOffset: u32,
    pub maxVertexInputBindingStride: u32,
    pub maxVertexOutputComponents: u32,
    pub maxTessellationGenerationLevel: u32,
    pub maxTessellationPatchSize: u32,
    pub maxTessellationControlPerVertexInputComponents: u32,
    pub maxTessellationControlPerVertexOutputComponents: u32,
    pub maxTessellationControlPerPatchOutputComponents: u32,
    pub maxTessellationControlTotalOutputComponents: u32,
    pub maxTessellationEvaluationInputComponents: u32,
    pub maxTessellationEvaluationOutputComponents: u32,
    pub maxGeometryShaderInvocations: u32,
    pub maxGeometryInputComponents: u32,
    pub maxGeometryOutputComponents: u32,
    pub maxGeometryOutputVertices: u32,
    pub maxGeometryTotalOutputComponents: u32,
    pub maxFragmentInputComponents: u32,
    pub maxFragmentOutputAttachments: u32,
    pub maxFragmentDualSrcAttachments: u32,
    pub maxFragmentCombinedOutputResources: u32,
    pub maxComputeSharedMemorySize: u32,
    pub maxComputeWorkGroupCount: [u32; 3usize],
    pub maxComputeWorkGroupInvocations: u32,
    pub maxComputeWorkGroupSize: [u32; 3usize],
    pub subPixelPrecisionBits: u32,
    pub subTexelPrecisionBits: u32,
    pub mipmapPrecisionBits: u32,
    pub maxDrawIndexedIndexValue: u32,
    pub maxDrawIndirectCount: u32,
    pub maxSamplerLodBias: f32,
    pub maxSamplerAnisotropy: f32,
    pub maxViewports: u32,
    pub maxViewportDimensions: [u32; 2usize],
    pub viewportBoundsRange: [f32; 2usize],
    pub viewportSubPixelBits: u32,
    pub minMemoryMapAlignment: usize,
    pub minTexelBufferOffsetAlignment: VkDeviceSize,
    pub minUniformBufferOffsetAlignment: VkDeviceSize,
    pub minStorageBufferOffsetAlignment: VkDeviceSize,
    pub minTexelOffset: i32,
    pub maxTexelOffset: u32,
    pub minTexelGatherOffset: i32,
    pub maxTexelGatherOffset: u32,
    pub minInterpolationOffset: f32,
    pub maxInterpolationOffset: f32,
    pub subPixelInterpolationOffsetBits: u32,
    pub maxFramebufferWidth: u32,
    pub maxFramebufferHeight: u32,
    pub maxFramebufferLayers: u32,
    pub framebufferColorSampleCounts: VkSampleCountFlags,
    pub framebufferDepthSampleCounts: VkSampleCountFlags,
    pub framebufferStencilSampleCounts: VkSampleCountFlags,
    pub framebufferNoAttachmentsSampleCounts: VkSampleCountFlags,
    pub maxColorAttachments: u32,
    pub sampledImageColorSampleCounts: VkSampleCountFlags,
    pub sampledImageIntegerSampleCounts: VkSampleCountFlags,
    pub sampledImageDepthSampleCounts: VkSampleCountFlags,
    pub sampledImageStencilSampleCounts: VkSampleCountFlags,
    pub storageImageSampleCounts: VkSampleCountFlags,
    pub maxSampleMaskWords: u32,
    pub timestampComputeAndGraphics: VkBool32,
    pub timestampPeriod: f32,
    pub maxClipDistances: u32,
    pub maxCullDistances: u32,
    pub maxCombinedClipAndCullDistances: u32,
    pub discreteQueuePriorities: u32,
    pub pointSizeRange: [f32; 2usize],
    pub lineWidthRange: [f32; 2usize],
    pub pointSizeGranularity: f32,
    pub lineWidthGranularity: f32,
    pub strictLines: VkBool32,
    pub standardSampleLocations: VkBool32,
    pub optimalBufferCopyOffsetAlignment: VkDeviceSize,
    pub optimalBufferCopyRowPitchAlignment: VkDeviceSize,
    pub nonCoherentAtomSize: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceLimits() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceLimits>(),
        504usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceLimits))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceLimits>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceLimits))
    );
    fn test_field_maxImageDimension1D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxImageDimension1D) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxImageDimension1D)
            )
        );
    }
    test_field_maxImageDimension1D();
    fn test_field_maxImageDimension2D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxImageDimension2D) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxImageDimension2D)
            )
        );
    }
    test_field_maxImageDimension2D();
    fn test_field_maxImageDimension3D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxImageDimension3D) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxImageDimension3D)
            )
        );
    }
    test_field_maxImageDimension3D();
    fn test_field_maxImageDimensionCube() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxImageDimensionCube) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxImageDimensionCube)
            )
        );
    }
    test_field_maxImageDimensionCube();
    fn test_field_maxImageArrayLayers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxImageArrayLayers) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxImageArrayLayers)
            )
        );
    }
    test_field_maxImageArrayLayers();
    fn test_field_maxTexelBufferElements() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexelBufferElements) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxTexelBufferElements)
            )
        );
    }
    test_field_maxTexelBufferElements();
    fn test_field_maxUniformBufferRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxUniformBufferRange) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxUniformBufferRange)
            )
        );
    }
    test_field_maxUniformBufferRange();
    fn test_field_maxStorageBufferRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxStorageBufferRange) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxStorageBufferRange)
            )
        );
    }
    test_field_maxStorageBufferRange();
    fn test_field_maxPushConstantsSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPushConstantsSize) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxPushConstantsSize)
            )
        );
    }
    test_field_maxPushConstantsSize();
    fn test_field_maxMemoryAllocationCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMemoryAllocationCount) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxMemoryAllocationCount)
            )
        );
    }
    test_field_maxMemoryAllocationCount();
    fn test_field_maxSamplerAllocationCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSamplerAllocationCount) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxSamplerAllocationCount)
            )
        );
    }
    test_field_maxSamplerAllocationCount();
    fn test_field_bufferImageGranularity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferImageGranularity) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(bufferImageGranularity)
            )
        );
    }
    test_field_bufferImageGranularity();
    fn test_field_sparseAddressSpaceSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseAddressSpaceSize) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(sparseAddressSpaceSize)
            )
        );
    }
    test_field_sparseAddressSpaceSize();
    fn test_field_maxBoundDescriptorSets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxBoundDescriptorSets) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxBoundDescriptorSets)
            )
        );
    }
    test_field_maxBoundDescriptorSets();
    fn test_field_maxPerStageDescriptorSamplers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorSamplers) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxPerStageDescriptorSamplers)
            )
        );
    }
    test_field_maxPerStageDescriptorSamplers();
    fn test_field_maxPerStageDescriptorUniformBuffers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorUniformBuffers) as usize
                    - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxPerStageDescriptorUniformBuffers)
            )
        );
    }
    test_field_maxPerStageDescriptorUniformBuffers();
    fn test_field_maxPerStageDescriptorStorageBuffers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorStorageBuffers) as usize
                    - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxPerStageDescriptorStorageBuffers)
            )
        );
    }
    test_field_maxPerStageDescriptorStorageBuffers();
    fn test_field_maxPerStageDescriptorSampledImages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorSampledImages) as usize
                    - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxPerStageDescriptorSampledImages)
            )
        );
    }
    test_field_maxPerStageDescriptorSampledImages();
    fn test_field_maxPerStageDescriptorStorageImages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorStorageImages) as usize
                    - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxPerStageDescriptorStorageImages)
            )
        );
    }
    test_field_maxPerStageDescriptorStorageImages();
    fn test_field_maxPerStageDescriptorInputAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorInputAttachments) as usize
                    - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxPerStageDescriptorInputAttachments)
            )
        );
    }
    test_field_maxPerStageDescriptorInputAttachments();
    fn test_field_maxPerStageResources() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageResources) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxPerStageResources)
            )
        );
    }
    test_field_maxPerStageResources();
    fn test_field_maxDescriptorSetSamplers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetSamplers) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxDescriptorSetSamplers)
            )
        );
    }
    test_field_maxDescriptorSetSamplers();
    fn test_field_maxDescriptorSetUniformBuffers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUniformBuffers) as usize - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxDescriptorSetUniformBuffers)
            )
        );
    }
    test_field_maxDescriptorSetUniformBuffers();
    fn test_field_maxDescriptorSetUniformBuffersDynamic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUniformBuffersDynamic) as usize
                    - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxDescriptorSetUniformBuffersDynamic)
            )
        );
    }
    test_field_maxDescriptorSetUniformBuffersDynamic();
    fn test_field_maxDescriptorSetStorageBuffers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetStorageBuffers) as usize - ptr as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxDescriptorSetStorageBuffers)
            )
        );
    }
    test_field_maxDescriptorSetStorageBuffers();
    fn test_field_maxDescriptorSetStorageBuffersDynamic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetStorageBuffersDynamic) as usize
                    - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxDescriptorSetStorageBuffersDynamic)
            )
        );
    }
    test_field_maxDescriptorSetStorageBuffersDynamic();
    fn test_field_maxDescriptorSetSampledImages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetSampledImages) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxDescriptorSetSampledImages)
            )
        );
    }
    test_field_maxDescriptorSetSampledImages();
    fn test_field_maxDescriptorSetStorageImages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetStorageImages) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxDescriptorSetStorageImages)
            )
        );
    }
    test_field_maxDescriptorSetStorageImages();
    fn test_field_maxDescriptorSetInputAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetInputAttachments) as usize
                    - ptr as usize
            },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxDescriptorSetInputAttachments)
            )
        );
    }
    test_field_maxDescriptorSetInputAttachments();
    fn test_field_maxVertexInputAttributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxVertexInputAttributes) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxVertexInputAttributes)
            )
        );
    }
    test_field_maxVertexInputAttributes();
    fn test_field_maxVertexInputBindings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxVertexInputBindings) as usize - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxVertexInputBindings)
            )
        );
    }
    test_field_maxVertexInputBindings();
    fn test_field_maxVertexInputAttributeOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxVertexInputAttributeOffset) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxVertexInputAttributeOffset)
            )
        );
    }
    test_field_maxVertexInputAttributeOffset();
    fn test_field_maxVertexInputBindingStride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxVertexInputBindingStride) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxVertexInputBindingStride)
            )
        );
    }
    test_field_maxVertexInputBindingStride();
    fn test_field_maxVertexOutputComponents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxVertexOutputComponents) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxVertexOutputComponents)
            )
        );
    }
    test_field_maxVertexOutputComponents();
    fn test_field_maxTessellationGenerationLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTessellationGenerationLevel) as usize - ptr as usize
            },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxTessellationGenerationLevel)
            )
        );
    }
    test_field_maxTessellationGenerationLevel();
    fn test_field_maxTessellationPatchSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTessellationPatchSize) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxTessellationPatchSize)
            )
        );
    }
    test_field_maxTessellationPatchSize();
    fn test_field_maxTessellationControlPerVertexInputComponents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTessellationControlPerVertexInputComponents) as usize
                    - ptr as usize
            },
            156usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxTessellationControlPerVertexInputComponents)
            )
        );
    }
    test_field_maxTessellationControlPerVertexInputComponents();
    fn test_field_maxTessellationControlPerVertexOutputComponents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTessellationControlPerVertexOutputComponents)
                    as usize
                    - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxTessellationControlPerVertexOutputComponents)
            )
        );
    }
    test_field_maxTessellationControlPerVertexOutputComponents();
    fn test_field_maxTessellationControlPerPatchOutputComponents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTessellationControlPerPatchOutputComponents) as usize
                    - ptr as usize
            },
            164usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxTessellationControlPerPatchOutputComponents)
            )
        );
    }
    test_field_maxTessellationControlPerPatchOutputComponents();
    fn test_field_maxTessellationControlTotalOutputComponents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTessellationControlTotalOutputComponents) as usize
                    - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxTessellationControlTotalOutputComponents)
            )
        );
    }
    test_field_maxTessellationControlTotalOutputComponents();
    fn test_field_maxTessellationEvaluationInputComponents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTessellationEvaluationInputComponents) as usize
                    - ptr as usize
            },
            172usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxTessellationEvaluationInputComponents)
            )
        );
    }
    test_field_maxTessellationEvaluationInputComponents();
    fn test_field_maxTessellationEvaluationOutputComponents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTessellationEvaluationOutputComponents) as usize
                    - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxTessellationEvaluationOutputComponents)
            )
        );
    }
    test_field_maxTessellationEvaluationOutputComponents();
    fn test_field_maxGeometryShaderInvocations() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxGeometryShaderInvocations) as usize - ptr as usize
            },
            180usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxGeometryShaderInvocations)
            )
        );
    }
    test_field_maxGeometryShaderInvocations();
    fn test_field_maxGeometryInputComponents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxGeometryInputComponents) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxGeometryInputComponents)
            )
        );
    }
    test_field_maxGeometryInputComponents();
    fn test_field_maxGeometryOutputComponents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxGeometryOutputComponents) as usize - ptr as usize
            },
            188usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxGeometryOutputComponents)
            )
        );
    }
    test_field_maxGeometryOutputComponents();
    fn test_field_maxGeometryOutputVertices() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxGeometryOutputVertices) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxGeometryOutputVertices)
            )
        );
    }
    test_field_maxGeometryOutputVertices();
    fn test_field_maxGeometryTotalOutputComponents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxGeometryTotalOutputComponents) as usize
                    - ptr as usize
            },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxGeometryTotalOutputComponents)
            )
        );
    }
    test_field_maxGeometryTotalOutputComponents();
    fn test_field_maxFragmentInputComponents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFragmentInputComponents) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxFragmentInputComponents)
            )
        );
    }
    test_field_maxFragmentInputComponents();
    fn test_field_maxFragmentOutputAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFragmentOutputAttachments) as usize - ptr as usize
            },
            204usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxFragmentOutputAttachments)
            )
        );
    }
    test_field_maxFragmentOutputAttachments();
    fn test_field_maxFragmentDualSrcAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFragmentDualSrcAttachments) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxFragmentDualSrcAttachments)
            )
        );
    }
    test_field_maxFragmentDualSrcAttachments();
    fn test_field_maxFragmentCombinedOutputResources() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFragmentCombinedOutputResources) as usize
                    - ptr as usize
            },
            212usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxFragmentCombinedOutputResources)
            )
        );
    }
    test_field_maxFragmentCombinedOutputResources();
    fn test_field_maxComputeSharedMemorySize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxComputeSharedMemorySize) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxComputeSharedMemorySize)
            )
        );
    }
    test_field_maxComputeSharedMemorySize();
    fn test_field_maxComputeWorkGroupCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxComputeWorkGroupCount) as usize - ptr as usize
            },
            220usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxComputeWorkGroupCount)
            )
        );
    }
    test_field_maxComputeWorkGroupCount();
    fn test_field_maxComputeWorkGroupInvocations() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxComputeWorkGroupInvocations) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxComputeWorkGroupInvocations)
            )
        );
    }
    test_field_maxComputeWorkGroupInvocations();
    fn test_field_maxComputeWorkGroupSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxComputeWorkGroupSize) as usize - ptr as usize
            },
            236usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxComputeWorkGroupSize)
            )
        );
    }
    test_field_maxComputeWorkGroupSize();
    fn test_field_subPixelPrecisionBits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subPixelPrecisionBits) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(subPixelPrecisionBits)
            )
        );
    }
    test_field_subPixelPrecisionBits();
    fn test_field_subTexelPrecisionBits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subTexelPrecisionBits) as usize - ptr as usize
            },
            252usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(subTexelPrecisionBits)
            )
        );
    }
    test_field_subTexelPrecisionBits();
    fn test_field_mipmapPrecisionBits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmapPrecisionBits) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(mipmapPrecisionBits)
            )
        );
    }
    test_field_mipmapPrecisionBits();
    fn test_field_maxDrawIndexedIndexValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDrawIndexedIndexValue) as usize - ptr as usize
            },
            260usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxDrawIndexedIndexValue)
            )
        );
    }
    test_field_maxDrawIndexedIndexValue();
    fn test_field_maxDrawIndirectCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDrawIndirectCount) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxDrawIndirectCount)
            )
        );
    }
    test_field_maxDrawIndirectCount();
    fn test_field_maxSamplerLodBias() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSamplerLodBias) as usize - ptr as usize
            },
            268usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxSamplerLodBias)
            )
        );
    }
    test_field_maxSamplerLodBias();
    fn test_field_maxSamplerAnisotropy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSamplerAnisotropy) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxSamplerAnisotropy)
            )
        );
    }
    test_field_maxSamplerAnisotropy();
    fn test_field_maxViewports() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxViewports) as usize - ptr as usize
            },
            276usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxViewports)
            )
        );
    }
    test_field_maxViewports();
    fn test_field_maxViewportDimensions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxViewportDimensions) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxViewportDimensions)
            )
        );
    }
    test_field_maxViewportDimensions();
    fn test_field_viewportBoundsRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewportBoundsRange) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(viewportBoundsRange)
            )
        );
    }
    test_field_viewportBoundsRange();
    fn test_field_viewportSubPixelBits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewportSubPixelBits) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(viewportSubPixelBits)
            )
        );
    }
    test_field_viewportSubPixelBits();
    fn test_field_minMemoryMapAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minMemoryMapAlignment) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(minMemoryMapAlignment)
            )
        );
    }
    test_field_minMemoryMapAlignment();
    fn test_field_minTexelBufferOffsetAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minTexelBufferOffsetAlignment) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(minTexelBufferOffsetAlignment)
            )
        );
    }
    test_field_minTexelBufferOffsetAlignment();
    fn test_field_minUniformBufferOffsetAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minUniformBufferOffsetAlignment) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(minUniformBufferOffsetAlignment)
            )
        );
    }
    test_field_minUniformBufferOffsetAlignment();
    fn test_field_minStorageBufferOffsetAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minStorageBufferOffsetAlignment) as usize - ptr as usize
            },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(minStorageBufferOffsetAlignment)
            )
        );
    }
    test_field_minStorageBufferOffsetAlignment();
    fn test_field_minTexelOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minTexelOffset) as usize - ptr as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(minTexelOffset)
            )
        );
    }
    test_field_minTexelOffset();
    fn test_field_maxTexelOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexelOffset) as usize - ptr as usize
            },
            340usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxTexelOffset)
            )
        );
    }
    test_field_maxTexelOffset();
    fn test_field_minTexelGatherOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minTexelGatherOffset) as usize - ptr as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(minTexelGatherOffset)
            )
        );
    }
    test_field_minTexelGatherOffset();
    fn test_field_maxTexelGatherOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTexelGatherOffset) as usize - ptr as usize
            },
            348usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxTexelGatherOffset)
            )
        );
    }
    test_field_maxTexelGatherOffset();
    fn test_field_minInterpolationOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minInterpolationOffset) as usize - ptr as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(minInterpolationOffset)
            )
        );
    }
    test_field_minInterpolationOffset();
    fn test_field_maxInterpolationOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxInterpolationOffset) as usize - ptr as usize
            },
            356usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxInterpolationOffset)
            )
        );
    }
    test_field_maxInterpolationOffset();
    fn test_field_subPixelInterpolationOffsetBits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subPixelInterpolationOffsetBits) as usize - ptr as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(subPixelInterpolationOffsetBits)
            )
        );
    }
    test_field_subPixelInterpolationOffsetBits();
    fn test_field_maxFramebufferWidth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFramebufferWidth) as usize - ptr as usize
            },
            364usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxFramebufferWidth)
            )
        );
    }
    test_field_maxFramebufferWidth();
    fn test_field_maxFramebufferHeight() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFramebufferHeight) as usize - ptr as usize
            },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxFramebufferHeight)
            )
        );
    }
    test_field_maxFramebufferHeight();
    fn test_field_maxFramebufferLayers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFramebufferLayers) as usize - ptr as usize
            },
            372usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxFramebufferLayers)
            )
        );
    }
    test_field_maxFramebufferLayers();
    fn test_field_framebufferColorSampleCounts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).framebufferColorSampleCounts) as usize - ptr as usize
            },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(framebufferColorSampleCounts)
            )
        );
    }
    test_field_framebufferColorSampleCounts();
    fn test_field_framebufferDepthSampleCounts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).framebufferDepthSampleCounts) as usize - ptr as usize
            },
            380usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(framebufferDepthSampleCounts)
            )
        );
    }
    test_field_framebufferDepthSampleCounts();
    fn test_field_framebufferStencilSampleCounts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).framebufferStencilSampleCounts) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(framebufferStencilSampleCounts)
            )
        );
    }
    test_field_framebufferStencilSampleCounts();
    fn test_field_framebufferNoAttachmentsSampleCounts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).framebufferNoAttachmentsSampleCounts) as usize
                    - ptr as usize
            },
            388usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(framebufferNoAttachmentsSampleCounts)
            )
        );
    }
    test_field_framebufferNoAttachmentsSampleCounts();
    fn test_field_maxColorAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxColorAttachments) as usize - ptr as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxColorAttachments)
            )
        );
    }
    test_field_maxColorAttachments();
    fn test_field_sampledImageColorSampleCounts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampledImageColorSampleCounts) as usize - ptr as usize
            },
            396usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(sampledImageColorSampleCounts)
            )
        );
    }
    test_field_sampledImageColorSampleCounts();
    fn test_field_sampledImageIntegerSampleCounts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampledImageIntegerSampleCounts) as usize - ptr as usize
            },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(sampledImageIntegerSampleCounts)
            )
        );
    }
    test_field_sampledImageIntegerSampleCounts();
    fn test_field_sampledImageDepthSampleCounts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampledImageDepthSampleCounts) as usize - ptr as usize
            },
            404usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(sampledImageDepthSampleCounts)
            )
        );
    }
    test_field_sampledImageDepthSampleCounts();
    fn test_field_sampledImageStencilSampleCounts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampledImageStencilSampleCounts) as usize - ptr as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(sampledImageStencilSampleCounts)
            )
        );
    }
    test_field_sampledImageStencilSampleCounts();
    fn test_field_storageImageSampleCounts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storageImageSampleCounts) as usize - ptr as usize
            },
            412usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(storageImageSampleCounts)
            )
        );
    }
    test_field_storageImageSampleCounts();
    fn test_field_maxSampleMaskWords() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSampleMaskWords) as usize - ptr as usize
            },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxSampleMaskWords)
            )
        );
    }
    test_field_maxSampleMaskWords();
    fn test_field_timestampComputeAndGraphics() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestampComputeAndGraphics) as usize - ptr as usize
            },
            420usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(timestampComputeAndGraphics)
            )
        );
    }
    test_field_timestampComputeAndGraphics();
    fn test_field_timestampPeriod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestampPeriod) as usize - ptr as usize
            },
            424usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(timestampPeriod)
            )
        );
    }
    test_field_timestampPeriod();
    fn test_field_maxClipDistances() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxClipDistances) as usize - ptr as usize
            },
            428usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxClipDistances)
            )
        );
    }
    test_field_maxClipDistances();
    fn test_field_maxCullDistances() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxCullDistances) as usize - ptr as usize
            },
            432usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxCullDistances)
            )
        );
    }
    test_field_maxCullDistances();
    fn test_field_maxCombinedClipAndCullDistances() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxCombinedClipAndCullDistances) as usize - ptr as usize
            },
            436usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(maxCombinedClipAndCullDistances)
            )
        );
    }
    test_field_maxCombinedClipAndCullDistances();
    fn test_field_discreteQueuePriorities() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).discreteQueuePriorities) as usize - ptr as usize
            },
            440usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(discreteQueuePriorities)
            )
        );
    }
    test_field_discreteQueuePriorities();
    fn test_field_pointSizeRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pointSizeRange) as usize - ptr as usize
            },
            444usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(pointSizeRange)
            )
        );
    }
    test_field_pointSizeRange();
    fn test_field_lineWidthRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lineWidthRange) as usize - ptr as usize
            },
            452usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(lineWidthRange)
            )
        );
    }
    test_field_lineWidthRange();
    fn test_field_pointSizeGranularity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pointSizeGranularity) as usize - ptr as usize
            },
            460usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(pointSizeGranularity)
            )
        );
    }
    test_field_pointSizeGranularity();
    fn test_field_lineWidthGranularity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lineWidthGranularity) as usize - ptr as usize
            },
            464usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(lineWidthGranularity)
            )
        );
    }
    test_field_lineWidthGranularity();
    fn test_field_strictLines() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).strictLines) as usize - ptr as usize
            },
            468usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(strictLines)
            )
        );
    }
    test_field_strictLines();
    fn test_field_standardSampleLocations() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).standardSampleLocations) as usize - ptr as usize
            },
            472usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(standardSampleLocations)
            )
        );
    }
    test_field_standardSampleLocations();
    fn test_field_optimalBufferCopyOffsetAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).optimalBufferCopyOffsetAlignment) as usize
                    - ptr as usize
            },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(optimalBufferCopyOffsetAlignment)
            )
        );
    }
    test_field_optimalBufferCopyOffsetAlignment();
    fn test_field_optimalBufferCopyRowPitchAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).optimalBufferCopyRowPitchAlignment) as usize
                    - ptr as usize
            },
            488usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(optimalBufferCopyRowPitchAlignment)
            )
        );
    }
    test_field_optimalBufferCopyRowPitchAlignment();
    fn test_field_nonCoherentAtomSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceLimits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nonCoherentAtomSize) as usize - ptr as usize
            },
            496usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLimits),
                "::",
                stringify!(nonCoherentAtomSize)
            )
        );
    }
    test_field_nonCoherentAtomSize();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkPhysicalDeviceMemoryProperties {
    pub memoryTypeCount: u32,
    pub memoryTypes: [VkMemoryType; 32usize],
    pub memoryHeapCount: u32,
    pub memoryHeaps: [VkMemoryHeap; 16usize],
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMemoryProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMemoryProperties>(),
        520usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceMemoryProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMemoryProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMemoryProperties)
        )
    );
    fn test_field_memoryTypeCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceMemoryProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryTypeCount) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryProperties),
                "::",
                stringify!(memoryTypeCount)
            )
        );
    }
    test_field_memoryTypeCount();
    fn test_field_memoryTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceMemoryProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryTypes) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryProperties),
                "::",
                stringify!(memoryTypes)
            )
        );
    }
    test_field_memoryTypes();
    fn test_field_memoryHeapCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceMemoryProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryHeapCount) as usize - ptr as usize
            },
            260usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryProperties),
                "::",
                stringify!(memoryHeapCount)
            )
        );
    }
    test_field_memoryHeapCount();
    fn test_field_memoryHeaps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceMemoryProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryHeaps) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryProperties),
                "::",
                stringify!(memoryHeaps)
            )
        );
    }
    test_field_memoryHeaps();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkPhysicalDeviceSparseProperties {
    pub residencyStandard2DBlockShape: VkBool32,
    pub residencyStandard2DMultisampleBlockShape: VkBool32,
    pub residencyStandard3DBlockShape: VkBool32,
    pub residencyAlignedMipSize: VkBool32,
    pub residencyNonResidentStrict: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSparseProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSparseProperties>(),
        20usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceSparseProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSparseProperties>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSparseProperties)
        )
    );
    fn test_field_residencyStandard2DBlockShape() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceSparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).residencyStandard2DBlockShape) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSparseProperties),
                "::",
                stringify!(residencyStandard2DBlockShape)
            )
        );
    }
    test_field_residencyStandard2DBlockShape();
    fn test_field_residencyStandard2DMultisampleBlockShape() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceSparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).residencyStandard2DMultisampleBlockShape) as usize
                    - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSparseProperties),
                "::",
                stringify!(residencyStandard2DMultisampleBlockShape)
            )
        );
    }
    test_field_residencyStandard2DMultisampleBlockShape();
    fn test_field_residencyStandard3DBlockShape() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceSparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).residencyStandard3DBlockShape) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSparseProperties),
                "::",
                stringify!(residencyStandard3DBlockShape)
            )
        );
    }
    test_field_residencyStandard3DBlockShape();
    fn test_field_residencyAlignedMipSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceSparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).residencyAlignedMipSize) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSparseProperties),
                "::",
                stringify!(residencyAlignedMipSize)
            )
        );
    }
    test_field_residencyAlignedMipSize();
    fn test_field_residencyNonResidentStrict() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceSparseProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).residencyNonResidentStrict) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSparseProperties),
                "::",
                stringify!(residencyNonResidentStrict)
            )
        );
    }
    test_field_residencyNonResidentStrict();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceProperties {
    pub apiVersion: u32,
    pub driverVersion: u32,
    pub vendorID: u32,
    pub deviceID: u32,
    pub deviceType: VkPhysicalDeviceType,
    pub deviceName: [::std::os::raw::c_char; 256usize],
    pub pipelineCacheUUID: [u8; 16usize],
    pub limits: VkPhysicalDeviceLimits,
    pub sparseProperties: VkPhysicalDeviceSparseProperties,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceProperties>(),
        824usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceProperties))
    );
    fn test_field_apiVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).apiVersion) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProperties),
                "::",
                stringify!(apiVersion)
            )
        );
    }
    test_field_apiVersion();
    fn test_field_driverVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).driverVersion) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProperties),
                "::",
                stringify!(driverVersion)
            )
        );
    }
    test_field_driverVersion();
    fn test_field_vendorID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vendorID) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProperties),
                "::",
                stringify!(vendorID)
            )
        );
    }
    test_field_vendorID();
    fn test_field_deviceID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceID) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProperties),
                "::",
                stringify!(deviceID)
            )
        );
    }
    test_field_deviceID();
    fn test_field_deviceType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProperties),
                "::",
                stringify!(deviceType)
            )
        );
    }
    test_field_deviceType();
    fn test_field_deviceName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceName) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProperties),
                "::",
                stringify!(deviceName)
            )
        );
    }
    test_field_deviceName();
    fn test_field_pipelineCacheUUID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineCacheUUID) as usize - ptr as usize
            },
            276usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProperties),
                "::",
                stringify!(pipelineCacheUUID)
            )
        );
    }
    test_field_pipelineCacheUUID();
    fn test_field_limits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).limits) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProperties),
                "::",
                stringify!(limits)
            )
        );
    }
    test_field_limits();
    fn test_field_sparseProperties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseProperties) as usize - ptr as usize
            },
            800usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProperties),
                "::",
                stringify!(sparseProperties)
            )
        );
    }
    test_field_sparseProperties();
}
impl Default for VkPhysicalDeviceProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkQueueFamilyProperties {
    pub queueFlags: VkQueueFlags,
    pub queueCount: u32,
    pub timestampValidBits: u32,
    pub minImageTransferGranularity: VkExtent3D,
}
#[test]
fn bindgen_test_layout_VkQueueFamilyProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkQueueFamilyProperties>(),
        24usize,
        concat!("Size of: ", stringify!(VkQueueFamilyProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkQueueFamilyProperties>(),
        4usize,
        concat!("Alignment of ", stringify!(VkQueueFamilyProperties))
    );
    fn test_field_queueFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkQueueFamilyProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queueFlags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyProperties),
                "::",
                stringify!(queueFlags)
            )
        );
    }
    test_field_queueFlags();
    fn test_field_queueCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkQueueFamilyProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queueCount) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyProperties),
                "::",
                stringify!(queueCount)
            )
        );
    }
    test_field_queueCount();
    fn test_field_timestampValidBits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkQueueFamilyProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestampValidBits) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyProperties),
                "::",
                stringify!(timestampValidBits)
            )
        );
    }
    test_field_timestampValidBits();
    fn test_field_minImageTransferGranularity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkQueueFamilyProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minImageTransferGranularity) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyProperties),
                "::",
                stringify!(minImageTransferGranularity)
            )
        );
    }
    test_field_minImageTransferGranularity();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceQueueCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDeviceQueueCreateFlags,
    pub queueFamilyIndex: u32,
    pub queueCount: u32,
    pub pQueuePriorities: *const f32,
}
#[test]
fn bindgen_test_layout_VkDeviceQueueCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceQueueCreateInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkDeviceQueueCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceQueueCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceQueueCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceQueueCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceQueueCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceQueueCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceQueueCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceQueueCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceQueueCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_queueFamilyIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceQueueCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queueFamilyIndex) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceQueueCreateInfo),
                "::",
                stringify!(queueFamilyIndex)
            )
        );
    }
    test_field_queueFamilyIndex();
    fn test_field_queueCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceQueueCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queueCount) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceQueueCreateInfo),
                "::",
                stringify!(queueCount)
            )
        );
    }
    test_field_queueCount();
    fn test_field_pQueuePriorities() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceQueueCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pQueuePriorities) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceQueueCreateInfo),
                "::",
                stringify!(pQueuePriorities)
            )
        );
    }
    test_field_pQueuePriorities();
}
impl Default for VkDeviceQueueCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDeviceCreateFlags,
    pub queueCreateInfoCount: u32,
    pub pQueueCreateInfos: *const VkDeviceQueueCreateInfo,
    pub enabledLayerCount: u32,
    pub ppEnabledLayerNames: *const *const ::std::os::raw::c_char,
    pub enabledExtensionCount: u32,
    pub ppEnabledExtensionNames: *const *const ::std::os::raw::c_char,
    pub pEnabledFeatures: *const VkPhysicalDeviceFeatures,
}
#[test]
fn bindgen_test_layout_VkDeviceCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceCreateInfo>(),
        72usize,
        concat!("Size of: ", stringify!(VkDeviceCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_queueCreateInfoCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queueCreateInfoCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceCreateInfo),
                "::",
                stringify!(queueCreateInfoCount)
            )
        );
    }
    test_field_queueCreateInfoCount();
    fn test_field_pQueueCreateInfos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pQueueCreateInfos) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceCreateInfo),
                "::",
                stringify!(pQueueCreateInfos)
            )
        );
    }
    test_field_pQueueCreateInfos();
    fn test_field_enabledLayerCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enabledLayerCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceCreateInfo),
                "::",
                stringify!(enabledLayerCount)
            )
        );
    }
    test_field_enabledLayerCount();
    fn test_field_ppEnabledLayerNames() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ppEnabledLayerNames) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceCreateInfo),
                "::",
                stringify!(ppEnabledLayerNames)
            )
        );
    }
    test_field_ppEnabledLayerNames();
    fn test_field_enabledExtensionCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enabledExtensionCount) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceCreateInfo),
                "::",
                stringify!(enabledExtensionCount)
            )
        );
    }
    test_field_enabledExtensionCount();
    fn test_field_ppEnabledExtensionNames() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ppEnabledExtensionNames) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceCreateInfo),
                "::",
                stringify!(ppEnabledExtensionNames)
            )
        );
    }
    test_field_ppEnabledExtensionNames();
    fn test_field_pEnabledFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pEnabledFeatures) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceCreateInfo),
                "::",
                stringify!(pEnabledFeatures)
            )
        );
    }
    test_field_pEnabledFeatures();
}
impl Default for VkDeviceCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExtensionProperties {
    pub extensionName: [::std::os::raw::c_char; 256usize],
    pub specVersion: u32,
}
#[test]
fn bindgen_test_layout_VkExtensionProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkExtensionProperties>(),
        260usize,
        concat!("Size of: ", stringify!(VkExtensionProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExtensionProperties>(),
        4usize,
        concat!("Alignment of ", stringify!(VkExtensionProperties))
    );
    fn test_field_extensionName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExtensionProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extensionName) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExtensionProperties),
                "::",
                stringify!(extensionName)
            )
        );
    }
    test_field_extensionName();
    fn test_field_specVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExtensionProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).specVersion) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExtensionProperties),
                "::",
                stringify!(specVersion)
            )
        );
    }
    test_field_specVersion();
}
impl Default for VkExtensionProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkLayerProperties {
    pub layerName: [::std::os::raw::c_char; 256usize],
    pub specVersion: u32,
    pub implementationVersion: u32,
    pub description: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_VkLayerProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkLayerProperties>(),
        520usize,
        concat!("Size of: ", stringify!(VkLayerProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkLayerProperties>(),
        4usize,
        concat!("Alignment of ", stringify!(VkLayerProperties))
    );
    fn test_field_layerName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkLayerProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layerName) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkLayerProperties),
                "::",
                stringify!(layerName)
            )
        );
    }
    test_field_layerName();
    fn test_field_specVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkLayerProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).specVersion) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(VkLayerProperties),
                "::",
                stringify!(specVersion)
            )
        );
    }
    test_field_specVersion();
    fn test_field_implementationVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkLayerProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).implementationVersion) as usize - ptr as usize
            },
            260usize,
            concat!(
                "Offset of field: ",
                stringify!(VkLayerProperties),
                "::",
                stringify!(implementationVersion)
            )
        );
    }
    test_field_implementationVersion();
    fn test_field_description() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkLayerProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(VkLayerProperties),
                "::",
                stringify!(description)
            )
        );
    }
    test_field_description();
}
impl Default for VkLayerProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubmitInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: u32,
    pub pWaitSemaphores: *const VkSemaphore,
    pub pWaitDstStageMask: *const VkPipelineStageFlags,
    pub commandBufferCount: u32,
    pub pCommandBuffers: *const VkCommandBuffer,
    pub signalSemaphoreCount: u32,
    pub pSignalSemaphores: *const VkSemaphore,
}
#[test]
fn bindgen_test_layout_VkSubmitInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSubmitInfo>(),
        72usize,
        concat!("Size of: ", stringify!(VkSubmitInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubmitInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubmitInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_waitSemaphoreCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).waitSemaphoreCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo),
                "::",
                stringify!(waitSemaphoreCount)
            )
        );
    }
    test_field_waitSemaphoreCount();
    fn test_field_pWaitSemaphores() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pWaitSemaphores) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo),
                "::",
                stringify!(pWaitSemaphores)
            )
        );
    }
    test_field_pWaitSemaphores();
    fn test_field_pWaitDstStageMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pWaitDstStageMask) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo),
                "::",
                stringify!(pWaitDstStageMask)
            )
        );
    }
    test_field_pWaitDstStageMask();
    fn test_field_commandBufferCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).commandBufferCount) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo),
                "::",
                stringify!(commandBufferCount)
            )
        );
    }
    test_field_commandBufferCount();
    fn test_field_pCommandBuffers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCommandBuffers) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo),
                "::",
                stringify!(pCommandBuffers)
            )
        );
    }
    test_field_pCommandBuffers();
    fn test_field_signalSemaphoreCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signalSemaphoreCount) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo),
                "::",
                stringify!(signalSemaphoreCount)
            )
        );
    }
    test_field_signalSemaphoreCount();
    fn test_field_pSignalSemaphores() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSignalSemaphores) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo),
                "::",
                stringify!(pSignalSemaphores)
            )
        );
    }
    test_field_pSignalSemaphores();
}
impl Default for VkSubmitInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMappedMemoryRange {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub memory: VkDeviceMemory,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkMappedMemoryRange() {
    assert_eq!(
        ::std::mem::size_of::<VkMappedMemoryRange>(),
        40usize,
        concat!("Size of: ", stringify!(VkMappedMemoryRange))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMappedMemoryRange>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMappedMemoryRange))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMappedMemoryRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMappedMemoryRange),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMappedMemoryRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMappedMemoryRange),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_memory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMappedMemoryRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMappedMemoryRange),
                "::",
                stringify!(memory)
            )
        );
    }
    test_field_memory();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMappedMemoryRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMappedMemoryRange),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMappedMemoryRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMappedMemoryRange),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
impl Default for VkMappedMemoryRange {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub allocationSize: VkDeviceSize,
    pub memoryTypeIndex: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryAllocateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryAllocateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkMemoryAllocateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryAllocateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryAllocateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryAllocateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryAllocateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_allocationSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allocationSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryAllocateInfo),
                "::",
                stringify!(allocationSize)
            )
        );
    }
    test_field_allocationSize();
    fn test_field_memoryTypeIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryTypeIndex) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryAllocateInfo),
                "::",
                stringify!(memoryTypeIndex)
            )
        );
    }
    test_field_memoryTypeIndex();
}
impl Default for VkMemoryAllocateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkMemoryRequirements {
    pub size: VkDeviceSize,
    pub alignment: VkDeviceSize,
    pub memoryTypeBits: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryRequirements() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryRequirements>(),
        24usize,
        concat!("Size of: ", stringify!(VkMemoryRequirements))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryRequirements>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryRequirements))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryRequirements),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_alignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryRequirements),
                "::",
                stringify!(alignment)
            )
        );
    }
    test_field_alignment();
    fn test_field_memoryTypeBits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryTypeBits) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryRequirements),
                "::",
                stringify!(memoryTypeBits)
            )
        );
    }
    test_field_memoryTypeBits();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSparseMemoryBind {
    pub resourceOffset: VkDeviceSize,
    pub size: VkDeviceSize,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub flags: VkSparseMemoryBindFlags,
}
#[test]
fn bindgen_test_layout_VkSparseMemoryBind() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseMemoryBind>(),
        40usize,
        concat!("Size of: ", stringify!(VkSparseMemoryBind))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseMemoryBind>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSparseMemoryBind))
    );
    fn test_field_resourceOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseMemoryBind>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resourceOffset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseMemoryBind),
                "::",
                stringify!(resourceOffset)
            )
        );
    }
    test_field_resourceOffset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseMemoryBind>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseMemoryBind),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_memory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseMemoryBind>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseMemoryBind),
                "::",
                stringify!(memory)
            )
        );
    }
    test_field_memory();
    fn test_field_memoryOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseMemoryBind>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryOffset) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseMemoryBind),
                "::",
                stringify!(memoryOffset)
            )
        );
    }
    test_field_memoryOffset();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseMemoryBind>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseMemoryBind),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for VkSparseMemoryBind {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSparseBufferMemoryBindInfo {
    pub buffer: VkBuffer,
    pub bindCount: u32,
    pub pBinds: *const VkSparseMemoryBind,
}
#[test]
fn bindgen_test_layout_VkSparseBufferMemoryBindInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseBufferMemoryBindInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkSparseBufferMemoryBindInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseBufferMemoryBindInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSparseBufferMemoryBindInfo))
    );
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseBufferMemoryBindInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseBufferMemoryBindInfo),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_bindCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseBufferMemoryBindInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bindCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseBufferMemoryBindInfo),
                "::",
                stringify!(bindCount)
            )
        );
    }
    test_field_bindCount();
    fn test_field_pBinds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseBufferMemoryBindInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pBinds) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseBufferMemoryBindInfo),
                "::",
                stringify!(pBinds)
            )
        );
    }
    test_field_pBinds();
}
impl Default for VkSparseBufferMemoryBindInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSparseImageOpaqueMemoryBindInfo {
    pub image: VkImage,
    pub bindCount: u32,
    pub pBinds: *const VkSparseMemoryBind,
}
#[test]
fn bindgen_test_layout_VkSparseImageOpaqueMemoryBindInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseImageOpaqueMemoryBindInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkSparseImageOpaqueMemoryBindInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseImageOpaqueMemoryBindInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSparseImageOpaqueMemoryBindInfo)
        )
    );
    fn test_field_image() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageOpaqueMemoryBindInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageOpaqueMemoryBindInfo),
                "::",
                stringify!(image)
            )
        );
    }
    test_field_image();
    fn test_field_bindCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageOpaqueMemoryBindInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bindCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageOpaqueMemoryBindInfo),
                "::",
                stringify!(bindCount)
            )
        );
    }
    test_field_bindCount();
    fn test_field_pBinds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageOpaqueMemoryBindInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pBinds) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageOpaqueMemoryBindInfo),
                "::",
                stringify!(pBinds)
            )
        );
    }
    test_field_pBinds();
}
impl Default for VkSparseImageOpaqueMemoryBindInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkImageSubresource {
    pub aspectMask: VkImageAspectFlags,
    pub mipLevel: u32,
    pub arrayLayer: u32,
}
#[test]
fn bindgen_test_layout_VkImageSubresource() {
    assert_eq!(
        ::std::mem::size_of::<VkImageSubresource>(),
        12usize,
        concat!("Size of: ", stringify!(VkImageSubresource))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageSubresource>(),
        4usize,
        concat!("Alignment of ", stringify!(VkImageSubresource))
    );
    fn test_field_aspectMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSubresource>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aspectMask) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSubresource),
                "::",
                stringify!(aspectMask)
            )
        );
    }
    test_field_aspectMask();
    fn test_field_mipLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSubresource>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipLevel) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSubresource),
                "::",
                stringify!(mipLevel)
            )
        );
    }
    test_field_mipLevel();
    fn test_field_arrayLayer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSubresource>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arrayLayer) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSubresource),
                "::",
                stringify!(arrayLayer)
            )
        );
    }
    test_field_arrayLayer();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSparseImageMemoryBind {
    pub subresource: VkImageSubresource,
    pub offset: VkOffset3D,
    pub extent: VkExtent3D,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub flags: VkSparseMemoryBindFlags,
}
#[test]
fn bindgen_test_layout_VkSparseImageMemoryBind() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseImageMemoryBind>(),
        64usize,
        concat!("Size of: ", stringify!(VkSparseImageMemoryBind))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseImageMemoryBind>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSparseImageMemoryBind))
    );
    fn test_field_subresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryBind>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subresource) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryBind),
                "::",
                stringify!(subresource)
            )
        );
    }
    test_field_subresource();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryBind>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryBind),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryBind>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryBind),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
    fn test_field_memory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryBind>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryBind),
                "::",
                stringify!(memory)
            )
        );
    }
    test_field_memory();
    fn test_field_memoryOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryBind>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryOffset) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryBind),
                "::",
                stringify!(memoryOffset)
            )
        );
    }
    test_field_memoryOffset();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryBind>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryBind),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for VkSparseImageMemoryBind {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSparseImageMemoryBindInfo {
    pub image: VkImage,
    pub bindCount: u32,
    pub pBinds: *const VkSparseImageMemoryBind,
}
#[test]
fn bindgen_test_layout_VkSparseImageMemoryBindInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseImageMemoryBindInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkSparseImageMemoryBindInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseImageMemoryBindInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSparseImageMemoryBindInfo))
    );
    fn test_field_image() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryBindInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryBindInfo),
                "::",
                stringify!(image)
            )
        );
    }
    test_field_image();
    fn test_field_bindCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryBindInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bindCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryBindInfo),
                "::",
                stringify!(bindCount)
            )
        );
    }
    test_field_bindCount();
    fn test_field_pBinds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryBindInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pBinds) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryBindInfo),
                "::",
                stringify!(pBinds)
            )
        );
    }
    test_field_pBinds();
}
impl Default for VkSparseImageMemoryBindInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindSparseInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: u32,
    pub pWaitSemaphores: *const VkSemaphore,
    pub bufferBindCount: u32,
    pub pBufferBinds: *const VkSparseBufferMemoryBindInfo,
    pub imageOpaqueBindCount: u32,
    pub pImageOpaqueBinds: *const VkSparseImageOpaqueMemoryBindInfo,
    pub imageBindCount: u32,
    pub pImageBinds: *const VkSparseImageMemoryBindInfo,
    pub signalSemaphoreCount: u32,
    pub pSignalSemaphores: *const VkSemaphore,
}
#[test]
fn bindgen_test_layout_VkBindSparseInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBindSparseInfo>(),
        96usize,
        concat!("Size of: ", stringify!(VkBindSparseInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindSparseInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBindSparseInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindSparseInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindSparseInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindSparseInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindSparseInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_waitSemaphoreCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindSparseInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).waitSemaphoreCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindSparseInfo),
                "::",
                stringify!(waitSemaphoreCount)
            )
        );
    }
    test_field_waitSemaphoreCount();
    fn test_field_pWaitSemaphores() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindSparseInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pWaitSemaphores) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindSparseInfo),
                "::",
                stringify!(pWaitSemaphores)
            )
        );
    }
    test_field_pWaitSemaphores();
    fn test_field_bufferBindCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindSparseInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferBindCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindSparseInfo),
                "::",
                stringify!(bufferBindCount)
            )
        );
    }
    test_field_bufferBindCount();
    fn test_field_pBufferBinds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindSparseInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pBufferBinds) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindSparseInfo),
                "::",
                stringify!(pBufferBinds)
            )
        );
    }
    test_field_pBufferBinds();
    fn test_field_imageOpaqueBindCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindSparseInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageOpaqueBindCount) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindSparseInfo),
                "::",
                stringify!(imageOpaqueBindCount)
            )
        );
    }
    test_field_imageOpaqueBindCount();
    fn test_field_pImageOpaqueBinds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindSparseInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pImageOpaqueBinds) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindSparseInfo),
                "::",
                stringify!(pImageOpaqueBinds)
            )
        );
    }
    test_field_pImageOpaqueBinds();
    fn test_field_imageBindCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindSparseInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageBindCount) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindSparseInfo),
                "::",
                stringify!(imageBindCount)
            )
        );
    }
    test_field_imageBindCount();
    fn test_field_pImageBinds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindSparseInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pImageBinds) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindSparseInfo),
                "::",
                stringify!(pImageBinds)
            )
        );
    }
    test_field_pImageBinds();
    fn test_field_signalSemaphoreCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindSparseInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signalSemaphoreCount) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindSparseInfo),
                "::",
                stringify!(signalSemaphoreCount)
            )
        );
    }
    test_field_signalSemaphoreCount();
    fn test_field_pSignalSemaphores() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindSparseInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSignalSemaphores) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindSparseInfo),
                "::",
                stringify!(pSignalSemaphores)
            )
        );
    }
    test_field_pSignalSemaphores();
}
impl Default for VkBindSparseInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkSparseImageFormatProperties {
    pub aspectMask: VkImageAspectFlags,
    pub imageGranularity: VkExtent3D,
    pub flags: VkSparseImageFormatFlags,
}
#[test]
fn bindgen_test_layout_VkSparseImageFormatProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseImageFormatProperties>(),
        20usize,
        concat!("Size of: ", stringify!(VkSparseImageFormatProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseImageFormatProperties>(),
        4usize,
        concat!("Alignment of ", stringify!(VkSparseImageFormatProperties))
    );
    fn test_field_aspectMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageFormatProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aspectMask) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageFormatProperties),
                "::",
                stringify!(aspectMask)
            )
        );
    }
    test_field_aspectMask();
    fn test_field_imageGranularity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageFormatProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageGranularity) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageFormatProperties),
                "::",
                stringify!(imageGranularity)
            )
        );
    }
    test_field_imageGranularity();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageFormatProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageFormatProperties),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkSparseImageMemoryRequirements {
    pub formatProperties: VkSparseImageFormatProperties,
    pub imageMipTailFirstLod: u32,
    pub imageMipTailSize: VkDeviceSize,
    pub imageMipTailOffset: VkDeviceSize,
    pub imageMipTailStride: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkSparseImageMemoryRequirements() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseImageMemoryRequirements>(),
        48usize,
        concat!("Size of: ", stringify!(VkSparseImageMemoryRequirements))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseImageMemoryRequirements>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSparseImageMemoryRequirements))
    );
    fn test_field_formatProperties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).formatProperties) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryRequirements),
                "::",
                stringify!(formatProperties)
            )
        );
    }
    test_field_formatProperties();
    fn test_field_imageMipTailFirstLod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageMipTailFirstLod) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryRequirements),
                "::",
                stringify!(imageMipTailFirstLod)
            )
        );
    }
    test_field_imageMipTailFirstLod();
    fn test_field_imageMipTailSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageMipTailSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryRequirements),
                "::",
                stringify!(imageMipTailSize)
            )
        );
    }
    test_field_imageMipTailSize();
    fn test_field_imageMipTailOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageMipTailOffset) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryRequirements),
                "::",
                stringify!(imageMipTailOffset)
            )
        );
    }
    test_field_imageMipTailOffset();
    fn test_field_imageMipTailStride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageMipTailStride) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryRequirements),
                "::",
                stringify!(imageMipTailStride)
            )
        );
    }
    test_field_imageMipTailStride();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFenceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkFenceCreateFlags,
}
#[test]
fn bindgen_test_layout_VkFenceCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkFenceCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkFenceCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkFenceCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkFenceCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFenceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFenceCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFenceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFenceCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFenceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFenceCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for VkFenceCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSemaphoreCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSemaphoreCreateFlags,
}
#[test]
fn bindgen_test_layout_VkSemaphoreCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSemaphoreCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkSemaphoreCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSemaphoreCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSemaphoreCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for VkSemaphoreCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkEventCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkEventCreateFlags,
}
#[test]
fn bindgen_test_layout_VkEventCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkEventCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkEventCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkEventCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkEventCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkEventCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkEventCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkEventCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkEventCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkEventCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkEventCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for VkEventCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueryPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkQueryPoolCreateFlags,
    pub queryType: VkQueryType,
    pub queryCount: u32,
    pub pipelineStatistics: VkQueryPipelineStatisticFlags,
}
#[test]
fn bindgen_test_layout_VkQueryPoolCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkQueryPoolCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkQueryPoolCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkQueryPoolCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkQueryPoolCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkQueryPoolCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueryPoolCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkQueryPoolCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueryPoolCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkQueryPoolCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueryPoolCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_queryType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkQueryPoolCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queryType) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueryPoolCreateInfo),
                "::",
                stringify!(queryType)
            )
        );
    }
    test_field_queryType();
    fn test_field_queryCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkQueryPoolCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queryCount) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueryPoolCreateInfo),
                "::",
                stringify!(queryCount)
            )
        );
    }
    test_field_queryCount();
    fn test_field_pipelineStatistics() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkQueryPoolCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineStatistics) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueryPoolCreateInfo),
                "::",
                stringify!(pipelineStatistics)
            )
        );
    }
    test_field_pipelineStatistics();
}
impl Default for VkQueryPoolCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkBufferCreateFlags,
    pub size: VkDeviceSize,
    pub usage: VkBufferUsageFlags,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: *const u32,
}
#[test]
fn bindgen_test_layout_VkBufferCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferCreateInfo>(),
        56usize,
        concat!("Size of: ", stringify!(VkBufferCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCreateInfo),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_usage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCreateInfo),
                "::",
                stringify!(usage)
            )
        );
    }
    test_field_usage();
    fn test_field_sharingMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharingMode) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCreateInfo),
                "::",
                stringify!(sharingMode)
            )
        );
    }
    test_field_sharingMode();
    fn test_field_queueFamilyIndexCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queueFamilyIndexCount) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCreateInfo),
                "::",
                stringify!(queueFamilyIndexCount)
            )
        );
    }
    test_field_queueFamilyIndexCount();
    fn test_field_pQueueFamilyIndices() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pQueueFamilyIndices) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCreateInfo),
                "::",
                stringify!(pQueueFamilyIndices)
            )
        );
    }
    test_field_pQueueFamilyIndices();
}
impl Default for VkBufferCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferViewCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkBufferViewCreateFlags,
    pub buffer: VkBuffer,
    pub format: VkFormat,
    pub offset: VkDeviceSize,
    pub range: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBufferViewCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferViewCreateInfo>(),
        56usize,
        concat!("Size of: ", stringify!(VkBufferViewCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferViewCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferViewCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferViewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferViewCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferViewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferViewCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferViewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferViewCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferViewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferViewCreateInfo),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferViewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferViewCreateInfo),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferViewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferViewCreateInfo),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_range() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferViewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferViewCreateInfo),
                "::",
                stringify!(range)
            )
        );
    }
    test_field_range();
}
impl Default for VkBufferViewCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkImageCreateFlags,
    pub imageType: VkImageType,
    pub format: VkFormat,
    pub extent: VkExtent3D,
    pub mipLevels: u32,
    pub arrayLayers: u32,
    pub samples: VkSampleCountFlagBits,
    pub tiling: VkImageTiling,
    pub usage: VkImageUsageFlags,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: *const u32,
    pub initialLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkImageCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkImageCreateInfo>(),
        88usize,
        concat!("Size of: ", stringify!(VkImageCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_imageType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageType) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCreateInfo),
                "::",
                stringify!(imageType)
            )
        );
    }
    test_field_imageType();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCreateInfo),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCreateInfo),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
    fn test_field_mipLevels() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipLevels) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCreateInfo),
                "::",
                stringify!(mipLevels)
            )
        );
    }
    test_field_mipLevels();
    fn test_field_arrayLayers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arrayLayers) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCreateInfo),
                "::",
                stringify!(arrayLayers)
            )
        );
    }
    test_field_arrayLayers();
    fn test_field_samples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samples) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCreateInfo),
                "::",
                stringify!(samples)
            )
        );
    }
    test_field_samples();
    fn test_field_tiling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tiling) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCreateInfo),
                "::",
                stringify!(tiling)
            )
        );
    }
    test_field_tiling();
    fn test_field_usage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCreateInfo),
                "::",
                stringify!(usage)
            )
        );
    }
    test_field_usage();
    fn test_field_sharingMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharingMode) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCreateInfo),
                "::",
                stringify!(sharingMode)
            )
        );
    }
    test_field_sharingMode();
    fn test_field_queueFamilyIndexCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queueFamilyIndexCount) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCreateInfo),
                "::",
                stringify!(queueFamilyIndexCount)
            )
        );
    }
    test_field_queueFamilyIndexCount();
    fn test_field_pQueueFamilyIndices() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pQueueFamilyIndices) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCreateInfo),
                "::",
                stringify!(pQueueFamilyIndices)
            )
        );
    }
    test_field_pQueueFamilyIndices();
    fn test_field_initialLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).initialLayout) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCreateInfo),
                "::",
                stringify!(initialLayout)
            )
        );
    }
    test_field_initialLayout();
}
impl Default for VkImageCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkSubresourceLayout {
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
    pub rowPitch: VkDeviceSize,
    pub arrayPitch: VkDeviceSize,
    pub depthPitch: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkSubresourceLayout() {
    assert_eq!(
        ::std::mem::size_of::<VkSubresourceLayout>(),
        40usize,
        concat!("Size of: ", stringify!(VkSubresourceLayout))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubresourceLayout>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubresourceLayout))
    );
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubresourceLayout>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubresourceLayout),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubresourceLayout>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubresourceLayout),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_rowPitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubresourceLayout>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rowPitch) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubresourceLayout),
                "::",
                stringify!(rowPitch)
            )
        );
    }
    test_field_rowPitch();
    fn test_field_arrayPitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubresourceLayout>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arrayPitch) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubresourceLayout),
                "::",
                stringify!(arrayPitch)
            )
        );
    }
    test_field_arrayPitch();
    fn test_field_depthPitch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubresourceLayout>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthPitch) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubresourceLayout),
                "::",
                stringify!(depthPitch)
            )
        );
    }
    test_field_depthPitch();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkComponentMapping {
    pub r: VkComponentSwizzle,
    pub g: VkComponentSwizzle,
    pub b: VkComponentSwizzle,
    pub a: VkComponentSwizzle,
}
#[test]
fn bindgen_test_layout_VkComponentMapping() {
    assert_eq!(
        ::std::mem::size_of::<VkComponentMapping>(),
        16usize,
        concat!("Size of: ", stringify!(VkComponentMapping))
    );
    assert_eq!(
        ::std::mem::align_of::<VkComponentMapping>(),
        4usize,
        concat!("Alignment of ", stringify!(VkComponentMapping))
    );
    fn test_field_r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkComponentMapping>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkComponentMapping),
                "::",
                stringify!(r)
            )
        );
    }
    test_field_r();
    fn test_field_g() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkComponentMapping>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).g) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkComponentMapping),
                "::",
                stringify!(g)
            )
        );
    }
    test_field_g();
    fn test_field_b() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkComponentMapping>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkComponentMapping),
                "::",
                stringify!(b)
            )
        );
    }
    test_field_b();
    fn test_field_a() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkComponentMapping>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkComponentMapping),
                "::",
                stringify!(a)
            )
        );
    }
    test_field_a();
}
impl Default for VkComponentMapping {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageViewCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkImageViewCreateFlags,
    pub image: VkImage,
    pub viewType: VkImageViewType,
    pub format: VkFormat,
    pub components: VkComponentMapping,
    pub subresourceRange: VkImageSubresourceRange,
}
#[test]
fn bindgen_test_layout_VkImageViewCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkImageViewCreateInfo>(),
        80usize,
        concat!("Size of: ", stringify!(VkImageViewCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageViewCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageViewCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_image() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewCreateInfo),
                "::",
                stringify!(image)
            )
        );
    }
    test_field_image();
    fn test_field_viewType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewType) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewCreateInfo),
                "::",
                stringify!(viewType)
            )
        );
    }
    test_field_viewType();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewCreateInfo),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_components() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).components) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewCreateInfo),
                "::",
                stringify!(components)
            )
        );
    }
    test_field_components();
    fn test_field_subresourceRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subresourceRange) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewCreateInfo),
                "::",
                stringify!(subresourceRange)
            )
        );
    }
    test_field_subresourceRange();
}
impl Default for VkImageViewCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkShaderModuleCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkShaderModuleCreateFlags,
    pub codeSize: usize,
    pub pCode: *const u32,
}
#[test]
fn bindgen_test_layout_VkShaderModuleCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkShaderModuleCreateInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkShaderModuleCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkShaderModuleCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkShaderModuleCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderModuleCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderModuleCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderModuleCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderModuleCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderModuleCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderModuleCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_codeSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderModuleCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).codeSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderModuleCreateInfo),
                "::",
                stringify!(codeSize)
            )
        );
    }
    test_field_codeSize();
    fn test_field_pCode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderModuleCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCode) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderModuleCreateInfo),
                "::",
                stringify!(pCode)
            )
        );
    }
    test_field_pCode();
}
impl Default for VkShaderModuleCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCacheCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCacheCreateFlags,
    pub initialDataSize: usize,
    pub pInitialData: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkPipelineCacheCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineCacheCreateInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkPipelineCacheCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineCacheCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPipelineCacheCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineCacheCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCacheCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineCacheCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCacheCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineCacheCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCacheCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_initialDataSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineCacheCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).initialDataSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCacheCreateInfo),
                "::",
                stringify!(initialDataSize)
            )
        );
    }
    test_field_initialDataSize();
    fn test_field_pInitialData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineCacheCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pInitialData) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCacheCreateInfo),
                "::",
                stringify!(pInitialData)
            )
        );
    }
    test_field_pInitialData();
}
impl Default for VkPipelineCacheCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkSpecializationMapEntry {
    pub constantID: u32,
    pub offset: u32,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_VkSpecializationMapEntry() {
    assert_eq!(
        ::std::mem::size_of::<VkSpecializationMapEntry>(),
        16usize,
        concat!("Size of: ", stringify!(VkSpecializationMapEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSpecializationMapEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSpecializationMapEntry))
    );
    fn test_field_constantID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSpecializationMapEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).constantID) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSpecializationMapEntry),
                "::",
                stringify!(constantID)
            )
        );
    }
    test_field_constantID();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSpecializationMapEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSpecializationMapEntry),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSpecializationMapEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSpecializationMapEntry),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSpecializationInfo {
    pub mapEntryCount: u32,
    pub pMapEntries: *const VkSpecializationMapEntry,
    pub dataSize: usize,
    pub pData: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkSpecializationInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSpecializationInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkSpecializationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSpecializationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSpecializationInfo))
    );
    fn test_field_mapEntryCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSpecializationInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mapEntryCount) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSpecializationInfo),
                "::",
                stringify!(mapEntryCount)
            )
        );
    }
    test_field_mapEntryCount();
    fn test_field_pMapEntries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSpecializationInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pMapEntries) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSpecializationInfo),
                "::",
                stringify!(pMapEntries)
            )
        );
    }
    test_field_pMapEntries();
    fn test_field_dataSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSpecializationInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSpecializationInfo),
                "::",
                stringify!(dataSize)
            )
        );
    }
    test_field_dataSize();
    fn test_field_pData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSpecializationInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pData) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSpecializationInfo),
                "::",
                stringify!(pData)
            )
        );
    }
    test_field_pData();
}
impl Default for VkSpecializationInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineShaderStageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineShaderStageCreateFlags,
    pub stage: VkShaderStageFlagBits,
    pub module: VkShaderModule,
    pub pName: *const ::std::os::raw::c_char,
    pub pSpecializationInfo: *const VkSpecializationInfo,
}
#[test]
fn bindgen_test_layout_VkPipelineShaderStageCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineShaderStageCreateInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VkPipelineShaderStageCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineShaderStageCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPipelineShaderStageCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineShaderStageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineShaderStageCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineShaderStageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineShaderStageCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineShaderStageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineShaderStageCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_stage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineShaderStageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stage) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineShaderStageCreateInfo),
                "::",
                stringify!(stage)
            )
        );
    }
    test_field_stage();
    fn test_field_module() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineShaderStageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).module) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineShaderStageCreateInfo),
                "::",
                stringify!(module)
            )
        );
    }
    test_field_module();
    fn test_field_pName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineShaderStageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pName) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineShaderStageCreateInfo),
                "::",
                stringify!(pName)
            )
        );
    }
    test_field_pName();
    fn test_field_pSpecializationInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineShaderStageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSpecializationInfo) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineShaderStageCreateInfo),
                "::",
                stringify!(pSpecializationInfo)
            )
        );
    }
    test_field_pSpecializationInfo();
}
impl Default for VkPipelineShaderStageCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkComputePipelineCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCreateFlags,
    pub stage: VkPipelineShaderStageCreateInfo,
    pub layout: VkPipelineLayout,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: i32,
}
#[test]
fn bindgen_test_layout_VkComputePipelineCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkComputePipelineCreateInfo>(),
        96usize,
        concat!("Size of: ", stringify!(VkComputePipelineCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkComputePipelineCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkComputePipelineCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkComputePipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkComputePipelineCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkComputePipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkComputePipelineCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkComputePipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkComputePipelineCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_stage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkComputePipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stage) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkComputePipelineCreateInfo),
                "::",
                stringify!(stage)
            )
        );
    }
    test_field_stage();
    fn test_field_layout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkComputePipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layout) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkComputePipelineCreateInfo),
                "::",
                stringify!(layout)
            )
        );
    }
    test_field_layout();
    fn test_field_basePipelineHandle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkComputePipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).basePipelineHandle) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkComputePipelineCreateInfo),
                "::",
                stringify!(basePipelineHandle)
            )
        );
    }
    test_field_basePipelineHandle();
    fn test_field_basePipelineIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkComputePipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).basePipelineIndex) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkComputePipelineCreateInfo),
                "::",
                stringify!(basePipelineIndex)
            )
        );
    }
    test_field_basePipelineIndex();
}
impl Default for VkComputePipelineCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkVertexInputBindingDescription {
    pub binding: u32,
    pub stride: u32,
    pub inputRate: VkVertexInputRate,
}
#[test]
fn bindgen_test_layout_VkVertexInputBindingDescription() {
    assert_eq!(
        ::std::mem::size_of::<VkVertexInputBindingDescription>(),
        12usize,
        concat!("Size of: ", stringify!(VkVertexInputBindingDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<VkVertexInputBindingDescription>(),
        4usize,
        concat!("Alignment of ", stringify!(VkVertexInputBindingDescription))
    );
    fn test_field_binding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkVertexInputBindingDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binding) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputBindingDescription),
                "::",
                stringify!(binding)
            )
        );
    }
    test_field_binding();
    fn test_field_stride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkVertexInputBindingDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputBindingDescription),
                "::",
                stringify!(stride)
            )
        );
    }
    test_field_stride();
    fn test_field_inputRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkVertexInputBindingDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inputRate) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputBindingDescription),
                "::",
                stringify!(inputRate)
            )
        );
    }
    test_field_inputRate();
}
impl Default for VkVertexInputBindingDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkVertexInputAttributeDescription {
    pub location: u32,
    pub binding: u32,
    pub format: VkFormat,
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_VkVertexInputAttributeDescription() {
    assert_eq!(
        ::std::mem::size_of::<VkVertexInputAttributeDescription>(),
        16usize,
        concat!("Size of: ", stringify!(VkVertexInputAttributeDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<VkVertexInputAttributeDescription>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkVertexInputAttributeDescription)
        )
    );
    fn test_field_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkVertexInputAttributeDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputAttributeDescription),
                "::",
                stringify!(location)
            )
        );
    }
    test_field_location();
    fn test_field_binding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkVertexInputAttributeDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binding) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputAttributeDescription),
                "::",
                stringify!(binding)
            )
        );
    }
    test_field_binding();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkVertexInputAttributeDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputAttributeDescription),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkVertexInputAttributeDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputAttributeDescription),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
}
impl Default for VkVertexInputAttributeDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineVertexInputStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineVertexInputStateCreateFlags,
    pub vertexBindingDescriptionCount: u32,
    pub pVertexBindingDescriptions: *const VkVertexInputBindingDescription,
    pub vertexAttributeDescriptionCount: u32,
    pub pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription,
}
#[test]
fn bindgen_test_layout_VkPipelineVertexInputStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineVertexInputStateCreateInfo>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineVertexInputStateCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineVertexInputStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineVertexInputStateCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineVertexInputStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineVertexInputStateCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineVertexInputStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineVertexInputStateCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineVertexInputStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineVertexInputStateCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_vertexBindingDescriptionCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineVertexInputStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexBindingDescriptionCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineVertexInputStateCreateInfo),
                "::",
                stringify!(vertexBindingDescriptionCount)
            )
        );
    }
    test_field_vertexBindingDescriptionCount();
    fn test_field_pVertexBindingDescriptions() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineVertexInputStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pVertexBindingDescriptions) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineVertexInputStateCreateInfo),
                "::",
                stringify!(pVertexBindingDescriptions)
            )
        );
    }
    test_field_pVertexBindingDescriptions();
    fn test_field_vertexAttributeDescriptionCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineVertexInputStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexAttributeDescriptionCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineVertexInputStateCreateInfo),
                "::",
                stringify!(vertexAttributeDescriptionCount)
            )
        );
    }
    test_field_vertexAttributeDescriptionCount();
    fn test_field_pVertexAttributeDescriptions() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineVertexInputStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pVertexAttributeDescriptions) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineVertexInputStateCreateInfo),
                "::",
                stringify!(pVertexAttributeDescriptions)
            )
        );
    }
    test_field_pVertexAttributeDescriptions();
}
impl Default for VkPipelineVertexInputStateCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineInputAssemblyStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineInputAssemblyStateCreateFlags,
    pub topology: VkPrimitiveTopology,
    pub primitiveRestartEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPipelineInputAssemblyStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineInputAssemblyStateCreateInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineInputAssemblyStateCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineInputAssemblyStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineInputAssemblyStateCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineInputAssemblyStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineInputAssemblyStateCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineInputAssemblyStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineInputAssemblyStateCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineInputAssemblyStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineInputAssemblyStateCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_topology() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineInputAssemblyStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).topology) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineInputAssemblyStateCreateInfo),
                "::",
                stringify!(topology)
            )
        );
    }
    test_field_topology();
    fn test_field_primitiveRestartEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineInputAssemblyStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).primitiveRestartEnable) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineInputAssemblyStateCreateInfo),
                "::",
                stringify!(primitiveRestartEnable)
            )
        );
    }
    test_field_primitiveRestartEnable();
}
impl Default for VkPipelineInputAssemblyStateCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineTessellationStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineTessellationStateCreateFlags,
    pub patchControlPoints: u32,
}
#[test]
fn bindgen_test_layout_VkPipelineTessellationStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineTessellationStateCreateInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineTessellationStateCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineTessellationStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineTessellationStateCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineTessellationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineTessellationStateCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineTessellationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineTessellationStateCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineTessellationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineTessellationStateCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_patchControlPoints() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineTessellationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).patchControlPoints) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineTessellationStateCreateInfo),
                "::",
                stringify!(patchControlPoints)
            )
        );
    }
    test_field_patchControlPoints();
}
impl Default for VkPipelineTessellationStateCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkViewport {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
    pub minDepth: f32,
    pub maxDepth: f32,
}
#[test]
fn bindgen_test_layout_VkViewport() {
    assert_eq!(
        ::std::mem::size_of::<VkViewport>(),
        24usize,
        concat!("Size of: ", stringify!(VkViewport))
    );
    assert_eq!(
        ::std::mem::align_of::<VkViewport>(),
        4usize,
        concat!("Alignment of ", stringify!(VkViewport))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkViewport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkViewport),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkViewport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkViewport),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkViewport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkViewport),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkViewport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkViewport),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_minDepth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkViewport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minDepth) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkViewport),
                "::",
                stringify!(minDepth)
            )
        );
    }
    test_field_minDepth();
    fn test_field_maxDepth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkViewport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDepth) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkViewport),
                "::",
                stringify!(maxDepth)
            )
        );
    }
    test_field_maxDepth();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineViewportStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineViewportStateCreateFlags,
    pub viewportCount: u32,
    pub pViewports: *const VkViewport,
    pub scissorCount: u32,
    pub pScissors: *const VkRect2D,
}
#[test]
fn bindgen_test_layout_VkPipelineViewportStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineViewportStateCreateInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VkPipelineViewportStateCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineViewportStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineViewportStateCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineViewportStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportStateCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineViewportStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportStateCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineViewportStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportStateCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_viewportCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineViewportStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewportCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportStateCreateInfo),
                "::",
                stringify!(viewportCount)
            )
        );
    }
    test_field_viewportCount();
    fn test_field_pViewports() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineViewportStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pViewports) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportStateCreateInfo),
                "::",
                stringify!(pViewports)
            )
        );
    }
    test_field_pViewports();
    fn test_field_scissorCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineViewportStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scissorCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportStateCreateInfo),
                "::",
                stringify!(scissorCount)
            )
        );
    }
    test_field_scissorCount();
    fn test_field_pScissors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineViewportStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pScissors) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportStateCreateInfo),
                "::",
                stringify!(pScissors)
            )
        );
    }
    test_field_pScissors();
}
impl Default for VkPipelineViewportStateCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRasterizationStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineRasterizationStateCreateFlags,
    pub depthClampEnable: VkBool32,
    pub rasterizerDiscardEnable: VkBool32,
    pub polygonMode: VkPolygonMode,
    pub cullMode: VkCullModeFlags,
    pub frontFace: VkFrontFace,
    pub depthBiasEnable: VkBool32,
    pub depthBiasConstantFactor: f32,
    pub depthBiasClamp: f32,
    pub depthBiasSlopeFactor: f32,
    pub lineWidth: f32,
}
#[test]
fn bindgen_test_layout_VkPipelineRasterizationStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRasterizationStateCreateInfo>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineRasterizationStateCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRasterizationStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineRasterizationStateCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineRasterizationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineRasterizationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineRasterizationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_depthClampEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineRasterizationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthClampEnable) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateCreateInfo),
                "::",
                stringify!(depthClampEnable)
            )
        );
    }
    test_field_depthClampEnable();
    fn test_field_rasterizerDiscardEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineRasterizationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rasterizerDiscardEnable) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateCreateInfo),
                "::",
                stringify!(rasterizerDiscardEnable)
            )
        );
    }
    test_field_rasterizerDiscardEnable();
    fn test_field_polygonMode() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineRasterizationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).polygonMode) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateCreateInfo),
                "::",
                stringify!(polygonMode)
            )
        );
    }
    test_field_polygonMode();
    fn test_field_cullMode() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineRasterizationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cullMode) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateCreateInfo),
                "::",
                stringify!(cullMode)
            )
        );
    }
    test_field_cullMode();
    fn test_field_frontFace() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineRasterizationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frontFace) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateCreateInfo),
                "::",
                stringify!(frontFace)
            )
        );
    }
    test_field_frontFace();
    fn test_field_depthBiasEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineRasterizationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthBiasEnable) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateCreateInfo),
                "::",
                stringify!(depthBiasEnable)
            )
        );
    }
    test_field_depthBiasEnable();
    fn test_field_depthBiasConstantFactor() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineRasterizationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthBiasConstantFactor) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateCreateInfo),
                "::",
                stringify!(depthBiasConstantFactor)
            )
        );
    }
    test_field_depthBiasConstantFactor();
    fn test_field_depthBiasClamp() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineRasterizationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthBiasClamp) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateCreateInfo),
                "::",
                stringify!(depthBiasClamp)
            )
        );
    }
    test_field_depthBiasClamp();
    fn test_field_depthBiasSlopeFactor() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineRasterizationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthBiasSlopeFactor) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateCreateInfo),
                "::",
                stringify!(depthBiasSlopeFactor)
            )
        );
    }
    test_field_depthBiasSlopeFactor();
    fn test_field_lineWidth() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineRasterizationStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lineWidth) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateCreateInfo),
                "::",
                stringify!(lineWidth)
            )
        );
    }
    test_field_lineWidth();
}
impl Default for VkPipelineRasterizationStateCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineMultisampleStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineMultisampleStateCreateFlags,
    pub rasterizationSamples: VkSampleCountFlagBits,
    pub sampleShadingEnable: VkBool32,
    pub minSampleShading: f32,
    pub pSampleMask: *const VkSampleMask,
    pub alphaToCoverageEnable: VkBool32,
    pub alphaToOneEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPipelineMultisampleStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineMultisampleStateCreateInfo>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineMultisampleStateCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineMultisampleStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineMultisampleStateCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineMultisampleStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineMultisampleStateCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineMultisampleStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineMultisampleStateCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineMultisampleStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineMultisampleStateCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_rasterizationSamples() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineMultisampleStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rasterizationSamples) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineMultisampleStateCreateInfo),
                "::",
                stringify!(rasterizationSamples)
            )
        );
    }
    test_field_rasterizationSamples();
    fn test_field_sampleShadingEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineMultisampleStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleShadingEnable) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineMultisampleStateCreateInfo),
                "::",
                stringify!(sampleShadingEnable)
            )
        );
    }
    test_field_sampleShadingEnable();
    fn test_field_minSampleShading() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineMultisampleStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minSampleShading) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineMultisampleStateCreateInfo),
                "::",
                stringify!(minSampleShading)
            )
        );
    }
    test_field_minSampleShading();
    fn test_field_pSampleMask() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineMultisampleStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSampleMask) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineMultisampleStateCreateInfo),
                "::",
                stringify!(pSampleMask)
            )
        );
    }
    test_field_pSampleMask();
    fn test_field_alphaToCoverageEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineMultisampleStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alphaToCoverageEnable) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineMultisampleStateCreateInfo),
                "::",
                stringify!(alphaToCoverageEnable)
            )
        );
    }
    test_field_alphaToCoverageEnable();
    fn test_field_alphaToOneEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineMultisampleStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alphaToOneEnable) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineMultisampleStateCreateInfo),
                "::",
                stringify!(alphaToOneEnable)
            )
        );
    }
    test_field_alphaToOneEnable();
}
impl Default for VkPipelineMultisampleStateCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkStencilOpState {
    pub failOp: VkStencilOp,
    pub passOp: VkStencilOp,
    pub depthFailOp: VkStencilOp,
    pub compareOp: VkCompareOp,
    pub compareMask: u32,
    pub writeMask: u32,
    pub reference: u32,
}
#[test]
fn bindgen_test_layout_VkStencilOpState() {
    assert_eq!(
        ::std::mem::size_of::<VkStencilOpState>(),
        28usize,
        concat!("Size of: ", stringify!(VkStencilOpState))
    );
    assert_eq!(
        ::std::mem::align_of::<VkStencilOpState>(),
        4usize,
        concat!("Alignment of ", stringify!(VkStencilOpState))
    );
    fn test_field_failOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkStencilOpState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).failOp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkStencilOpState),
                "::",
                stringify!(failOp)
            )
        );
    }
    test_field_failOp();
    fn test_field_passOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkStencilOpState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).passOp) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkStencilOpState),
                "::",
                stringify!(passOp)
            )
        );
    }
    test_field_passOp();
    fn test_field_depthFailOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkStencilOpState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthFailOp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkStencilOpState),
                "::",
                stringify!(depthFailOp)
            )
        );
    }
    test_field_depthFailOp();
    fn test_field_compareOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkStencilOpState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compareOp) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkStencilOpState),
                "::",
                stringify!(compareOp)
            )
        );
    }
    test_field_compareOp();
    fn test_field_compareMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkStencilOpState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compareMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkStencilOpState),
                "::",
                stringify!(compareMask)
            )
        );
    }
    test_field_compareMask();
    fn test_field_writeMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkStencilOpState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).writeMask) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkStencilOpState),
                "::",
                stringify!(writeMask)
            )
        );
    }
    test_field_writeMask();
    fn test_field_reference() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkStencilOpState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reference) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkStencilOpState),
                "::",
                stringify!(reference)
            )
        );
    }
    test_field_reference();
}
impl Default for VkStencilOpState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineDepthStencilStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineDepthStencilStateCreateFlags,
    pub depthTestEnable: VkBool32,
    pub depthWriteEnable: VkBool32,
    pub depthCompareOp: VkCompareOp,
    pub depthBoundsTestEnable: VkBool32,
    pub stencilTestEnable: VkBool32,
    pub front: VkStencilOpState,
    pub back: VkStencilOpState,
    pub minDepthBounds: f32,
    pub maxDepthBounds: f32,
}
#[test]
fn bindgen_test_layout_VkPipelineDepthStencilStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineDepthStencilStateCreateInfo>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineDepthStencilStateCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineDepthStencilStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineDepthStencilStateCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDepthStencilStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDepthStencilStateCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDepthStencilStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDepthStencilStateCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDepthStencilStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDepthStencilStateCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_depthTestEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDepthStencilStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthTestEnable) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDepthStencilStateCreateInfo),
                "::",
                stringify!(depthTestEnable)
            )
        );
    }
    test_field_depthTestEnable();
    fn test_field_depthWriteEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDepthStencilStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthWriteEnable) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDepthStencilStateCreateInfo),
                "::",
                stringify!(depthWriteEnable)
            )
        );
    }
    test_field_depthWriteEnable();
    fn test_field_depthCompareOp() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDepthStencilStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthCompareOp) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDepthStencilStateCreateInfo),
                "::",
                stringify!(depthCompareOp)
            )
        );
    }
    test_field_depthCompareOp();
    fn test_field_depthBoundsTestEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDepthStencilStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthBoundsTestEnable) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDepthStencilStateCreateInfo),
                "::",
                stringify!(depthBoundsTestEnable)
            )
        );
    }
    test_field_depthBoundsTestEnable();
    fn test_field_stencilTestEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDepthStencilStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stencilTestEnable) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDepthStencilStateCreateInfo),
                "::",
                stringify!(stencilTestEnable)
            )
        );
    }
    test_field_stencilTestEnable();
    fn test_field_front() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDepthStencilStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).front) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDepthStencilStateCreateInfo),
                "::",
                stringify!(front)
            )
        );
    }
    test_field_front();
    fn test_field_back() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDepthStencilStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).back) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDepthStencilStateCreateInfo),
                "::",
                stringify!(back)
            )
        );
    }
    test_field_back();
    fn test_field_minDepthBounds() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDepthStencilStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minDepthBounds) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDepthStencilStateCreateInfo),
                "::",
                stringify!(minDepthBounds)
            )
        );
    }
    test_field_minDepthBounds();
    fn test_field_maxDepthBounds() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDepthStencilStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDepthBounds) as usize - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDepthStencilStateCreateInfo),
                "::",
                stringify!(maxDepthBounds)
            )
        );
    }
    test_field_maxDepthBounds();
}
impl Default for VkPipelineDepthStencilStateCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineColorBlendAttachmentState {
    pub blendEnable: VkBool32,
    pub srcColorBlendFactor: VkBlendFactor,
    pub dstColorBlendFactor: VkBlendFactor,
    pub colorBlendOp: VkBlendOp,
    pub srcAlphaBlendFactor: VkBlendFactor,
    pub dstAlphaBlendFactor: VkBlendFactor,
    pub alphaBlendOp: VkBlendOp,
    pub colorWriteMask: VkColorComponentFlags,
}
#[test]
fn bindgen_test_layout_VkPipelineColorBlendAttachmentState() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineColorBlendAttachmentState>(),
        32usize,
        concat!("Size of: ", stringify!(VkPipelineColorBlendAttachmentState))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineColorBlendAttachmentState>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineColorBlendAttachmentState)
        )
    );
    fn test_field_blendEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineColorBlendAttachmentState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blendEnable) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendAttachmentState),
                "::",
                stringify!(blendEnable)
            )
        );
    }
    test_field_blendEnable();
    fn test_field_srcColorBlendFactor() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineColorBlendAttachmentState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcColorBlendFactor) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendAttachmentState),
                "::",
                stringify!(srcColorBlendFactor)
            )
        );
    }
    test_field_srcColorBlendFactor();
    fn test_field_dstColorBlendFactor() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineColorBlendAttachmentState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstColorBlendFactor) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendAttachmentState),
                "::",
                stringify!(dstColorBlendFactor)
            )
        );
    }
    test_field_dstColorBlendFactor();
    fn test_field_colorBlendOp() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineColorBlendAttachmentState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorBlendOp) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendAttachmentState),
                "::",
                stringify!(colorBlendOp)
            )
        );
    }
    test_field_colorBlendOp();
    fn test_field_srcAlphaBlendFactor() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineColorBlendAttachmentState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcAlphaBlendFactor) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendAttachmentState),
                "::",
                stringify!(srcAlphaBlendFactor)
            )
        );
    }
    test_field_srcAlphaBlendFactor();
    fn test_field_dstAlphaBlendFactor() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineColorBlendAttachmentState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstAlphaBlendFactor) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendAttachmentState),
                "::",
                stringify!(dstAlphaBlendFactor)
            )
        );
    }
    test_field_dstAlphaBlendFactor();
    fn test_field_alphaBlendOp() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineColorBlendAttachmentState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alphaBlendOp) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendAttachmentState),
                "::",
                stringify!(alphaBlendOp)
            )
        );
    }
    test_field_alphaBlendOp();
    fn test_field_colorWriteMask() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineColorBlendAttachmentState>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorWriteMask) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendAttachmentState),
                "::",
                stringify!(colorWriteMask)
            )
        );
    }
    test_field_colorWriteMask();
}
impl Default for VkPipelineColorBlendAttachmentState {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineColorBlendStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineColorBlendStateCreateFlags,
    pub logicOpEnable: VkBool32,
    pub logicOp: VkLogicOp,
    pub attachmentCount: u32,
    pub pAttachments: *const VkPipelineColorBlendAttachmentState,
    pub blendConstants: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_VkPipelineColorBlendStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineColorBlendStateCreateInfo>(),
        56usize,
        concat!("Size of: ", stringify!(VkPipelineColorBlendStateCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineColorBlendStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineColorBlendStateCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineColorBlendStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendStateCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineColorBlendStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendStateCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineColorBlendStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendStateCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_logicOpEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineColorBlendStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).logicOpEnable) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendStateCreateInfo),
                "::",
                stringify!(logicOpEnable)
            )
        );
    }
    test_field_logicOpEnable();
    fn test_field_logicOp() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineColorBlendStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).logicOp) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendStateCreateInfo),
                "::",
                stringify!(logicOp)
            )
        );
    }
    test_field_logicOp();
    fn test_field_attachmentCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineColorBlendStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attachmentCount) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendStateCreateInfo),
                "::",
                stringify!(attachmentCount)
            )
        );
    }
    test_field_attachmentCount();
    fn test_field_pAttachments() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineColorBlendStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pAttachments) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendStateCreateInfo),
                "::",
                stringify!(pAttachments)
            )
        );
    }
    test_field_pAttachments();
    fn test_field_blendConstants() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineColorBlendStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blendConstants) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendStateCreateInfo),
                "::",
                stringify!(blendConstants)
            )
        );
    }
    test_field_blendConstants();
}
impl Default for VkPipelineColorBlendStateCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineDynamicStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineDynamicStateCreateFlags,
    pub dynamicStateCount: u32,
    pub pDynamicStates: *const VkDynamicState,
}
#[test]
fn bindgen_test_layout_VkPipelineDynamicStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineDynamicStateCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkPipelineDynamicStateCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineDynamicStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineDynamicStateCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineDynamicStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDynamicStateCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineDynamicStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDynamicStateCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineDynamicStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDynamicStateCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_dynamicStateCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineDynamicStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dynamicStateCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDynamicStateCreateInfo),
                "::",
                stringify!(dynamicStateCount)
            )
        );
    }
    test_field_dynamicStateCount();
    fn test_field_pDynamicStates() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineDynamicStateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDynamicStates) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDynamicStateCreateInfo),
                "::",
                stringify!(pDynamicStates)
            )
        );
    }
    test_field_pDynamicStates();
}
impl Default for VkPipelineDynamicStateCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkGraphicsPipelineCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCreateFlags,
    pub stageCount: u32,
    pub pStages: *const VkPipelineShaderStageCreateInfo,
    pub pVertexInputState: *const VkPipelineVertexInputStateCreateInfo,
    pub pInputAssemblyState: *const VkPipelineInputAssemblyStateCreateInfo,
    pub pTessellationState: *const VkPipelineTessellationStateCreateInfo,
    pub pViewportState: *const VkPipelineViewportStateCreateInfo,
    pub pRasterizationState: *const VkPipelineRasterizationStateCreateInfo,
    pub pMultisampleState: *const VkPipelineMultisampleStateCreateInfo,
    pub pDepthStencilState: *const VkPipelineDepthStencilStateCreateInfo,
    pub pColorBlendState: *const VkPipelineColorBlendStateCreateInfo,
    pub pDynamicState: *const VkPipelineDynamicStateCreateInfo,
    pub layout: VkPipelineLayout,
    pub renderPass: VkRenderPass,
    pub subpass: u32,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: i32,
}
#[test]
fn bindgen_test_layout_VkGraphicsPipelineCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkGraphicsPipelineCreateInfo>(),
        144usize,
        concat!("Size of: ", stringify!(VkGraphicsPipelineCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkGraphicsPipelineCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkGraphicsPipelineCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_stageCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stageCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(stageCount)
            )
        );
    }
    test_field_stageCount();
    fn test_field_pStages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pStages) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(pStages)
            )
        );
    }
    test_field_pStages();
    fn test_field_pVertexInputState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pVertexInputState) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(pVertexInputState)
            )
        );
    }
    test_field_pVertexInputState();
    fn test_field_pInputAssemblyState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pInputAssemblyState) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(pInputAssemblyState)
            )
        );
    }
    test_field_pInputAssemblyState();
    fn test_field_pTessellationState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pTessellationState) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(pTessellationState)
            )
        );
    }
    test_field_pTessellationState();
    fn test_field_pViewportState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pViewportState) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(pViewportState)
            )
        );
    }
    test_field_pViewportState();
    fn test_field_pRasterizationState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pRasterizationState) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(pRasterizationState)
            )
        );
    }
    test_field_pRasterizationState();
    fn test_field_pMultisampleState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pMultisampleState) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(pMultisampleState)
            )
        );
    }
    test_field_pMultisampleState();
    fn test_field_pDepthStencilState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDepthStencilState) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(pDepthStencilState)
            )
        );
    }
    test_field_pDepthStencilState();
    fn test_field_pColorBlendState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pColorBlendState) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(pColorBlendState)
            )
        );
    }
    test_field_pColorBlendState();
    fn test_field_pDynamicState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDynamicState) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(pDynamicState)
            )
        );
    }
    test_field_pDynamicState();
    fn test_field_layout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layout) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(layout)
            )
        );
    }
    test_field_layout();
    fn test_field_renderPass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).renderPass) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(renderPass)
            )
        );
    }
    test_field_renderPass();
    fn test_field_subpass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subpass) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(subpass)
            )
        );
    }
    test_field_subpass();
    fn test_field_basePipelineHandle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).basePipelineHandle) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(basePipelineHandle)
            )
        );
    }
    test_field_basePipelineHandle();
    fn test_field_basePipelineIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsPipelineCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).basePipelineIndex) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineCreateInfo),
                "::",
                stringify!(basePipelineIndex)
            )
        );
    }
    test_field_basePipelineIndex();
}
impl Default for VkGraphicsPipelineCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkPushConstantRange {
    pub stageFlags: VkShaderStageFlags,
    pub offset: u32,
    pub size: u32,
}
#[test]
fn bindgen_test_layout_VkPushConstantRange() {
    assert_eq!(
        ::std::mem::size_of::<VkPushConstantRange>(),
        12usize,
        concat!("Size of: ", stringify!(VkPushConstantRange))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPushConstantRange>(),
        4usize,
        concat!("Alignment of ", stringify!(VkPushConstantRange))
    );
    fn test_field_stageFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPushConstantRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stageFlags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPushConstantRange),
                "::",
                stringify!(stageFlags)
            )
        );
    }
    test_field_stageFlags();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPushConstantRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPushConstantRange),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPushConstantRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPushConstantRange),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineLayoutCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineLayoutCreateFlags,
    pub setLayoutCount: u32,
    pub pSetLayouts: *const VkDescriptorSetLayout,
    pub pushConstantRangeCount: u32,
    pub pPushConstantRanges: *const VkPushConstantRange,
}
#[test]
fn bindgen_test_layout_VkPipelineLayoutCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineLayoutCreateInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VkPipelineLayoutCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineLayoutCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPipelineLayoutCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineLayoutCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineLayoutCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineLayoutCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineLayoutCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineLayoutCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineLayoutCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_setLayoutCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineLayoutCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).setLayoutCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineLayoutCreateInfo),
                "::",
                stringify!(setLayoutCount)
            )
        );
    }
    test_field_setLayoutCount();
    fn test_field_pSetLayouts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineLayoutCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSetLayouts) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineLayoutCreateInfo),
                "::",
                stringify!(pSetLayouts)
            )
        );
    }
    test_field_pSetLayouts();
    fn test_field_pushConstantRangeCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineLayoutCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pushConstantRangeCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineLayoutCreateInfo),
                "::",
                stringify!(pushConstantRangeCount)
            )
        );
    }
    test_field_pushConstantRangeCount();
    fn test_field_pPushConstantRanges() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineLayoutCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pPushConstantRanges) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineLayoutCreateInfo),
                "::",
                stringify!(pPushConstantRanges)
            )
        );
    }
    test_field_pPushConstantRanges();
}
impl Default for VkPipelineLayoutCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSamplerCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSamplerCreateFlags,
    pub magFilter: VkFilter,
    pub minFilter: VkFilter,
    pub mipmapMode: VkSamplerMipmapMode,
    pub addressModeU: VkSamplerAddressMode,
    pub addressModeV: VkSamplerAddressMode,
    pub addressModeW: VkSamplerAddressMode,
    pub mipLodBias: f32,
    pub anisotropyEnable: VkBool32,
    pub maxAnisotropy: f32,
    pub compareEnable: VkBool32,
    pub compareOp: VkCompareOp,
    pub minLod: f32,
    pub maxLod: f32,
    pub borderColor: VkBorderColor,
    pub unnormalizedCoordinates: VkBool32,
}
#[test]
fn bindgen_test_layout_VkSamplerCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSamplerCreateInfo>(),
        80usize,
        concat!("Size of: ", stringify!(VkSamplerCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSamplerCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSamplerCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_magFilter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).magFilter) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(magFilter)
            )
        );
    }
    test_field_magFilter();
    fn test_field_minFilter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minFilter) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(minFilter)
            )
        );
    }
    test_field_minFilter();
    fn test_field_mipmapMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipmapMode) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(mipmapMode)
            )
        );
    }
    test_field_mipmapMode();
    fn test_field_addressModeU() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).addressModeU) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(addressModeU)
            )
        );
    }
    test_field_addressModeU();
    fn test_field_addressModeV() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).addressModeV) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(addressModeV)
            )
        );
    }
    test_field_addressModeV();
    fn test_field_addressModeW() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).addressModeW) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(addressModeW)
            )
        );
    }
    test_field_addressModeW();
    fn test_field_mipLodBias() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipLodBias) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(mipLodBias)
            )
        );
    }
    test_field_mipLodBias();
    fn test_field_anisotropyEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).anisotropyEnable) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(anisotropyEnable)
            )
        );
    }
    test_field_anisotropyEnable();
    fn test_field_maxAnisotropy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxAnisotropy) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(maxAnisotropy)
            )
        );
    }
    test_field_maxAnisotropy();
    fn test_field_compareEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compareEnable) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(compareEnable)
            )
        );
    }
    test_field_compareEnable();
    fn test_field_compareOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compareOp) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(compareOp)
            )
        );
    }
    test_field_compareOp();
    fn test_field_minLod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minLod) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(minLod)
            )
        );
    }
    test_field_minLod();
    fn test_field_maxLod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxLod) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(maxLod)
            )
        );
    }
    test_field_maxLod();
    fn test_field_borderColor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).borderColor) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(borderColor)
            )
        );
    }
    test_field_borderColor();
    fn test_field_unnormalizedCoordinates() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unnormalizedCoordinates) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCreateInfo),
                "::",
                stringify!(unnormalizedCoordinates)
            )
        );
    }
    test_field_unnormalizedCoordinates();
}
impl Default for VkSamplerCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCopyDescriptorSet {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcSet: VkDescriptorSet,
    pub srcBinding: u32,
    pub srcArrayElement: u32,
    pub dstSet: VkDescriptorSet,
    pub dstBinding: u32,
    pub dstArrayElement: u32,
    pub descriptorCount: u32,
}
#[test]
fn bindgen_test_layout_VkCopyDescriptorSet() {
    assert_eq!(
        ::std::mem::size_of::<VkCopyDescriptorSet>(),
        56usize,
        concat!("Size of: ", stringify!(VkCopyDescriptorSet))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCopyDescriptorSet>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCopyDescriptorSet))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyDescriptorSet),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyDescriptorSet),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcSet() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcSet) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyDescriptorSet),
                "::",
                stringify!(srcSet)
            )
        );
    }
    test_field_srcSet();
    fn test_field_srcBinding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcBinding) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyDescriptorSet),
                "::",
                stringify!(srcBinding)
            )
        );
    }
    test_field_srcBinding();
    fn test_field_srcArrayElement() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcArrayElement) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyDescriptorSet),
                "::",
                stringify!(srcArrayElement)
            )
        );
    }
    test_field_srcArrayElement();
    fn test_field_dstSet() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstSet) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyDescriptorSet),
                "::",
                stringify!(dstSet)
            )
        );
    }
    test_field_dstSet();
    fn test_field_dstBinding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstBinding) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyDescriptorSet),
                "::",
                stringify!(dstBinding)
            )
        );
    }
    test_field_dstBinding();
    fn test_field_dstArrayElement() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstArrayElement) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyDescriptorSet),
                "::",
                stringify!(dstArrayElement)
            )
        );
    }
    test_field_dstArrayElement();
    fn test_field_descriptorCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorCount) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyDescriptorSet),
                "::",
                stringify!(descriptorCount)
            )
        );
    }
    test_field_descriptorCount();
}
impl Default for VkCopyDescriptorSet {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorBufferInfo {
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub range: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkDescriptorBufferInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorBufferInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkDescriptorBufferInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorBufferInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorBufferInfo))
    );
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorBufferInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorBufferInfo),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorBufferInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorBufferInfo),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_range() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorBufferInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorBufferInfo),
                "::",
                stringify!(range)
            )
        );
    }
    test_field_range();
}
impl Default for VkDescriptorBufferInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorImageInfo {
    pub sampler: VkSampler,
    pub imageView: VkImageView,
    pub imageLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkDescriptorImageInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorImageInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkDescriptorImageInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorImageInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorImageInfo))
    );
    fn test_field_sampler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorImageInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampler) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorImageInfo),
                "::",
                stringify!(sampler)
            )
        );
    }
    test_field_sampler();
    fn test_field_imageView() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorImageInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageView) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorImageInfo),
                "::",
                stringify!(imageView)
            )
        );
    }
    test_field_imageView();
    fn test_field_imageLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorImageInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageLayout) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorImageInfo),
                "::",
                stringify!(imageLayout)
            )
        );
    }
    test_field_imageLayout();
}
impl Default for VkDescriptorImageInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorPoolSize {
    pub type_: VkDescriptorType,
    pub descriptorCount: u32,
}
#[test]
fn bindgen_test_layout_VkDescriptorPoolSize() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorPoolSize>(),
        8usize,
        concat!("Size of: ", stringify!(VkDescriptorPoolSize))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorPoolSize>(),
        4usize,
        concat!("Alignment of ", stringify!(VkDescriptorPoolSize))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorPoolSize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorPoolSize),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_descriptorCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorPoolSize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorCount) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorPoolSize),
                "::",
                stringify!(descriptorCount)
            )
        );
    }
    test_field_descriptorCount();
}
impl Default for VkDescriptorPoolSize {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDescriptorPoolCreateFlags,
    pub maxSets: u32,
    pub poolSizeCount: u32,
    pub pPoolSizes: *const VkDescriptorPoolSize,
}
#[test]
fn bindgen_test_layout_VkDescriptorPoolCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorPoolCreateInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkDescriptorPoolCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorPoolCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorPoolCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorPoolCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorPoolCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorPoolCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorPoolCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorPoolCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorPoolCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_maxSets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorPoolCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSets) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorPoolCreateInfo),
                "::",
                stringify!(maxSets)
            )
        );
    }
    test_field_maxSets();
    fn test_field_poolSizeCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorPoolCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).poolSizeCount) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorPoolCreateInfo),
                "::",
                stringify!(poolSizeCount)
            )
        );
    }
    test_field_poolSizeCount();
    fn test_field_pPoolSizes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorPoolCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pPoolSizes) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorPoolCreateInfo),
                "::",
                stringify!(pPoolSizes)
            )
        );
    }
    test_field_pPoolSizes();
}
impl Default for VkDescriptorPoolCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub descriptorPool: VkDescriptorPool,
    pub descriptorSetCount: u32,
    pub pSetLayouts: *const VkDescriptorSetLayout,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetAllocateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorSetAllocateInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkDescriptorSetAllocateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorSetAllocateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorSetAllocateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetAllocateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetAllocateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_descriptorPool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorPool) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetAllocateInfo),
                "::",
                stringify!(descriptorPool)
            )
        );
    }
    test_field_descriptorPool();
    fn test_field_descriptorSetCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorSetCount) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetAllocateInfo),
                "::",
                stringify!(descriptorSetCount)
            )
        );
    }
    test_field_descriptorSetCount();
    fn test_field_pSetLayouts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSetLayouts) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetAllocateInfo),
                "::",
                stringify!(pSetLayouts)
            )
        );
    }
    test_field_pSetLayouts();
}
impl Default for VkDescriptorSetAllocateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetLayoutBinding {
    pub binding: u32,
    pub descriptorType: VkDescriptorType,
    pub descriptorCount: u32,
    pub stageFlags: VkShaderStageFlags,
    pub pImmutableSamplers: *const VkSampler,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetLayoutBinding() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorSetLayoutBinding>(),
        24usize,
        concat!("Size of: ", stringify!(VkDescriptorSetLayoutBinding))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorSetLayoutBinding>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorSetLayoutBinding))
    );
    fn test_field_binding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetLayoutBinding>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binding) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutBinding),
                "::",
                stringify!(binding)
            )
        );
    }
    test_field_binding();
    fn test_field_descriptorType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetLayoutBinding>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorType) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutBinding),
                "::",
                stringify!(descriptorType)
            )
        );
    }
    test_field_descriptorType();
    fn test_field_descriptorCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetLayoutBinding>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutBinding),
                "::",
                stringify!(descriptorCount)
            )
        );
    }
    test_field_descriptorCount();
    fn test_field_stageFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetLayoutBinding>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stageFlags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutBinding),
                "::",
                stringify!(stageFlags)
            )
        );
    }
    test_field_stageFlags();
    fn test_field_pImmutableSamplers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetLayoutBinding>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pImmutableSamplers) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutBinding),
                "::",
                stringify!(pImmutableSamplers)
            )
        );
    }
    test_field_pImmutableSamplers();
}
impl Default for VkDescriptorSetLayoutBinding {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetLayoutCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDescriptorSetLayoutCreateFlags,
    pub bindingCount: u32,
    pub pBindings: *const VkDescriptorSetLayoutBinding,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetLayoutCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorSetLayoutCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkDescriptorSetLayoutCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorSetLayoutCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorSetLayoutCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetLayoutCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetLayoutCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetLayoutCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_bindingCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetLayoutCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bindingCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutCreateInfo),
                "::",
                stringify!(bindingCount)
            )
        );
    }
    test_field_bindingCount();
    fn test_field_pBindings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetLayoutCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pBindings) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutCreateInfo),
                "::",
                stringify!(pBindings)
            )
        );
    }
    test_field_pBindings();
}
impl Default for VkDescriptorSetLayoutCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkWriteDescriptorSet {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub dstSet: VkDescriptorSet,
    pub dstBinding: u32,
    pub dstArrayElement: u32,
    pub descriptorCount: u32,
    pub descriptorType: VkDescriptorType,
    pub pImageInfo: *const VkDescriptorImageInfo,
    pub pBufferInfo: *const VkDescriptorBufferInfo,
    pub pTexelBufferView: *const VkBufferView,
}
#[test]
fn bindgen_test_layout_VkWriteDescriptorSet() {
    assert_eq!(
        ::std::mem::size_of::<VkWriteDescriptorSet>(),
        64usize,
        concat!("Size of: ", stringify!(VkWriteDescriptorSet))
    );
    assert_eq!(
        ::std::mem::align_of::<VkWriteDescriptorSet>(),
        8usize,
        concat!("Alignment of ", stringify!(VkWriteDescriptorSet))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkWriteDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSet),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkWriteDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSet),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_dstSet() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkWriteDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstSet) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSet),
                "::",
                stringify!(dstSet)
            )
        );
    }
    test_field_dstSet();
    fn test_field_dstBinding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkWriteDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstBinding) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSet),
                "::",
                stringify!(dstBinding)
            )
        );
    }
    test_field_dstBinding();
    fn test_field_dstArrayElement() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkWriteDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstArrayElement) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSet),
                "::",
                stringify!(dstArrayElement)
            )
        );
    }
    test_field_dstArrayElement();
    fn test_field_descriptorCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkWriteDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSet),
                "::",
                stringify!(descriptorCount)
            )
        );
    }
    test_field_descriptorCount();
    fn test_field_descriptorType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkWriteDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorType) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSet),
                "::",
                stringify!(descriptorType)
            )
        );
    }
    test_field_descriptorType();
    fn test_field_pImageInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkWriteDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pImageInfo) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSet),
                "::",
                stringify!(pImageInfo)
            )
        );
    }
    test_field_pImageInfo();
    fn test_field_pBufferInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkWriteDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pBufferInfo) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSet),
                "::",
                stringify!(pBufferInfo)
            )
        );
    }
    test_field_pBufferInfo();
    fn test_field_pTexelBufferView() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkWriteDescriptorSet>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pTexelBufferView) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSet),
                "::",
                stringify!(pTexelBufferView)
            )
        );
    }
    test_field_pTexelBufferView();
}
impl Default for VkWriteDescriptorSet {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAttachmentDescription {
    pub flags: VkAttachmentDescriptionFlags,
    pub format: VkFormat,
    pub samples: VkSampleCountFlagBits,
    pub loadOp: VkAttachmentLoadOp,
    pub storeOp: VkAttachmentStoreOp,
    pub stencilLoadOp: VkAttachmentLoadOp,
    pub stencilStoreOp: VkAttachmentStoreOp,
    pub initialLayout: VkImageLayout,
    pub finalLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkAttachmentDescription() {
    assert_eq!(
        ::std::mem::size_of::<VkAttachmentDescription>(),
        36usize,
        concat!("Size of: ", stringify!(VkAttachmentDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAttachmentDescription>(),
        4usize,
        concat!("Alignment of ", stringify!(VkAttachmentDescription))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_samples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samples) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription),
                "::",
                stringify!(samples)
            )
        );
    }
    test_field_samples();
    fn test_field_loadOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).loadOp) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription),
                "::",
                stringify!(loadOp)
            )
        );
    }
    test_field_loadOp();
    fn test_field_storeOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storeOp) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription),
                "::",
                stringify!(storeOp)
            )
        );
    }
    test_field_storeOp();
    fn test_field_stencilLoadOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stencilLoadOp) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription),
                "::",
                stringify!(stencilLoadOp)
            )
        );
    }
    test_field_stencilLoadOp();
    fn test_field_stencilStoreOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stencilStoreOp) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription),
                "::",
                stringify!(stencilStoreOp)
            )
        );
    }
    test_field_stencilStoreOp();
    fn test_field_initialLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).initialLayout) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription),
                "::",
                stringify!(initialLayout)
            )
        );
    }
    test_field_initialLayout();
    fn test_field_finalLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).finalLayout) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription),
                "::",
                stringify!(finalLayout)
            )
        );
    }
    test_field_finalLayout();
}
impl Default for VkAttachmentDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAttachmentReference {
    pub attachment: u32,
    pub layout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkAttachmentReference() {
    assert_eq!(
        ::std::mem::size_of::<VkAttachmentReference>(),
        8usize,
        concat!("Size of: ", stringify!(VkAttachmentReference))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAttachmentReference>(),
        4usize,
        concat!("Alignment of ", stringify!(VkAttachmentReference))
    );
    fn test_field_attachment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attachment) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentReference),
                "::",
                stringify!(attachment)
            )
        );
    }
    test_field_attachment();
    fn test_field_layout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layout) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentReference),
                "::",
                stringify!(layout)
            )
        );
    }
    test_field_layout();
}
impl Default for VkAttachmentReference {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFramebufferCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkFramebufferCreateFlags,
    pub renderPass: VkRenderPass,
    pub attachmentCount: u32,
    pub pAttachments: *const VkImageView,
    pub width: u32,
    pub height: u32,
    pub layers: u32,
}
#[test]
fn bindgen_test_layout_VkFramebufferCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkFramebufferCreateInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VkFramebufferCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkFramebufferCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkFramebufferCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_renderPass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).renderPass) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferCreateInfo),
                "::",
                stringify!(renderPass)
            )
        );
    }
    test_field_renderPass();
    fn test_field_attachmentCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attachmentCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferCreateInfo),
                "::",
                stringify!(attachmentCount)
            )
        );
    }
    test_field_attachmentCount();
    fn test_field_pAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pAttachments) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferCreateInfo),
                "::",
                stringify!(pAttachments)
            )
        );
    }
    test_field_pAttachments();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferCreateInfo),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferCreateInfo),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_layers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layers) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferCreateInfo),
                "::",
                stringify!(layers)
            )
        );
    }
    test_field_layers();
}
impl Default for VkFramebufferCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassDescription {
    pub flags: VkSubpassDescriptionFlags,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub inputAttachmentCount: u32,
    pub pInputAttachments: *const VkAttachmentReference,
    pub colorAttachmentCount: u32,
    pub pColorAttachments: *const VkAttachmentReference,
    pub pResolveAttachments: *const VkAttachmentReference,
    pub pDepthStencilAttachment: *const VkAttachmentReference,
    pub preserveAttachmentCount: u32,
    pub pPreserveAttachments: *const u32,
}
#[test]
fn bindgen_test_layout_VkSubpassDescription() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassDescription>(),
        72usize,
        concat!("Size of: ", stringify!(VkSubpassDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassDescription>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubpassDescription))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_pipelineBindPoint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineBindPoint) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription),
                "::",
                stringify!(pipelineBindPoint)
            )
        );
    }
    test_field_pipelineBindPoint();
    fn test_field_inputAttachmentCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inputAttachmentCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription),
                "::",
                stringify!(inputAttachmentCount)
            )
        );
    }
    test_field_inputAttachmentCount();
    fn test_field_pInputAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pInputAttachments) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription),
                "::",
                stringify!(pInputAttachments)
            )
        );
    }
    test_field_pInputAttachments();
    fn test_field_colorAttachmentCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorAttachmentCount) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription),
                "::",
                stringify!(colorAttachmentCount)
            )
        );
    }
    test_field_colorAttachmentCount();
    fn test_field_pColorAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pColorAttachments) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription),
                "::",
                stringify!(pColorAttachments)
            )
        );
    }
    test_field_pColorAttachments();
    fn test_field_pResolveAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pResolveAttachments) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription),
                "::",
                stringify!(pResolveAttachments)
            )
        );
    }
    test_field_pResolveAttachments();
    fn test_field_pDepthStencilAttachment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDepthStencilAttachment) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription),
                "::",
                stringify!(pDepthStencilAttachment)
            )
        );
    }
    test_field_pDepthStencilAttachment();
    fn test_field_preserveAttachmentCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).preserveAttachmentCount) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription),
                "::",
                stringify!(preserveAttachmentCount)
            )
        );
    }
    test_field_preserveAttachmentCount();
    fn test_field_pPreserveAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pPreserveAttachments) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription),
                "::",
                stringify!(pPreserveAttachments)
            )
        );
    }
    test_field_pPreserveAttachments();
}
impl Default for VkSubpassDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkSubpassDependency {
    pub srcSubpass: u32,
    pub dstSubpass: u32,
    pub srcStageMask: VkPipelineStageFlags,
    pub dstStageMask: VkPipelineStageFlags,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub dependencyFlags: VkDependencyFlags,
}
#[test]
fn bindgen_test_layout_VkSubpassDependency() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassDependency>(),
        28usize,
        concat!("Size of: ", stringify!(VkSubpassDependency))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassDependency>(),
        4usize,
        concat!("Alignment of ", stringify!(VkSubpassDependency))
    );
    fn test_field_srcSubpass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcSubpass) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency),
                "::",
                stringify!(srcSubpass)
            )
        );
    }
    test_field_srcSubpass();
    fn test_field_dstSubpass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstSubpass) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency),
                "::",
                stringify!(dstSubpass)
            )
        );
    }
    test_field_dstSubpass();
    fn test_field_srcStageMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcStageMask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency),
                "::",
                stringify!(srcStageMask)
            )
        );
    }
    test_field_srcStageMask();
    fn test_field_dstStageMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstStageMask) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency),
                "::",
                stringify!(dstStageMask)
            )
        );
    }
    test_field_dstStageMask();
    fn test_field_srcAccessMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcAccessMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency),
                "::",
                stringify!(srcAccessMask)
            )
        );
    }
    test_field_srcAccessMask();
    fn test_field_dstAccessMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstAccessMask) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency),
                "::",
                stringify!(dstAccessMask)
            )
        );
    }
    test_field_dstAccessMask();
    fn test_field_dependencyFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dependencyFlags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency),
                "::",
                stringify!(dependencyFlags)
            )
        );
    }
    test_field_dependencyFlags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkRenderPassCreateFlags,
    pub attachmentCount: u32,
    pub pAttachments: *const VkAttachmentDescription,
    pub subpassCount: u32,
    pub pSubpasses: *const VkSubpassDescription,
    pub dependencyCount: u32,
    pub pDependencies: *const VkSubpassDependency,
}
#[test]
fn bindgen_test_layout_VkRenderPassCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassCreateInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VkRenderPassCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkRenderPassCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_attachmentCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attachmentCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo),
                "::",
                stringify!(attachmentCount)
            )
        );
    }
    test_field_attachmentCount();
    fn test_field_pAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pAttachments) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo),
                "::",
                stringify!(pAttachments)
            )
        );
    }
    test_field_pAttachments();
    fn test_field_subpassCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subpassCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo),
                "::",
                stringify!(subpassCount)
            )
        );
    }
    test_field_subpassCount();
    fn test_field_pSubpasses() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSubpasses) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo),
                "::",
                stringify!(pSubpasses)
            )
        );
    }
    test_field_pSubpasses();
    fn test_field_dependencyCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dependencyCount) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo),
                "::",
                stringify!(dependencyCount)
            )
        );
    }
    test_field_dependencyCount();
    fn test_field_pDependencies() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDependencies) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo),
                "::",
                stringify!(pDependencies)
            )
        );
    }
    test_field_pDependencies();
}
impl Default for VkRenderPassCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkCommandPoolCreateFlags,
    pub queueFamilyIndex: u32,
}
#[test]
fn bindgen_test_layout_VkCommandPoolCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkCommandPoolCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkCommandPoolCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCommandPoolCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCommandPoolCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandPoolCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandPoolCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandPoolCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandPoolCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandPoolCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandPoolCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_queueFamilyIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandPoolCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queueFamilyIndex) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandPoolCreateInfo),
                "::",
                stringify!(queueFamilyIndex)
            )
        );
    }
    test_field_queueFamilyIndex();
}
impl Default for VkCommandPoolCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBufferAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub commandPool: VkCommandPool,
    pub level: VkCommandBufferLevel,
    pub commandBufferCount: u32,
}
#[test]
fn bindgen_test_layout_VkCommandBufferAllocateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkCommandBufferAllocateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkCommandBufferAllocateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCommandBufferAllocateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCommandBufferAllocateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferAllocateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferAllocateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_commandPool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).commandPool) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferAllocateInfo),
                "::",
                stringify!(commandPool)
            )
        );
    }
    test_field_commandPool();
    fn test_field_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferAllocateInfo),
                "::",
                stringify!(level)
            )
        );
    }
    test_field_level();
    fn test_field_commandBufferCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).commandBufferCount) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferAllocateInfo),
                "::",
                stringify!(commandBufferCount)
            )
        );
    }
    test_field_commandBufferCount();
}
impl Default for VkCommandBufferAllocateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBufferInheritanceInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub renderPass: VkRenderPass,
    pub subpass: u32,
    pub framebuffer: VkFramebuffer,
    pub occlusionQueryEnable: VkBool32,
    pub queryFlags: VkQueryControlFlags,
    pub pipelineStatistics: VkQueryPipelineStatisticFlags,
}
#[test]
fn bindgen_test_layout_VkCommandBufferInheritanceInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkCommandBufferInheritanceInfo>(),
        56usize,
        concat!("Size of: ", stringify!(VkCommandBufferInheritanceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCommandBufferInheritanceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCommandBufferInheritanceInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferInheritanceInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferInheritanceInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_renderPass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferInheritanceInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).renderPass) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceInfo),
                "::",
                stringify!(renderPass)
            )
        );
    }
    test_field_renderPass();
    fn test_field_subpass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferInheritanceInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subpass) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceInfo),
                "::",
                stringify!(subpass)
            )
        );
    }
    test_field_subpass();
    fn test_field_framebuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferInheritanceInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).framebuffer) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceInfo),
                "::",
                stringify!(framebuffer)
            )
        );
    }
    test_field_framebuffer();
    fn test_field_occlusionQueryEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferInheritanceInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).occlusionQueryEnable) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceInfo),
                "::",
                stringify!(occlusionQueryEnable)
            )
        );
    }
    test_field_occlusionQueryEnable();
    fn test_field_queryFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferInheritanceInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queryFlags) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceInfo),
                "::",
                stringify!(queryFlags)
            )
        );
    }
    test_field_queryFlags();
    fn test_field_pipelineStatistics() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferInheritanceInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineStatistics) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceInfo),
                "::",
                stringify!(pipelineStatistics)
            )
        );
    }
    test_field_pipelineStatistics();
}
impl Default for VkCommandBufferInheritanceInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBufferBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkCommandBufferUsageFlags,
    pub pInheritanceInfo: *const VkCommandBufferInheritanceInfo,
}
#[test]
fn bindgen_test_layout_VkCommandBufferBeginInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkCommandBufferBeginInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkCommandBufferBeginInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCommandBufferBeginInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCommandBufferBeginInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferBeginInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferBeginInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferBeginInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_pInheritanceInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pInheritanceInfo) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferBeginInfo),
                "::",
                stringify!(pInheritanceInfo)
            )
        );
    }
    test_field_pInheritanceInfo();
}
impl Default for VkCommandBufferBeginInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkBufferCopy {
    pub srcOffset: VkDeviceSize,
    pub dstOffset: VkDeviceSize,
    pub size: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBufferCopy() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferCopy>(),
        24usize,
        concat!("Size of: ", stringify!(VkBufferCopy))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferCopy>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferCopy))
    );
    fn test_field_srcOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferCopy>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcOffset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCopy),
                "::",
                stringify!(srcOffset)
            )
        );
    }
    test_field_srcOffset();
    fn test_field_dstOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferCopy>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstOffset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCopy),
                "::",
                stringify!(dstOffset)
            )
        );
    }
    test_field_dstOffset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferCopy>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCopy),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkImageSubresourceLayers {
    pub aspectMask: VkImageAspectFlags,
    pub mipLevel: u32,
    pub baseArrayLayer: u32,
    pub layerCount: u32,
}
#[test]
fn bindgen_test_layout_VkImageSubresourceLayers() {
    assert_eq!(
        ::std::mem::size_of::<VkImageSubresourceLayers>(),
        16usize,
        concat!("Size of: ", stringify!(VkImageSubresourceLayers))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageSubresourceLayers>(),
        4usize,
        concat!("Alignment of ", stringify!(VkImageSubresourceLayers))
    );
    fn test_field_aspectMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSubresourceLayers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aspectMask) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSubresourceLayers),
                "::",
                stringify!(aspectMask)
            )
        );
    }
    test_field_aspectMask();
    fn test_field_mipLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSubresourceLayers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mipLevel) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSubresourceLayers),
                "::",
                stringify!(mipLevel)
            )
        );
    }
    test_field_mipLevel();
    fn test_field_baseArrayLayer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSubresourceLayers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).baseArrayLayer) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSubresourceLayers),
                "::",
                stringify!(baseArrayLayer)
            )
        );
    }
    test_field_baseArrayLayer();
    fn test_field_layerCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSubresourceLayers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layerCount) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSubresourceLayers),
                "::",
                stringify!(layerCount)
            )
        );
    }
    test_field_layerCount();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkBufferImageCopy {
    pub bufferOffset: VkDeviceSize,
    pub bufferRowLength: u32,
    pub bufferImageHeight: u32,
    pub imageSubresource: VkImageSubresourceLayers,
    pub imageOffset: VkOffset3D,
    pub imageExtent: VkExtent3D,
}
#[test]
fn bindgen_test_layout_VkBufferImageCopy() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferImageCopy>(),
        56usize,
        concat!("Size of: ", stringify!(VkBufferImageCopy))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferImageCopy>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferImageCopy))
    );
    fn test_field_bufferOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferImageCopy>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferOffset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferImageCopy),
                "::",
                stringify!(bufferOffset)
            )
        );
    }
    test_field_bufferOffset();
    fn test_field_bufferRowLength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferImageCopy>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferRowLength) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferImageCopy),
                "::",
                stringify!(bufferRowLength)
            )
        );
    }
    test_field_bufferRowLength();
    fn test_field_bufferImageHeight() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferImageCopy>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferImageHeight) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferImageCopy),
                "::",
                stringify!(bufferImageHeight)
            )
        );
    }
    test_field_bufferImageHeight();
    fn test_field_imageSubresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferImageCopy>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageSubresource) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferImageCopy),
                "::",
                stringify!(imageSubresource)
            )
        );
    }
    test_field_imageSubresource();
    fn test_field_imageOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferImageCopy>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageOffset) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferImageCopy),
                "::",
                stringify!(imageOffset)
            )
        );
    }
    test_field_imageOffset();
    fn test_field_imageExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferImageCopy>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageExtent) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferImageCopy),
                "::",
                stringify!(imageExtent)
            )
        );
    }
    test_field_imageExtent();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkClearColorValue {
    pub float32: [f32; 4usize],
    pub int32: [i32; 4usize],
    pub uint32: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_VkClearColorValue() {
    assert_eq!(
        ::std::mem::size_of::<VkClearColorValue>(),
        16usize,
        concat!("Size of: ", stringify!(VkClearColorValue))
    );
    assert_eq!(
        ::std::mem::align_of::<VkClearColorValue>(),
        4usize,
        concat!("Alignment of ", stringify!(VkClearColorValue))
    );
    fn test_field_float32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkClearColorValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).float32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkClearColorValue),
                "::",
                stringify!(float32)
            )
        );
    }
    test_field_float32();
    fn test_field_int32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkClearColorValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).int32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkClearColorValue),
                "::",
                stringify!(int32)
            )
        );
    }
    test_field_int32();
    fn test_field_uint32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkClearColorValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uint32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkClearColorValue),
                "::",
                stringify!(uint32)
            )
        );
    }
    test_field_uint32();
}
impl Default for VkClearColorValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkClearDepthStencilValue {
    pub depth: f32,
    pub stencil: u32,
}
#[test]
fn bindgen_test_layout_VkClearDepthStencilValue() {
    assert_eq!(
        ::std::mem::size_of::<VkClearDepthStencilValue>(),
        8usize,
        concat!("Size of: ", stringify!(VkClearDepthStencilValue))
    );
    assert_eq!(
        ::std::mem::align_of::<VkClearDepthStencilValue>(),
        4usize,
        concat!("Alignment of ", stringify!(VkClearDepthStencilValue))
    );
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkClearDepthStencilValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkClearDepthStencilValue),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
    fn test_field_stencil() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkClearDepthStencilValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stencil) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkClearDepthStencilValue),
                "::",
                stringify!(stencil)
            )
        );
    }
    test_field_stencil();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkClearValue {
    pub color: VkClearColorValue,
    pub depthStencil: VkClearDepthStencilValue,
}
#[test]
fn bindgen_test_layout_VkClearValue() {
    assert_eq!(
        ::std::mem::size_of::<VkClearValue>(),
        16usize,
        concat!("Size of: ", stringify!(VkClearValue))
    );
    assert_eq!(
        ::std::mem::align_of::<VkClearValue>(),
        4usize,
        concat!("Alignment of ", stringify!(VkClearValue))
    );
    fn test_field_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkClearValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkClearValue),
                "::",
                stringify!(color)
            )
        );
    }
    test_field_color();
    fn test_field_depthStencil() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkClearValue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthStencil) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkClearValue),
                "::",
                stringify!(depthStencil)
            )
        );
    }
    test_field_depthStencil();
}
impl Default for VkClearValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkClearAttachment {
    pub aspectMask: VkImageAspectFlags,
    pub colorAttachment: u32,
    pub clearValue: VkClearValue,
}
#[test]
fn bindgen_test_layout_VkClearAttachment() {
    assert_eq!(
        ::std::mem::size_of::<VkClearAttachment>(),
        24usize,
        concat!("Size of: ", stringify!(VkClearAttachment))
    );
    assert_eq!(
        ::std::mem::align_of::<VkClearAttachment>(),
        4usize,
        concat!("Alignment of ", stringify!(VkClearAttachment))
    );
    fn test_field_aspectMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkClearAttachment>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aspectMask) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkClearAttachment),
                "::",
                stringify!(aspectMask)
            )
        );
    }
    test_field_aspectMask();
    fn test_field_colorAttachment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkClearAttachment>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorAttachment) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkClearAttachment),
                "::",
                stringify!(colorAttachment)
            )
        );
    }
    test_field_colorAttachment();
    fn test_field_clearValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkClearAttachment>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clearValue) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkClearAttachment),
                "::",
                stringify!(clearValue)
            )
        );
    }
    test_field_clearValue();
}
impl Default for VkClearAttachment {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkClearRect {
    pub rect: VkRect2D,
    pub baseArrayLayer: u32,
    pub layerCount: u32,
}
#[test]
fn bindgen_test_layout_VkClearRect() {
    assert_eq!(
        ::std::mem::size_of::<VkClearRect>(),
        24usize,
        concat!("Size of: ", stringify!(VkClearRect))
    );
    assert_eq!(
        ::std::mem::align_of::<VkClearRect>(),
        4usize,
        concat!("Alignment of ", stringify!(VkClearRect))
    );
    fn test_field_rect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkClearRect>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rect) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkClearRect),
                "::",
                stringify!(rect)
            )
        );
    }
    test_field_rect();
    fn test_field_baseArrayLayer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkClearRect>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).baseArrayLayer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkClearRect),
                "::",
                stringify!(baseArrayLayer)
            )
        );
    }
    test_field_baseArrayLayer();
    fn test_field_layerCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkClearRect>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layerCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkClearRect),
                "::",
                stringify!(layerCount)
            )
        );
    }
    test_field_layerCount();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkImageBlit {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffsets: [VkOffset3D; 2usize],
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffsets: [VkOffset3D; 2usize],
}
#[test]
fn bindgen_test_layout_VkImageBlit() {
    assert_eq!(
        ::std::mem::size_of::<VkImageBlit>(),
        80usize,
        concat!("Size of: ", stringify!(VkImageBlit))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageBlit>(),
        4usize,
        concat!("Alignment of ", stringify!(VkImageBlit))
    );
    fn test_field_srcSubresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageBlit>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcSubresource) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageBlit),
                "::",
                stringify!(srcSubresource)
            )
        );
    }
    test_field_srcSubresource();
    fn test_field_srcOffsets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageBlit>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcOffsets) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageBlit),
                "::",
                stringify!(srcOffsets)
            )
        );
    }
    test_field_srcOffsets();
    fn test_field_dstSubresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageBlit>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstSubresource) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageBlit),
                "::",
                stringify!(dstSubresource)
            )
        );
    }
    test_field_dstSubresource();
    fn test_field_dstOffsets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageBlit>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstOffsets) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageBlit),
                "::",
                stringify!(dstOffsets)
            )
        );
    }
    test_field_dstOffsets();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkImageCopy {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffset: VkOffset3D,
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffset: VkOffset3D,
    pub extent: VkExtent3D,
}
#[test]
fn bindgen_test_layout_VkImageCopy() {
    assert_eq!(
        ::std::mem::size_of::<VkImageCopy>(),
        68usize,
        concat!("Size of: ", stringify!(VkImageCopy))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageCopy>(),
        4usize,
        concat!("Alignment of ", stringify!(VkImageCopy))
    );
    fn test_field_srcSubresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCopy>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcSubresource) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCopy),
                "::",
                stringify!(srcSubresource)
            )
        );
    }
    test_field_srcSubresource();
    fn test_field_srcOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCopy>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcOffset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCopy),
                "::",
                stringify!(srcOffset)
            )
        );
    }
    test_field_srcOffset();
    fn test_field_dstSubresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCopy>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstSubresource) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCopy),
                "::",
                stringify!(dstSubresource)
            )
        );
    }
    test_field_dstSubresource();
    fn test_field_dstOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCopy>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstOffset) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCopy),
                "::",
                stringify!(dstOffset)
            )
        );
    }
    test_field_dstOffset();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCopy>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCopy),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkImageResolve {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffset: VkOffset3D,
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffset: VkOffset3D,
    pub extent: VkExtent3D,
}
#[test]
fn bindgen_test_layout_VkImageResolve() {
    assert_eq!(
        ::std::mem::size_of::<VkImageResolve>(),
        68usize,
        concat!("Size of: ", stringify!(VkImageResolve))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageResolve>(),
        4usize,
        concat!("Alignment of ", stringify!(VkImageResolve))
    );
    fn test_field_srcSubresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageResolve>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcSubresource) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageResolve),
                "::",
                stringify!(srcSubresource)
            )
        );
    }
    test_field_srcSubresource();
    fn test_field_srcOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageResolve>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcOffset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageResolve),
                "::",
                stringify!(srcOffset)
            )
        );
    }
    test_field_srcOffset();
    fn test_field_dstSubresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageResolve>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstSubresource) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageResolve),
                "::",
                stringify!(dstSubresource)
            )
        );
    }
    test_field_dstSubresource();
    fn test_field_dstOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageResolve>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstOffset) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageResolve),
                "::",
                stringify!(dstOffset)
            )
        );
    }
    test_field_dstOffset();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageResolve>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageResolve),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub renderPass: VkRenderPass,
    pub framebuffer: VkFramebuffer,
    pub renderArea: VkRect2D,
    pub clearValueCount: u32,
    pub pClearValues: *const VkClearValue,
}
#[test]
fn bindgen_test_layout_VkRenderPassBeginInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassBeginInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VkRenderPassBeginInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassBeginInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkRenderPassBeginInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassBeginInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassBeginInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_renderPass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).renderPass) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassBeginInfo),
                "::",
                stringify!(renderPass)
            )
        );
    }
    test_field_renderPass();
    fn test_field_framebuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).framebuffer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassBeginInfo),
                "::",
                stringify!(framebuffer)
            )
        );
    }
    test_field_framebuffer();
    fn test_field_renderArea() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).renderArea) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassBeginInfo),
                "::",
                stringify!(renderArea)
            )
        );
    }
    test_field_renderArea();
    fn test_field_clearValueCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clearValueCount) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassBeginInfo),
                "::",
                stringify!(clearValueCount)
            )
        );
    }
    test_field_clearValueCount();
    fn test_field_pClearValues() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pClearValues) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassBeginInfo),
                "::",
                stringify!(pClearValues)
            )
        );
    }
    test_field_pClearValues();
}
impl Default for VkRenderPassBeginInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCreateInstance = ::std::option::Option<
    unsafe extern "C" fn(
        pCreateInfo: *const VkInstanceCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pInstance: *mut VkInstance,
    ) -> VkResult,
>;
pub type PFN_vkDestroyInstance = ::std::option::Option<
    unsafe extern "C" fn(instance: VkInstance, pAllocator: *const VkAllocationCallbacks),
>;
pub type PFN_vkEnumeratePhysicalDevices = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pPhysicalDeviceCount: *mut u32,
        pPhysicalDevices: *mut VkPhysicalDevice,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceFeatures = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pFeatures: *mut VkPhysicalDeviceFeatures,
    ),
>;
pub type PFN_vkGetPhysicalDeviceFormatProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        pFormatProperties: *mut VkFormatProperties,
    ),
>;
pub type PFN_vkGetPhysicalDeviceImageFormatProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        type_: VkImageType,
        tiling: VkImageTiling,
        usage: VkImageUsageFlags,
        flags: VkImageCreateFlags,
        pImageFormatProperties: *mut VkImageFormatProperties,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties,
    ),
>;
pub type PFN_vkGetPhysicalDeviceQueueFamilyProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pQueueFamilyPropertyCount: *mut u32,
        pQueueFamilyProperties: *mut VkQueueFamilyProperties,
    ),
>;
pub type PFN_vkGetPhysicalDeviceMemoryProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties,
    ),
>;
pub type PFN_vkGetInstanceProcAddr = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pName: *const ::std::os::raw::c_char,
    ) -> PFN_vkVoidFunction,
>;
pub type PFN_vkGetDeviceProcAddr = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pName: *const ::std::os::raw::c_char,
    ) -> PFN_vkVoidFunction,
>;
pub type PFN_vkCreateDevice = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pCreateInfo: *const VkDeviceCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDevice: *mut VkDevice,
    ) -> VkResult,
>;
pub type PFN_vkDestroyDevice = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, pAllocator: *const VkAllocationCallbacks),
>;
pub type PFN_vkEnumerateInstanceExtensionProperties = ::std::option::Option<
    unsafe extern "C" fn(
        pLayerName: *const ::std::os::raw::c_char,
        pPropertyCount: *mut u32,
        pProperties: *mut VkExtensionProperties,
    ) -> VkResult,
>;
pub type PFN_vkEnumerateDeviceExtensionProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pLayerName: *const ::std::os::raw::c_char,
        pPropertyCount: *mut u32,
        pProperties: *mut VkExtensionProperties,
    ) -> VkResult,
>;
pub type PFN_vkEnumerateInstanceLayerProperties = ::std::option::Option<
    unsafe extern "C" fn(pPropertyCount: *mut u32, pProperties: *mut VkLayerProperties) -> VkResult,
>;
pub type PFN_vkEnumerateDeviceLayerProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkLayerProperties,
    ) -> VkResult,
>;
pub type PFN_vkGetDeviceQueue = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        queueFamilyIndex: u32,
        queueIndex: u32,
        pQueue: *mut VkQueue,
    ),
>;
pub type PFN_vkQueueSubmit = ::std::option::Option<
    unsafe extern "C" fn(
        queue: VkQueue,
        submitCount: u32,
        pSubmits: *const VkSubmitInfo,
        fence: VkFence,
    ) -> VkResult,
>;
pub type PFN_vkQueueWaitIdle =
    ::std::option::Option<unsafe extern "C" fn(queue: VkQueue) -> VkResult>;
pub type PFN_vkDeviceWaitIdle =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice) -> VkResult>;
pub type PFN_vkAllocateMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pAllocateInfo: *const VkMemoryAllocateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pMemory: *mut VkDeviceMemory,
    ) -> VkResult,
>;
pub type PFN_vkFreeMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memory: VkDeviceMemory,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkMapMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memory: VkDeviceMemory,
        offset: VkDeviceSize,
        size: VkDeviceSize,
        flags: VkMemoryMapFlags,
        ppData: *mut *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkUnmapMemory =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice, memory: VkDeviceMemory)>;
pub type PFN_vkFlushMappedMemoryRanges = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memoryRangeCount: u32,
        pMemoryRanges: *const VkMappedMemoryRange,
    ) -> VkResult,
>;
pub type PFN_vkInvalidateMappedMemoryRanges = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memoryRangeCount: u32,
        pMemoryRanges: *const VkMappedMemoryRange,
    ) -> VkResult,
>;
pub type PFN_vkGetDeviceMemoryCommitment = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        memory: VkDeviceMemory,
        pCommittedMemoryInBytes: *mut VkDeviceSize,
    ),
>;
pub type PFN_vkBindBufferMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        buffer: VkBuffer,
        memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize,
    ) -> VkResult,
>;
pub type PFN_vkBindImageMemory = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize,
    ) -> VkResult,
>;
pub type PFN_vkGetBufferMemoryRequirements = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        buffer: VkBuffer,
        pMemoryRequirements: *mut VkMemoryRequirements,
    ),
>;
pub type PFN_vkGetImageMemoryRequirements = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pMemoryRequirements: *mut VkMemoryRequirements,
    ),
>;
pub type PFN_vkGetImageSparseMemoryRequirements = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pSparseMemoryRequirementCount: *mut u32,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements,
    ),
>;
pub type PFN_vkGetPhysicalDeviceSparseImageFormatProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        type_: VkImageType,
        samples: VkSampleCountFlagBits,
        usage: VkImageUsageFlags,
        tiling: VkImageTiling,
        pPropertyCount: *mut u32,
        pProperties: *mut VkSparseImageFormatProperties,
    ),
>;
pub type PFN_vkQueueBindSparse = ::std::option::Option<
    unsafe extern "C" fn(
        queue: VkQueue,
        bindInfoCount: u32,
        pBindInfo: *const VkBindSparseInfo,
        fence: VkFence,
    ) -> VkResult,
>;
pub type PFN_vkCreateFence = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkFenceCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pFence: *mut VkFence,
    ) -> VkResult,
>;
pub type PFN_vkDestroyFence = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        fence: VkFence,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkResetFences = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, fenceCount: u32, pFences: *const VkFence) -> VkResult,
>;
pub type PFN_vkGetFenceStatus =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice, fence: VkFence) -> VkResult>;
pub type PFN_vkWaitForFences = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        fenceCount: u32,
        pFences: *const VkFence,
        waitAll: VkBool32,
        timeout: u64,
    ) -> VkResult,
>;
pub type PFN_vkCreateSemaphore = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkSemaphoreCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSemaphore: *mut VkSemaphore,
    ) -> VkResult,
>;
pub type PFN_vkDestroySemaphore = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        semaphore: VkSemaphore,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateEvent = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkEventCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pEvent: *mut VkEvent,
    ) -> VkResult,
>;
pub type PFN_vkDestroyEvent = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        event: VkEvent,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetEventStatus =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice, event: VkEvent) -> VkResult>;
pub type PFN_vkSetEvent =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice, event: VkEvent) -> VkResult>;
pub type PFN_vkResetEvent =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice, event: VkEvent) -> VkResult>;
pub type PFN_vkCreateQueryPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkQueryPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pQueryPool: *mut VkQueryPool,
    ) -> VkResult,
>;
pub type PFN_vkDestroyQueryPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        queryPool: VkQueryPool,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetQueryPoolResults = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
        dataSize: usize,
        pData: *mut ::std::os::raw::c_void,
        stride: VkDeviceSize,
        flags: VkQueryResultFlags,
    ) -> VkResult,
>;
pub type PFN_vkCreateBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkBufferCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pBuffer: *mut VkBuffer,
    ) -> VkResult,
>;
pub type PFN_vkDestroyBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        buffer: VkBuffer,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateBufferView = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkBufferViewCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pView: *mut VkBufferView,
    ) -> VkResult,
>;
pub type PFN_vkDestroyBufferView = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        bufferView: VkBufferView,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateImage = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkImageCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pImage: *mut VkImage,
    ) -> VkResult,
>;
pub type PFN_vkDestroyImage = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetImageSubresourceLayout = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pSubresource: *const VkImageSubresource,
        pLayout: *mut VkSubresourceLayout,
    ),
>;
pub type PFN_vkCreateImageView = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkImageViewCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pView: *mut VkImageView,
    ) -> VkResult,
>;
pub type PFN_vkDestroyImageView = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        imageView: VkImageView,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateShaderModule = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkShaderModuleCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pShaderModule: *mut VkShaderModule,
    ) -> VkResult,
>;
pub type PFN_vkDestroyShaderModule = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        shaderModule: VkShaderModule,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreatePipelineCache = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkPipelineCacheCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelineCache: *mut VkPipelineCache,
    ) -> VkResult,
>;
pub type PFN_vkDestroyPipelineCache = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetPipelineCacheData = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        pDataSize: *mut usize,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkMergePipelineCaches = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        dstCache: VkPipelineCache,
        srcCacheCount: u32,
        pSrcCaches: *const VkPipelineCache,
    ) -> VkResult,
>;
pub type PFN_vkCreateGraphicsPipelines = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        createInfoCount: u32,
        pCreateInfos: *const VkGraphicsPipelineCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult,
>;
pub type PFN_vkCreateComputePipelines = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        createInfoCount: u32,
        pCreateInfos: *const VkComputePipelineCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult,
>;
pub type PFN_vkDestroyPipeline = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipeline: VkPipeline,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreatePipelineLayout = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkPipelineLayoutCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelineLayout: *mut VkPipelineLayout,
    ) -> VkResult,
>;
pub type PFN_vkDestroyPipelineLayout = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipelineLayout: VkPipelineLayout,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateSampler = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkSamplerCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSampler: *mut VkSampler,
    ) -> VkResult,
>;
pub type PFN_vkDestroySampler = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        sampler: VkSampler,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateDescriptorSetLayout = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSetLayout: *mut VkDescriptorSetLayout,
    ) -> VkResult,
>;
pub type PFN_vkDestroyDescriptorSetLayout = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorSetLayout: VkDescriptorSetLayout,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateDescriptorPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDescriptorPool: *mut VkDescriptorPool,
    ) -> VkResult,
>;
pub type PFN_vkDestroyDescriptorPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorPool: VkDescriptorPool,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkResetDescriptorPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorPool: VkDescriptorPool,
        flags: VkDescriptorPoolResetFlags,
    ) -> VkResult,
>;
pub type PFN_vkAllocateDescriptorSets = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pAllocateInfo: *const VkDescriptorSetAllocateInfo,
        pDescriptorSets: *mut VkDescriptorSet,
    ) -> VkResult,
>;
pub type PFN_vkFreeDescriptorSets = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorPool: VkDescriptorPool,
        descriptorSetCount: u32,
        pDescriptorSets: *const VkDescriptorSet,
    ) -> VkResult,
>;
pub type PFN_vkUpdateDescriptorSets = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorWriteCount: u32,
        pDescriptorWrites: *const VkWriteDescriptorSet,
        descriptorCopyCount: u32,
        pDescriptorCopies: *const VkCopyDescriptorSet,
    ),
>;
pub type PFN_vkCreateFramebuffer = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkFramebufferCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pFramebuffer: *mut VkFramebuffer,
    ) -> VkResult,
>;
pub type PFN_vkDestroyFramebuffer = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        framebuffer: VkFramebuffer,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateRenderPass = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkRenderPassCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pRenderPass: *mut VkRenderPass,
    ) -> VkResult,
>;
pub type PFN_vkDestroyRenderPass = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        renderPass: VkRenderPass,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetRenderAreaGranularity = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, renderPass: VkRenderPass, pGranularity: *mut VkExtent2D),
>;
pub type PFN_vkCreateCommandPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkCommandPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pCommandPool: *mut VkCommandPool,
    ) -> VkResult,
>;
pub type PFN_vkDestroyCommandPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        commandPool: VkCommandPool,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkResetCommandPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        commandPool: VkCommandPool,
        flags: VkCommandPoolResetFlags,
    ) -> VkResult,
>;
pub type PFN_vkAllocateCommandBuffers = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pAllocateInfo: *const VkCommandBufferAllocateInfo,
        pCommandBuffers: *mut VkCommandBuffer,
    ) -> VkResult,
>;
pub type PFN_vkFreeCommandBuffers = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        commandPool: VkCommandPool,
        commandBufferCount: u32,
        pCommandBuffers: *const VkCommandBuffer,
    ),
>;
pub type PFN_vkBeginCommandBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pBeginInfo: *const VkCommandBufferBeginInfo,
    ) -> VkResult,
>;
pub type PFN_vkEndCommandBuffer =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer) -> VkResult>;
pub type PFN_vkResetCommandBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        flags: VkCommandBufferResetFlags,
    ) -> VkResult,
>;
pub type PFN_vkCmdBindPipeline = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        pipeline: VkPipeline,
    ),
>;
pub type PFN_vkCmdSetViewport = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstViewport: u32,
        viewportCount: u32,
        pViewports: *const VkViewport,
    ),
>;
pub type PFN_vkCmdSetScissor = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstScissor: u32,
        scissorCount: u32,
        pScissors: *const VkRect2D,
    ),
>;
pub type PFN_vkCmdSetLineWidth =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer, lineWidth: f32)>;
pub type PFN_vkCmdSetDepthBias = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        depthBiasConstantFactor: f32,
        depthBiasClamp: f32,
        depthBiasSlopeFactor: f32,
    ),
>;
pub type PFN_vkCmdSetBlendConstants = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, blendConstants: *const f32),
>;
pub type PFN_vkCmdSetDepthBounds = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, minDepthBounds: f32, maxDepthBounds: f32),
>;
pub type PFN_vkCmdSetStencilCompareMask = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        compareMask: u32,
    ),
>;
pub type PFN_vkCmdSetStencilWriteMask = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        writeMask: u32,
    ),
>;
pub type PFN_vkCmdSetStencilReference = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        reference: u32,
    ),
>;
pub type PFN_vkCmdBindDescriptorSets = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        layout: VkPipelineLayout,
        firstSet: u32,
        descriptorSetCount: u32,
        pDescriptorSets: *const VkDescriptorSet,
        dynamicOffsetCount: u32,
        pDynamicOffsets: *const u32,
    ),
>;
pub type PFN_vkCmdBindIndexBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        indexType: VkIndexType,
    ),
>;
pub type PFN_vkCmdBindVertexBuffers = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstBinding: u32,
        bindingCount: u32,
        pBuffers: *const VkBuffer,
        pOffsets: *const VkDeviceSize,
    ),
>;
pub type PFN_vkCmdDraw = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        vertexCount: u32,
        instanceCount: u32,
        firstVertex: u32,
        firstInstance: u32,
    ),
>;
pub type PFN_vkCmdDrawIndexed = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        indexCount: u32,
        instanceCount: u32,
        firstIndex: u32,
        vertexOffset: i32,
        firstInstance: u32,
    ),
>;
pub type PFN_vkCmdDrawIndirect = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        drawCount: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCmdDrawIndexedIndirect = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        drawCount: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCmdDispatch = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        groupCountX: u32,
        groupCountY: u32,
        groupCountZ: u32,
    ),
>;
pub type PFN_vkCmdDispatchIndirect = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, buffer: VkBuffer, offset: VkDeviceSize),
>;
pub type PFN_vkCmdCopyBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcBuffer: VkBuffer,
        dstBuffer: VkBuffer,
        regionCount: u32,
        pRegions: *const VkBufferCopy,
    ),
>;
pub type PFN_vkCmdCopyImage = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: u32,
        pRegions: *const VkImageCopy,
    ),
>;
pub type PFN_vkCmdBlitImage = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: u32,
        pRegions: *const VkImageBlit,
        filter: VkFilter,
    ),
>;
pub type PFN_vkCmdCopyBufferToImage = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcBuffer: VkBuffer,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: u32,
        pRegions: *const VkBufferImageCopy,
    ),
>;
pub type PFN_vkCmdCopyImageToBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstBuffer: VkBuffer,
        regionCount: u32,
        pRegions: *const VkBufferImageCopy,
    ),
>;
pub type PFN_vkCmdUpdateBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        dataSize: VkDeviceSize,
        pData: *const ::std::os::raw::c_void,
    ),
>;
pub type PFN_vkCmdFillBuffer = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        size: VkDeviceSize,
        data: u32,
    ),
>;
pub type PFN_vkCmdClearColorImage = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        image: VkImage,
        imageLayout: VkImageLayout,
        pColor: *const VkClearColorValue,
        rangeCount: u32,
        pRanges: *const VkImageSubresourceRange,
    ),
>;
pub type PFN_vkCmdClearDepthStencilImage = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        image: VkImage,
        imageLayout: VkImageLayout,
        pDepthStencil: *const VkClearDepthStencilValue,
        rangeCount: u32,
        pRanges: *const VkImageSubresourceRange,
    ),
>;
pub type PFN_vkCmdClearAttachments = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        attachmentCount: u32,
        pAttachments: *const VkClearAttachment,
        rectCount: u32,
        pRects: *const VkClearRect,
    ),
>;
pub type PFN_vkCmdResolveImage = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: u32,
        pRegions: *const VkImageResolve,
    ),
>;
pub type PFN_vkCmdSetEvent = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        stageMask: VkPipelineStageFlags,
    ),
>;
pub type PFN_vkCmdResetEvent = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        stageMask: VkPipelineStageFlags,
    ),
>;
pub type PFN_vkCmdWaitEvents = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        eventCount: u32,
        pEvents: *const VkEvent,
        srcStageMask: VkPipelineStageFlags,
        dstStageMask: VkPipelineStageFlags,
        memoryBarrierCount: u32,
        pMemoryBarriers: *const VkMemoryBarrier,
        bufferMemoryBarrierCount: u32,
        pBufferMemoryBarriers: *const VkBufferMemoryBarrier,
        imageMemoryBarrierCount: u32,
        pImageMemoryBarriers: *const VkImageMemoryBarrier,
    ),
>;
pub type PFN_vkCmdPipelineBarrier = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        srcStageMask: VkPipelineStageFlags,
        dstStageMask: VkPipelineStageFlags,
        dependencyFlags: VkDependencyFlags,
        memoryBarrierCount: u32,
        pMemoryBarriers: *const VkMemoryBarrier,
        bufferMemoryBarrierCount: u32,
        pBufferMemoryBarriers: *const VkBufferMemoryBarrier,
        imageMemoryBarrierCount: u32,
        pImageMemoryBarriers: *const VkImageMemoryBarrier,
    ),
>;
pub type PFN_vkCmdBeginQuery = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        query: u32,
        flags: VkQueryControlFlags,
    ),
>;
pub type PFN_vkCmdEndQuery = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32),
>;
pub type PFN_vkCmdResetQueryPool = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
    ),
>;
pub type PFN_vkCmdWriteTimestamp = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pipelineStage: VkPipelineStageFlagBits,
        queryPool: VkQueryPool,
        query: u32,
    ),
>;
pub type PFN_vkCmdCopyQueryPoolResults = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        stride: VkDeviceSize,
        flags: VkQueryResultFlags,
    ),
>;
pub type PFN_vkCmdPushConstants = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        layout: VkPipelineLayout,
        stageFlags: VkShaderStageFlags,
        offset: u32,
        size: u32,
        pValues: *const ::std::os::raw::c_void,
    ),
>;
pub type PFN_vkCmdBeginRenderPass = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pRenderPassBegin: *const VkRenderPassBeginInfo,
        contents: VkSubpassContents,
    ),
>;
pub type PFN_vkCmdNextSubpass = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, contents: VkSubpassContents),
>;
pub type PFN_vkCmdEndRenderPass =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer)>;
pub type PFN_vkCmdExecuteCommands = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        commandBufferCount: u32,
        pCommandBuffers: *const VkCommandBuffer,
    ),
>;
extern "C" {
    pub fn vkCreateInstance(
        pCreateInfo: *const VkInstanceCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pInstance: *mut VkInstance,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyInstance(instance: VkInstance, pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkEnumeratePhysicalDevices(
        instance: VkInstance,
        pPhysicalDeviceCount: *mut u32,
        pPhysicalDevices: *mut VkPhysicalDevice,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceFeatures(
        physicalDevice: VkPhysicalDevice,
        pFeatures: *mut VkPhysicalDeviceFeatures,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceFormatProperties(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        pFormatProperties: *mut VkFormatProperties,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceImageFormatProperties(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        type_: VkImageType,
        tiling: VkImageTiling,
        usage: VkImageUsageFlags,
        flags: VkImageCreateFlags,
        pImageFormatProperties: *mut VkImageFormatProperties,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceProperties(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceQueueFamilyProperties(
        physicalDevice: VkPhysicalDevice,
        pQueueFamilyPropertyCount: *mut u32,
        pQueueFamilyProperties: *mut VkQueueFamilyProperties,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceMemoryProperties(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties,
    );
}
extern "C" {
    pub fn vkGetInstanceProcAddr(
        instance: VkInstance,
        pName: *const ::std::os::raw::c_char,
    ) -> PFN_vkVoidFunction;
}
extern "C" {
    pub fn vkGetDeviceProcAddr(
        device: VkDevice,
        pName: *const ::std::os::raw::c_char,
    ) -> PFN_vkVoidFunction;
}
extern "C" {
    pub fn vkCreateDevice(
        physicalDevice: VkPhysicalDevice,
        pCreateInfo: *const VkDeviceCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDevice: *mut VkDevice,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyDevice(device: VkDevice, pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkEnumerateInstanceExtensionProperties(
        pLayerName: *const ::std::os::raw::c_char,
        pPropertyCount: *mut u32,
        pProperties: *mut VkExtensionProperties,
    ) -> VkResult;
}
extern "C" {
    pub fn vkEnumerateDeviceExtensionProperties(
        physicalDevice: VkPhysicalDevice,
        pLayerName: *const ::std::os::raw::c_char,
        pPropertyCount: *mut u32,
        pProperties: *mut VkExtensionProperties,
    ) -> VkResult;
}
extern "C" {
    pub fn vkEnumerateInstanceLayerProperties(
        pPropertyCount: *mut u32,
        pProperties: *mut VkLayerProperties,
    ) -> VkResult;
}
extern "C" {
    pub fn vkEnumerateDeviceLayerProperties(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkLayerProperties,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDeviceQueue(
        device: VkDevice,
        queueFamilyIndex: u32,
        queueIndex: u32,
        pQueue: *mut VkQueue,
    );
}
extern "C" {
    pub fn vkQueueSubmit(
        queue: VkQueue,
        submitCount: u32,
        pSubmits: *const VkSubmitInfo,
        fence: VkFence,
    ) -> VkResult;
}
extern "C" {
    pub fn vkQueueWaitIdle(queue: VkQueue) -> VkResult;
}
extern "C" {
    pub fn vkDeviceWaitIdle(device: VkDevice) -> VkResult;
}
extern "C" {
    pub fn vkAllocateMemory(
        device: VkDevice,
        pAllocateInfo: *const VkMemoryAllocateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pMemory: *mut VkDeviceMemory,
    ) -> VkResult;
}
extern "C" {
    pub fn vkFreeMemory(
        device: VkDevice,
        memory: VkDeviceMemory,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkMapMemory(
        device: VkDevice,
        memory: VkDeviceMemory,
        offset: VkDeviceSize,
        size: VkDeviceSize,
        flags: VkMemoryMapFlags,
        ppData: *mut *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    pub fn vkUnmapMemory(device: VkDevice, memory: VkDeviceMemory);
}
extern "C" {
    pub fn vkFlushMappedMemoryRanges(
        device: VkDevice,
        memoryRangeCount: u32,
        pMemoryRanges: *const VkMappedMemoryRange,
    ) -> VkResult;
}
extern "C" {
    pub fn vkInvalidateMappedMemoryRanges(
        device: VkDevice,
        memoryRangeCount: u32,
        pMemoryRanges: *const VkMappedMemoryRange,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDeviceMemoryCommitment(
        device: VkDevice,
        memory: VkDeviceMemory,
        pCommittedMemoryInBytes: *mut VkDeviceSize,
    );
}
extern "C" {
    pub fn vkBindBufferMemory(
        device: VkDevice,
        buffer: VkBuffer,
        memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize,
    ) -> VkResult;
}
extern "C" {
    pub fn vkBindImageMemory(
        device: VkDevice,
        image: VkImage,
        memory: VkDeviceMemory,
        memoryOffset: VkDeviceSize,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetBufferMemoryRequirements(
        device: VkDevice,
        buffer: VkBuffer,
        pMemoryRequirements: *mut VkMemoryRequirements,
    );
}
extern "C" {
    pub fn vkGetImageMemoryRequirements(
        device: VkDevice,
        image: VkImage,
        pMemoryRequirements: *mut VkMemoryRequirements,
    );
}
extern "C" {
    pub fn vkGetImageSparseMemoryRequirements(
        device: VkDevice,
        image: VkImage,
        pSparseMemoryRequirementCount: *mut u32,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceSparseImageFormatProperties(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        type_: VkImageType,
        samples: VkSampleCountFlagBits,
        usage: VkImageUsageFlags,
        tiling: VkImageTiling,
        pPropertyCount: *mut u32,
        pProperties: *mut VkSparseImageFormatProperties,
    );
}
extern "C" {
    pub fn vkQueueBindSparse(
        queue: VkQueue,
        bindInfoCount: u32,
        pBindInfo: *const VkBindSparseInfo,
        fence: VkFence,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreateFence(
        device: VkDevice,
        pCreateInfo: *const VkFenceCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pFence: *mut VkFence,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyFence(
        device: VkDevice,
        fence: VkFence,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkResetFences(device: VkDevice, fenceCount: u32, pFences: *const VkFence) -> VkResult;
}
extern "C" {
    pub fn vkGetFenceStatus(device: VkDevice, fence: VkFence) -> VkResult;
}
extern "C" {
    pub fn vkWaitForFences(
        device: VkDevice,
        fenceCount: u32,
        pFences: *const VkFence,
        waitAll: VkBool32,
        timeout: u64,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreateSemaphore(
        device: VkDevice,
        pCreateInfo: *const VkSemaphoreCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSemaphore: *mut VkSemaphore,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroySemaphore(
        device: VkDevice,
        semaphore: VkSemaphore,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateEvent(
        device: VkDevice,
        pCreateInfo: *const VkEventCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pEvent: *mut VkEvent,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyEvent(
        device: VkDevice,
        event: VkEvent,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetEventStatus(device: VkDevice, event: VkEvent) -> VkResult;
}
extern "C" {
    pub fn vkSetEvent(device: VkDevice, event: VkEvent) -> VkResult;
}
extern "C" {
    pub fn vkResetEvent(device: VkDevice, event: VkEvent) -> VkResult;
}
extern "C" {
    pub fn vkCreateQueryPool(
        device: VkDevice,
        pCreateInfo: *const VkQueryPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pQueryPool: *mut VkQueryPool,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyQueryPool(
        device: VkDevice,
        queryPool: VkQueryPool,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetQueryPoolResults(
        device: VkDevice,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
        dataSize: usize,
        pData: *mut ::std::os::raw::c_void,
        stride: VkDeviceSize,
        flags: VkQueryResultFlags,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreateBuffer(
        device: VkDevice,
        pCreateInfo: *const VkBufferCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pBuffer: *mut VkBuffer,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyBuffer(
        device: VkDevice,
        buffer: VkBuffer,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateBufferView(
        device: VkDevice,
        pCreateInfo: *const VkBufferViewCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pView: *mut VkBufferView,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyBufferView(
        device: VkDevice,
        bufferView: VkBufferView,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateImage(
        device: VkDevice,
        pCreateInfo: *const VkImageCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pImage: *mut VkImage,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyImage(
        device: VkDevice,
        image: VkImage,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetImageSubresourceLayout(
        device: VkDevice,
        image: VkImage,
        pSubresource: *const VkImageSubresource,
        pLayout: *mut VkSubresourceLayout,
    );
}
extern "C" {
    pub fn vkCreateImageView(
        device: VkDevice,
        pCreateInfo: *const VkImageViewCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pView: *mut VkImageView,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyImageView(
        device: VkDevice,
        imageView: VkImageView,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateShaderModule(
        device: VkDevice,
        pCreateInfo: *const VkShaderModuleCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pShaderModule: *mut VkShaderModule,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyShaderModule(
        device: VkDevice,
        shaderModule: VkShaderModule,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreatePipelineCache(
        device: VkDevice,
        pCreateInfo: *const VkPipelineCacheCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelineCache: *mut VkPipelineCache,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyPipelineCache(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetPipelineCacheData(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        pDataSize: *mut usize,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    pub fn vkMergePipelineCaches(
        device: VkDevice,
        dstCache: VkPipelineCache,
        srcCacheCount: u32,
        pSrcCaches: *const VkPipelineCache,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreateGraphicsPipelines(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        createInfoCount: u32,
        pCreateInfos: *const VkGraphicsPipelineCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreateComputePipelines(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        createInfoCount: u32,
        pCreateInfos: *const VkComputePipelineCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyPipeline(
        device: VkDevice,
        pipeline: VkPipeline,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreatePipelineLayout(
        device: VkDevice,
        pCreateInfo: *const VkPipelineLayoutCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPipelineLayout: *mut VkPipelineLayout,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyPipelineLayout(
        device: VkDevice,
        pipelineLayout: VkPipelineLayout,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateSampler(
        device: VkDevice,
        pCreateInfo: *const VkSamplerCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSampler: *mut VkSampler,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroySampler(
        device: VkDevice,
        sampler: VkSampler,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateDescriptorSetLayout(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pSetLayout: *mut VkDescriptorSetLayout,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyDescriptorSetLayout(
        device: VkDevice,
        descriptorSetLayout: VkDescriptorSetLayout,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateDescriptorPool(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDescriptorPool: *mut VkDescriptorPool,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyDescriptorPool(
        device: VkDevice,
        descriptorPool: VkDescriptorPool,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkResetDescriptorPool(
        device: VkDevice,
        descriptorPool: VkDescriptorPool,
        flags: VkDescriptorPoolResetFlags,
    ) -> VkResult;
}
extern "C" {
    pub fn vkAllocateDescriptorSets(
        device: VkDevice,
        pAllocateInfo: *const VkDescriptorSetAllocateInfo,
        pDescriptorSets: *mut VkDescriptorSet,
    ) -> VkResult;
}
extern "C" {
    pub fn vkFreeDescriptorSets(
        device: VkDevice,
        descriptorPool: VkDescriptorPool,
        descriptorSetCount: u32,
        pDescriptorSets: *const VkDescriptorSet,
    ) -> VkResult;
}
extern "C" {
    pub fn vkUpdateDescriptorSets(
        device: VkDevice,
        descriptorWriteCount: u32,
        pDescriptorWrites: *const VkWriteDescriptorSet,
        descriptorCopyCount: u32,
        pDescriptorCopies: *const VkCopyDescriptorSet,
    );
}
extern "C" {
    pub fn vkCreateFramebuffer(
        device: VkDevice,
        pCreateInfo: *const VkFramebufferCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pFramebuffer: *mut VkFramebuffer,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyFramebuffer(
        device: VkDevice,
        framebuffer: VkFramebuffer,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateRenderPass(
        device: VkDevice,
        pCreateInfo: *const VkRenderPassCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pRenderPass: *mut VkRenderPass,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyRenderPass(
        device: VkDevice,
        renderPass: VkRenderPass,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetRenderAreaGranularity(
        device: VkDevice,
        renderPass: VkRenderPass,
        pGranularity: *mut VkExtent2D,
    );
}
extern "C" {
    pub fn vkCreateCommandPool(
        device: VkDevice,
        pCreateInfo: *const VkCommandPoolCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pCommandPool: *mut VkCommandPool,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyCommandPool(
        device: VkDevice,
        commandPool: VkCommandPool,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkResetCommandPool(
        device: VkDevice,
        commandPool: VkCommandPool,
        flags: VkCommandPoolResetFlags,
    ) -> VkResult;
}
extern "C" {
    pub fn vkAllocateCommandBuffers(
        device: VkDevice,
        pAllocateInfo: *const VkCommandBufferAllocateInfo,
        pCommandBuffers: *mut VkCommandBuffer,
    ) -> VkResult;
}
extern "C" {
    pub fn vkFreeCommandBuffers(
        device: VkDevice,
        commandPool: VkCommandPool,
        commandBufferCount: u32,
        pCommandBuffers: *const VkCommandBuffer,
    );
}
extern "C" {
    pub fn vkBeginCommandBuffer(
        commandBuffer: VkCommandBuffer,
        pBeginInfo: *const VkCommandBufferBeginInfo,
    ) -> VkResult;
}
extern "C" {
    pub fn vkEndCommandBuffer(commandBuffer: VkCommandBuffer) -> VkResult;
}
extern "C" {
    pub fn vkResetCommandBuffer(
        commandBuffer: VkCommandBuffer,
        flags: VkCommandBufferResetFlags,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdBindPipeline(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        pipeline: VkPipeline,
    );
}
extern "C" {
    pub fn vkCmdSetViewport(
        commandBuffer: VkCommandBuffer,
        firstViewport: u32,
        viewportCount: u32,
        pViewports: *const VkViewport,
    );
}
extern "C" {
    pub fn vkCmdSetScissor(
        commandBuffer: VkCommandBuffer,
        firstScissor: u32,
        scissorCount: u32,
        pScissors: *const VkRect2D,
    );
}
extern "C" {
    pub fn vkCmdSetLineWidth(commandBuffer: VkCommandBuffer, lineWidth: f32);
}
extern "C" {
    pub fn vkCmdSetDepthBias(
        commandBuffer: VkCommandBuffer,
        depthBiasConstantFactor: f32,
        depthBiasClamp: f32,
        depthBiasSlopeFactor: f32,
    );
}
extern "C" {
    pub fn vkCmdSetBlendConstants(commandBuffer: VkCommandBuffer, blendConstants: *const f32);
}
extern "C" {
    pub fn vkCmdSetDepthBounds(
        commandBuffer: VkCommandBuffer,
        minDepthBounds: f32,
        maxDepthBounds: f32,
    );
}
extern "C" {
    pub fn vkCmdSetStencilCompareMask(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        compareMask: u32,
    );
}
extern "C" {
    pub fn vkCmdSetStencilWriteMask(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        writeMask: u32,
    );
}
extern "C" {
    pub fn vkCmdSetStencilReference(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        reference: u32,
    );
}
extern "C" {
    pub fn vkCmdBindDescriptorSets(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        layout: VkPipelineLayout,
        firstSet: u32,
        descriptorSetCount: u32,
        pDescriptorSets: *const VkDescriptorSet,
        dynamicOffsetCount: u32,
        pDynamicOffsets: *const u32,
    );
}
extern "C" {
    pub fn vkCmdBindIndexBuffer(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        indexType: VkIndexType,
    );
}
extern "C" {
    pub fn vkCmdBindVertexBuffers(
        commandBuffer: VkCommandBuffer,
        firstBinding: u32,
        bindingCount: u32,
        pBuffers: *const VkBuffer,
        pOffsets: *const VkDeviceSize,
    );
}
extern "C" {
    pub fn vkCmdDraw(
        commandBuffer: VkCommandBuffer,
        vertexCount: u32,
        instanceCount: u32,
        firstVertex: u32,
        firstInstance: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawIndexed(
        commandBuffer: VkCommandBuffer,
        indexCount: u32,
        instanceCount: u32,
        firstIndex: u32,
        vertexOffset: i32,
        firstInstance: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawIndirect(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        drawCount: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawIndexedIndirect(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        drawCount: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCmdDispatch(
        commandBuffer: VkCommandBuffer,
        groupCountX: u32,
        groupCountY: u32,
        groupCountZ: u32,
    );
}
extern "C" {
    pub fn vkCmdDispatchIndirect(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
    );
}
extern "C" {
    pub fn vkCmdCopyBuffer(
        commandBuffer: VkCommandBuffer,
        srcBuffer: VkBuffer,
        dstBuffer: VkBuffer,
        regionCount: u32,
        pRegions: *const VkBufferCopy,
    );
}
extern "C" {
    pub fn vkCmdCopyImage(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: u32,
        pRegions: *const VkImageCopy,
    );
}
extern "C" {
    pub fn vkCmdBlitImage(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: u32,
        pRegions: *const VkImageBlit,
        filter: VkFilter,
    );
}
extern "C" {
    pub fn vkCmdCopyBufferToImage(
        commandBuffer: VkCommandBuffer,
        srcBuffer: VkBuffer,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: u32,
        pRegions: *const VkBufferImageCopy,
    );
}
extern "C" {
    pub fn vkCmdCopyImageToBuffer(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstBuffer: VkBuffer,
        regionCount: u32,
        pRegions: *const VkBufferImageCopy,
    );
}
extern "C" {
    pub fn vkCmdUpdateBuffer(
        commandBuffer: VkCommandBuffer,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        dataSize: VkDeviceSize,
        pData: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn vkCmdFillBuffer(
        commandBuffer: VkCommandBuffer,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        size: VkDeviceSize,
        data: u32,
    );
}
extern "C" {
    pub fn vkCmdClearColorImage(
        commandBuffer: VkCommandBuffer,
        image: VkImage,
        imageLayout: VkImageLayout,
        pColor: *const VkClearColorValue,
        rangeCount: u32,
        pRanges: *const VkImageSubresourceRange,
    );
}
extern "C" {
    pub fn vkCmdClearDepthStencilImage(
        commandBuffer: VkCommandBuffer,
        image: VkImage,
        imageLayout: VkImageLayout,
        pDepthStencil: *const VkClearDepthStencilValue,
        rangeCount: u32,
        pRanges: *const VkImageSubresourceRange,
    );
}
extern "C" {
    pub fn vkCmdClearAttachments(
        commandBuffer: VkCommandBuffer,
        attachmentCount: u32,
        pAttachments: *const VkClearAttachment,
        rectCount: u32,
        pRects: *const VkClearRect,
    );
}
extern "C" {
    pub fn vkCmdResolveImage(
        commandBuffer: VkCommandBuffer,
        srcImage: VkImage,
        srcImageLayout: VkImageLayout,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        regionCount: u32,
        pRegions: *const VkImageResolve,
    );
}
extern "C" {
    pub fn vkCmdSetEvent(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        stageMask: VkPipelineStageFlags,
    );
}
extern "C" {
    pub fn vkCmdResetEvent(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        stageMask: VkPipelineStageFlags,
    );
}
extern "C" {
    pub fn vkCmdWaitEvents(
        commandBuffer: VkCommandBuffer,
        eventCount: u32,
        pEvents: *const VkEvent,
        srcStageMask: VkPipelineStageFlags,
        dstStageMask: VkPipelineStageFlags,
        memoryBarrierCount: u32,
        pMemoryBarriers: *const VkMemoryBarrier,
        bufferMemoryBarrierCount: u32,
        pBufferMemoryBarriers: *const VkBufferMemoryBarrier,
        imageMemoryBarrierCount: u32,
        pImageMemoryBarriers: *const VkImageMemoryBarrier,
    );
}
extern "C" {
    pub fn vkCmdPipelineBarrier(
        commandBuffer: VkCommandBuffer,
        srcStageMask: VkPipelineStageFlags,
        dstStageMask: VkPipelineStageFlags,
        dependencyFlags: VkDependencyFlags,
        memoryBarrierCount: u32,
        pMemoryBarriers: *const VkMemoryBarrier,
        bufferMemoryBarrierCount: u32,
        pBufferMemoryBarriers: *const VkBufferMemoryBarrier,
        imageMemoryBarrierCount: u32,
        pImageMemoryBarriers: *const VkImageMemoryBarrier,
    );
}
extern "C" {
    pub fn vkCmdBeginQuery(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        query: u32,
        flags: VkQueryControlFlags,
    );
}
extern "C" {
    pub fn vkCmdEndQuery(commandBuffer: VkCommandBuffer, queryPool: VkQueryPool, query: u32);
}
extern "C" {
    pub fn vkCmdResetQueryPool(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
    );
}
extern "C" {
    pub fn vkCmdWriteTimestamp(
        commandBuffer: VkCommandBuffer,
        pipelineStage: VkPipelineStageFlagBits,
        queryPool: VkQueryPool,
        query: u32,
    );
}
extern "C" {
    pub fn vkCmdCopyQueryPoolResults(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        stride: VkDeviceSize,
        flags: VkQueryResultFlags,
    );
}
extern "C" {
    pub fn vkCmdPushConstants(
        commandBuffer: VkCommandBuffer,
        layout: VkPipelineLayout,
        stageFlags: VkShaderStageFlags,
        offset: u32,
        size: u32,
        pValues: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn vkCmdBeginRenderPass(
        commandBuffer: VkCommandBuffer,
        pRenderPassBegin: *const VkRenderPassBeginInfo,
        contents: VkSubpassContents,
    );
}
extern "C" {
    pub fn vkCmdNextSubpass(commandBuffer: VkCommandBuffer, contents: VkSubpassContents);
}
extern "C" {
    pub fn vkCmdEndRenderPass(commandBuffer: VkCommandBuffer);
}
extern "C" {
    pub fn vkCmdExecuteCommands(
        commandBuffer: VkCommandBuffer,
        commandBufferCount: u32,
        pCommandBuffers: *const VkCommandBuffer,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSamplerYcbcrConversion_T {
    _unused: [u8; 0],
}
pub type VkSamplerYcbcrConversion = *mut VkSamplerYcbcrConversion_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorUpdateTemplate_T {
    _unused: [u8; 0],
}
pub type VkDescriptorUpdateTemplate = *mut VkDescriptorUpdateTemplate_T;
pub const VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES: VkPointClippingBehavior = 0;
pub const VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY: VkPointClippingBehavior = 1;
pub const VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR: VkPointClippingBehavior = 0;
pub const VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR: VkPointClippingBehavior = 1;
pub const VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM: VkPointClippingBehavior = 2147483647;
pub type VkPointClippingBehavior = ::std::os::raw::c_int;
pub const VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT: VkTessellationDomainOrigin = 0;
pub const VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT: VkTessellationDomainOrigin = 1;
pub const VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR: VkTessellationDomainOrigin = 0;
pub const VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR: VkTessellationDomainOrigin = 1;
pub const VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM: VkTessellationDomainOrigin = 2147483647;
pub type VkTessellationDomainOrigin = ::std::os::raw::c_int;
pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY: VkSamplerYcbcrModelConversion = 0;
pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY: VkSamplerYcbcrModelConversion = 1;
pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709: VkSamplerYcbcrModelConversion = 2;
pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601: VkSamplerYcbcrModelConversion = 3;
pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020: VkSamplerYcbcrModelConversion = 4;
pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR: VkSamplerYcbcrModelConversion = 0;
pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR: VkSamplerYcbcrModelConversion = 1;
pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR: VkSamplerYcbcrModelConversion = 2;
pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR: VkSamplerYcbcrModelConversion = 3;
pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR: VkSamplerYcbcrModelConversion = 4;
pub const VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM: VkSamplerYcbcrModelConversion = 2147483647;
pub type VkSamplerYcbcrModelConversion = ::std::os::raw::c_int;
pub const VK_SAMPLER_YCBCR_RANGE_ITU_FULL: VkSamplerYcbcrRange = 0;
pub const VK_SAMPLER_YCBCR_RANGE_ITU_NARROW: VkSamplerYcbcrRange = 1;
pub const VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR: VkSamplerYcbcrRange = 0;
pub const VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR: VkSamplerYcbcrRange = 1;
pub const VK_SAMPLER_YCBCR_RANGE_MAX_ENUM: VkSamplerYcbcrRange = 2147483647;
pub type VkSamplerYcbcrRange = ::std::os::raw::c_int;
pub const VK_CHROMA_LOCATION_COSITED_EVEN: VkChromaLocation = 0;
pub const VK_CHROMA_LOCATION_MIDPOINT: VkChromaLocation = 1;
pub const VK_CHROMA_LOCATION_COSITED_EVEN_KHR: VkChromaLocation = 0;
pub const VK_CHROMA_LOCATION_MIDPOINT_KHR: VkChromaLocation = 1;
pub const VK_CHROMA_LOCATION_MAX_ENUM: VkChromaLocation = 2147483647;
pub type VkChromaLocation = ::std::os::raw::c_int;
pub const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET: VkDescriptorUpdateTemplateType = 0;
pub const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR: VkDescriptorUpdateTemplateType =
    1;
pub const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR: VkDescriptorUpdateTemplateType = 0;
pub const VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM: VkDescriptorUpdateTemplateType = 2147483647;
pub type VkDescriptorUpdateTemplateType = ::std::os::raw::c_int;
pub const VK_SUBGROUP_FEATURE_BASIC_BIT: VkSubgroupFeatureFlagBits = 1;
pub const VK_SUBGROUP_FEATURE_VOTE_BIT: VkSubgroupFeatureFlagBits = 2;
pub const VK_SUBGROUP_FEATURE_ARITHMETIC_BIT: VkSubgroupFeatureFlagBits = 4;
pub const VK_SUBGROUP_FEATURE_BALLOT_BIT: VkSubgroupFeatureFlagBits = 8;
pub const VK_SUBGROUP_FEATURE_SHUFFLE_BIT: VkSubgroupFeatureFlagBits = 16;
pub const VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT: VkSubgroupFeatureFlagBits = 32;
pub const VK_SUBGROUP_FEATURE_CLUSTERED_BIT: VkSubgroupFeatureFlagBits = 64;
pub const VK_SUBGROUP_FEATURE_QUAD_BIT: VkSubgroupFeatureFlagBits = 128;
pub const VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV: VkSubgroupFeatureFlagBits = 256;
pub const VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM: VkSubgroupFeatureFlagBits = 2147483647;
pub type VkSubgroupFeatureFlagBits = ::std::os::raw::c_int;
pub type VkSubgroupFeatureFlags = VkFlags;
pub const VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT: VkPeerMemoryFeatureFlagBits = 1;
pub const VK_PEER_MEMORY_FEATURE_COPY_DST_BIT: VkPeerMemoryFeatureFlagBits = 2;
pub const VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT: VkPeerMemoryFeatureFlagBits = 4;
pub const VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT: VkPeerMemoryFeatureFlagBits = 8;
pub const VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR: VkPeerMemoryFeatureFlagBits = 1;
pub const VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR: VkPeerMemoryFeatureFlagBits = 2;
pub const VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR: VkPeerMemoryFeatureFlagBits = 4;
pub const VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR: VkPeerMemoryFeatureFlagBits = 8;
pub const VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM: VkPeerMemoryFeatureFlagBits = 2147483647;
pub type VkPeerMemoryFeatureFlagBits = ::std::os::raw::c_int;
pub type VkPeerMemoryFeatureFlags = VkFlags;
pub const VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT: VkMemoryAllocateFlagBits = 1;
pub const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT: VkMemoryAllocateFlagBits = 2;
pub const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT: VkMemoryAllocateFlagBits = 4;
pub const VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR: VkMemoryAllocateFlagBits = 1;
pub const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR: VkMemoryAllocateFlagBits = 2;
pub const VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR: VkMemoryAllocateFlagBits = 4;
pub const VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM: VkMemoryAllocateFlagBits = 2147483647;
pub type VkMemoryAllocateFlagBits = ::std::os::raw::c_int;
pub type VkMemoryAllocateFlags = VkFlags;
pub type VkCommandPoolTrimFlags = VkFlags;
pub type VkDescriptorUpdateTemplateCreateFlags = VkFlags;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT: VkExternalMemoryHandleTypeFlagBits = 1;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT: VkExternalMemoryHandleTypeFlagBits = 2;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: VkExternalMemoryHandleTypeFlagBits =
    4;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT: VkExternalMemoryHandleTypeFlagBits = 8;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT: VkExternalMemoryHandleTypeFlagBits =
    16;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT: VkExternalMemoryHandleTypeFlagBits = 32;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT: VkExternalMemoryHandleTypeFlagBits =
    64;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT: VkExternalMemoryHandleTypeFlagBits = 512;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID:
    VkExternalMemoryHandleTypeFlagBits = 1024;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT:
    VkExternalMemoryHandleTypeFlagBits = 128;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT:
    VkExternalMemoryHandleTypeFlagBits = 256;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA:
    VkExternalMemoryHandleTypeFlagBits = 2048;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV: VkExternalMemoryHandleTypeFlagBits =
    4096;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalMemoryHandleTypeFlagBits = 1;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalMemoryHandleTypeFlagBits =
    2;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR:
    VkExternalMemoryHandleTypeFlagBits = 4;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR: VkExternalMemoryHandleTypeFlagBits =
    8;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR:
    VkExternalMemoryHandleTypeFlagBits = 16;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR: VkExternalMemoryHandleTypeFlagBits =
    32;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR:
    VkExternalMemoryHandleTypeFlagBits = 64;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM: VkExternalMemoryHandleTypeFlagBits =
    2147483647;
pub type VkExternalMemoryHandleTypeFlagBits = ::std::os::raw::c_int;
pub type VkExternalMemoryHandleTypeFlags = VkFlags;
pub const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT: VkExternalMemoryFeatureFlagBits = 1;
pub const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT: VkExternalMemoryFeatureFlagBits = 2;
pub const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT: VkExternalMemoryFeatureFlagBits = 4;
pub const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR: VkExternalMemoryFeatureFlagBits = 1;
pub const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR: VkExternalMemoryFeatureFlagBits = 2;
pub const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR: VkExternalMemoryFeatureFlagBits = 4;
pub const VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM: VkExternalMemoryFeatureFlagBits =
    2147483647;
pub type VkExternalMemoryFeatureFlagBits = ::std::os::raw::c_int;
pub type VkExternalMemoryFeatureFlags = VkFlags;
pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT: VkExternalFenceHandleTypeFlagBits = 1;
pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT: VkExternalFenceHandleTypeFlagBits = 2;
pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT: VkExternalFenceHandleTypeFlagBits = 4;
pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT: VkExternalFenceHandleTypeFlagBits = 8;
pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR: VkExternalFenceHandleTypeFlagBits = 1;
pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR: VkExternalFenceHandleTypeFlagBits = 2;
pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR:
    VkExternalFenceHandleTypeFlagBits = 4;
pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR: VkExternalFenceHandleTypeFlagBits = 8;
pub const VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM: VkExternalFenceHandleTypeFlagBits =
    2147483647;
pub type VkExternalFenceHandleTypeFlagBits = ::std::os::raw::c_int;
pub type VkExternalFenceHandleTypeFlags = VkFlags;
pub const VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT: VkExternalFenceFeatureFlagBits = 1;
pub const VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT: VkExternalFenceFeatureFlagBits = 2;
pub const VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR: VkExternalFenceFeatureFlagBits = 1;
pub const VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR: VkExternalFenceFeatureFlagBits = 2;
pub const VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM: VkExternalFenceFeatureFlagBits = 2147483647;
pub type VkExternalFenceFeatureFlagBits = ::std::os::raw::c_int;
pub type VkExternalFenceFeatureFlags = VkFlags;
pub const VK_FENCE_IMPORT_TEMPORARY_BIT: VkFenceImportFlagBits = 1;
pub const VK_FENCE_IMPORT_TEMPORARY_BIT_KHR: VkFenceImportFlagBits = 1;
pub const VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM: VkFenceImportFlagBits = 2147483647;
pub type VkFenceImportFlagBits = ::std::os::raw::c_int;
pub type VkFenceImportFlags = VkFlags;
pub const VK_SEMAPHORE_IMPORT_TEMPORARY_BIT: VkSemaphoreImportFlagBits = 1;
pub const VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR: VkSemaphoreImportFlagBits = 1;
pub const VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM: VkSemaphoreImportFlagBits = 2147483647;
pub type VkSemaphoreImportFlagBits = ::std::os::raw::c_int;
pub type VkSemaphoreImportFlags = VkFlags;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT: VkExternalSemaphoreHandleTypeFlagBits =
    1;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
    VkExternalSemaphoreHandleTypeFlagBits = 2;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
    VkExternalSemaphoreHandleTypeFlagBits = 4;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT: VkExternalSemaphoreHandleTypeFlagBits =
    8;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT: VkExternalSemaphoreHandleTypeFlagBits = 16;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA:
    VkExternalSemaphoreHandleTypeFlagBits = 128;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE_BIT: VkExternalSemaphoreHandleTypeFlagBits =
    8;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR:
    VkExternalSemaphoreHandleTypeFlagBits = 1;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR:
    VkExternalSemaphoreHandleTypeFlagBits = 2;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR:
    VkExternalSemaphoreHandleTypeFlagBits = 4;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR:
    VkExternalSemaphoreHandleTypeFlagBits = 8;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR: VkExternalSemaphoreHandleTypeFlagBits =
    16;
pub const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM:
    VkExternalSemaphoreHandleTypeFlagBits = 2147483647;
pub type VkExternalSemaphoreHandleTypeFlagBits = ::std::os::raw::c_int;
pub type VkExternalSemaphoreHandleTypeFlags = VkFlags;
pub const VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT: VkExternalSemaphoreFeatureFlagBits = 1;
pub const VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT: VkExternalSemaphoreFeatureFlagBits = 2;
pub const VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR: VkExternalSemaphoreFeatureFlagBits = 1;
pub const VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR: VkExternalSemaphoreFeatureFlagBits = 2;
pub const VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM: VkExternalSemaphoreFeatureFlagBits =
    2147483647;
pub type VkExternalSemaphoreFeatureFlagBits = ::std::os::raw::c_int;
pub type VkExternalSemaphoreFeatureFlags = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSubgroupProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub subgroupSize: u32,
    pub supportedStages: VkShaderStageFlags,
    pub supportedOperations: VkSubgroupFeatureFlags,
    pub quadOperationsInAllStages: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSubgroupProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSubgroupProperties>(),
        32usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceSubgroupProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSubgroupProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSubgroupProperties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSubgroupProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubgroupProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSubgroupProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubgroupProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_subgroupSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSubgroupProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subgroupSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubgroupProperties),
                "::",
                stringify!(subgroupSize)
            )
        );
    }
    test_field_subgroupSize();
    fn test_field_supportedStages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSubgroupProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedStages) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubgroupProperties),
                "::",
                stringify!(supportedStages)
            )
        );
    }
    test_field_supportedStages();
    fn test_field_supportedOperations() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSubgroupProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedOperations) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubgroupProperties),
                "::",
                stringify!(supportedOperations)
            )
        );
    }
    test_field_supportedOperations();
    fn test_field_quadOperationsInAllStages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSubgroupProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quadOperationsInAllStages) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubgroupProperties),
                "::",
                stringify!(quadOperationsInAllStages)
            )
        );
    }
    test_field_quadOperationsInAllStages();
}
impl Default for VkPhysicalDeviceSubgroupProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindBufferMemoryInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub buffer: VkBuffer,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBindBufferMemoryInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBindBufferMemoryInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkBindBufferMemoryInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindBufferMemoryInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBindBufferMemoryInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindBufferMemoryInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindBufferMemoryInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindBufferMemoryInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindBufferMemoryInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindBufferMemoryInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindBufferMemoryInfo),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_memory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindBufferMemoryInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindBufferMemoryInfo),
                "::",
                stringify!(memory)
            )
        );
    }
    test_field_memory();
    fn test_field_memoryOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindBufferMemoryInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryOffset) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindBufferMemoryInfo),
                "::",
                stringify!(memoryOffset)
            )
        );
    }
    test_field_memoryOffset();
}
impl Default for VkBindBufferMemoryInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindImageMemoryInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBindImageMemoryInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBindImageMemoryInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkBindImageMemoryInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindImageMemoryInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBindImageMemoryInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImageMemoryInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImageMemoryInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImageMemoryInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImageMemoryInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_image() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImageMemoryInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImageMemoryInfo),
                "::",
                stringify!(image)
            )
        );
    }
    test_field_image();
    fn test_field_memory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImageMemoryInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImageMemoryInfo),
                "::",
                stringify!(memory)
            )
        );
    }
    test_field_memory();
    fn test_field_memoryOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImageMemoryInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryOffset) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImageMemoryInfo),
                "::",
                stringify!(memoryOffset)
            )
        );
    }
    test_field_memoryOffset();
}
impl Default for VkBindImageMemoryInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevice16BitStorageFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub storageBuffer16BitAccess: VkBool32,
    pub uniformAndStorageBuffer16BitAccess: VkBool32,
    pub storagePushConstant16: VkBool32,
    pub storageInputOutput16: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevice16BitStorageFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevice16BitStorageFeatures>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevice16BitStorageFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevice16BitStorageFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevice16BitStorageFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevice16BitStorageFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevice16BitStorageFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevice16BitStorageFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevice16BitStorageFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_storageBuffer16BitAccess() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevice16BitStorageFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storageBuffer16BitAccess) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevice16BitStorageFeatures),
                "::",
                stringify!(storageBuffer16BitAccess)
            )
        );
    }
    test_field_storageBuffer16BitAccess();
    fn test_field_uniformAndStorageBuffer16BitAccess() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevice16BitStorageFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uniformAndStorageBuffer16BitAccess) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevice16BitStorageFeatures),
                "::",
                stringify!(uniformAndStorageBuffer16BitAccess)
            )
        );
    }
    test_field_uniformAndStorageBuffer16BitAccess();
    fn test_field_storagePushConstant16() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevice16BitStorageFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storagePushConstant16) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevice16BitStorageFeatures),
                "::",
                stringify!(storagePushConstant16)
            )
        );
    }
    test_field_storagePushConstant16();
    fn test_field_storageInputOutput16() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevice16BitStorageFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storageInputOutput16) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevice16BitStorageFeatures),
                "::",
                stringify!(storageInputOutput16)
            )
        );
    }
    test_field_storageInputOutput16();
}
impl Default for VkPhysicalDevice16BitStorageFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryDedicatedRequirements {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub prefersDedicatedAllocation: VkBool32,
    pub requiresDedicatedAllocation: VkBool32,
}
#[test]
fn bindgen_test_layout_VkMemoryDedicatedRequirements() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryDedicatedRequirements>(),
        24usize,
        concat!("Size of: ", stringify!(VkMemoryDedicatedRequirements))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryDedicatedRequirements>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryDedicatedRequirements))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryDedicatedRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryDedicatedRequirements),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryDedicatedRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryDedicatedRequirements),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_prefersDedicatedAllocation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryDedicatedRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prefersDedicatedAllocation) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryDedicatedRequirements),
                "::",
                stringify!(prefersDedicatedAllocation)
            )
        );
    }
    test_field_prefersDedicatedAllocation();
    fn test_field_requiresDedicatedAllocation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryDedicatedRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).requiresDedicatedAllocation) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryDedicatedRequirements),
                "::",
                stringify!(requiresDedicatedAllocation)
            )
        );
    }
    test_field_requiresDedicatedAllocation();
}
impl Default for VkMemoryDedicatedRequirements {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryDedicatedAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
    pub buffer: VkBuffer,
}
#[test]
fn bindgen_test_layout_VkMemoryDedicatedAllocateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryDedicatedAllocateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkMemoryDedicatedAllocateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryDedicatedAllocateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryDedicatedAllocateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryDedicatedAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryDedicatedAllocateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryDedicatedAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryDedicatedAllocateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_image() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryDedicatedAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryDedicatedAllocateInfo),
                "::",
                stringify!(image)
            )
        );
    }
    test_field_image();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryDedicatedAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryDedicatedAllocateInfo),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
}
impl Default for VkMemoryDedicatedAllocateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryAllocateFlagsInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkMemoryAllocateFlags,
    pub deviceMask: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryAllocateFlagsInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryAllocateFlagsInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkMemoryAllocateFlagsInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryAllocateFlagsInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryAllocateFlagsInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryAllocateFlagsInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryAllocateFlagsInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryAllocateFlagsInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryAllocateFlagsInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryAllocateFlagsInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryAllocateFlagsInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_deviceMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryAllocateFlagsInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceMask) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryAllocateFlagsInfo),
                "::",
                stringify!(deviceMask)
            )
        );
    }
    test_field_deviceMask();
}
impl Default for VkMemoryAllocateFlagsInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGroupRenderPassBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub deviceMask: u32,
    pub deviceRenderAreaCount: u32,
    pub pDeviceRenderAreas: *const VkRect2D,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupRenderPassBeginInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGroupRenderPassBeginInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkDeviceGroupRenderPassBeginInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGroupRenderPassBeginInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceGroupRenderPassBeginInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupRenderPassBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupRenderPassBeginInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupRenderPassBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupRenderPassBeginInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_deviceMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupRenderPassBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupRenderPassBeginInfo),
                "::",
                stringify!(deviceMask)
            )
        );
    }
    test_field_deviceMask();
    fn test_field_deviceRenderAreaCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupRenderPassBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceRenderAreaCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupRenderPassBeginInfo),
                "::",
                stringify!(deviceRenderAreaCount)
            )
        );
    }
    test_field_deviceRenderAreaCount();
    fn test_field_pDeviceRenderAreas() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupRenderPassBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDeviceRenderAreas) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupRenderPassBeginInfo),
                "::",
                stringify!(pDeviceRenderAreas)
            )
        );
    }
    test_field_pDeviceRenderAreas();
}
impl Default for VkDeviceGroupRenderPassBeginInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGroupCommandBufferBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub deviceMask: u32,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupCommandBufferBeginInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGroupCommandBufferBeginInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkDeviceGroupCommandBufferBeginInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGroupCommandBufferBeginInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceGroupCommandBufferBeginInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceGroupCommandBufferBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupCommandBufferBeginInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceGroupCommandBufferBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupCommandBufferBeginInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_deviceMask() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceGroupCommandBufferBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupCommandBufferBeginInfo),
                "::",
                stringify!(deviceMask)
            )
        );
    }
    test_field_deviceMask();
}
impl Default for VkDeviceGroupCommandBufferBeginInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGroupSubmitInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: u32,
    pub pWaitSemaphoreDeviceIndices: *const u32,
    pub commandBufferCount: u32,
    pub pCommandBufferDeviceMasks: *const u32,
    pub signalSemaphoreCount: u32,
    pub pSignalSemaphoreDeviceIndices: *const u32,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupSubmitInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGroupSubmitInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VkDeviceGroupSubmitInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGroupSubmitInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceGroupSubmitInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupSubmitInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupSubmitInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_waitSemaphoreCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).waitSemaphoreCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupSubmitInfo),
                "::",
                stringify!(waitSemaphoreCount)
            )
        );
    }
    test_field_waitSemaphoreCount();
    fn test_field_pWaitSemaphoreDeviceIndices() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pWaitSemaphoreDeviceIndices) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupSubmitInfo),
                "::",
                stringify!(pWaitSemaphoreDeviceIndices)
            )
        );
    }
    test_field_pWaitSemaphoreDeviceIndices();
    fn test_field_commandBufferCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).commandBufferCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupSubmitInfo),
                "::",
                stringify!(commandBufferCount)
            )
        );
    }
    test_field_commandBufferCount();
    fn test_field_pCommandBufferDeviceMasks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCommandBufferDeviceMasks) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupSubmitInfo),
                "::",
                stringify!(pCommandBufferDeviceMasks)
            )
        );
    }
    test_field_pCommandBufferDeviceMasks();
    fn test_field_signalSemaphoreCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signalSemaphoreCount) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupSubmitInfo),
                "::",
                stringify!(signalSemaphoreCount)
            )
        );
    }
    test_field_signalSemaphoreCount();
    fn test_field_pSignalSemaphoreDeviceIndices() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSignalSemaphoreDeviceIndices) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupSubmitInfo),
                "::",
                stringify!(pSignalSemaphoreDeviceIndices)
            )
        );
    }
    test_field_pSignalSemaphoreDeviceIndices();
}
impl Default for VkDeviceGroupSubmitInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGroupBindSparseInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub resourceDeviceIndex: u32,
    pub memoryDeviceIndex: u32,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupBindSparseInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGroupBindSparseInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkDeviceGroupBindSparseInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGroupBindSparseInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceGroupBindSparseInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupBindSparseInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupBindSparseInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupBindSparseInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupBindSparseInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_resourceDeviceIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupBindSparseInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resourceDeviceIndex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupBindSparseInfo),
                "::",
                stringify!(resourceDeviceIndex)
            )
        );
    }
    test_field_resourceDeviceIndex();
    fn test_field_memoryDeviceIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupBindSparseInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryDeviceIndex) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupBindSparseInfo),
                "::",
                stringify!(memoryDeviceIndex)
            )
        );
    }
    test_field_memoryDeviceIndex();
}
impl Default for VkDeviceGroupBindSparseInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindBufferMemoryDeviceGroupInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub deviceIndexCount: u32,
    pub pDeviceIndices: *const u32,
}
#[test]
fn bindgen_test_layout_VkBindBufferMemoryDeviceGroupInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBindBufferMemoryDeviceGroupInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkBindBufferMemoryDeviceGroupInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindBufferMemoryDeviceGroupInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkBindBufferMemoryDeviceGroupInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindBufferMemoryDeviceGroupInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindBufferMemoryDeviceGroupInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindBufferMemoryDeviceGroupInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindBufferMemoryDeviceGroupInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_deviceIndexCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindBufferMemoryDeviceGroupInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceIndexCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindBufferMemoryDeviceGroupInfo),
                "::",
                stringify!(deviceIndexCount)
            )
        );
    }
    test_field_deviceIndexCount();
    fn test_field_pDeviceIndices() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindBufferMemoryDeviceGroupInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDeviceIndices) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindBufferMemoryDeviceGroupInfo),
                "::",
                stringify!(pDeviceIndices)
            )
        );
    }
    test_field_pDeviceIndices();
}
impl Default for VkBindBufferMemoryDeviceGroupInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindImageMemoryDeviceGroupInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub deviceIndexCount: u32,
    pub pDeviceIndices: *const u32,
    pub splitInstanceBindRegionCount: u32,
    pub pSplitInstanceBindRegions: *const VkRect2D,
}
#[test]
fn bindgen_test_layout_VkBindImageMemoryDeviceGroupInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBindImageMemoryDeviceGroupInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VkBindImageMemoryDeviceGroupInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindImageMemoryDeviceGroupInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkBindImageMemoryDeviceGroupInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImageMemoryDeviceGroupInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImageMemoryDeviceGroupInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImageMemoryDeviceGroupInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImageMemoryDeviceGroupInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_deviceIndexCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImageMemoryDeviceGroupInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceIndexCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImageMemoryDeviceGroupInfo),
                "::",
                stringify!(deviceIndexCount)
            )
        );
    }
    test_field_deviceIndexCount();
    fn test_field_pDeviceIndices() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImageMemoryDeviceGroupInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDeviceIndices) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImageMemoryDeviceGroupInfo),
                "::",
                stringify!(pDeviceIndices)
            )
        );
    }
    test_field_pDeviceIndices();
    fn test_field_splitInstanceBindRegionCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImageMemoryDeviceGroupInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).splitInstanceBindRegionCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImageMemoryDeviceGroupInfo),
                "::",
                stringify!(splitInstanceBindRegionCount)
            )
        );
    }
    test_field_splitInstanceBindRegionCount();
    fn test_field_pSplitInstanceBindRegions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImageMemoryDeviceGroupInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSplitInstanceBindRegions) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImageMemoryDeviceGroupInfo),
                "::",
                stringify!(pSplitInstanceBindRegions)
            )
        );
    }
    test_field_pSplitInstanceBindRegions();
}
impl Default for VkBindImageMemoryDeviceGroupInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceGroupProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub physicalDeviceCount: u32,
    pub physicalDevices: [VkPhysicalDevice; 32usize],
    pub subsetAllocation: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceGroupProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceGroupProperties>(),
        288usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceGroupProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceGroupProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceGroupProperties))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceGroupProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceGroupProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceGroupProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceGroupProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_physicalDeviceCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceGroupProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).physicalDeviceCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceGroupProperties),
                "::",
                stringify!(physicalDeviceCount)
            )
        );
    }
    test_field_physicalDeviceCount();
    fn test_field_physicalDevices() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceGroupProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).physicalDevices) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceGroupProperties),
                "::",
                stringify!(physicalDevices)
            )
        );
    }
    test_field_physicalDevices();
    fn test_field_subsetAllocation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceGroupProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subsetAllocation) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceGroupProperties),
                "::",
                stringify!(subsetAllocation)
            )
        );
    }
    test_field_subsetAllocation();
}
impl Default for VkPhysicalDeviceGroupProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGroupDeviceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub physicalDeviceCount: u32,
    pub pPhysicalDevices: *const VkPhysicalDevice,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupDeviceCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGroupDeviceCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkDeviceGroupDeviceCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGroupDeviceCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceGroupDeviceCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupDeviceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupDeviceCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupDeviceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupDeviceCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_physicalDeviceCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupDeviceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).physicalDeviceCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupDeviceCreateInfo),
                "::",
                stringify!(physicalDeviceCount)
            )
        );
    }
    test_field_physicalDeviceCount();
    fn test_field_pPhysicalDevices() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupDeviceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pPhysicalDevices) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupDeviceCreateInfo),
                "::",
                stringify!(pPhysicalDevices)
            )
        );
    }
    test_field_pPhysicalDevices();
}
impl Default for VkDeviceGroupDeviceCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferMemoryRequirementsInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub buffer: VkBuffer,
}
#[test]
fn bindgen_test_layout_VkBufferMemoryRequirementsInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferMemoryRequirementsInfo2>(),
        24usize,
        concat!("Size of: ", stringify!(VkBufferMemoryRequirementsInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferMemoryRequirementsInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferMemoryRequirementsInfo2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryRequirementsInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryRequirementsInfo2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryRequirementsInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryRequirementsInfo2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryRequirementsInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryRequirementsInfo2),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
}
impl Default for VkBufferMemoryRequirementsInfo2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageMemoryRequirementsInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
}
#[test]
fn bindgen_test_layout_VkImageMemoryRequirementsInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkImageMemoryRequirementsInfo2>(),
        24usize,
        concat!("Size of: ", stringify!(VkImageMemoryRequirementsInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageMemoryRequirementsInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageMemoryRequirementsInfo2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryRequirementsInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryRequirementsInfo2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryRequirementsInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryRequirementsInfo2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_image() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryRequirementsInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryRequirementsInfo2),
                "::",
                stringify!(image)
            )
        );
    }
    test_field_image();
}
impl Default for VkImageMemoryRequirementsInfo2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageSparseMemoryRequirementsInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
}
#[test]
fn bindgen_test_layout_VkImageSparseMemoryRequirementsInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkImageSparseMemoryRequirementsInfo2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkImageSparseMemoryRequirementsInfo2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageSparseMemoryRequirementsInfo2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkImageSparseMemoryRequirementsInfo2)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageSparseMemoryRequirementsInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSparseMemoryRequirementsInfo2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageSparseMemoryRequirementsInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSparseMemoryRequirementsInfo2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_image() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageSparseMemoryRequirementsInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSparseMemoryRequirementsInfo2),
                "::",
                stringify!(image)
            )
        );
    }
    test_field_image();
}
impl Default for VkImageSparseMemoryRequirementsInfo2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryRequirements2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryRequirements: VkMemoryRequirements,
}
#[test]
fn bindgen_test_layout_VkMemoryRequirements2() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryRequirements2>(),
        40usize,
        concat!("Size of: ", stringify!(VkMemoryRequirements2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryRequirements2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryRequirements2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryRequirements2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryRequirements2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryRequirements2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryRequirements2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_memoryRequirements() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryRequirements2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryRequirements) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryRequirements2),
                "::",
                stringify!(memoryRequirements)
            )
        );
    }
    test_field_memoryRequirements();
}
impl Default for VkMemoryRequirements2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSparseImageMemoryRequirements2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryRequirements: VkSparseImageMemoryRequirements,
}
#[test]
fn bindgen_test_layout_VkSparseImageMemoryRequirements2() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseImageMemoryRequirements2>(),
        64usize,
        concat!("Size of: ", stringify!(VkSparseImageMemoryRequirements2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseImageMemoryRequirements2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSparseImageMemoryRequirements2)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryRequirements2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryRequirements2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryRequirements2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryRequirements2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_memoryRequirements() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageMemoryRequirements2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryRequirements) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageMemoryRequirements2),
                "::",
                stringify!(memoryRequirements)
            )
        );
    }
    test_field_memoryRequirements();
}
impl Default for VkSparseImageMemoryRequirements2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFeatures2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub features: VkPhysicalDeviceFeatures,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFeatures2() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFeatures2>(),
        240usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceFeatures2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFeatures2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceFeatures2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_features() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFeatures2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).features) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFeatures2),
                "::",
                stringify!(features)
            )
        );
    }
    test_field_features();
}
impl Default for VkPhysicalDeviceFeatures2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceProperties2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub properties: VkPhysicalDeviceProperties,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceProperties2() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceProperties2>(),
        840usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceProperties2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceProperties2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceProperties2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProperties2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProperties2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_properties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProperties2),
                "::",
                stringify!(properties)
            )
        );
    }
    test_field_properties();
}
impl Default for VkPhysicalDeviceProperties2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFormatProperties2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub formatProperties: VkFormatProperties,
}
#[test]
fn bindgen_test_layout_VkFormatProperties2() {
    assert_eq!(
        ::std::mem::size_of::<VkFormatProperties2>(),
        32usize,
        concat!("Size of: ", stringify!(VkFormatProperties2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkFormatProperties2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkFormatProperties2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFormatProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFormatProperties2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFormatProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFormatProperties2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_formatProperties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFormatProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).formatProperties) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFormatProperties2),
                "::",
                stringify!(formatProperties)
            )
        );
    }
    test_field_formatProperties();
}
impl Default for VkFormatProperties2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageFormatProperties2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub imageFormatProperties: VkImageFormatProperties,
}
#[test]
fn bindgen_test_layout_VkImageFormatProperties2() {
    assert_eq!(
        ::std::mem::size_of::<VkImageFormatProperties2>(),
        48usize,
        concat!("Size of: ", stringify!(VkImageFormatProperties2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageFormatProperties2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageFormatProperties2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageFormatProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageFormatProperties2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageFormatProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageFormatProperties2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_imageFormatProperties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageFormatProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageFormatProperties) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageFormatProperties2),
                "::",
                stringify!(imageFormatProperties)
            )
        );
    }
    test_field_imageFormatProperties();
}
impl Default for VkImageFormatProperties2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceImageFormatInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub format: VkFormat,
    pub type_: VkImageType,
    pub tiling: VkImageTiling,
    pub usage: VkImageUsageFlags,
    pub flags: VkImageCreateFlags,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceImageFormatInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceImageFormatInfo2>(),
        40usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceImageFormatInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceImageFormatInfo2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceImageFormatInfo2)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceImageFormatInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageFormatInfo2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceImageFormatInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageFormatInfo2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceImageFormatInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageFormatInfo2),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceImageFormatInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageFormatInfo2),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_tiling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceImageFormatInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tiling) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageFormatInfo2),
                "::",
                stringify!(tiling)
            )
        );
    }
    test_field_tiling();
    fn test_field_usage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceImageFormatInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageFormatInfo2),
                "::",
                stringify!(usage)
            )
        );
    }
    test_field_usage();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceImageFormatInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageFormatInfo2),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for VkPhysicalDeviceImageFormatInfo2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueueFamilyProperties2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub queueFamilyProperties: VkQueueFamilyProperties,
}
#[test]
fn bindgen_test_layout_VkQueueFamilyProperties2() {
    assert_eq!(
        ::std::mem::size_of::<VkQueueFamilyProperties2>(),
        40usize,
        concat!("Size of: ", stringify!(VkQueueFamilyProperties2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkQueueFamilyProperties2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkQueueFamilyProperties2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkQueueFamilyProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyProperties2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkQueueFamilyProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyProperties2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_queueFamilyProperties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkQueueFamilyProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queueFamilyProperties) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyProperties2),
                "::",
                stringify!(queueFamilyProperties)
            )
        );
    }
    test_field_queueFamilyProperties();
}
impl Default for VkQueueFamilyProperties2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMemoryProperties2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryProperties: VkPhysicalDeviceMemoryProperties,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMemoryProperties2() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMemoryProperties2>(),
        536usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceMemoryProperties2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMemoryProperties2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMemoryProperties2)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceMemoryProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryProperties2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceMemoryProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryProperties2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_memoryProperties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceMemoryProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryProperties) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryProperties2),
                "::",
                stringify!(memoryProperties)
            )
        );
    }
    test_field_memoryProperties();
}
impl Default for VkPhysicalDeviceMemoryProperties2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSparseImageFormatProperties2 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub properties: VkSparseImageFormatProperties,
}
#[test]
fn bindgen_test_layout_VkSparseImageFormatProperties2() {
    assert_eq!(
        ::std::mem::size_of::<VkSparseImageFormatProperties2>(),
        40usize,
        concat!("Size of: ", stringify!(VkSparseImageFormatProperties2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSparseImageFormatProperties2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSparseImageFormatProperties2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageFormatProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageFormatProperties2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageFormatProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageFormatProperties2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_properties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSparseImageFormatProperties2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSparseImageFormatProperties2),
                "::",
                stringify!(properties)
            )
        );
    }
    test_field_properties();
}
impl Default for VkSparseImageFormatProperties2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSparseImageFormatInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub format: VkFormat,
    pub type_: VkImageType,
    pub samples: VkSampleCountFlagBits,
    pub usage: VkImageUsageFlags,
    pub tiling: VkImageTiling,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSparseImageFormatInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSparseImageFormatInfo2>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSparseImageFormatInfo2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSparseImageFormatInfo2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSparseImageFormatInfo2)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSparseImageFormatInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSparseImageFormatInfo2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSparseImageFormatInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSparseImageFormatInfo2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSparseImageFormatInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSparseImageFormatInfo2),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSparseImageFormatInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSparseImageFormatInfo2),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_samples() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSparseImageFormatInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samples) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSparseImageFormatInfo2),
                "::",
                stringify!(samples)
            )
        );
    }
    test_field_samples();
    fn test_field_usage() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSparseImageFormatInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSparseImageFormatInfo2),
                "::",
                stringify!(usage)
            )
        );
    }
    test_field_usage();
    fn test_field_tiling() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSparseImageFormatInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tiling) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSparseImageFormatInfo2),
                "::",
                stringify!(tiling)
            )
        );
    }
    test_field_tiling();
}
impl Default for VkPhysicalDeviceSparseImageFormatInfo2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePointClippingProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub pointClippingBehavior: VkPointClippingBehavior,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePointClippingProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePointClippingProperties>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePointClippingProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePointClippingProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePointClippingProperties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePointClippingProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePointClippingProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePointClippingProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePointClippingProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pointClippingBehavior() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePointClippingProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pointClippingBehavior) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePointClippingProperties),
                "::",
                stringify!(pointClippingBehavior)
            )
        );
    }
    test_field_pointClippingBehavior();
}
impl Default for VkPhysicalDevicePointClippingProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkInputAttachmentAspectReference {
    pub subpass: u32,
    pub inputAttachmentIndex: u32,
    pub aspectMask: VkImageAspectFlags,
}
#[test]
fn bindgen_test_layout_VkInputAttachmentAspectReference() {
    assert_eq!(
        ::std::mem::size_of::<VkInputAttachmentAspectReference>(),
        12usize,
        concat!("Size of: ", stringify!(VkInputAttachmentAspectReference))
    );
    assert_eq!(
        ::std::mem::align_of::<VkInputAttachmentAspectReference>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkInputAttachmentAspectReference)
        )
    );
    fn test_field_subpass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkInputAttachmentAspectReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subpass) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkInputAttachmentAspectReference),
                "::",
                stringify!(subpass)
            )
        );
    }
    test_field_subpass();
    fn test_field_inputAttachmentIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkInputAttachmentAspectReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inputAttachmentIndex) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkInputAttachmentAspectReference),
                "::",
                stringify!(inputAttachmentIndex)
            )
        );
    }
    test_field_inputAttachmentIndex();
    fn test_field_aspectMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkInputAttachmentAspectReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aspectMask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkInputAttachmentAspectReference),
                "::",
                stringify!(aspectMask)
            )
        );
    }
    test_field_aspectMask();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassInputAttachmentAspectCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub aspectReferenceCount: u32,
    pub pAspectReferences: *const VkInputAttachmentAspectReference,
}
#[test]
fn bindgen_test_layout_VkRenderPassInputAttachmentAspectCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassInputAttachmentAspectCreateInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkRenderPassInputAttachmentAspectCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassInputAttachmentAspectCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRenderPassInputAttachmentAspectCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassInputAttachmentAspectCreateInfo>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassInputAttachmentAspectCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassInputAttachmentAspectCreateInfo>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassInputAttachmentAspectCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_aspectReferenceCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassInputAttachmentAspectCreateInfo>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aspectReferenceCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassInputAttachmentAspectCreateInfo),
                "::",
                stringify!(aspectReferenceCount)
            )
        );
    }
    test_field_aspectReferenceCount();
    fn test_field_pAspectReferences() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassInputAttachmentAspectCreateInfo>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pAspectReferences) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassInputAttachmentAspectCreateInfo),
                "::",
                stringify!(pAspectReferences)
            )
        );
    }
    test_field_pAspectReferences();
}
impl Default for VkRenderPassInputAttachmentAspectCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageViewUsageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub usage: VkImageUsageFlags,
}
#[test]
fn bindgen_test_layout_VkImageViewUsageCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkImageViewUsageCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkImageViewUsageCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageViewUsageCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageViewUsageCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewUsageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewUsageCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewUsageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewUsageCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_usage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewUsageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewUsageCreateInfo),
                "::",
                stringify!(usage)
            )
        );
    }
    test_field_usage();
}
impl Default for VkImageViewUsageCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineTessellationDomainOriginStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub domainOrigin: VkTessellationDomainOrigin,
}
#[test]
fn bindgen_test_layout_VkPipelineTessellationDomainOriginStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineTessellationDomainOriginStateCreateInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineTessellationDomainOriginStateCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineTessellationDomainOriginStateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineTessellationDomainOriginStateCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineTessellationDomainOriginStateCreateInfo,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineTessellationDomainOriginStateCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineTessellationDomainOriginStateCreateInfo,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineTessellationDomainOriginStateCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_domainOrigin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineTessellationDomainOriginStateCreateInfo,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).domainOrigin) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineTessellationDomainOriginStateCreateInfo),
                "::",
                stringify!(domainOrigin)
            )
        );
    }
    test_field_domainOrigin();
}
impl Default for VkPipelineTessellationDomainOriginStateCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassMultiviewCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub subpassCount: u32,
    pub pViewMasks: *const u32,
    pub dependencyCount: u32,
    pub pViewOffsets: *const i32,
    pub correlationMaskCount: u32,
    pub pCorrelationMasks: *const u32,
}
#[test]
fn bindgen_test_layout_VkRenderPassMultiviewCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassMultiviewCreateInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VkRenderPassMultiviewCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassMultiviewCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkRenderPassMultiviewCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassMultiviewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassMultiviewCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassMultiviewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassMultiviewCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_subpassCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassMultiviewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subpassCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassMultiviewCreateInfo),
                "::",
                stringify!(subpassCount)
            )
        );
    }
    test_field_subpassCount();
    fn test_field_pViewMasks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassMultiviewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pViewMasks) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassMultiviewCreateInfo),
                "::",
                stringify!(pViewMasks)
            )
        );
    }
    test_field_pViewMasks();
    fn test_field_dependencyCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassMultiviewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dependencyCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassMultiviewCreateInfo),
                "::",
                stringify!(dependencyCount)
            )
        );
    }
    test_field_dependencyCount();
    fn test_field_pViewOffsets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassMultiviewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pViewOffsets) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassMultiviewCreateInfo),
                "::",
                stringify!(pViewOffsets)
            )
        );
    }
    test_field_pViewOffsets();
    fn test_field_correlationMaskCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassMultiviewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).correlationMaskCount) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassMultiviewCreateInfo),
                "::",
                stringify!(correlationMaskCount)
            )
        );
    }
    test_field_correlationMaskCount();
    fn test_field_pCorrelationMasks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassMultiviewCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCorrelationMasks) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassMultiviewCreateInfo),
                "::",
                stringify!(pCorrelationMasks)
            )
        );
    }
    test_field_pCorrelationMasks();
}
impl Default for VkRenderPassMultiviewCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMultiviewFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub multiview: VkBool32,
    pub multiviewGeometryShader: VkBool32,
    pub multiviewTessellationShader: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMultiviewFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMultiviewFeatures>(),
        32usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceMultiviewFeatures))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMultiviewFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMultiviewFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceMultiviewFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiviewFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceMultiviewFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiviewFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_multiview() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceMultiviewFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiview) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiviewFeatures),
                "::",
                stringify!(multiview)
            )
        );
    }
    test_field_multiview();
    fn test_field_multiviewGeometryShader() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceMultiviewFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiviewGeometryShader) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiviewFeatures),
                "::",
                stringify!(multiviewGeometryShader)
            )
        );
    }
    test_field_multiviewGeometryShader();
    fn test_field_multiviewTessellationShader() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceMultiviewFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiviewTessellationShader) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiviewFeatures),
                "::",
                stringify!(multiviewTessellationShader)
            )
        );
    }
    test_field_multiviewTessellationShader();
}
impl Default for VkPhysicalDeviceMultiviewFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMultiviewProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxMultiviewViewCount: u32,
    pub maxMultiviewInstanceIndex: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMultiviewProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMultiviewProperties>(),
        24usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceMultiviewProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMultiviewProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMultiviewProperties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMultiviewProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiviewProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMultiviewProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiviewProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxMultiviewViewCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMultiviewProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMultiviewViewCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiviewProperties),
                "::",
                stringify!(maxMultiviewViewCount)
            )
        );
    }
    test_field_maxMultiviewViewCount();
    fn test_field_maxMultiviewInstanceIndex() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMultiviewProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMultiviewInstanceIndex) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiviewProperties),
                "::",
                stringify!(maxMultiviewInstanceIndex)
            )
        );
    }
    test_field_maxMultiviewInstanceIndex();
}
impl Default for VkPhysicalDeviceMultiviewProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVariablePointersFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub variablePointersStorageBuffer: VkBool32,
    pub variablePointers: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVariablePointersFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVariablePointersFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceVariablePointersFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVariablePointersFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVariablePointersFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVariablePointersFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVariablePointersFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVariablePointersFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVariablePointersFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_variablePointersStorageBuffer() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVariablePointersFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).variablePointersStorageBuffer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVariablePointersFeatures),
                "::",
                stringify!(variablePointersStorageBuffer)
            )
        );
    }
    test_field_variablePointersStorageBuffer();
    fn test_field_variablePointers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVariablePointersFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).variablePointers) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVariablePointersFeatures),
                "::",
                stringify!(variablePointers)
            )
        );
    }
    test_field_variablePointers();
}
impl Default for VkPhysicalDeviceVariablePointersFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPhysicalDeviceVariablePointerFeatures = VkPhysicalDeviceVariablePointersFeatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceProtectedMemoryFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub protectedMemory: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceProtectedMemoryFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceProtectedMemoryFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceProtectedMemoryFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceProtectedMemoryFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceProtectedMemoryFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceProtectedMemoryFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProtectedMemoryFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceProtectedMemoryFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProtectedMemoryFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_protectedMemory() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceProtectedMemoryFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).protectedMemory) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProtectedMemoryFeatures),
                "::",
                stringify!(protectedMemory)
            )
        );
    }
    test_field_protectedMemory();
}
impl Default for VkPhysicalDeviceProtectedMemoryFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceProtectedMemoryProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub protectedNoFault: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceProtectedMemoryProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceProtectedMemoryProperties>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceProtectedMemoryProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceProtectedMemoryProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceProtectedMemoryProperties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceProtectedMemoryProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProtectedMemoryProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceProtectedMemoryProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProtectedMemoryProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_protectedNoFault() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceProtectedMemoryProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).protectedNoFault) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProtectedMemoryProperties),
                "::",
                stringify!(protectedNoFault)
            )
        );
    }
    test_field_protectedNoFault();
}
impl Default for VkPhysicalDeviceProtectedMemoryProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceQueueInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDeviceQueueCreateFlags,
    pub queueFamilyIndex: u32,
    pub queueIndex: u32,
}
#[test]
fn bindgen_test_layout_VkDeviceQueueInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceQueueInfo2>(),
        32usize,
        concat!("Size of: ", stringify!(VkDeviceQueueInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceQueueInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceQueueInfo2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceQueueInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceQueueInfo2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceQueueInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceQueueInfo2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceQueueInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceQueueInfo2),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_queueFamilyIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceQueueInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queueFamilyIndex) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceQueueInfo2),
                "::",
                stringify!(queueFamilyIndex)
            )
        );
    }
    test_field_queueFamilyIndex();
    fn test_field_queueIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceQueueInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queueIndex) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceQueueInfo2),
                "::",
                stringify!(queueIndex)
            )
        );
    }
    test_field_queueIndex();
}
impl Default for VkDeviceQueueInfo2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkProtectedSubmitInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub protectedSubmit: VkBool32,
}
#[test]
fn bindgen_test_layout_VkProtectedSubmitInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkProtectedSubmitInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkProtectedSubmitInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkProtectedSubmitInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkProtectedSubmitInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkProtectedSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkProtectedSubmitInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkProtectedSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkProtectedSubmitInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_protectedSubmit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkProtectedSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).protectedSubmit) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkProtectedSubmitInfo),
                "::",
                stringify!(protectedSubmit)
            )
        );
    }
    test_field_protectedSubmit();
}
impl Default for VkProtectedSubmitInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSamplerYcbcrConversionCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub format: VkFormat,
    pub ycbcrModel: VkSamplerYcbcrModelConversion,
    pub ycbcrRange: VkSamplerYcbcrRange,
    pub components: VkComponentMapping,
    pub xChromaOffset: VkChromaLocation,
    pub yChromaOffset: VkChromaLocation,
    pub chromaFilter: VkFilter,
    pub forceExplicitReconstruction: VkBool32,
}
#[test]
fn bindgen_test_layout_VkSamplerYcbcrConversionCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSamplerYcbcrConversionCreateInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VkSamplerYcbcrConversionCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSamplerYcbcrConversionCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSamplerYcbcrConversionCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerYcbcrConversionCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerYcbcrConversionCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerYcbcrConversionCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerYcbcrConversionCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerYcbcrConversionCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerYcbcrConversionCreateInfo),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_ycbcrModel() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerYcbcrConversionCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ycbcrModel) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerYcbcrConversionCreateInfo),
                "::",
                stringify!(ycbcrModel)
            )
        );
    }
    test_field_ycbcrModel();
    fn test_field_ycbcrRange() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerYcbcrConversionCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ycbcrRange) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerYcbcrConversionCreateInfo),
                "::",
                stringify!(ycbcrRange)
            )
        );
    }
    test_field_ycbcrRange();
    fn test_field_components() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerYcbcrConversionCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).components) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerYcbcrConversionCreateInfo),
                "::",
                stringify!(components)
            )
        );
    }
    test_field_components();
    fn test_field_xChromaOffset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerYcbcrConversionCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xChromaOffset) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerYcbcrConversionCreateInfo),
                "::",
                stringify!(xChromaOffset)
            )
        );
    }
    test_field_xChromaOffset();
    fn test_field_yChromaOffset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerYcbcrConversionCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).yChromaOffset) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerYcbcrConversionCreateInfo),
                "::",
                stringify!(yChromaOffset)
            )
        );
    }
    test_field_yChromaOffset();
    fn test_field_chromaFilter() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerYcbcrConversionCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chromaFilter) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerYcbcrConversionCreateInfo),
                "::",
                stringify!(chromaFilter)
            )
        );
    }
    test_field_chromaFilter();
    fn test_field_forceExplicitReconstruction() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerYcbcrConversionCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).forceExplicitReconstruction) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerYcbcrConversionCreateInfo),
                "::",
                stringify!(forceExplicitReconstruction)
            )
        );
    }
    test_field_forceExplicitReconstruction();
}
impl Default for VkSamplerYcbcrConversionCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSamplerYcbcrConversionInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub conversion: VkSamplerYcbcrConversion,
}
#[test]
fn bindgen_test_layout_VkSamplerYcbcrConversionInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSamplerYcbcrConversionInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkSamplerYcbcrConversionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSamplerYcbcrConversionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSamplerYcbcrConversionInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerYcbcrConversionInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerYcbcrConversionInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerYcbcrConversionInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerYcbcrConversionInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_conversion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerYcbcrConversionInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).conversion) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerYcbcrConversionInfo),
                "::",
                stringify!(conversion)
            )
        );
    }
    test_field_conversion();
}
impl Default for VkSamplerYcbcrConversionInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindImagePlaneMemoryInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub planeAspect: VkImageAspectFlagBits,
}
#[test]
fn bindgen_test_layout_VkBindImagePlaneMemoryInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBindImagePlaneMemoryInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkBindImagePlaneMemoryInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindImagePlaneMemoryInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBindImagePlaneMemoryInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImagePlaneMemoryInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImagePlaneMemoryInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImagePlaneMemoryInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImagePlaneMemoryInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_planeAspect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImagePlaneMemoryInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).planeAspect) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImagePlaneMemoryInfo),
                "::",
                stringify!(planeAspect)
            )
        );
    }
    test_field_planeAspect();
}
impl Default for VkBindImagePlaneMemoryInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImagePlaneMemoryRequirementsInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub planeAspect: VkImageAspectFlagBits,
}
#[test]
fn bindgen_test_layout_VkImagePlaneMemoryRequirementsInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkImagePlaneMemoryRequirementsInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkImagePlaneMemoryRequirementsInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImagePlaneMemoryRequirementsInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkImagePlaneMemoryRequirementsInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImagePlaneMemoryRequirementsInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImagePlaneMemoryRequirementsInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImagePlaneMemoryRequirementsInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImagePlaneMemoryRequirementsInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_planeAspect() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImagePlaneMemoryRequirementsInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).planeAspect) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImagePlaneMemoryRequirementsInfo),
                "::",
                stringify!(planeAspect)
            )
        );
    }
    test_field_planeAspect();
}
impl Default for VkImagePlaneMemoryRequirementsInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSamplerYcbcrConversionFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub samplerYcbcrConversion: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSamplerYcbcrConversionFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSamplerYcbcrConversionFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSamplerYcbcrConversionFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSamplerYcbcrConversionFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSamplerYcbcrConversionFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceSamplerYcbcrConversionFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSamplerYcbcrConversionFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceSamplerYcbcrConversionFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSamplerYcbcrConversionFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_samplerYcbcrConversion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceSamplerYcbcrConversionFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samplerYcbcrConversion) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSamplerYcbcrConversionFeatures),
                "::",
                stringify!(samplerYcbcrConversion)
            )
        );
    }
    test_field_samplerYcbcrConversion();
}
impl Default for VkPhysicalDeviceSamplerYcbcrConversionFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSamplerYcbcrConversionImageFormatProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub combinedImageSamplerDescriptorCount: u32,
}
#[test]
fn bindgen_test_layout_VkSamplerYcbcrConversionImageFormatProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkSamplerYcbcrConversionImageFormatProperties>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkSamplerYcbcrConversionImageFormatProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkSamplerYcbcrConversionImageFormatProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSamplerYcbcrConversionImageFormatProperties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkSamplerYcbcrConversionImageFormatProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerYcbcrConversionImageFormatProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkSamplerYcbcrConversionImageFormatProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerYcbcrConversionImageFormatProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_combinedImageSamplerDescriptorCount() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkSamplerYcbcrConversionImageFormatProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).combinedImageSamplerDescriptorCount) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerYcbcrConversionImageFormatProperties),
                "::",
                stringify!(combinedImageSamplerDescriptorCount)
            )
        );
    }
    test_field_combinedImageSamplerDescriptorCount();
}
impl Default for VkSamplerYcbcrConversionImageFormatProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorUpdateTemplateEntry {
    pub dstBinding: u32,
    pub dstArrayElement: u32,
    pub descriptorCount: u32,
    pub descriptorType: VkDescriptorType,
    pub offset: usize,
    pub stride: usize,
}
#[test]
fn bindgen_test_layout_VkDescriptorUpdateTemplateEntry() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorUpdateTemplateEntry>(),
        32usize,
        concat!("Size of: ", stringify!(VkDescriptorUpdateTemplateEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorUpdateTemplateEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorUpdateTemplateEntry))
    );
    fn test_field_dstBinding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorUpdateTemplateEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstBinding) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorUpdateTemplateEntry),
                "::",
                stringify!(dstBinding)
            )
        );
    }
    test_field_dstBinding();
    fn test_field_dstArrayElement() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorUpdateTemplateEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstArrayElement) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorUpdateTemplateEntry),
                "::",
                stringify!(dstArrayElement)
            )
        );
    }
    test_field_dstArrayElement();
    fn test_field_descriptorCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorUpdateTemplateEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorUpdateTemplateEntry),
                "::",
                stringify!(descriptorCount)
            )
        );
    }
    test_field_descriptorCount();
    fn test_field_descriptorType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorUpdateTemplateEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorType) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorUpdateTemplateEntry),
                "::",
                stringify!(descriptorType)
            )
        );
    }
    test_field_descriptorType();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorUpdateTemplateEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorUpdateTemplateEntry),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_stride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorUpdateTemplateEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorUpdateTemplateEntry),
                "::",
                stringify!(stride)
            )
        );
    }
    test_field_stride();
}
impl Default for VkDescriptorUpdateTemplateEntry {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorUpdateTemplateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDescriptorUpdateTemplateCreateFlags,
    pub descriptorUpdateEntryCount: u32,
    pub pDescriptorUpdateEntries: *const VkDescriptorUpdateTemplateEntry,
    pub templateType: VkDescriptorUpdateTemplateType,
    pub descriptorSetLayout: VkDescriptorSetLayout,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub pipelineLayout: VkPipelineLayout,
    pub set: u32,
}
#[test]
fn bindgen_test_layout_VkDescriptorUpdateTemplateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorUpdateTemplateCreateInfo>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(VkDescriptorUpdateTemplateCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorUpdateTemplateCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDescriptorUpdateTemplateCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorUpdateTemplateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorUpdateTemplateCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorUpdateTemplateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorUpdateTemplateCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorUpdateTemplateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorUpdateTemplateCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_descriptorUpdateEntryCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorUpdateTemplateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorUpdateEntryCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorUpdateTemplateCreateInfo),
                "::",
                stringify!(descriptorUpdateEntryCount)
            )
        );
    }
    test_field_descriptorUpdateEntryCount();
    fn test_field_pDescriptorUpdateEntries() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorUpdateTemplateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDescriptorUpdateEntries) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorUpdateTemplateCreateInfo),
                "::",
                stringify!(pDescriptorUpdateEntries)
            )
        );
    }
    test_field_pDescriptorUpdateEntries();
    fn test_field_templateType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorUpdateTemplateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).templateType) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorUpdateTemplateCreateInfo),
                "::",
                stringify!(templateType)
            )
        );
    }
    test_field_templateType();
    fn test_field_descriptorSetLayout() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorUpdateTemplateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorSetLayout) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorUpdateTemplateCreateInfo),
                "::",
                stringify!(descriptorSetLayout)
            )
        );
    }
    test_field_descriptorSetLayout();
    fn test_field_pipelineBindPoint() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorUpdateTemplateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineBindPoint) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorUpdateTemplateCreateInfo),
                "::",
                stringify!(pipelineBindPoint)
            )
        );
    }
    test_field_pipelineBindPoint();
    fn test_field_pipelineLayout() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorUpdateTemplateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineLayout) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorUpdateTemplateCreateInfo),
                "::",
                stringify!(pipelineLayout)
            )
        );
    }
    test_field_pipelineLayout();
    fn test_field_set() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorUpdateTemplateCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorUpdateTemplateCreateInfo),
                "::",
                stringify!(set)
            )
        );
    }
    test_field_set();
}
impl Default for VkDescriptorUpdateTemplateCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkExternalMemoryProperties {
    pub externalMemoryFeatures: VkExternalMemoryFeatureFlags,
    pub exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlags,
    pub compatibleHandleTypes: VkExternalMemoryHandleTypeFlags,
}
#[test]
fn bindgen_test_layout_VkExternalMemoryProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalMemoryProperties>(),
        12usize,
        concat!("Size of: ", stringify!(VkExternalMemoryProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalMemoryProperties>(),
        4usize,
        concat!("Alignment of ", stringify!(VkExternalMemoryProperties))
    );
    fn test_field_externalMemoryFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalMemoryProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).externalMemoryFeatures) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalMemoryProperties),
                "::",
                stringify!(externalMemoryFeatures)
            )
        );
    }
    test_field_externalMemoryFeatures();
    fn test_field_exportFromImportedHandleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalMemoryProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).exportFromImportedHandleTypes) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalMemoryProperties),
                "::",
                stringify!(exportFromImportedHandleTypes)
            )
        );
    }
    test_field_exportFromImportedHandleTypes();
    fn test_field_compatibleHandleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalMemoryProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compatibleHandleTypes) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalMemoryProperties),
                "::",
                stringify!(compatibleHandleTypes)
            )
        );
    }
    test_field_compatibleHandleTypes();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExternalImageFormatInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExternalImageFormatInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExternalImageFormatInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceExternalImageFormatInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExternalImageFormatInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExternalImageFormatInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalImageFormatInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalImageFormatInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalImageFormatInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalImageFormatInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_handleType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalImageFormatInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalImageFormatInfo),
                "::",
                stringify!(handleType)
            )
        );
    }
    test_field_handleType();
}
impl Default for VkPhysicalDeviceExternalImageFormatInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExternalImageFormatProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub externalMemoryProperties: VkExternalMemoryProperties,
}
#[test]
fn bindgen_test_layout_VkExternalImageFormatProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalImageFormatProperties>(),
        32usize,
        concat!("Size of: ", stringify!(VkExternalImageFormatProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalImageFormatProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExternalImageFormatProperties))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalImageFormatProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalImageFormatProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalImageFormatProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalImageFormatProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_externalMemoryProperties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalImageFormatProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).externalMemoryProperties) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalImageFormatProperties),
                "::",
                stringify!(externalMemoryProperties)
            )
        );
    }
    test_field_externalMemoryProperties();
}
impl Default for VkExternalImageFormatProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExternalBufferInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkBufferCreateFlags,
    pub usage: VkBufferUsageFlags,
    pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExternalBufferInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExternalBufferInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceExternalBufferInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExternalBufferInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExternalBufferInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalBufferInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalBufferInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalBufferInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalBufferInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalBufferInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalBufferInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_usage() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalBufferInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalBufferInfo),
                "::",
                stringify!(usage)
            )
        );
    }
    test_field_usage();
    fn test_field_handleType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalBufferInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleType) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalBufferInfo),
                "::",
                stringify!(handleType)
            )
        );
    }
    test_field_handleType();
}
impl Default for VkPhysicalDeviceExternalBufferInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExternalBufferProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub externalMemoryProperties: VkExternalMemoryProperties,
}
#[test]
fn bindgen_test_layout_VkExternalBufferProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalBufferProperties>(),
        32usize,
        concat!("Size of: ", stringify!(VkExternalBufferProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalBufferProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExternalBufferProperties))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalBufferProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalBufferProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalBufferProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalBufferProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_externalMemoryProperties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalBufferProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).externalMemoryProperties) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalBufferProperties),
                "::",
                stringify!(externalMemoryProperties)
            )
        );
    }
    test_field_externalMemoryProperties();
}
impl Default for VkExternalBufferProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceIDProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub deviceUUID: [u8; 16usize],
    pub driverUUID: [u8; 16usize],
    pub deviceLUID: [u8; 8usize],
    pub deviceNodeMask: u32,
    pub deviceLUIDValid: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceIDProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceIDProperties>(),
        64usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceIDProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceIDProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceIDProperties))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceIDProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceIDProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceIDProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceIDProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_deviceUUID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceIDProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceUUID) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceIDProperties),
                "::",
                stringify!(deviceUUID)
            )
        );
    }
    test_field_deviceUUID();
    fn test_field_driverUUID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceIDProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).driverUUID) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceIDProperties),
                "::",
                stringify!(driverUUID)
            )
        );
    }
    test_field_driverUUID();
    fn test_field_deviceLUID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceIDProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceLUID) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceIDProperties),
                "::",
                stringify!(deviceLUID)
            )
        );
    }
    test_field_deviceLUID();
    fn test_field_deviceNodeMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceIDProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceNodeMask) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceIDProperties),
                "::",
                stringify!(deviceNodeMask)
            )
        );
    }
    test_field_deviceNodeMask();
    fn test_field_deviceLUIDValid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceIDProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceLUIDValid) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceIDProperties),
                "::",
                stringify!(deviceLUIDValid)
            )
        );
    }
    test_field_deviceLUIDValid();
}
impl Default for VkPhysicalDeviceIDProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExternalMemoryImageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlags,
}
#[test]
fn bindgen_test_layout_VkExternalMemoryImageCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalMemoryImageCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkExternalMemoryImageCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalMemoryImageCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExternalMemoryImageCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalMemoryImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalMemoryImageCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalMemoryImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalMemoryImageCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_handleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalMemoryImageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleTypes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalMemoryImageCreateInfo),
                "::",
                stringify!(handleTypes)
            )
        );
    }
    test_field_handleTypes();
}
impl Default for VkExternalMemoryImageCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExternalMemoryBufferCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlags,
}
#[test]
fn bindgen_test_layout_VkExternalMemoryBufferCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalMemoryBufferCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkExternalMemoryBufferCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalMemoryBufferCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkExternalMemoryBufferCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalMemoryBufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalMemoryBufferCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalMemoryBufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalMemoryBufferCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_handleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalMemoryBufferCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleTypes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalMemoryBufferCreateInfo),
                "::",
                stringify!(handleTypes)
            )
        );
    }
    test_field_handleTypes();
}
impl Default for VkExternalMemoryBufferCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExportMemoryAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlags,
}
#[test]
fn bindgen_test_layout_VkExportMemoryAllocateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkExportMemoryAllocateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkExportMemoryAllocateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExportMemoryAllocateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExportMemoryAllocateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExportMemoryAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExportMemoryAllocateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExportMemoryAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExportMemoryAllocateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_handleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExportMemoryAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleTypes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExportMemoryAllocateInfo),
                "::",
                stringify!(handleTypes)
            )
        );
    }
    test_field_handleTypes();
}
impl Default for VkExportMemoryAllocateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExternalFenceInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleType: VkExternalFenceHandleTypeFlagBits,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExternalFenceInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExternalFenceInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceExternalFenceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExternalFenceInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExternalFenceInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalFenceInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalFenceInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalFenceInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalFenceInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_handleType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalFenceInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalFenceInfo),
                "::",
                stringify!(handleType)
            )
        );
    }
    test_field_handleType();
}
impl Default for VkPhysicalDeviceExternalFenceInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExternalFenceProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlags,
    pub compatibleHandleTypes: VkExternalFenceHandleTypeFlags,
    pub externalFenceFeatures: VkExternalFenceFeatureFlags,
}
#[test]
fn bindgen_test_layout_VkExternalFenceProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalFenceProperties>(),
        32usize,
        concat!("Size of: ", stringify!(VkExternalFenceProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalFenceProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExternalFenceProperties))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalFenceProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalFenceProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalFenceProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalFenceProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_exportFromImportedHandleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalFenceProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).exportFromImportedHandleTypes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalFenceProperties),
                "::",
                stringify!(exportFromImportedHandleTypes)
            )
        );
    }
    test_field_exportFromImportedHandleTypes();
    fn test_field_compatibleHandleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalFenceProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compatibleHandleTypes) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalFenceProperties),
                "::",
                stringify!(compatibleHandleTypes)
            )
        );
    }
    test_field_compatibleHandleTypes();
    fn test_field_externalFenceFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalFenceProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).externalFenceFeatures) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalFenceProperties),
                "::",
                stringify!(externalFenceFeatures)
            )
        );
    }
    test_field_externalFenceFeatures();
}
impl Default for VkExternalFenceProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExportFenceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalFenceHandleTypeFlags,
}
#[test]
fn bindgen_test_layout_VkExportFenceCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkExportFenceCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkExportFenceCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExportFenceCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExportFenceCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExportFenceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExportFenceCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExportFenceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExportFenceCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_handleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExportFenceCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleTypes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExportFenceCreateInfo),
                "::",
                stringify!(handleTypes)
            )
        );
    }
    test_field_handleTypes();
}
impl Default for VkExportFenceCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExportSemaphoreCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalSemaphoreHandleTypeFlags,
}
#[test]
fn bindgen_test_layout_VkExportSemaphoreCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkExportSemaphoreCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkExportSemaphoreCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExportSemaphoreCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExportSemaphoreCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExportSemaphoreCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExportSemaphoreCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExportSemaphoreCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExportSemaphoreCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_handleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExportSemaphoreCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleTypes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExportSemaphoreCreateInfo),
                "::",
                stringify!(handleTypes)
            )
        );
    }
    test_field_handleTypes();
}
impl Default for VkExportSemaphoreCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExternalSemaphoreInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleType: VkExternalSemaphoreHandleTypeFlagBits,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExternalSemaphoreInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExternalSemaphoreInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceExternalSemaphoreInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExternalSemaphoreInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExternalSemaphoreInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalSemaphoreInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalSemaphoreInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalSemaphoreInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalSemaphoreInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_handleType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalSemaphoreInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalSemaphoreInfo),
                "::",
                stringify!(handleType)
            )
        );
    }
    test_field_handleType();
}
impl Default for VkPhysicalDeviceExternalSemaphoreInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExternalSemaphoreProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlags,
    pub compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlags,
    pub externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlags,
}
#[test]
fn bindgen_test_layout_VkExternalSemaphoreProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalSemaphoreProperties>(),
        32usize,
        concat!("Size of: ", stringify!(VkExternalSemaphoreProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalSemaphoreProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExternalSemaphoreProperties))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalSemaphoreProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalSemaphoreProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalSemaphoreProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalSemaphoreProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_exportFromImportedHandleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalSemaphoreProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).exportFromImportedHandleTypes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalSemaphoreProperties),
                "::",
                stringify!(exportFromImportedHandleTypes)
            )
        );
    }
    test_field_exportFromImportedHandleTypes();
    fn test_field_compatibleHandleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalSemaphoreProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compatibleHandleTypes) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalSemaphoreProperties),
                "::",
                stringify!(compatibleHandleTypes)
            )
        );
    }
    test_field_compatibleHandleTypes();
    fn test_field_externalSemaphoreFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalSemaphoreProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).externalSemaphoreFeatures) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalSemaphoreProperties),
                "::",
                stringify!(externalSemaphoreFeatures)
            )
        );
    }
    test_field_externalSemaphoreFeatures();
}
impl Default for VkExternalSemaphoreProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMaintenance3Properties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxPerSetDescriptors: u32,
    pub maxMemoryAllocationSize: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMaintenance3Properties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMaintenance3Properties>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMaintenance3Properties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMaintenance3Properties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMaintenance3Properties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMaintenance3Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMaintenance3Properties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMaintenance3Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMaintenance3Properties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxPerSetDescriptors() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMaintenance3Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerSetDescriptors) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMaintenance3Properties),
                "::",
                stringify!(maxPerSetDescriptors)
            )
        );
    }
    test_field_maxPerSetDescriptors();
    fn test_field_maxMemoryAllocationSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMaintenance3Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMemoryAllocationSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMaintenance3Properties),
                "::",
                stringify!(maxMemoryAllocationSize)
            )
        );
    }
    test_field_maxMemoryAllocationSize();
}
impl Default for VkPhysicalDeviceMaintenance3Properties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetLayoutSupport {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub supported: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetLayoutSupport() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorSetLayoutSupport>(),
        24usize,
        concat!("Size of: ", stringify!(VkDescriptorSetLayoutSupport))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorSetLayoutSupport>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorSetLayoutSupport))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetLayoutSupport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutSupport),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetLayoutSupport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutSupport),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_supported() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorSetLayoutSupport>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supported) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutSupport),
                "::",
                stringify!(supported)
            )
        );
    }
    test_field_supported();
}
impl Default for VkDescriptorSetLayoutSupport {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderDrawParametersFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderDrawParameters: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderDrawParametersFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderDrawParametersFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderDrawParametersFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderDrawParametersFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderDrawParametersFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderDrawParametersFeatures>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderDrawParametersFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderDrawParametersFeatures>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderDrawParametersFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderDrawParameters() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderDrawParametersFeatures>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDrawParameters) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderDrawParametersFeatures),
                "::",
                stringify!(shaderDrawParameters)
            )
        );
    }
    test_field_shaderDrawParameters();
}
impl Default for VkPhysicalDeviceShaderDrawParametersFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPhysicalDeviceShaderDrawParameterFeatures = VkPhysicalDeviceShaderDrawParametersFeatures;
pub type PFN_vkEnumerateInstanceVersion =
    ::std::option::Option<unsafe extern "C" fn(pApiVersion: *mut u32) -> VkResult>;
pub type PFN_vkBindBufferMemory2 = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindBufferMemoryInfo,
    ) -> VkResult,
>;
pub type PFN_vkBindImageMemory2 = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindImageMemoryInfo,
    ) -> VkResult,
>;
pub type PFN_vkGetDeviceGroupPeerMemoryFeatures = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        heapIndex: u32,
        localDeviceIndex: u32,
        remoteDeviceIndex: u32,
        pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags,
    ),
>;
pub type PFN_vkCmdSetDeviceMask =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer, deviceMask: u32)>;
pub type PFN_vkCmdDispatchBase = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        baseGroupX: u32,
        baseGroupY: u32,
        baseGroupZ: u32,
        groupCountX: u32,
        groupCountY: u32,
        groupCountZ: u32,
    ),
>;
pub type PFN_vkEnumeratePhysicalDeviceGroups = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pPhysicalDeviceGroupCount: *mut u32,
        pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties,
    ) -> VkResult,
>;
pub type PFN_vkGetImageMemoryRequirements2 = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkImageMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetBufferMemoryRequirements2 = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkBufferMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetImageSparseMemoryRequirements2 = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkImageSparseMemoryRequirementsInfo2,
        pSparseMemoryRequirementCount: *mut u32,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceFeatures2 = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pFeatures: *mut VkPhysicalDeviceFeatures2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceProperties2 = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceFormatProperties2 = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        pFormatProperties: *mut VkFormatProperties2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceImageFormatProperties2 = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2,
        pImageFormatProperties: *mut VkImageFormatProperties2,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceQueueFamilyProperties2 = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pQueueFamilyPropertyCount: *mut u32,
        pQueueFamilyProperties: *mut VkQueueFamilyProperties2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceMemoryProperties2 = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2,
        pPropertyCount: *mut u32,
        pProperties: *mut VkSparseImageFormatProperties2,
    ),
>;
pub type PFN_vkTrimCommandPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        commandPool: VkCommandPool,
        flags: VkCommandPoolTrimFlags,
    ),
>;
pub type PFN_vkGetDeviceQueue2 = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pQueueInfo: *const VkDeviceQueueInfo2,
        pQueue: *mut VkQueue,
    ),
>;
pub type PFN_vkCreateSamplerYcbcrConversion = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pYcbcrConversion: *mut VkSamplerYcbcrConversion,
    ) -> VkResult,
>;
pub type PFN_vkDestroySamplerYcbcrConversion = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        ycbcrConversion: VkSamplerYcbcrConversion,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCreateDescriptorUpdateTemplate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate,
    ) -> VkResult,
>;
pub type PFN_vkDestroyDescriptorUpdateTemplate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkUpdateDescriptorSetWithTemplate = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorSet: VkDescriptorSet,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        pData: *const ::std::os::raw::c_void,
    ),
>;
pub type PFN_vkGetPhysicalDeviceExternalBufferProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo,
        pExternalBufferProperties: *mut VkExternalBufferProperties,
    ),
>;
pub type PFN_vkGetPhysicalDeviceExternalFenceProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo,
        pExternalFenceProperties: *mut VkExternalFenceProperties,
    ),
>;
pub type PFN_vkGetPhysicalDeviceExternalSemaphoreProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo,
        pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties,
    ),
>;
pub type PFN_vkGetDescriptorSetLayoutSupport = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
        pSupport: *mut VkDescriptorSetLayoutSupport,
    ),
>;
extern "C" {
    pub fn vkEnumerateInstanceVersion(pApiVersion: *mut u32) -> VkResult;
}
extern "C" {
    pub fn vkBindBufferMemory2(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindBufferMemoryInfo,
    ) -> VkResult;
}
extern "C" {
    pub fn vkBindImageMemory2(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindImageMemoryInfo,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDeviceGroupPeerMemoryFeatures(
        device: VkDevice,
        heapIndex: u32,
        localDeviceIndex: u32,
        remoteDeviceIndex: u32,
        pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags,
    );
}
extern "C" {
    pub fn vkCmdSetDeviceMask(commandBuffer: VkCommandBuffer, deviceMask: u32);
}
extern "C" {
    pub fn vkCmdDispatchBase(
        commandBuffer: VkCommandBuffer,
        baseGroupX: u32,
        baseGroupY: u32,
        baseGroupZ: u32,
        groupCountX: u32,
        groupCountY: u32,
        groupCountZ: u32,
    );
}
extern "C" {
    pub fn vkEnumeratePhysicalDeviceGroups(
        instance: VkInstance,
        pPhysicalDeviceGroupCount: *mut u32,
        pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetImageMemoryRequirements2(
        device: VkDevice,
        pInfo: *const VkImageMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    );
}
extern "C" {
    pub fn vkGetBufferMemoryRequirements2(
        device: VkDevice,
        pInfo: *const VkBufferMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    );
}
extern "C" {
    pub fn vkGetImageSparseMemoryRequirements2(
        device: VkDevice,
        pInfo: *const VkImageSparseMemoryRequirementsInfo2,
        pSparseMemoryRequirementCount: *mut u32,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceFeatures2(
        physicalDevice: VkPhysicalDevice,
        pFeatures: *mut VkPhysicalDeviceFeatures2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceProperties2(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceFormatProperties2(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        pFormatProperties: *mut VkFormatProperties2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceImageFormatProperties2(
        physicalDevice: VkPhysicalDevice,
        pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2,
        pImageFormatProperties: *mut VkImageFormatProperties2,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceQueueFamilyProperties2(
        physicalDevice: VkPhysicalDevice,
        pQueueFamilyPropertyCount: *mut u32,
        pQueueFamilyProperties: *mut VkQueueFamilyProperties2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceMemoryProperties2(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceSparseImageFormatProperties2(
        physicalDevice: VkPhysicalDevice,
        pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2,
        pPropertyCount: *mut u32,
        pProperties: *mut VkSparseImageFormatProperties2,
    );
}
extern "C" {
    pub fn vkTrimCommandPool(
        device: VkDevice,
        commandPool: VkCommandPool,
        flags: VkCommandPoolTrimFlags,
    );
}
extern "C" {
    pub fn vkGetDeviceQueue2(
        device: VkDevice,
        pQueueInfo: *const VkDeviceQueueInfo2,
        pQueue: *mut VkQueue,
    );
}
extern "C" {
    pub fn vkCreateSamplerYcbcrConversion(
        device: VkDevice,
        pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pYcbcrConversion: *mut VkSamplerYcbcrConversion,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroySamplerYcbcrConversion(
        device: VkDevice,
        ycbcrConversion: VkSamplerYcbcrConversion,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCreateDescriptorUpdateTemplate(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyDescriptorUpdateTemplate(
        device: VkDevice,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkUpdateDescriptorSetWithTemplate(
        device: VkDevice,
        descriptorSet: VkDescriptorSet,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        pData: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceExternalBufferProperties(
        physicalDevice: VkPhysicalDevice,
        pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo,
        pExternalBufferProperties: *mut VkExternalBufferProperties,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceExternalFenceProperties(
        physicalDevice: VkPhysicalDevice,
        pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo,
        pExternalFenceProperties: *mut VkExternalFenceProperties,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceExternalSemaphoreProperties(
        physicalDevice: VkPhysicalDevice,
        pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo,
        pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties,
    );
}
extern "C" {
    pub fn vkGetDescriptorSetLayoutSupport(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
        pSupport: *mut VkDescriptorSetLayoutSupport,
    );
}
pub const VK_DRIVER_ID_AMD_PROPRIETARY: VkDriverId = 1;
pub const VK_DRIVER_ID_AMD_OPEN_SOURCE: VkDriverId = 2;
pub const VK_DRIVER_ID_MESA_RADV: VkDriverId = 3;
pub const VK_DRIVER_ID_NVIDIA_PROPRIETARY: VkDriverId = 4;
pub const VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS: VkDriverId = 5;
pub const VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA: VkDriverId = 6;
pub const VK_DRIVER_ID_IMAGINATION_PROPRIETARY: VkDriverId = 7;
pub const VK_DRIVER_ID_QUALCOMM_PROPRIETARY: VkDriverId = 8;
pub const VK_DRIVER_ID_ARM_PROPRIETARY: VkDriverId = 9;
pub const VK_DRIVER_ID_GOOGLE_SWIFTSHADER: VkDriverId = 10;
pub const VK_DRIVER_ID_GGP_PROPRIETARY: VkDriverId = 11;
pub const VK_DRIVER_ID_BROADCOM_PROPRIETARY: VkDriverId = 12;
pub const VK_DRIVER_ID_MESA_LLVMPIPE: VkDriverId = 13;
pub const VK_DRIVER_ID_MOLTENVK: VkDriverId = 14;
pub const VK_DRIVER_ID_COREAVI_PROPRIETARY: VkDriverId = 15;
pub const VK_DRIVER_ID_JUICE_PROPRIETARY: VkDriverId = 16;
pub const VK_DRIVER_ID_VERISILICON_PROPRIETARY: VkDriverId = 17;
pub const VK_DRIVER_ID_MESA_TURNIP: VkDriverId = 18;
pub const VK_DRIVER_ID_MESA_V3DV: VkDriverId = 19;
pub const VK_DRIVER_ID_MESA_PANVK: VkDriverId = 20;
pub const VK_DRIVER_ID_SAMSUNG_PROPRIETARY: VkDriverId = 21;
pub const VK_DRIVER_ID_MESA_VENUS: VkDriverId = 22;
pub const VK_DRIVER_ID_MESA_DOZEN: VkDriverId = 23;
pub const VK_DRIVER_ID_MESA_NVK: VkDriverId = 24;
pub const VK_DRIVER_ID_AMD_PROPRIETARY_KHR: VkDriverId = 1;
pub const VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR: VkDriverId = 2;
pub const VK_DRIVER_ID_MESA_RADV_KHR: VkDriverId = 3;
pub const VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR: VkDriverId = 4;
pub const VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR: VkDriverId = 5;
pub const VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR: VkDriverId = 6;
pub const VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR: VkDriverId = 7;
pub const VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR: VkDriverId = 8;
pub const VK_DRIVER_ID_ARM_PROPRIETARY_KHR: VkDriverId = 9;
pub const VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR: VkDriverId = 10;
pub const VK_DRIVER_ID_GGP_PROPRIETARY_KHR: VkDriverId = 11;
pub const VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR: VkDriverId = 12;
pub const VK_DRIVER_ID_MAX_ENUM: VkDriverId = 2147483647;
pub type VkDriverId = ::std::os::raw::c_int;
pub const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY: VkShaderFloatControlsIndependence = 0;
pub const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL: VkShaderFloatControlsIndependence = 1;
pub const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE: VkShaderFloatControlsIndependence = 2;
pub const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR: VkShaderFloatControlsIndependence =
    0;
pub const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR: VkShaderFloatControlsIndependence = 1;
pub const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR: VkShaderFloatControlsIndependence = 2;
pub const VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM: VkShaderFloatControlsIndependence =
    2147483647;
pub type VkShaderFloatControlsIndependence = ::std::os::raw::c_int;
pub const VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE: VkSamplerReductionMode = 0;
pub const VK_SAMPLER_REDUCTION_MODE_MIN: VkSamplerReductionMode = 1;
pub const VK_SAMPLER_REDUCTION_MODE_MAX: VkSamplerReductionMode = 2;
pub const VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT: VkSamplerReductionMode = 0;
pub const VK_SAMPLER_REDUCTION_MODE_MIN_EXT: VkSamplerReductionMode = 1;
pub const VK_SAMPLER_REDUCTION_MODE_MAX_EXT: VkSamplerReductionMode = 2;
pub const VK_SAMPLER_REDUCTION_MODE_MAX_ENUM: VkSamplerReductionMode = 2147483647;
pub type VkSamplerReductionMode = ::std::os::raw::c_int;
pub const VK_SEMAPHORE_TYPE_BINARY: VkSemaphoreType = 0;
pub const VK_SEMAPHORE_TYPE_TIMELINE: VkSemaphoreType = 1;
pub const VK_SEMAPHORE_TYPE_BINARY_KHR: VkSemaphoreType = 0;
pub const VK_SEMAPHORE_TYPE_TIMELINE_KHR: VkSemaphoreType = 1;
pub const VK_SEMAPHORE_TYPE_MAX_ENUM: VkSemaphoreType = 2147483647;
pub type VkSemaphoreType = ::std::os::raw::c_int;
pub const VK_RESOLVE_MODE_NONE: VkResolveModeFlagBits = 0;
pub const VK_RESOLVE_MODE_SAMPLE_ZERO_BIT: VkResolveModeFlagBits = 1;
pub const VK_RESOLVE_MODE_AVERAGE_BIT: VkResolveModeFlagBits = 2;
pub const VK_RESOLVE_MODE_MIN_BIT: VkResolveModeFlagBits = 4;
pub const VK_RESOLVE_MODE_MAX_BIT: VkResolveModeFlagBits = 8;
pub const VK_RESOLVE_MODE_NONE_KHR: VkResolveModeFlagBits = 0;
pub const VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR: VkResolveModeFlagBits = 1;
pub const VK_RESOLVE_MODE_AVERAGE_BIT_KHR: VkResolveModeFlagBits = 2;
pub const VK_RESOLVE_MODE_MIN_BIT_KHR: VkResolveModeFlagBits = 4;
pub const VK_RESOLVE_MODE_MAX_BIT_KHR: VkResolveModeFlagBits = 8;
pub const VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM: VkResolveModeFlagBits = 2147483647;
pub type VkResolveModeFlagBits = ::std::os::raw::c_int;
pub type VkResolveModeFlags = VkFlags;
pub const VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT: VkDescriptorBindingFlagBits = 1;
pub const VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT: VkDescriptorBindingFlagBits = 2;
pub const VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT: VkDescriptorBindingFlagBits = 4;
pub const VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT: VkDescriptorBindingFlagBits = 8;
pub const VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT: VkDescriptorBindingFlagBits = 1;
pub const VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT: VkDescriptorBindingFlagBits =
    2;
pub const VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT: VkDescriptorBindingFlagBits = 4;
pub const VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT: VkDescriptorBindingFlagBits = 8;
pub const VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM: VkDescriptorBindingFlagBits = 2147483647;
pub type VkDescriptorBindingFlagBits = ::std::os::raw::c_int;
pub type VkDescriptorBindingFlags = VkFlags;
pub const VK_SEMAPHORE_WAIT_ANY_BIT: VkSemaphoreWaitFlagBits = 1;
pub const VK_SEMAPHORE_WAIT_ANY_BIT_KHR: VkSemaphoreWaitFlagBits = 1;
pub const VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM: VkSemaphoreWaitFlagBits = 2147483647;
pub type VkSemaphoreWaitFlagBits = ::std::os::raw::c_int;
pub type VkSemaphoreWaitFlags = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVulkan11Features {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub storageBuffer16BitAccess: VkBool32,
    pub uniformAndStorageBuffer16BitAccess: VkBool32,
    pub storagePushConstant16: VkBool32,
    pub storageInputOutput16: VkBool32,
    pub multiview: VkBool32,
    pub multiviewGeometryShader: VkBool32,
    pub multiviewTessellationShader: VkBool32,
    pub variablePointersStorageBuffer: VkBool32,
    pub variablePointers: VkBool32,
    pub protectedMemory: VkBool32,
    pub samplerYcbcrConversion: VkBool32,
    pub shaderDrawParameters: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVulkan11Features() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVulkan11Features>(),
        64usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceVulkan11Features))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVulkan11Features>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVulkan11Features)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Features),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Features),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_storageBuffer16BitAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storageBuffer16BitAccess) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Features),
                "::",
                stringify!(storageBuffer16BitAccess)
            )
        );
    }
    test_field_storageBuffer16BitAccess();
    fn test_field_uniformAndStorageBuffer16BitAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uniformAndStorageBuffer16BitAccess) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Features),
                "::",
                stringify!(uniformAndStorageBuffer16BitAccess)
            )
        );
    }
    test_field_uniformAndStorageBuffer16BitAccess();
    fn test_field_storagePushConstant16() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storagePushConstant16) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Features),
                "::",
                stringify!(storagePushConstant16)
            )
        );
    }
    test_field_storagePushConstant16();
    fn test_field_storageInputOutput16() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storageInputOutput16) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Features),
                "::",
                stringify!(storageInputOutput16)
            )
        );
    }
    test_field_storageInputOutput16();
    fn test_field_multiview() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiview) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Features),
                "::",
                stringify!(multiview)
            )
        );
    }
    test_field_multiview();
    fn test_field_multiviewGeometryShader() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiviewGeometryShader) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Features),
                "::",
                stringify!(multiviewGeometryShader)
            )
        );
    }
    test_field_multiviewGeometryShader();
    fn test_field_multiviewTessellationShader() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiviewTessellationShader) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Features),
                "::",
                stringify!(multiviewTessellationShader)
            )
        );
    }
    test_field_multiviewTessellationShader();
    fn test_field_variablePointersStorageBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).variablePointersStorageBuffer) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Features),
                "::",
                stringify!(variablePointersStorageBuffer)
            )
        );
    }
    test_field_variablePointersStorageBuffer();
    fn test_field_variablePointers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).variablePointers) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Features),
                "::",
                stringify!(variablePointers)
            )
        );
    }
    test_field_variablePointers();
    fn test_field_protectedMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).protectedMemory) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Features),
                "::",
                stringify!(protectedMemory)
            )
        );
    }
    test_field_protectedMemory();
    fn test_field_samplerYcbcrConversion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samplerYcbcrConversion) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Features),
                "::",
                stringify!(samplerYcbcrConversion)
            )
        );
    }
    test_field_samplerYcbcrConversion();
    fn test_field_shaderDrawParameters() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDrawParameters) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Features),
                "::",
                stringify!(shaderDrawParameters)
            )
        );
    }
    test_field_shaderDrawParameters();
}
impl Default for VkPhysicalDeviceVulkan11Features {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVulkan11Properties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub deviceUUID: [u8; 16usize],
    pub driverUUID: [u8; 16usize],
    pub deviceLUID: [u8; 8usize],
    pub deviceNodeMask: u32,
    pub deviceLUIDValid: VkBool32,
    pub subgroupSize: u32,
    pub subgroupSupportedStages: VkShaderStageFlags,
    pub subgroupSupportedOperations: VkSubgroupFeatureFlags,
    pub subgroupQuadOperationsInAllStages: VkBool32,
    pub pointClippingBehavior: VkPointClippingBehavior,
    pub maxMultiviewViewCount: u32,
    pub maxMultiviewInstanceIndex: u32,
    pub protectedNoFault: VkBool32,
    pub maxPerSetDescriptors: u32,
    pub maxMemoryAllocationSize: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVulkan11Properties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVulkan11Properties>(),
        112usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceVulkan11Properties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVulkan11Properties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVulkan11Properties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_deviceUUID() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceUUID) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(deviceUUID)
            )
        );
    }
    test_field_deviceUUID();
    fn test_field_driverUUID() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).driverUUID) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(driverUUID)
            )
        );
    }
    test_field_driverUUID();
    fn test_field_deviceLUID() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceLUID) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(deviceLUID)
            )
        );
    }
    test_field_deviceLUID();
    fn test_field_deviceNodeMask() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceNodeMask) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(deviceNodeMask)
            )
        );
    }
    test_field_deviceNodeMask();
    fn test_field_deviceLUIDValid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceLUIDValid) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(deviceLUIDValid)
            )
        );
    }
    test_field_deviceLUIDValid();
    fn test_field_subgroupSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subgroupSize) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(subgroupSize)
            )
        );
    }
    test_field_subgroupSize();
    fn test_field_subgroupSupportedStages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subgroupSupportedStages) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(subgroupSupportedStages)
            )
        );
    }
    test_field_subgroupSupportedStages();
    fn test_field_subgroupSupportedOperations() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subgroupSupportedOperations) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(subgroupSupportedOperations)
            )
        );
    }
    test_field_subgroupSupportedOperations();
    fn test_field_subgroupQuadOperationsInAllStages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subgroupQuadOperationsInAllStages) as usize
                    - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(subgroupQuadOperationsInAllStages)
            )
        );
    }
    test_field_subgroupQuadOperationsInAllStages();
    fn test_field_pointClippingBehavior() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pointClippingBehavior) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(pointClippingBehavior)
            )
        );
    }
    test_field_pointClippingBehavior();
    fn test_field_maxMultiviewViewCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMultiviewViewCount) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(maxMultiviewViewCount)
            )
        );
    }
    test_field_maxMultiviewViewCount();
    fn test_field_maxMultiviewInstanceIndex() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMultiviewInstanceIndex) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(maxMultiviewInstanceIndex)
            )
        );
    }
    test_field_maxMultiviewInstanceIndex();
    fn test_field_protectedNoFault() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).protectedNoFault) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(protectedNoFault)
            )
        );
    }
    test_field_protectedNoFault();
    fn test_field_maxPerSetDescriptors() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerSetDescriptors) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(maxPerSetDescriptors)
            )
        );
    }
    test_field_maxPerSetDescriptors();
    fn test_field_maxMemoryAllocationSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan11Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMemoryAllocationSize) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan11Properties),
                "::",
                stringify!(maxMemoryAllocationSize)
            )
        );
    }
    test_field_maxMemoryAllocationSize();
}
impl Default for VkPhysicalDeviceVulkan11Properties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVulkan12Features {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub samplerMirrorClampToEdge: VkBool32,
    pub drawIndirectCount: VkBool32,
    pub storageBuffer8BitAccess: VkBool32,
    pub uniformAndStorageBuffer8BitAccess: VkBool32,
    pub storagePushConstant8: VkBool32,
    pub shaderBufferInt64Atomics: VkBool32,
    pub shaderSharedInt64Atomics: VkBool32,
    pub shaderFloat16: VkBool32,
    pub shaderInt8: VkBool32,
    pub descriptorIndexing: VkBool32,
    pub shaderInputAttachmentArrayDynamicIndexing: VkBool32,
    pub shaderUniformTexelBufferArrayDynamicIndexing: VkBool32,
    pub shaderStorageTexelBufferArrayDynamicIndexing: VkBool32,
    pub shaderUniformBufferArrayNonUniformIndexing: VkBool32,
    pub shaderSampledImageArrayNonUniformIndexing: VkBool32,
    pub shaderStorageBufferArrayNonUniformIndexing: VkBool32,
    pub shaderStorageImageArrayNonUniformIndexing: VkBool32,
    pub shaderInputAttachmentArrayNonUniformIndexing: VkBool32,
    pub shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32,
    pub shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32,
    pub descriptorBindingUniformBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingSampledImageUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageImageUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingUpdateUnusedWhilePending: VkBool32,
    pub descriptorBindingPartiallyBound: VkBool32,
    pub descriptorBindingVariableDescriptorCount: VkBool32,
    pub runtimeDescriptorArray: VkBool32,
    pub samplerFilterMinmax: VkBool32,
    pub scalarBlockLayout: VkBool32,
    pub imagelessFramebuffer: VkBool32,
    pub uniformBufferStandardLayout: VkBool32,
    pub shaderSubgroupExtendedTypes: VkBool32,
    pub separateDepthStencilLayouts: VkBool32,
    pub hostQueryReset: VkBool32,
    pub timelineSemaphore: VkBool32,
    pub bufferDeviceAddress: VkBool32,
    pub bufferDeviceAddressCaptureReplay: VkBool32,
    pub bufferDeviceAddressMultiDevice: VkBool32,
    pub vulkanMemoryModel: VkBool32,
    pub vulkanMemoryModelDeviceScope: VkBool32,
    pub vulkanMemoryModelAvailabilityVisibilityChains: VkBool32,
    pub shaderOutputViewportIndex: VkBool32,
    pub shaderOutputLayer: VkBool32,
    pub subgroupBroadcastDynamicId: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVulkan12Features() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVulkan12Features>(),
        208usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceVulkan12Features))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVulkan12Features>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVulkan12Features)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_samplerMirrorClampToEdge() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samplerMirrorClampToEdge) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(samplerMirrorClampToEdge)
            )
        );
    }
    test_field_samplerMirrorClampToEdge();
    fn test_field_drawIndirectCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drawIndirectCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(drawIndirectCount)
            )
        );
    }
    test_field_drawIndirectCount();
    fn test_field_storageBuffer8BitAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storageBuffer8BitAccess) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(storageBuffer8BitAccess)
            )
        );
    }
    test_field_storageBuffer8BitAccess();
    fn test_field_uniformAndStorageBuffer8BitAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uniformAndStorageBuffer8BitAccess) as usize
                    - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(uniformAndStorageBuffer8BitAccess)
            )
        );
    }
    test_field_uniformAndStorageBuffer8BitAccess();
    fn test_field_storagePushConstant8() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storagePushConstant8) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(storagePushConstant8)
            )
        );
    }
    test_field_storagePushConstant8();
    fn test_field_shaderBufferInt64Atomics() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderBufferInt64Atomics) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderBufferInt64Atomics)
            )
        );
    }
    test_field_shaderBufferInt64Atomics();
    fn test_field_shaderSharedInt64Atomics() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSharedInt64Atomics) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderSharedInt64Atomics)
            )
        );
    }
    test_field_shaderSharedInt64Atomics();
    fn test_field_shaderFloat16() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderFloat16) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderFloat16)
            )
        );
    }
    test_field_shaderFloat16();
    fn test_field_shaderInt8() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderInt8) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderInt8)
            )
        );
    }
    test_field_shaderInt8();
    fn test_field_descriptorIndexing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorIndexing) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(descriptorIndexing)
            )
        );
    }
    test_field_descriptorIndexing();
    fn test_field_shaderInputAttachmentArrayDynamicIndexing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderInputAttachmentArrayDynamicIndexing) as usize
                    - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderInputAttachmentArrayDynamicIndexing)
            )
        );
    }
    test_field_shaderInputAttachmentArrayDynamicIndexing();
    fn test_field_shaderUniformTexelBufferArrayDynamicIndexing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderUniformTexelBufferArrayDynamicIndexing) as usize
                    - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderUniformTexelBufferArrayDynamicIndexing)
            )
        );
    }
    test_field_shaderUniformTexelBufferArrayDynamicIndexing();
    fn test_field_shaderStorageTexelBufferArrayDynamicIndexing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageTexelBufferArrayDynamicIndexing) as usize
                    - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderStorageTexelBufferArrayDynamicIndexing)
            )
        );
    }
    test_field_shaderStorageTexelBufferArrayDynamicIndexing();
    fn test_field_shaderUniformBufferArrayNonUniformIndexing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderUniformBufferArrayNonUniformIndexing) as usize
                    - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderUniformBufferArrayNonUniformIndexing)
            )
        );
    }
    test_field_shaderUniformBufferArrayNonUniformIndexing();
    fn test_field_shaderSampledImageArrayNonUniformIndexing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSampledImageArrayNonUniformIndexing) as usize
                    - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderSampledImageArrayNonUniformIndexing)
            )
        );
    }
    test_field_shaderSampledImageArrayNonUniformIndexing();
    fn test_field_shaderStorageBufferArrayNonUniformIndexing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageBufferArrayNonUniformIndexing) as usize
                    - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderStorageBufferArrayNonUniformIndexing)
            )
        );
    }
    test_field_shaderStorageBufferArrayNonUniformIndexing();
    fn test_field_shaderStorageImageArrayNonUniformIndexing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageImageArrayNonUniformIndexing) as usize
                    - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderStorageImageArrayNonUniformIndexing)
            )
        );
    }
    test_field_shaderStorageImageArrayNonUniformIndexing();
    fn test_field_shaderInputAttachmentArrayNonUniformIndexing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderInputAttachmentArrayNonUniformIndexing) as usize
                    - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderInputAttachmentArrayNonUniformIndexing)
            )
        );
    }
    test_field_shaderInputAttachmentArrayNonUniformIndexing();
    fn test_field_shaderUniformTexelBufferArrayNonUniformIndexing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderUniformTexelBufferArrayNonUniformIndexing)
                    as usize
                    - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderUniformTexelBufferArrayNonUniformIndexing)
            )
        );
    }
    test_field_shaderUniformTexelBufferArrayNonUniformIndexing();
    fn test_field_shaderStorageTexelBufferArrayNonUniformIndexing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageTexelBufferArrayNonUniformIndexing)
                    as usize
                    - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderStorageTexelBufferArrayNonUniformIndexing)
            )
        );
    }
    test_field_shaderStorageTexelBufferArrayNonUniformIndexing();
    fn test_field_descriptorBindingUniformBufferUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingUniformBufferUpdateAfterBind) as usize
                    - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(descriptorBindingUniformBufferUpdateAfterBind)
            )
        );
    }
    test_field_descriptorBindingUniformBufferUpdateAfterBind();
    fn test_field_descriptorBindingSampledImageUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingSampledImageUpdateAfterBind) as usize
                    - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(descriptorBindingSampledImageUpdateAfterBind)
            )
        );
    }
    test_field_descriptorBindingSampledImageUpdateAfterBind();
    fn test_field_descriptorBindingStorageImageUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingStorageImageUpdateAfterBind) as usize
                    - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(descriptorBindingStorageImageUpdateAfterBind)
            )
        );
    }
    test_field_descriptorBindingStorageImageUpdateAfterBind();
    fn test_field_descriptorBindingStorageBufferUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingStorageBufferUpdateAfterBind) as usize
                    - ptr as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(descriptorBindingStorageBufferUpdateAfterBind)
            )
        );
    }
    test_field_descriptorBindingStorageBufferUpdateAfterBind();
    fn test_field_descriptorBindingUniformTexelBufferUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingUniformTexelBufferUpdateAfterBind)
                    as usize
                    - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(descriptorBindingUniformTexelBufferUpdateAfterBind)
            )
        );
    }
    test_field_descriptorBindingUniformTexelBufferUpdateAfterBind();
    fn test_field_descriptorBindingStorageTexelBufferUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingStorageTexelBufferUpdateAfterBind)
                    as usize
                    - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(descriptorBindingStorageTexelBufferUpdateAfterBind)
            )
        );
    }
    test_field_descriptorBindingStorageTexelBufferUpdateAfterBind();
    fn test_field_descriptorBindingUpdateUnusedWhilePending() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingUpdateUnusedWhilePending) as usize
                    - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(descriptorBindingUpdateUnusedWhilePending)
            )
        );
    }
    test_field_descriptorBindingUpdateUnusedWhilePending();
    fn test_field_descriptorBindingPartiallyBound() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingPartiallyBound) as usize - ptr as usize
            },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(descriptorBindingPartiallyBound)
            )
        );
    }
    test_field_descriptorBindingPartiallyBound();
    fn test_field_descriptorBindingVariableDescriptorCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingVariableDescriptorCount) as usize
                    - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(descriptorBindingVariableDescriptorCount)
            )
        );
    }
    test_field_descriptorBindingVariableDescriptorCount();
    fn test_field_runtimeDescriptorArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).runtimeDescriptorArray) as usize - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(runtimeDescriptorArray)
            )
        );
    }
    test_field_runtimeDescriptorArray();
    fn test_field_samplerFilterMinmax() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samplerFilterMinmax) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(samplerFilterMinmax)
            )
        );
    }
    test_field_samplerFilterMinmax();
    fn test_field_scalarBlockLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scalarBlockLayout) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(scalarBlockLayout)
            )
        );
    }
    test_field_scalarBlockLayout();
    fn test_field_imagelessFramebuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imagelessFramebuffer) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(imagelessFramebuffer)
            )
        );
    }
    test_field_imagelessFramebuffer();
    fn test_field_uniformBufferStandardLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uniformBufferStandardLayout) as usize - ptr as usize
            },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(uniformBufferStandardLayout)
            )
        );
    }
    test_field_uniformBufferStandardLayout();
    fn test_field_shaderSubgroupExtendedTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSubgroupExtendedTypes) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderSubgroupExtendedTypes)
            )
        );
    }
    test_field_shaderSubgroupExtendedTypes();
    fn test_field_separateDepthStencilLayouts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).separateDepthStencilLayouts) as usize - ptr as usize
            },
            156usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(separateDepthStencilLayouts)
            )
        );
    }
    test_field_separateDepthStencilLayouts();
    fn test_field_hostQueryReset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostQueryReset) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(hostQueryReset)
            )
        );
    }
    test_field_hostQueryReset();
    fn test_field_timelineSemaphore() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timelineSemaphore) as usize - ptr as usize
            },
            164usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(timelineSemaphore)
            )
        );
    }
    test_field_timelineSemaphore();
    fn test_field_bufferDeviceAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferDeviceAddress) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(bufferDeviceAddress)
            )
        );
    }
    test_field_bufferDeviceAddress();
    fn test_field_bufferDeviceAddressCaptureReplay() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferDeviceAddressCaptureReplay) as usize
                    - ptr as usize
            },
            172usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(bufferDeviceAddressCaptureReplay)
            )
        );
    }
    test_field_bufferDeviceAddressCaptureReplay();
    fn test_field_bufferDeviceAddressMultiDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferDeviceAddressMultiDevice) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(bufferDeviceAddressMultiDevice)
            )
        );
    }
    test_field_bufferDeviceAddressMultiDevice();
    fn test_field_vulkanMemoryModel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vulkanMemoryModel) as usize - ptr as usize
            },
            180usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(vulkanMemoryModel)
            )
        );
    }
    test_field_vulkanMemoryModel();
    fn test_field_vulkanMemoryModelDeviceScope() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vulkanMemoryModelDeviceScope) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(vulkanMemoryModelDeviceScope)
            )
        );
    }
    test_field_vulkanMemoryModelDeviceScope();
    fn test_field_vulkanMemoryModelAvailabilityVisibilityChains() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vulkanMemoryModelAvailabilityVisibilityChains) as usize
                    - ptr as usize
            },
            188usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(vulkanMemoryModelAvailabilityVisibilityChains)
            )
        );
    }
    test_field_vulkanMemoryModelAvailabilityVisibilityChains();
    fn test_field_shaderOutputViewportIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderOutputViewportIndex) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderOutputViewportIndex)
            )
        );
    }
    test_field_shaderOutputViewportIndex();
    fn test_field_shaderOutputLayer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderOutputLayer) as usize - ptr as usize
            },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(shaderOutputLayer)
            )
        );
    }
    test_field_shaderOutputLayer();
    fn test_field_subgroupBroadcastDynamicId() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subgroupBroadcastDynamicId) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Features),
                "::",
                stringify!(subgroupBroadcastDynamicId)
            )
        );
    }
    test_field_subgroupBroadcastDynamicId();
}
impl Default for VkPhysicalDeviceVulkan12Features {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkConformanceVersion {
    pub major: u8,
    pub minor: u8,
    pub subminor: u8,
    pub patch: u8,
}
#[test]
fn bindgen_test_layout_VkConformanceVersion() {
    assert_eq!(
        ::std::mem::size_of::<VkConformanceVersion>(),
        4usize,
        concat!("Size of: ", stringify!(VkConformanceVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<VkConformanceVersion>(),
        1usize,
        concat!("Alignment of ", stringify!(VkConformanceVersion))
    );
    fn test_field_major() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkConformanceVersion>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkConformanceVersion),
                "::",
                stringify!(major)
            )
        );
    }
    test_field_major();
    fn test_field_minor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkConformanceVersion>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(VkConformanceVersion),
                "::",
                stringify!(minor)
            )
        );
    }
    test_field_minor();
    fn test_field_subminor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkConformanceVersion>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subminor) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(VkConformanceVersion),
                "::",
                stringify!(subminor)
            )
        );
    }
    test_field_subminor();
    fn test_field_patch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkConformanceVersion>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).patch) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(VkConformanceVersion),
                "::",
                stringify!(patch)
            )
        );
    }
    test_field_patch();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVulkan12Properties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub driverID: VkDriverId,
    pub driverName: [::std::os::raw::c_char; 256usize],
    pub driverInfo: [::std::os::raw::c_char; 256usize],
    pub conformanceVersion: VkConformanceVersion,
    pub denormBehaviorIndependence: VkShaderFloatControlsIndependence,
    pub roundingModeIndependence: VkShaderFloatControlsIndependence,
    pub shaderSignedZeroInfNanPreserveFloat16: VkBool32,
    pub shaderSignedZeroInfNanPreserveFloat32: VkBool32,
    pub shaderSignedZeroInfNanPreserveFloat64: VkBool32,
    pub shaderDenormPreserveFloat16: VkBool32,
    pub shaderDenormPreserveFloat32: VkBool32,
    pub shaderDenormPreserveFloat64: VkBool32,
    pub shaderDenormFlushToZeroFloat16: VkBool32,
    pub shaderDenormFlushToZeroFloat32: VkBool32,
    pub shaderDenormFlushToZeroFloat64: VkBool32,
    pub shaderRoundingModeRTEFloat16: VkBool32,
    pub shaderRoundingModeRTEFloat32: VkBool32,
    pub shaderRoundingModeRTEFloat64: VkBool32,
    pub shaderRoundingModeRTZFloat16: VkBool32,
    pub shaderRoundingModeRTZFloat32: VkBool32,
    pub shaderRoundingModeRTZFloat64: VkBool32,
    pub maxUpdateAfterBindDescriptorsInAllPools: u32,
    pub shaderUniformBufferArrayNonUniformIndexingNative: VkBool32,
    pub shaderSampledImageArrayNonUniformIndexingNative: VkBool32,
    pub shaderStorageBufferArrayNonUniformIndexingNative: VkBool32,
    pub shaderStorageImageArrayNonUniformIndexingNative: VkBool32,
    pub shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32,
    pub robustBufferAccessUpdateAfterBind: VkBool32,
    pub quadDivergentImplicitLod: VkBool32,
    pub maxPerStageDescriptorUpdateAfterBindSamplers: u32,
    pub maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32,
    pub maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32,
    pub maxPerStageDescriptorUpdateAfterBindSampledImages: u32,
    pub maxPerStageDescriptorUpdateAfterBindStorageImages: u32,
    pub maxPerStageDescriptorUpdateAfterBindInputAttachments: u32,
    pub maxPerStageUpdateAfterBindResources: u32,
    pub maxDescriptorSetUpdateAfterBindSamplers: u32,
    pub maxDescriptorSetUpdateAfterBindUniformBuffers: u32,
    pub maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32,
    pub maxDescriptorSetUpdateAfterBindStorageBuffers: u32,
    pub maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32,
    pub maxDescriptorSetUpdateAfterBindSampledImages: u32,
    pub maxDescriptorSetUpdateAfterBindStorageImages: u32,
    pub maxDescriptorSetUpdateAfterBindInputAttachments: u32,
    pub supportedDepthResolveModes: VkResolveModeFlags,
    pub supportedStencilResolveModes: VkResolveModeFlags,
    pub independentResolveNone: VkBool32,
    pub independentResolve: VkBool32,
    pub filterMinmaxSingleComponentFormats: VkBool32,
    pub filterMinmaxImageComponentMapping: VkBool32,
    pub maxTimelineSemaphoreValueDifference: u64,
    pub framebufferIntegerColorSampleCounts: VkSampleCountFlags,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVulkan12Properties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVulkan12Properties>(),
        736usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceVulkan12Properties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVulkan12Properties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVulkan12Properties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_driverID() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).driverID) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(driverID)
            )
        );
    }
    test_field_driverID();
    fn test_field_driverName() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).driverName) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(driverName)
            )
        );
    }
    test_field_driverName();
    fn test_field_driverInfo() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).driverInfo) as usize - ptr as usize
            },
            276usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(driverInfo)
            )
        );
    }
    test_field_driverInfo();
    fn test_field_conformanceVersion() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).conformanceVersion) as usize - ptr as usize
            },
            532usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(conformanceVersion)
            )
        );
    }
    test_field_conformanceVersion();
    fn test_field_denormBehaviorIndependence() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).denormBehaviorIndependence) as usize - ptr as usize
            },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(denormBehaviorIndependence)
            )
        );
    }
    test_field_denormBehaviorIndependence();
    fn test_field_roundingModeIndependence() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).roundingModeIndependence) as usize - ptr as usize
            },
            540usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(roundingModeIndependence)
            )
        );
    }
    test_field_roundingModeIndependence();
    fn test_field_shaderSignedZeroInfNanPreserveFloat16() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSignedZeroInfNanPreserveFloat16) as usize
                    - ptr as usize
            },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderSignedZeroInfNanPreserveFloat16)
            )
        );
    }
    test_field_shaderSignedZeroInfNanPreserveFloat16();
    fn test_field_shaderSignedZeroInfNanPreserveFloat32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSignedZeroInfNanPreserveFloat32) as usize
                    - ptr as usize
            },
            548usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderSignedZeroInfNanPreserveFloat32)
            )
        );
    }
    test_field_shaderSignedZeroInfNanPreserveFloat32();
    fn test_field_shaderSignedZeroInfNanPreserveFloat64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSignedZeroInfNanPreserveFloat64) as usize
                    - ptr as usize
            },
            552usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderSignedZeroInfNanPreserveFloat64)
            )
        );
    }
    test_field_shaderSignedZeroInfNanPreserveFloat64();
    fn test_field_shaderDenormPreserveFloat16() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDenormPreserveFloat16) as usize - ptr as usize
            },
            556usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderDenormPreserveFloat16)
            )
        );
    }
    test_field_shaderDenormPreserveFloat16();
    fn test_field_shaderDenormPreserveFloat32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDenormPreserveFloat32) as usize - ptr as usize
            },
            560usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderDenormPreserveFloat32)
            )
        );
    }
    test_field_shaderDenormPreserveFloat32();
    fn test_field_shaderDenormPreserveFloat64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDenormPreserveFloat64) as usize - ptr as usize
            },
            564usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderDenormPreserveFloat64)
            )
        );
    }
    test_field_shaderDenormPreserveFloat64();
    fn test_field_shaderDenormFlushToZeroFloat16() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDenormFlushToZeroFloat16) as usize - ptr as usize
            },
            568usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderDenormFlushToZeroFloat16)
            )
        );
    }
    test_field_shaderDenormFlushToZeroFloat16();
    fn test_field_shaderDenormFlushToZeroFloat32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDenormFlushToZeroFloat32) as usize - ptr as usize
            },
            572usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderDenormFlushToZeroFloat32)
            )
        );
    }
    test_field_shaderDenormFlushToZeroFloat32();
    fn test_field_shaderDenormFlushToZeroFloat64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDenormFlushToZeroFloat64) as usize - ptr as usize
            },
            576usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderDenormFlushToZeroFloat64)
            )
        );
    }
    test_field_shaderDenormFlushToZeroFloat64();
    fn test_field_shaderRoundingModeRTEFloat16() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderRoundingModeRTEFloat16) as usize - ptr as usize
            },
            580usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderRoundingModeRTEFloat16)
            )
        );
    }
    test_field_shaderRoundingModeRTEFloat16();
    fn test_field_shaderRoundingModeRTEFloat32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderRoundingModeRTEFloat32) as usize - ptr as usize
            },
            584usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderRoundingModeRTEFloat32)
            )
        );
    }
    test_field_shaderRoundingModeRTEFloat32();
    fn test_field_shaderRoundingModeRTEFloat64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderRoundingModeRTEFloat64) as usize - ptr as usize
            },
            588usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderRoundingModeRTEFloat64)
            )
        );
    }
    test_field_shaderRoundingModeRTEFloat64();
    fn test_field_shaderRoundingModeRTZFloat16() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderRoundingModeRTZFloat16) as usize - ptr as usize
            },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderRoundingModeRTZFloat16)
            )
        );
    }
    test_field_shaderRoundingModeRTZFloat16();
    fn test_field_shaderRoundingModeRTZFloat32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderRoundingModeRTZFloat32) as usize - ptr as usize
            },
            596usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderRoundingModeRTZFloat32)
            )
        );
    }
    test_field_shaderRoundingModeRTZFloat32();
    fn test_field_shaderRoundingModeRTZFloat64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderRoundingModeRTZFloat64) as usize - ptr as usize
            },
            600usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderRoundingModeRTZFloat64)
            )
        );
    }
    test_field_shaderRoundingModeRTZFloat64();
    fn test_field_maxUpdateAfterBindDescriptorsInAllPools() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxUpdateAfterBindDescriptorsInAllPools) as usize
                    - ptr as usize
            },
            604usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxUpdateAfterBindDescriptorsInAllPools)
            )
        );
    }
    test_field_maxUpdateAfterBindDescriptorsInAllPools();
    fn test_field_shaderUniformBufferArrayNonUniformIndexingNative() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderUniformBufferArrayNonUniformIndexingNative)
                    as usize
                    - ptr as usize
            },
            608usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderUniformBufferArrayNonUniformIndexingNative)
            )
        );
    }
    test_field_shaderUniformBufferArrayNonUniformIndexingNative();
    fn test_field_shaderSampledImageArrayNonUniformIndexingNative() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSampledImageArrayNonUniformIndexingNative)
                    as usize
                    - ptr as usize
            },
            612usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderSampledImageArrayNonUniformIndexingNative)
            )
        );
    }
    test_field_shaderSampledImageArrayNonUniformIndexingNative();
    fn test_field_shaderStorageBufferArrayNonUniformIndexingNative() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageBufferArrayNonUniformIndexingNative)
                    as usize
                    - ptr as usize
            },
            616usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderStorageBufferArrayNonUniformIndexingNative)
            )
        );
    }
    test_field_shaderStorageBufferArrayNonUniformIndexingNative();
    fn test_field_shaderStorageImageArrayNonUniformIndexingNative() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageImageArrayNonUniformIndexingNative)
                    as usize
                    - ptr as usize
            },
            620usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderStorageImageArrayNonUniformIndexingNative)
            )
        );
    }
    test_field_shaderStorageImageArrayNonUniformIndexingNative();
    fn test_field_shaderInputAttachmentArrayNonUniformIndexingNative() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderInputAttachmentArrayNonUniformIndexingNative)
                    as usize
                    - ptr as usize
            },
            624usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(shaderInputAttachmentArrayNonUniformIndexingNative)
            )
        );
    }
    test_field_shaderInputAttachmentArrayNonUniformIndexingNative();
    fn test_field_robustBufferAccessUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).robustBufferAccessUpdateAfterBind) as usize
                    - ptr as usize
            },
            628usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(robustBufferAccessUpdateAfterBind)
            )
        );
    }
    test_field_robustBufferAccessUpdateAfterBind();
    fn test_field_quadDivergentImplicitLod() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quadDivergentImplicitLod) as usize - ptr as usize
            },
            632usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(quadDivergentImplicitLod)
            )
        );
    }
    test_field_quadDivergentImplicitLod();
    fn test_field_maxPerStageDescriptorUpdateAfterBindSamplers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorUpdateAfterBindSamplers) as usize
                    - ptr as usize
            },
            636usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxPerStageDescriptorUpdateAfterBindSamplers)
            )
        );
    }
    test_field_maxPerStageDescriptorUpdateAfterBindSamplers();
    fn test_field_maxPerStageDescriptorUpdateAfterBindUniformBuffers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorUpdateAfterBindUniformBuffers)
                    as usize
                    - ptr as usize
            },
            640usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxPerStageDescriptorUpdateAfterBindUniformBuffers)
            )
        );
    }
    test_field_maxPerStageDescriptorUpdateAfterBindUniformBuffers();
    fn test_field_maxPerStageDescriptorUpdateAfterBindStorageBuffers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorUpdateAfterBindStorageBuffers)
                    as usize
                    - ptr as usize
            },
            644usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxPerStageDescriptorUpdateAfterBindStorageBuffers)
            )
        );
    }
    test_field_maxPerStageDescriptorUpdateAfterBindStorageBuffers();
    fn test_field_maxPerStageDescriptorUpdateAfterBindSampledImages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorUpdateAfterBindSampledImages)
                    as usize
                    - ptr as usize
            },
            648usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxPerStageDescriptorUpdateAfterBindSampledImages)
            )
        );
    }
    test_field_maxPerStageDescriptorUpdateAfterBindSampledImages();
    fn test_field_maxPerStageDescriptorUpdateAfterBindStorageImages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorUpdateAfterBindStorageImages)
                    as usize
                    - ptr as usize
            },
            652usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxPerStageDescriptorUpdateAfterBindStorageImages)
            )
        );
    }
    test_field_maxPerStageDescriptorUpdateAfterBindStorageImages();
    fn test_field_maxPerStageDescriptorUpdateAfterBindInputAttachments() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorUpdateAfterBindInputAttachments)
                    as usize
                    - ptr as usize
            },
            656usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxPerStageDescriptorUpdateAfterBindInputAttachments)
            )
        );
    }
    test_field_maxPerStageDescriptorUpdateAfterBindInputAttachments();
    fn test_field_maxPerStageUpdateAfterBindResources() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageUpdateAfterBindResources) as usize
                    - ptr as usize
            },
            660usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxPerStageUpdateAfterBindResources)
            )
        );
    }
    test_field_maxPerStageUpdateAfterBindResources();
    fn test_field_maxDescriptorSetUpdateAfterBindSamplers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindSamplers) as usize
                    - ptr as usize
            },
            664usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindSamplers)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindSamplers();
    fn test_field_maxDescriptorSetUpdateAfterBindUniformBuffers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindUniformBuffers) as usize
                    - ptr as usize
            },
            668usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindUniformBuffers)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindUniformBuffers();
    fn test_field_maxDescriptorSetUpdateAfterBindUniformBuffersDynamic() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
                    as usize
                    - ptr as usize
            },
            672usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindUniformBuffersDynamic();
    fn test_field_maxDescriptorSetUpdateAfterBindStorageBuffers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindStorageBuffers) as usize
                    - ptr as usize
            },
            676usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindStorageBuffers)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindStorageBuffers();
    fn test_field_maxDescriptorSetUpdateAfterBindStorageBuffersDynamic() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
                    as usize
                    - ptr as usize
            },
            680usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindStorageBuffersDynamic();
    fn test_field_maxDescriptorSetUpdateAfterBindSampledImages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindSampledImages) as usize
                    - ptr as usize
            },
            684usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindSampledImages)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindSampledImages();
    fn test_field_maxDescriptorSetUpdateAfterBindStorageImages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindStorageImages) as usize
                    - ptr as usize
            },
            688usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindStorageImages)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindStorageImages();
    fn test_field_maxDescriptorSetUpdateAfterBindInputAttachments() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindInputAttachments)
                    as usize
                    - ptr as usize
            },
            692usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindInputAttachments)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindInputAttachments();
    fn test_field_supportedDepthResolveModes() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedDepthResolveModes) as usize - ptr as usize
            },
            696usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(supportedDepthResolveModes)
            )
        );
    }
    test_field_supportedDepthResolveModes();
    fn test_field_supportedStencilResolveModes() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedStencilResolveModes) as usize - ptr as usize
            },
            700usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(supportedStencilResolveModes)
            )
        );
    }
    test_field_supportedStencilResolveModes();
    fn test_field_independentResolveNone() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).independentResolveNone) as usize - ptr as usize
            },
            704usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(independentResolveNone)
            )
        );
    }
    test_field_independentResolveNone();
    fn test_field_independentResolve() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).independentResolve) as usize - ptr as usize
            },
            708usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(independentResolve)
            )
        );
    }
    test_field_independentResolve();
    fn test_field_filterMinmaxSingleComponentFormats() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filterMinmaxSingleComponentFormats) as usize
                    - ptr as usize
            },
            712usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(filterMinmaxSingleComponentFormats)
            )
        );
    }
    test_field_filterMinmaxSingleComponentFormats();
    fn test_field_filterMinmaxImageComponentMapping() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filterMinmaxImageComponentMapping) as usize
                    - ptr as usize
            },
            716usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(filterMinmaxImageComponentMapping)
            )
        );
    }
    test_field_filterMinmaxImageComponentMapping();
    fn test_field_maxTimelineSemaphoreValueDifference() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTimelineSemaphoreValueDifference) as usize
                    - ptr as usize
            },
            720usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(maxTimelineSemaphoreValueDifference)
            )
        );
    }
    test_field_maxTimelineSemaphoreValueDifference();
    fn test_field_framebufferIntegerColorSampleCounts() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan12Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).framebufferIntegerColorSampleCounts) as usize
                    - ptr as usize
            },
            728usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan12Properties),
                "::",
                stringify!(framebufferIntegerColorSampleCounts)
            )
        );
    }
    test_field_framebufferIntegerColorSampleCounts();
}
impl Default for VkPhysicalDeviceVulkan12Properties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageFormatListCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub viewFormatCount: u32,
    pub pViewFormats: *const VkFormat,
}
#[test]
fn bindgen_test_layout_VkImageFormatListCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkImageFormatListCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkImageFormatListCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageFormatListCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageFormatListCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageFormatListCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageFormatListCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageFormatListCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageFormatListCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_viewFormatCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageFormatListCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewFormatCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageFormatListCreateInfo),
                "::",
                stringify!(viewFormatCount)
            )
        );
    }
    test_field_viewFormatCount();
    fn test_field_pViewFormats() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageFormatListCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pViewFormats) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageFormatListCreateInfo),
                "::",
                stringify!(pViewFormats)
            )
        );
    }
    test_field_pViewFormats();
}
impl Default for VkImageFormatListCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAttachmentDescription2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkAttachmentDescriptionFlags,
    pub format: VkFormat,
    pub samples: VkSampleCountFlagBits,
    pub loadOp: VkAttachmentLoadOp,
    pub storeOp: VkAttachmentStoreOp,
    pub stencilLoadOp: VkAttachmentLoadOp,
    pub stencilStoreOp: VkAttachmentStoreOp,
    pub initialLayout: VkImageLayout,
    pub finalLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkAttachmentDescription2() {
    assert_eq!(
        ::std::mem::size_of::<VkAttachmentDescription2>(),
        56usize,
        concat!("Size of: ", stringify!(VkAttachmentDescription2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAttachmentDescription2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAttachmentDescription2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription2),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription2),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_samples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samples) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription2),
                "::",
                stringify!(samples)
            )
        );
    }
    test_field_samples();
    fn test_field_loadOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).loadOp) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription2),
                "::",
                stringify!(loadOp)
            )
        );
    }
    test_field_loadOp();
    fn test_field_storeOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storeOp) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription2),
                "::",
                stringify!(storeOp)
            )
        );
    }
    test_field_storeOp();
    fn test_field_stencilLoadOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stencilLoadOp) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription2),
                "::",
                stringify!(stencilLoadOp)
            )
        );
    }
    test_field_stencilLoadOp();
    fn test_field_stencilStoreOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stencilStoreOp) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription2),
                "::",
                stringify!(stencilStoreOp)
            )
        );
    }
    test_field_stencilStoreOp();
    fn test_field_initialLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).initialLayout) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription2),
                "::",
                stringify!(initialLayout)
            )
        );
    }
    test_field_initialLayout();
    fn test_field_finalLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).finalLayout) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescription2),
                "::",
                stringify!(finalLayout)
            )
        );
    }
    test_field_finalLayout();
}
impl Default for VkAttachmentDescription2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAttachmentReference2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub attachment: u32,
    pub layout: VkImageLayout,
    pub aspectMask: VkImageAspectFlags,
}
#[test]
fn bindgen_test_layout_VkAttachmentReference2() {
    assert_eq!(
        ::std::mem::size_of::<VkAttachmentReference2>(),
        32usize,
        concat!("Size of: ", stringify!(VkAttachmentReference2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAttachmentReference2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAttachmentReference2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentReference2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentReference2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentReference2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentReference2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_attachment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentReference2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attachment) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentReference2),
                "::",
                stringify!(attachment)
            )
        );
    }
    test_field_attachment();
    fn test_field_layout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentReference2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layout) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentReference2),
                "::",
                stringify!(layout)
            )
        );
    }
    test_field_layout();
    fn test_field_aspectMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentReference2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aspectMask) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentReference2),
                "::",
                stringify!(aspectMask)
            )
        );
    }
    test_field_aspectMask();
}
impl Default for VkAttachmentReference2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassDescription2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSubpassDescriptionFlags,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub viewMask: u32,
    pub inputAttachmentCount: u32,
    pub pInputAttachments: *const VkAttachmentReference2,
    pub colorAttachmentCount: u32,
    pub pColorAttachments: *const VkAttachmentReference2,
    pub pResolveAttachments: *const VkAttachmentReference2,
    pub pDepthStencilAttachment: *const VkAttachmentReference2,
    pub preserveAttachmentCount: u32,
    pub pPreserveAttachments: *const u32,
}
#[test]
fn bindgen_test_layout_VkSubpassDescription2() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassDescription2>(),
        88usize,
        concat!("Size of: ", stringify!(VkSubpassDescription2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassDescription2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubpassDescription2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription2),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_pipelineBindPoint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineBindPoint) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription2),
                "::",
                stringify!(pipelineBindPoint)
            )
        );
    }
    test_field_pipelineBindPoint();
    fn test_field_viewMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewMask) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription2),
                "::",
                stringify!(viewMask)
            )
        );
    }
    test_field_viewMask();
    fn test_field_inputAttachmentCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inputAttachmentCount) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription2),
                "::",
                stringify!(inputAttachmentCount)
            )
        );
    }
    test_field_inputAttachmentCount();
    fn test_field_pInputAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pInputAttachments) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription2),
                "::",
                stringify!(pInputAttachments)
            )
        );
    }
    test_field_pInputAttachments();
    fn test_field_colorAttachmentCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorAttachmentCount) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription2),
                "::",
                stringify!(colorAttachmentCount)
            )
        );
    }
    test_field_colorAttachmentCount();
    fn test_field_pColorAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pColorAttachments) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription2),
                "::",
                stringify!(pColorAttachments)
            )
        );
    }
    test_field_pColorAttachments();
    fn test_field_pResolveAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pResolveAttachments) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription2),
                "::",
                stringify!(pResolveAttachments)
            )
        );
    }
    test_field_pResolveAttachments();
    fn test_field_pDepthStencilAttachment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDepthStencilAttachment) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription2),
                "::",
                stringify!(pDepthStencilAttachment)
            )
        );
    }
    test_field_pDepthStencilAttachment();
    fn test_field_preserveAttachmentCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).preserveAttachmentCount) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription2),
                "::",
                stringify!(preserveAttachmentCount)
            )
        );
    }
    test_field_preserveAttachmentCount();
    fn test_field_pPreserveAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDescription2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pPreserveAttachments) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescription2),
                "::",
                stringify!(pPreserveAttachments)
            )
        );
    }
    test_field_pPreserveAttachments();
}
impl Default for VkSubpassDescription2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassDependency2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcSubpass: u32,
    pub dstSubpass: u32,
    pub srcStageMask: VkPipelineStageFlags,
    pub dstStageMask: VkPipelineStageFlags,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub dependencyFlags: VkDependencyFlags,
    pub viewOffset: i32,
}
#[test]
fn bindgen_test_layout_VkSubpassDependency2() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassDependency2>(),
        48usize,
        concat!("Size of: ", stringify!(VkSubpassDependency2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassDependency2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubpassDependency2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcSubpass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcSubpass) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency2),
                "::",
                stringify!(srcSubpass)
            )
        );
    }
    test_field_srcSubpass();
    fn test_field_dstSubpass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstSubpass) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency2),
                "::",
                stringify!(dstSubpass)
            )
        );
    }
    test_field_dstSubpass();
    fn test_field_srcStageMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcStageMask) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency2),
                "::",
                stringify!(srcStageMask)
            )
        );
    }
    test_field_srcStageMask();
    fn test_field_dstStageMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstStageMask) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency2),
                "::",
                stringify!(dstStageMask)
            )
        );
    }
    test_field_dstStageMask();
    fn test_field_srcAccessMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcAccessMask) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency2),
                "::",
                stringify!(srcAccessMask)
            )
        );
    }
    test_field_srcAccessMask();
    fn test_field_dstAccessMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstAccessMask) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency2),
                "::",
                stringify!(dstAccessMask)
            )
        );
    }
    test_field_dstAccessMask();
    fn test_field_dependencyFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dependencyFlags) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency2),
                "::",
                stringify!(dependencyFlags)
            )
        );
    }
    test_field_dependencyFlags();
    fn test_field_viewOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassDependency2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewOffset) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDependency2),
                "::",
                stringify!(viewOffset)
            )
        );
    }
    test_field_viewOffset();
}
impl Default for VkSubpassDependency2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassCreateInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkRenderPassCreateFlags,
    pub attachmentCount: u32,
    pub pAttachments: *const VkAttachmentDescription2,
    pub subpassCount: u32,
    pub pSubpasses: *const VkSubpassDescription2,
    pub dependencyCount: u32,
    pub pDependencies: *const VkSubpassDependency2,
    pub correlatedViewMaskCount: u32,
    pub pCorrelatedViewMasks: *const u32,
}
#[test]
fn bindgen_test_layout_VkRenderPassCreateInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassCreateInfo2>(),
        80usize,
        concat!("Size of: ", stringify!(VkRenderPassCreateInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassCreateInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkRenderPassCreateInfo2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo2),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_attachmentCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attachmentCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo2),
                "::",
                stringify!(attachmentCount)
            )
        );
    }
    test_field_attachmentCount();
    fn test_field_pAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pAttachments) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo2),
                "::",
                stringify!(pAttachments)
            )
        );
    }
    test_field_pAttachments();
    fn test_field_subpassCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subpassCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo2),
                "::",
                stringify!(subpassCount)
            )
        );
    }
    test_field_subpassCount();
    fn test_field_pSubpasses() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSubpasses) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo2),
                "::",
                stringify!(pSubpasses)
            )
        );
    }
    test_field_pSubpasses();
    fn test_field_dependencyCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dependencyCount) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo2),
                "::",
                stringify!(dependencyCount)
            )
        );
    }
    test_field_dependencyCount();
    fn test_field_pDependencies() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDependencies) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo2),
                "::",
                stringify!(pDependencies)
            )
        );
    }
    test_field_pDependencies();
    fn test_field_correlatedViewMaskCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).correlatedViewMaskCount) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo2),
                "::",
                stringify!(correlatedViewMaskCount)
            )
        );
    }
    test_field_correlatedViewMaskCount();
    fn test_field_pCorrelatedViewMasks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreateInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCorrelatedViewMasks) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreateInfo2),
                "::",
                stringify!(pCorrelatedViewMasks)
            )
        );
    }
    test_field_pCorrelatedViewMasks();
}
impl Default for VkRenderPassCreateInfo2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub contents: VkSubpassContents,
}
#[test]
fn bindgen_test_layout_VkSubpassBeginInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassBeginInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkSubpassBeginInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassBeginInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubpassBeginInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassBeginInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassBeginInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_contents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).contents) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassBeginInfo),
                "::",
                stringify!(contents)
            )
        );
    }
    test_field_contents();
}
impl Default for VkSubpassBeginInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassEndInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkSubpassEndInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassEndInfo>(),
        16usize,
        concat!("Size of: ", stringify!(VkSubpassEndInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassEndInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubpassEndInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassEndInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassEndInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassEndInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassEndInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
}
impl Default for VkSubpassEndInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevice8BitStorageFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub storageBuffer8BitAccess: VkBool32,
    pub uniformAndStorageBuffer8BitAccess: VkBool32,
    pub storagePushConstant8: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevice8BitStorageFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevice8BitStorageFeatures>(),
        32usize,
        concat!("Size of: ", stringify!(VkPhysicalDevice8BitStorageFeatures))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevice8BitStorageFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevice8BitStorageFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevice8BitStorageFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevice8BitStorageFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevice8BitStorageFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevice8BitStorageFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_storageBuffer8BitAccess() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevice8BitStorageFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storageBuffer8BitAccess) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevice8BitStorageFeatures),
                "::",
                stringify!(storageBuffer8BitAccess)
            )
        );
    }
    test_field_storageBuffer8BitAccess();
    fn test_field_uniformAndStorageBuffer8BitAccess() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevice8BitStorageFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uniformAndStorageBuffer8BitAccess) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevice8BitStorageFeatures),
                "::",
                stringify!(uniformAndStorageBuffer8BitAccess)
            )
        );
    }
    test_field_uniformAndStorageBuffer8BitAccess();
    fn test_field_storagePushConstant8() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevice8BitStorageFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storagePushConstant8) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevice8BitStorageFeatures),
                "::",
                stringify!(storagePushConstant8)
            )
        );
    }
    test_field_storagePushConstant8();
}
impl Default for VkPhysicalDevice8BitStorageFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDriverProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub driverID: VkDriverId,
    pub driverName: [::std::os::raw::c_char; 256usize],
    pub driverInfo: [::std::os::raw::c_char; 256usize],
    pub conformanceVersion: VkConformanceVersion,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDriverProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDriverProperties>(),
        536usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceDriverProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDriverProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDriverProperties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceDriverProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDriverProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceDriverProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDriverProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_driverID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceDriverProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).driverID) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDriverProperties),
                "::",
                stringify!(driverID)
            )
        );
    }
    test_field_driverID();
    fn test_field_driverName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceDriverProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).driverName) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDriverProperties),
                "::",
                stringify!(driverName)
            )
        );
    }
    test_field_driverName();
    fn test_field_driverInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceDriverProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).driverInfo) as usize - ptr as usize
            },
            276usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDriverProperties),
                "::",
                stringify!(driverInfo)
            )
        );
    }
    test_field_driverInfo();
    fn test_field_conformanceVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceDriverProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).conformanceVersion) as usize - ptr as usize
            },
            532usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDriverProperties),
                "::",
                stringify!(conformanceVersion)
            )
        );
    }
    test_field_conformanceVersion();
}
impl Default for VkPhysicalDeviceDriverProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderAtomicInt64Features {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderBufferInt64Atomics: VkBool32,
    pub shaderSharedInt64Atomics: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderAtomicInt64Features() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderAtomicInt64Features>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderAtomicInt64Features)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderAtomicInt64Features>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderAtomicInt64Features)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicInt64Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicInt64Features),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicInt64Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicInt64Features),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderBufferInt64Atomics() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicInt64Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderBufferInt64Atomics) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicInt64Features),
                "::",
                stringify!(shaderBufferInt64Atomics)
            )
        );
    }
    test_field_shaderBufferInt64Atomics();
    fn test_field_shaderSharedInt64Atomics() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicInt64Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSharedInt64Atomics) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicInt64Features),
                "::",
                stringify!(shaderSharedInt64Atomics)
            )
        );
    }
    test_field_shaderSharedInt64Atomics();
}
impl Default for VkPhysicalDeviceShaderAtomicInt64Features {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderFloat16Int8Features {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderFloat16: VkBool32,
    pub shaderInt8: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderFloat16Int8Features() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderFloat16Int8Features>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderFloat16Int8Features)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderFloat16Int8Features>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderFloat16Int8Features)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderFloat16Int8Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderFloat16Int8Features),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderFloat16Int8Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderFloat16Int8Features),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderFloat16() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderFloat16Int8Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderFloat16) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderFloat16Int8Features),
                "::",
                stringify!(shaderFloat16)
            )
        );
    }
    test_field_shaderFloat16();
    fn test_field_shaderInt8() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderFloat16Int8Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderInt8) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderFloat16Int8Features),
                "::",
                stringify!(shaderInt8)
            )
        );
    }
    test_field_shaderInt8();
}
impl Default for VkPhysicalDeviceShaderFloat16Int8Features {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFloatControlsProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub denormBehaviorIndependence: VkShaderFloatControlsIndependence,
    pub roundingModeIndependence: VkShaderFloatControlsIndependence,
    pub shaderSignedZeroInfNanPreserveFloat16: VkBool32,
    pub shaderSignedZeroInfNanPreserveFloat32: VkBool32,
    pub shaderSignedZeroInfNanPreserveFloat64: VkBool32,
    pub shaderDenormPreserveFloat16: VkBool32,
    pub shaderDenormPreserveFloat32: VkBool32,
    pub shaderDenormPreserveFloat64: VkBool32,
    pub shaderDenormFlushToZeroFloat16: VkBool32,
    pub shaderDenormFlushToZeroFloat32: VkBool32,
    pub shaderDenormFlushToZeroFloat64: VkBool32,
    pub shaderRoundingModeRTEFloat16: VkBool32,
    pub shaderRoundingModeRTEFloat32: VkBool32,
    pub shaderRoundingModeRTEFloat64: VkBool32,
    pub shaderRoundingModeRTZFloat16: VkBool32,
    pub shaderRoundingModeRTZFloat32: VkBool32,
    pub shaderRoundingModeRTZFloat64: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFloatControlsProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFloatControlsProperties>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFloatControlsProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFloatControlsProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFloatControlsProperties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_denormBehaviorIndependence() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).denormBehaviorIndependence) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(denormBehaviorIndependence)
            )
        );
    }
    test_field_denormBehaviorIndependence();
    fn test_field_roundingModeIndependence() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).roundingModeIndependence) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(roundingModeIndependence)
            )
        );
    }
    test_field_roundingModeIndependence();
    fn test_field_shaderSignedZeroInfNanPreserveFloat16() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSignedZeroInfNanPreserveFloat16) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(shaderSignedZeroInfNanPreserveFloat16)
            )
        );
    }
    test_field_shaderSignedZeroInfNanPreserveFloat16();
    fn test_field_shaderSignedZeroInfNanPreserveFloat32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSignedZeroInfNanPreserveFloat32) as usize
                    - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(shaderSignedZeroInfNanPreserveFloat32)
            )
        );
    }
    test_field_shaderSignedZeroInfNanPreserveFloat32();
    fn test_field_shaderSignedZeroInfNanPreserveFloat64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSignedZeroInfNanPreserveFloat64) as usize
                    - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(shaderSignedZeroInfNanPreserveFloat64)
            )
        );
    }
    test_field_shaderSignedZeroInfNanPreserveFloat64();
    fn test_field_shaderDenormPreserveFloat16() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDenormPreserveFloat16) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(shaderDenormPreserveFloat16)
            )
        );
    }
    test_field_shaderDenormPreserveFloat16();
    fn test_field_shaderDenormPreserveFloat32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDenormPreserveFloat32) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(shaderDenormPreserveFloat32)
            )
        );
    }
    test_field_shaderDenormPreserveFloat32();
    fn test_field_shaderDenormPreserveFloat64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDenormPreserveFloat64) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(shaderDenormPreserveFloat64)
            )
        );
    }
    test_field_shaderDenormPreserveFloat64();
    fn test_field_shaderDenormFlushToZeroFloat16() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDenormFlushToZeroFloat16) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(shaderDenormFlushToZeroFloat16)
            )
        );
    }
    test_field_shaderDenormFlushToZeroFloat16();
    fn test_field_shaderDenormFlushToZeroFloat32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDenormFlushToZeroFloat32) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(shaderDenormFlushToZeroFloat32)
            )
        );
    }
    test_field_shaderDenormFlushToZeroFloat32();
    fn test_field_shaderDenormFlushToZeroFloat64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDenormFlushToZeroFloat64) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(shaderDenormFlushToZeroFloat64)
            )
        );
    }
    test_field_shaderDenormFlushToZeroFloat64();
    fn test_field_shaderRoundingModeRTEFloat16() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderRoundingModeRTEFloat16) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(shaderRoundingModeRTEFloat16)
            )
        );
    }
    test_field_shaderRoundingModeRTEFloat16();
    fn test_field_shaderRoundingModeRTEFloat32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderRoundingModeRTEFloat32) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(shaderRoundingModeRTEFloat32)
            )
        );
    }
    test_field_shaderRoundingModeRTEFloat32();
    fn test_field_shaderRoundingModeRTEFloat64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderRoundingModeRTEFloat64) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(shaderRoundingModeRTEFloat64)
            )
        );
    }
    test_field_shaderRoundingModeRTEFloat64();
    fn test_field_shaderRoundingModeRTZFloat16() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderRoundingModeRTZFloat16) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(shaderRoundingModeRTZFloat16)
            )
        );
    }
    test_field_shaderRoundingModeRTZFloat16();
    fn test_field_shaderRoundingModeRTZFloat32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderRoundingModeRTZFloat32) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(shaderRoundingModeRTZFloat32)
            )
        );
    }
    test_field_shaderRoundingModeRTZFloat32();
    fn test_field_shaderRoundingModeRTZFloat64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFloatControlsProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderRoundingModeRTZFloat64) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFloatControlsProperties),
                "::",
                stringify!(shaderRoundingModeRTZFloat64)
            )
        );
    }
    test_field_shaderRoundingModeRTZFloat64();
}
impl Default for VkPhysicalDeviceFloatControlsProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetLayoutBindingFlagsCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub bindingCount: u32,
    pub pBindingFlags: *const VkDescriptorBindingFlags,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetLayoutBindingFlagsCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorSetLayoutBindingFlagsCreateInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkDescriptorSetLayoutBindingFlagsCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorSetLayoutBindingFlagsCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDescriptorSetLayoutBindingFlagsCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorSetLayoutBindingFlagsCreateInfo>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutBindingFlagsCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorSetLayoutBindingFlagsCreateInfo>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutBindingFlagsCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_bindingCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorSetLayoutBindingFlagsCreateInfo>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bindingCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutBindingFlagsCreateInfo),
                "::",
                stringify!(bindingCount)
            )
        );
    }
    test_field_bindingCount();
    fn test_field_pBindingFlags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorSetLayoutBindingFlagsCreateInfo>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pBindingFlags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutBindingFlagsCreateInfo),
                "::",
                stringify!(pBindingFlags)
            )
        );
    }
    test_field_pBindingFlags();
}
impl Default for VkDescriptorSetLayoutBindingFlagsCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDescriptorIndexingFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderInputAttachmentArrayDynamicIndexing: VkBool32,
    pub shaderUniformTexelBufferArrayDynamicIndexing: VkBool32,
    pub shaderStorageTexelBufferArrayDynamicIndexing: VkBool32,
    pub shaderUniformBufferArrayNonUniformIndexing: VkBool32,
    pub shaderSampledImageArrayNonUniformIndexing: VkBool32,
    pub shaderStorageBufferArrayNonUniformIndexing: VkBool32,
    pub shaderStorageImageArrayNonUniformIndexing: VkBool32,
    pub shaderInputAttachmentArrayNonUniformIndexing: VkBool32,
    pub shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32,
    pub shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32,
    pub descriptorBindingUniformBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingSampledImageUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageImageUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32,
    pub descriptorBindingUpdateUnusedWhilePending: VkBool32,
    pub descriptorBindingPartiallyBound: VkBool32,
    pub descriptorBindingVariableDescriptorCount: VkBool32,
    pub runtimeDescriptorArray: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDescriptorIndexingFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDescriptorIndexingFeatures>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDescriptorIndexingFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDescriptorIndexingFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderInputAttachmentArrayDynamicIndexing() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderInputAttachmentArrayDynamicIndexing) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(shaderInputAttachmentArrayDynamicIndexing)
            )
        );
    }
    test_field_shaderInputAttachmentArrayDynamicIndexing();
    fn test_field_shaderUniformTexelBufferArrayDynamicIndexing() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderUniformTexelBufferArrayDynamicIndexing) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(shaderUniformTexelBufferArrayDynamicIndexing)
            )
        );
    }
    test_field_shaderUniformTexelBufferArrayDynamicIndexing();
    fn test_field_shaderStorageTexelBufferArrayDynamicIndexing() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageTexelBufferArrayDynamicIndexing) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(shaderStorageTexelBufferArrayDynamicIndexing)
            )
        );
    }
    test_field_shaderStorageTexelBufferArrayDynamicIndexing();
    fn test_field_shaderUniformBufferArrayNonUniformIndexing() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderUniformBufferArrayNonUniformIndexing) as usize
                    - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(shaderUniformBufferArrayNonUniformIndexing)
            )
        );
    }
    test_field_shaderUniformBufferArrayNonUniformIndexing();
    fn test_field_shaderSampledImageArrayNonUniformIndexing() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSampledImageArrayNonUniformIndexing) as usize
                    - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(shaderSampledImageArrayNonUniformIndexing)
            )
        );
    }
    test_field_shaderSampledImageArrayNonUniformIndexing();
    fn test_field_shaderStorageBufferArrayNonUniformIndexing() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageBufferArrayNonUniformIndexing) as usize
                    - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(shaderStorageBufferArrayNonUniformIndexing)
            )
        );
    }
    test_field_shaderStorageBufferArrayNonUniformIndexing();
    fn test_field_shaderStorageImageArrayNonUniformIndexing() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageImageArrayNonUniformIndexing) as usize
                    - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(shaderStorageImageArrayNonUniformIndexing)
            )
        );
    }
    test_field_shaderStorageImageArrayNonUniformIndexing();
    fn test_field_shaderInputAttachmentArrayNonUniformIndexing() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderInputAttachmentArrayNonUniformIndexing) as usize
                    - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(shaderInputAttachmentArrayNonUniformIndexing)
            )
        );
    }
    test_field_shaderInputAttachmentArrayNonUniformIndexing();
    fn test_field_shaderUniformTexelBufferArrayNonUniformIndexing() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderUniformTexelBufferArrayNonUniformIndexing)
                    as usize
                    - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(shaderUniformTexelBufferArrayNonUniformIndexing)
            )
        );
    }
    test_field_shaderUniformTexelBufferArrayNonUniformIndexing();
    fn test_field_shaderStorageTexelBufferArrayNonUniformIndexing() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageTexelBufferArrayNonUniformIndexing)
                    as usize
                    - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(shaderStorageTexelBufferArrayNonUniformIndexing)
            )
        );
    }
    test_field_shaderStorageTexelBufferArrayNonUniformIndexing();
    fn test_field_descriptorBindingUniformBufferUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingUniformBufferUpdateAfterBind) as usize
                    - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(descriptorBindingUniformBufferUpdateAfterBind)
            )
        );
    }
    test_field_descriptorBindingUniformBufferUpdateAfterBind();
    fn test_field_descriptorBindingSampledImageUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingSampledImageUpdateAfterBind) as usize
                    - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(descriptorBindingSampledImageUpdateAfterBind)
            )
        );
    }
    test_field_descriptorBindingSampledImageUpdateAfterBind();
    fn test_field_descriptorBindingStorageImageUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingStorageImageUpdateAfterBind) as usize
                    - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(descriptorBindingStorageImageUpdateAfterBind)
            )
        );
    }
    test_field_descriptorBindingStorageImageUpdateAfterBind();
    fn test_field_descriptorBindingStorageBufferUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingStorageBufferUpdateAfterBind) as usize
                    - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(descriptorBindingStorageBufferUpdateAfterBind)
            )
        );
    }
    test_field_descriptorBindingStorageBufferUpdateAfterBind();
    fn test_field_descriptorBindingUniformTexelBufferUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingUniformTexelBufferUpdateAfterBind)
                    as usize
                    - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(descriptorBindingUniformTexelBufferUpdateAfterBind)
            )
        );
    }
    test_field_descriptorBindingUniformTexelBufferUpdateAfterBind();
    fn test_field_descriptorBindingStorageTexelBufferUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingStorageTexelBufferUpdateAfterBind)
                    as usize
                    - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(descriptorBindingStorageTexelBufferUpdateAfterBind)
            )
        );
    }
    test_field_descriptorBindingStorageTexelBufferUpdateAfterBind();
    fn test_field_descriptorBindingUpdateUnusedWhilePending() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingUpdateUnusedWhilePending) as usize
                    - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(descriptorBindingUpdateUnusedWhilePending)
            )
        );
    }
    test_field_descriptorBindingUpdateUnusedWhilePending();
    fn test_field_descriptorBindingPartiallyBound() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingPartiallyBound) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(descriptorBindingPartiallyBound)
            )
        );
    }
    test_field_descriptorBindingPartiallyBound();
    fn test_field_descriptorBindingVariableDescriptorCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingVariableDescriptorCount) as usize
                    - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(descriptorBindingVariableDescriptorCount)
            )
        );
    }
    test_field_descriptorBindingVariableDescriptorCount();
    fn test_field_runtimeDescriptorArray() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).runtimeDescriptorArray) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingFeatures),
                "::",
                stringify!(runtimeDescriptorArray)
            )
        );
    }
    test_field_runtimeDescriptorArray();
}
impl Default for VkPhysicalDeviceDescriptorIndexingFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDescriptorIndexingProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxUpdateAfterBindDescriptorsInAllPools: u32,
    pub shaderUniformBufferArrayNonUniformIndexingNative: VkBool32,
    pub shaderSampledImageArrayNonUniformIndexingNative: VkBool32,
    pub shaderStorageBufferArrayNonUniformIndexingNative: VkBool32,
    pub shaderStorageImageArrayNonUniformIndexingNative: VkBool32,
    pub shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32,
    pub robustBufferAccessUpdateAfterBind: VkBool32,
    pub quadDivergentImplicitLod: VkBool32,
    pub maxPerStageDescriptorUpdateAfterBindSamplers: u32,
    pub maxPerStageDescriptorUpdateAfterBindUniformBuffers: u32,
    pub maxPerStageDescriptorUpdateAfterBindStorageBuffers: u32,
    pub maxPerStageDescriptorUpdateAfterBindSampledImages: u32,
    pub maxPerStageDescriptorUpdateAfterBindStorageImages: u32,
    pub maxPerStageDescriptorUpdateAfterBindInputAttachments: u32,
    pub maxPerStageUpdateAfterBindResources: u32,
    pub maxDescriptorSetUpdateAfterBindSamplers: u32,
    pub maxDescriptorSetUpdateAfterBindUniformBuffers: u32,
    pub maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: u32,
    pub maxDescriptorSetUpdateAfterBindStorageBuffers: u32,
    pub maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: u32,
    pub maxDescriptorSetUpdateAfterBindSampledImages: u32,
    pub maxDescriptorSetUpdateAfterBindStorageImages: u32,
    pub maxDescriptorSetUpdateAfterBindInputAttachments: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDescriptorIndexingProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDescriptorIndexingProperties>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDescriptorIndexingProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDescriptorIndexingProperties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxUpdateAfterBindDescriptorsInAllPools() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxUpdateAfterBindDescriptorsInAllPools) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(maxUpdateAfterBindDescriptorsInAllPools)
            )
        );
    }
    test_field_maxUpdateAfterBindDescriptorsInAllPools();
    fn test_field_shaderUniformBufferArrayNonUniformIndexingNative() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderUniformBufferArrayNonUniformIndexingNative)
                    as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(shaderUniformBufferArrayNonUniformIndexingNative)
            )
        );
    }
    test_field_shaderUniformBufferArrayNonUniformIndexingNative();
    fn test_field_shaderSampledImageArrayNonUniformIndexingNative() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSampledImageArrayNonUniformIndexingNative)
                    as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(shaderSampledImageArrayNonUniformIndexingNative)
            )
        );
    }
    test_field_shaderSampledImageArrayNonUniformIndexingNative();
    fn test_field_shaderStorageBufferArrayNonUniformIndexingNative() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageBufferArrayNonUniformIndexingNative)
                    as usize
                    - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(shaderStorageBufferArrayNonUniformIndexingNative)
            )
        );
    }
    test_field_shaderStorageBufferArrayNonUniformIndexingNative();
    fn test_field_shaderStorageImageArrayNonUniformIndexingNative() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStorageImageArrayNonUniformIndexingNative)
                    as usize
                    - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(shaderStorageImageArrayNonUniformIndexingNative)
            )
        );
    }
    test_field_shaderStorageImageArrayNonUniformIndexingNative();
    fn test_field_shaderInputAttachmentArrayNonUniformIndexingNative() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderInputAttachmentArrayNonUniformIndexingNative)
                    as usize
                    - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(shaderInputAttachmentArrayNonUniformIndexingNative)
            )
        );
    }
    test_field_shaderInputAttachmentArrayNonUniformIndexingNative();
    fn test_field_robustBufferAccessUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).robustBufferAccessUpdateAfterBind) as usize
                    - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(robustBufferAccessUpdateAfterBind)
            )
        );
    }
    test_field_robustBufferAccessUpdateAfterBind();
    fn test_field_quadDivergentImplicitLod() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quadDivergentImplicitLod) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(quadDivergentImplicitLod)
            )
        );
    }
    test_field_quadDivergentImplicitLod();
    fn test_field_maxPerStageDescriptorUpdateAfterBindSamplers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorUpdateAfterBindSamplers) as usize
                    - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(maxPerStageDescriptorUpdateAfterBindSamplers)
            )
        );
    }
    test_field_maxPerStageDescriptorUpdateAfterBindSamplers();
    fn test_field_maxPerStageDescriptorUpdateAfterBindUniformBuffers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorUpdateAfterBindUniformBuffers)
                    as usize
                    - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(maxPerStageDescriptorUpdateAfterBindUniformBuffers)
            )
        );
    }
    test_field_maxPerStageDescriptorUpdateAfterBindUniformBuffers();
    fn test_field_maxPerStageDescriptorUpdateAfterBindStorageBuffers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorUpdateAfterBindStorageBuffers)
                    as usize
                    - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(maxPerStageDescriptorUpdateAfterBindStorageBuffers)
            )
        );
    }
    test_field_maxPerStageDescriptorUpdateAfterBindStorageBuffers();
    fn test_field_maxPerStageDescriptorUpdateAfterBindSampledImages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorUpdateAfterBindSampledImages)
                    as usize
                    - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(maxPerStageDescriptorUpdateAfterBindSampledImages)
            )
        );
    }
    test_field_maxPerStageDescriptorUpdateAfterBindSampledImages();
    fn test_field_maxPerStageDescriptorUpdateAfterBindStorageImages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorUpdateAfterBindStorageImages)
                    as usize
                    - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(maxPerStageDescriptorUpdateAfterBindStorageImages)
            )
        );
    }
    test_field_maxPerStageDescriptorUpdateAfterBindStorageImages();
    fn test_field_maxPerStageDescriptorUpdateAfterBindInputAttachments() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorUpdateAfterBindInputAttachments)
                    as usize
                    - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(maxPerStageDescriptorUpdateAfterBindInputAttachments)
            )
        );
    }
    test_field_maxPerStageDescriptorUpdateAfterBindInputAttachments();
    fn test_field_maxPerStageUpdateAfterBindResources() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageUpdateAfterBindResources) as usize
                    - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(maxPerStageUpdateAfterBindResources)
            )
        );
    }
    test_field_maxPerStageUpdateAfterBindResources();
    fn test_field_maxDescriptorSetUpdateAfterBindSamplers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindSamplers) as usize
                    - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindSamplers)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindSamplers();
    fn test_field_maxDescriptorSetUpdateAfterBindUniformBuffers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindUniformBuffers) as usize
                    - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindUniformBuffers)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindUniformBuffers();
    fn test_field_maxDescriptorSetUpdateAfterBindUniformBuffersDynamic() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
                    as usize
                    - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindUniformBuffersDynamic)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindUniformBuffersDynamic();
    fn test_field_maxDescriptorSetUpdateAfterBindStorageBuffers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindStorageBuffers) as usize
                    - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindStorageBuffers)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindStorageBuffers();
    fn test_field_maxDescriptorSetUpdateAfterBindStorageBuffersDynamic() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
                    as usize
                    - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindStorageBuffersDynamic)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindStorageBuffersDynamic();
    fn test_field_maxDescriptorSetUpdateAfterBindSampledImages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindSampledImages) as usize
                    - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindSampledImages)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindSampledImages();
    fn test_field_maxDescriptorSetUpdateAfterBindStorageImages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindStorageImages) as usize
                    - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindStorageImages)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindStorageImages();
    fn test_field_maxDescriptorSetUpdateAfterBindInputAttachments() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorIndexingProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindInputAttachments)
                    as usize
                    - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorIndexingProperties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindInputAttachments)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindInputAttachments();
}
impl Default for VkPhysicalDeviceDescriptorIndexingProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetVariableDescriptorCountAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub descriptorSetCount: u32,
    pub pDescriptorCounts: *const u32,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetVariableDescriptorCountAllocateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorSetVariableDescriptorCountAllocateInfo>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkDescriptorSetVariableDescriptorCountAllocateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorSetVariableDescriptorCountAllocateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDescriptorSetVariableDescriptorCountAllocateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkDescriptorSetVariableDescriptorCountAllocateInfo,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetVariableDescriptorCountAllocateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkDescriptorSetVariableDescriptorCountAllocateInfo,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetVariableDescriptorCountAllocateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_descriptorSetCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkDescriptorSetVariableDescriptorCountAllocateInfo,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorSetCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetVariableDescriptorCountAllocateInfo),
                "::",
                stringify!(descriptorSetCount)
            )
        );
    }
    test_field_descriptorSetCount();
    fn test_field_pDescriptorCounts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkDescriptorSetVariableDescriptorCountAllocateInfo,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDescriptorCounts) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetVariableDescriptorCountAllocateInfo),
                "::",
                stringify!(pDescriptorCounts)
            )
        );
    }
    test_field_pDescriptorCounts();
}
impl Default for VkDescriptorSetVariableDescriptorCountAllocateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetVariableDescriptorCountLayoutSupport {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxVariableDescriptorCount: u32,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetVariableDescriptorCountLayoutSupport() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorSetVariableDescriptorCountLayoutSupport>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDescriptorSetVariableDescriptorCountLayoutSupport)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorSetVariableDescriptorCountLayoutSupport>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDescriptorSetVariableDescriptorCountLayoutSupport)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkDescriptorSetVariableDescriptorCountLayoutSupport,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetVariableDescriptorCountLayoutSupport),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkDescriptorSetVariableDescriptorCountLayoutSupport,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetVariableDescriptorCountLayoutSupport),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxVariableDescriptorCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkDescriptorSetVariableDescriptorCountLayoutSupport,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxVariableDescriptorCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetVariableDescriptorCountLayoutSupport),
                "::",
                stringify!(maxVariableDescriptorCount)
            )
        );
    }
    test_field_maxVariableDescriptorCount();
}
impl Default for VkDescriptorSetVariableDescriptorCountLayoutSupport {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassDescriptionDepthStencilResolve {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub depthResolveMode: VkResolveModeFlagBits,
    pub stencilResolveMode: VkResolveModeFlagBits,
    pub pDepthStencilResolveAttachment: *const VkAttachmentReference2,
}
#[test]
fn bindgen_test_layout_VkSubpassDescriptionDepthStencilResolve() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassDescriptionDepthStencilResolve>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkSubpassDescriptionDepthStencilResolve)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassDescriptionDepthStencilResolve>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSubpassDescriptionDepthStencilResolve)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSubpassDescriptionDepthStencilResolve>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescriptionDepthStencilResolve),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSubpassDescriptionDepthStencilResolve>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescriptionDepthStencilResolve),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_depthResolveMode() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSubpassDescriptionDepthStencilResolve>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthResolveMode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescriptionDepthStencilResolve),
                "::",
                stringify!(depthResolveMode)
            )
        );
    }
    test_field_depthResolveMode();
    fn test_field_stencilResolveMode() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSubpassDescriptionDepthStencilResolve>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stencilResolveMode) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescriptionDepthStencilResolve),
                "::",
                stringify!(stencilResolveMode)
            )
        );
    }
    test_field_stencilResolveMode();
    fn test_field_pDepthStencilResolveAttachment() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSubpassDescriptionDepthStencilResolve>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDepthStencilResolveAttachment) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassDescriptionDepthStencilResolve),
                "::",
                stringify!(pDepthStencilResolveAttachment)
            )
        );
    }
    test_field_pDepthStencilResolveAttachment();
}
impl Default for VkSubpassDescriptionDepthStencilResolve {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDepthStencilResolveProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub supportedDepthResolveModes: VkResolveModeFlags,
    pub supportedStencilResolveModes: VkResolveModeFlags,
    pub independentResolveNone: VkBool32,
    pub independentResolve: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDepthStencilResolveProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDepthStencilResolveProperties>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDepthStencilResolveProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDepthStencilResolveProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDepthStencilResolveProperties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDepthStencilResolveProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDepthStencilResolveProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDepthStencilResolveProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDepthStencilResolveProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_supportedDepthResolveModes() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDepthStencilResolveProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedDepthResolveModes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDepthStencilResolveProperties),
                "::",
                stringify!(supportedDepthResolveModes)
            )
        );
    }
    test_field_supportedDepthResolveModes();
    fn test_field_supportedStencilResolveModes() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDepthStencilResolveProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedStencilResolveModes) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDepthStencilResolveProperties),
                "::",
                stringify!(supportedStencilResolveModes)
            )
        );
    }
    test_field_supportedStencilResolveModes();
    fn test_field_independentResolveNone() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDepthStencilResolveProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).independentResolveNone) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDepthStencilResolveProperties),
                "::",
                stringify!(independentResolveNone)
            )
        );
    }
    test_field_independentResolveNone();
    fn test_field_independentResolve() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDepthStencilResolveProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).independentResolve) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDepthStencilResolveProperties),
                "::",
                stringify!(independentResolve)
            )
        );
    }
    test_field_independentResolve();
}
impl Default for VkPhysicalDeviceDepthStencilResolveProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceScalarBlockLayoutFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub scalarBlockLayout: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceScalarBlockLayoutFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceScalarBlockLayoutFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceScalarBlockLayoutFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceScalarBlockLayoutFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceScalarBlockLayoutFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceScalarBlockLayoutFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceScalarBlockLayoutFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceScalarBlockLayoutFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceScalarBlockLayoutFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_scalarBlockLayout() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceScalarBlockLayoutFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scalarBlockLayout) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceScalarBlockLayoutFeatures),
                "::",
                stringify!(scalarBlockLayout)
            )
        );
    }
    test_field_scalarBlockLayout();
}
impl Default for VkPhysicalDeviceScalarBlockLayoutFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageStencilUsageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub stencilUsage: VkImageUsageFlags,
}
#[test]
fn bindgen_test_layout_VkImageStencilUsageCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkImageStencilUsageCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkImageStencilUsageCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageStencilUsageCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageStencilUsageCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageStencilUsageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageStencilUsageCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageStencilUsageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageStencilUsageCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_stencilUsage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageStencilUsageCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stencilUsage) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageStencilUsageCreateInfo),
                "::",
                stringify!(stencilUsage)
            )
        );
    }
    test_field_stencilUsage();
}
impl Default for VkImageStencilUsageCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSamplerReductionModeCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub reductionMode: VkSamplerReductionMode,
}
#[test]
fn bindgen_test_layout_VkSamplerReductionModeCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSamplerReductionModeCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkSamplerReductionModeCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSamplerReductionModeCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSamplerReductionModeCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerReductionModeCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerReductionModeCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerReductionModeCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerReductionModeCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_reductionMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSamplerReductionModeCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reductionMode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerReductionModeCreateInfo),
                "::",
                stringify!(reductionMode)
            )
        );
    }
    test_field_reductionMode();
}
impl Default for VkSamplerReductionModeCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSamplerFilterMinmaxProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub filterMinmaxSingleComponentFormats: VkBool32,
    pub filterMinmaxImageComponentMapping: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSamplerFilterMinmaxProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSamplerFilterMinmaxProperties>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSamplerFilterMinmaxProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSamplerFilterMinmaxProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSamplerFilterMinmaxProperties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceSamplerFilterMinmaxProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSamplerFilterMinmaxProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceSamplerFilterMinmaxProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSamplerFilterMinmaxProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_filterMinmaxSingleComponentFormats() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceSamplerFilterMinmaxProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filterMinmaxSingleComponentFormats) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSamplerFilterMinmaxProperties),
                "::",
                stringify!(filterMinmaxSingleComponentFormats)
            )
        );
    }
    test_field_filterMinmaxSingleComponentFormats();
    fn test_field_filterMinmaxImageComponentMapping() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceSamplerFilterMinmaxProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filterMinmaxImageComponentMapping) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSamplerFilterMinmaxProperties),
                "::",
                stringify!(filterMinmaxImageComponentMapping)
            )
        );
    }
    test_field_filterMinmaxImageComponentMapping();
}
impl Default for VkPhysicalDeviceSamplerFilterMinmaxProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVulkanMemoryModelFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub vulkanMemoryModel: VkBool32,
    pub vulkanMemoryModelDeviceScope: VkBool32,
    pub vulkanMemoryModelAvailabilityVisibilityChains: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVulkanMemoryModelFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVulkanMemoryModelFeatures>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceVulkanMemoryModelFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVulkanMemoryModelFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVulkanMemoryModelFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkanMemoryModelFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkanMemoryModelFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkanMemoryModelFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkanMemoryModelFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_vulkanMemoryModel() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkanMemoryModelFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vulkanMemoryModel) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkanMemoryModelFeatures),
                "::",
                stringify!(vulkanMemoryModel)
            )
        );
    }
    test_field_vulkanMemoryModel();
    fn test_field_vulkanMemoryModelDeviceScope() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkanMemoryModelFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vulkanMemoryModelDeviceScope) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkanMemoryModelFeatures),
                "::",
                stringify!(vulkanMemoryModelDeviceScope)
            )
        );
    }
    test_field_vulkanMemoryModelDeviceScope();
    fn test_field_vulkanMemoryModelAvailabilityVisibilityChains() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkanMemoryModelFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vulkanMemoryModelAvailabilityVisibilityChains) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkanMemoryModelFeatures),
                "::",
                stringify!(vulkanMemoryModelAvailabilityVisibilityChains)
            )
        );
    }
    test_field_vulkanMemoryModelAvailabilityVisibilityChains();
}
impl Default for VkPhysicalDeviceVulkanMemoryModelFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceImagelessFramebufferFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub imagelessFramebuffer: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceImagelessFramebufferFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceImagelessFramebufferFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceImagelessFramebufferFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceImagelessFramebufferFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceImagelessFramebufferFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImagelessFramebufferFeatures>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImagelessFramebufferFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImagelessFramebufferFeatures>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImagelessFramebufferFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_imagelessFramebuffer() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImagelessFramebufferFeatures>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imagelessFramebuffer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImagelessFramebufferFeatures),
                "::",
                stringify!(imagelessFramebuffer)
            )
        );
    }
    test_field_imagelessFramebuffer();
}
impl Default for VkPhysicalDeviceImagelessFramebufferFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFramebufferAttachmentImageInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkImageCreateFlags,
    pub usage: VkImageUsageFlags,
    pub width: u32,
    pub height: u32,
    pub layerCount: u32,
    pub viewFormatCount: u32,
    pub pViewFormats: *const VkFormat,
}
#[test]
fn bindgen_test_layout_VkFramebufferAttachmentImageInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkFramebufferAttachmentImageInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VkFramebufferAttachmentImageInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkFramebufferAttachmentImageInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkFramebufferAttachmentImageInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferAttachmentImageInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferAttachmentImageInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferAttachmentImageInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferAttachmentImageInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferAttachmentImageInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferAttachmentImageInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_usage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferAttachmentImageInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferAttachmentImageInfo),
                "::",
                stringify!(usage)
            )
        );
    }
    test_field_usage();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferAttachmentImageInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferAttachmentImageInfo),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferAttachmentImageInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferAttachmentImageInfo),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_layerCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferAttachmentImageInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layerCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferAttachmentImageInfo),
                "::",
                stringify!(layerCount)
            )
        );
    }
    test_field_layerCount();
    fn test_field_viewFormatCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferAttachmentImageInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewFormatCount) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferAttachmentImageInfo),
                "::",
                stringify!(viewFormatCount)
            )
        );
    }
    test_field_viewFormatCount();
    fn test_field_pViewFormats() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFramebufferAttachmentImageInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pViewFormats) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferAttachmentImageInfo),
                "::",
                stringify!(pViewFormats)
            )
        );
    }
    test_field_pViewFormats();
}
impl Default for VkFramebufferAttachmentImageInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFramebufferAttachmentsCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub attachmentImageInfoCount: u32,
    pub pAttachmentImageInfos: *const VkFramebufferAttachmentImageInfo,
}
#[test]
fn bindgen_test_layout_VkFramebufferAttachmentsCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkFramebufferAttachmentsCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkFramebufferAttachmentsCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkFramebufferAttachmentsCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkFramebufferAttachmentsCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkFramebufferAttachmentsCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferAttachmentsCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkFramebufferAttachmentsCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferAttachmentsCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_attachmentImageInfoCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkFramebufferAttachmentsCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attachmentImageInfoCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferAttachmentsCreateInfo),
                "::",
                stringify!(attachmentImageInfoCount)
            )
        );
    }
    test_field_attachmentImageInfoCount();
    fn test_field_pAttachmentImageInfos() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkFramebufferAttachmentsCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pAttachmentImageInfos) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferAttachmentsCreateInfo),
                "::",
                stringify!(pAttachmentImageInfos)
            )
        );
    }
    test_field_pAttachmentImageInfos();
}
impl Default for VkFramebufferAttachmentsCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassAttachmentBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub attachmentCount: u32,
    pub pAttachments: *const VkImageView,
}
#[test]
fn bindgen_test_layout_VkRenderPassAttachmentBeginInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassAttachmentBeginInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkRenderPassAttachmentBeginInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassAttachmentBeginInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkRenderPassAttachmentBeginInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassAttachmentBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassAttachmentBeginInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassAttachmentBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassAttachmentBeginInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_attachmentCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassAttachmentBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attachmentCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassAttachmentBeginInfo),
                "::",
                stringify!(attachmentCount)
            )
        );
    }
    test_field_attachmentCount();
    fn test_field_pAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassAttachmentBeginInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pAttachments) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassAttachmentBeginInfo),
                "::",
                stringify!(pAttachments)
            )
        );
    }
    test_field_pAttachments();
}
impl Default for VkRenderPassAttachmentBeginInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceUniformBufferStandardLayoutFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub uniformBufferStandardLayout: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceUniformBufferStandardLayoutFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceUniformBufferStandardLayoutFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceUniformBufferStandardLayoutFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceUniformBufferStandardLayoutFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceUniformBufferStandardLayoutFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceUniformBufferStandardLayoutFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceUniformBufferStandardLayoutFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_uniformBufferStandardLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceUniformBufferStandardLayoutFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uniformBufferStandardLayout) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceUniformBufferStandardLayoutFeatures),
                "::",
                stringify!(uniformBufferStandardLayout)
            )
        );
    }
    test_field_uniformBufferStandardLayout();
}
impl Default for VkPhysicalDeviceUniformBufferStandardLayoutFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderSubgroupExtendedTypes: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderSubgroupExtendedTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSubgroupExtendedTypes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures),
                "::",
                stringify!(shaderSubgroupExtendedTypes)
            )
        );
    }
    test_field_shaderSubgroupExtendedTypes();
}
impl Default for VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub separateDepthStencilLayouts: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_separateDepthStencilLayouts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).separateDepthStencilLayouts) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures),
                "::",
                stringify!(separateDepthStencilLayouts)
            )
        );
    }
    test_field_separateDepthStencilLayouts();
}
impl Default for VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAttachmentReferenceStencilLayout {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub stencilLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkAttachmentReferenceStencilLayout() {
    assert_eq!(
        ::std::mem::size_of::<VkAttachmentReferenceStencilLayout>(),
        24usize,
        concat!("Size of: ", stringify!(VkAttachmentReferenceStencilLayout))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAttachmentReferenceStencilLayout>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAttachmentReferenceStencilLayout)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAttachmentReferenceStencilLayout>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentReferenceStencilLayout),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAttachmentReferenceStencilLayout>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentReferenceStencilLayout),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_stencilLayout() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAttachmentReferenceStencilLayout>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stencilLayout) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentReferenceStencilLayout),
                "::",
                stringify!(stencilLayout)
            )
        );
    }
    test_field_stencilLayout();
}
impl Default for VkAttachmentReferenceStencilLayout {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAttachmentDescriptionStencilLayout {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub stencilInitialLayout: VkImageLayout,
    pub stencilFinalLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkAttachmentDescriptionStencilLayout() {
    assert_eq!(
        ::std::mem::size_of::<VkAttachmentDescriptionStencilLayout>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkAttachmentDescriptionStencilLayout)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAttachmentDescriptionStencilLayout>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAttachmentDescriptionStencilLayout)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAttachmentDescriptionStencilLayout>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescriptionStencilLayout),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAttachmentDescriptionStencilLayout>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescriptionStencilLayout),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_stencilInitialLayout() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAttachmentDescriptionStencilLayout>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stencilInitialLayout) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescriptionStencilLayout),
                "::",
                stringify!(stencilInitialLayout)
            )
        );
    }
    test_field_stencilInitialLayout();
    fn test_field_stencilFinalLayout() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAttachmentDescriptionStencilLayout>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stencilFinalLayout) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentDescriptionStencilLayout),
                "::",
                stringify!(stencilFinalLayout)
            )
        );
    }
    test_field_stencilFinalLayout();
}
impl Default for VkAttachmentDescriptionStencilLayout {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceHostQueryResetFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub hostQueryReset: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceHostQueryResetFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceHostQueryResetFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceHostQueryResetFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceHostQueryResetFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceHostQueryResetFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceHostQueryResetFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceHostQueryResetFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceHostQueryResetFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceHostQueryResetFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_hostQueryReset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceHostQueryResetFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostQueryReset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceHostQueryResetFeatures),
                "::",
                stringify!(hostQueryReset)
            )
        );
    }
    test_field_hostQueryReset();
}
impl Default for VkPhysicalDeviceHostQueryResetFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceTimelineSemaphoreFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub timelineSemaphore: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceTimelineSemaphoreFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceTimelineSemaphoreFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceTimelineSemaphoreFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceTimelineSemaphoreFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceTimelineSemaphoreFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceTimelineSemaphoreFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTimelineSemaphoreFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceTimelineSemaphoreFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTimelineSemaphoreFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_timelineSemaphore() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceTimelineSemaphoreFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timelineSemaphore) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTimelineSemaphoreFeatures),
                "::",
                stringify!(timelineSemaphore)
            )
        );
    }
    test_field_timelineSemaphore();
}
impl Default for VkPhysicalDeviceTimelineSemaphoreFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceTimelineSemaphoreProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxTimelineSemaphoreValueDifference: u64,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceTimelineSemaphoreProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceTimelineSemaphoreProperties>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceTimelineSemaphoreProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceTimelineSemaphoreProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceTimelineSemaphoreProperties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceTimelineSemaphoreProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTimelineSemaphoreProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceTimelineSemaphoreProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTimelineSemaphoreProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxTimelineSemaphoreValueDifference() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceTimelineSemaphoreProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTimelineSemaphoreValueDifference) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTimelineSemaphoreProperties),
                "::",
                stringify!(maxTimelineSemaphoreValueDifference)
            )
        );
    }
    test_field_maxTimelineSemaphoreValueDifference();
}
impl Default for VkPhysicalDeviceTimelineSemaphoreProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSemaphoreTypeCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub semaphoreType: VkSemaphoreType,
    pub initialValue: u64,
}
#[test]
fn bindgen_test_layout_VkSemaphoreTypeCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSemaphoreTypeCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkSemaphoreTypeCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSemaphoreTypeCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSemaphoreTypeCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreTypeCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreTypeCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreTypeCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreTypeCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_semaphoreType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreTypeCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).semaphoreType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreTypeCreateInfo),
                "::",
                stringify!(semaphoreType)
            )
        );
    }
    test_field_semaphoreType();
    fn test_field_initialValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreTypeCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).initialValue) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreTypeCreateInfo),
                "::",
                stringify!(initialValue)
            )
        );
    }
    test_field_initialValue();
}
impl Default for VkSemaphoreTypeCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkTimelineSemaphoreSubmitInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreValueCount: u32,
    pub pWaitSemaphoreValues: *const u64,
    pub signalSemaphoreValueCount: u32,
    pub pSignalSemaphoreValues: *const u64,
}
#[test]
fn bindgen_test_layout_VkTimelineSemaphoreSubmitInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkTimelineSemaphoreSubmitInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VkTimelineSemaphoreSubmitInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkTimelineSemaphoreSubmitInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkTimelineSemaphoreSubmitInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTimelineSemaphoreSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTimelineSemaphoreSubmitInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTimelineSemaphoreSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTimelineSemaphoreSubmitInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_waitSemaphoreValueCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTimelineSemaphoreSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).waitSemaphoreValueCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTimelineSemaphoreSubmitInfo),
                "::",
                stringify!(waitSemaphoreValueCount)
            )
        );
    }
    test_field_waitSemaphoreValueCount();
    fn test_field_pWaitSemaphoreValues() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTimelineSemaphoreSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pWaitSemaphoreValues) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTimelineSemaphoreSubmitInfo),
                "::",
                stringify!(pWaitSemaphoreValues)
            )
        );
    }
    test_field_pWaitSemaphoreValues();
    fn test_field_signalSemaphoreValueCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTimelineSemaphoreSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signalSemaphoreValueCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTimelineSemaphoreSubmitInfo),
                "::",
                stringify!(signalSemaphoreValueCount)
            )
        );
    }
    test_field_signalSemaphoreValueCount();
    fn test_field_pSignalSemaphoreValues() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTimelineSemaphoreSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSignalSemaphoreValues) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTimelineSemaphoreSubmitInfo),
                "::",
                stringify!(pSignalSemaphoreValues)
            )
        );
    }
    test_field_pSignalSemaphoreValues();
}
impl Default for VkTimelineSemaphoreSubmitInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSemaphoreWaitInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSemaphoreWaitFlags,
    pub semaphoreCount: u32,
    pub pSemaphores: *const VkSemaphore,
    pub pValues: *const u64,
}
#[test]
fn bindgen_test_layout_VkSemaphoreWaitInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSemaphoreWaitInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkSemaphoreWaitInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSemaphoreWaitInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSemaphoreWaitInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreWaitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreWaitInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreWaitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreWaitInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreWaitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreWaitInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_semaphoreCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreWaitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).semaphoreCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreWaitInfo),
                "::",
                stringify!(semaphoreCount)
            )
        );
    }
    test_field_semaphoreCount();
    fn test_field_pSemaphores() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreWaitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSemaphores) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreWaitInfo),
                "::",
                stringify!(pSemaphores)
            )
        );
    }
    test_field_pSemaphores();
    fn test_field_pValues() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreWaitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pValues) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreWaitInfo),
                "::",
                stringify!(pValues)
            )
        );
    }
    test_field_pValues();
}
impl Default for VkSemaphoreWaitInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSemaphoreSignalInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub semaphore: VkSemaphore,
    pub value: u64,
}
#[test]
fn bindgen_test_layout_VkSemaphoreSignalInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSemaphoreSignalInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkSemaphoreSignalInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSemaphoreSignalInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSemaphoreSignalInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreSignalInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreSignalInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreSignalInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreSignalInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_semaphore() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreSignalInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).semaphore) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreSignalInfo),
                "::",
                stringify!(semaphore)
            )
        );
    }
    test_field_semaphore();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreSignalInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreSignalInfo),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
impl Default for VkSemaphoreSignalInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceBufferDeviceAddressFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub bufferDeviceAddress: VkBool32,
    pub bufferDeviceAddressCaptureReplay: VkBool32,
    pub bufferDeviceAddressMultiDevice: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceBufferDeviceAddressFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceBufferDeviceAddressFeatures>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceBufferDeviceAddressFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceBufferDeviceAddressFeatures>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBufferDeviceAddressFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceBufferDeviceAddressFeatures>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBufferDeviceAddressFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_bufferDeviceAddress() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceBufferDeviceAddressFeatures>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferDeviceAddress) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBufferDeviceAddressFeatures),
                "::",
                stringify!(bufferDeviceAddress)
            )
        );
    }
    test_field_bufferDeviceAddress();
    fn test_field_bufferDeviceAddressCaptureReplay() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceBufferDeviceAddressFeatures>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferDeviceAddressCaptureReplay) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBufferDeviceAddressFeatures),
                "::",
                stringify!(bufferDeviceAddressCaptureReplay)
            )
        );
    }
    test_field_bufferDeviceAddressCaptureReplay();
    fn test_field_bufferDeviceAddressMultiDevice() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceBufferDeviceAddressFeatures>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferDeviceAddressMultiDevice) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBufferDeviceAddressFeatures),
                "::",
                stringify!(bufferDeviceAddressMultiDevice)
            )
        );
    }
    test_field_bufferDeviceAddressMultiDevice();
}
impl Default for VkPhysicalDeviceBufferDeviceAddressFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferDeviceAddressInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub buffer: VkBuffer,
}
#[test]
fn bindgen_test_layout_VkBufferDeviceAddressInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferDeviceAddressInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkBufferDeviceAddressInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferDeviceAddressInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferDeviceAddressInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferDeviceAddressInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferDeviceAddressInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferDeviceAddressInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferDeviceAddressInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferDeviceAddressInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferDeviceAddressInfo),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
}
impl Default for VkBufferDeviceAddressInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferOpaqueCaptureAddressCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub opaqueCaptureAddress: u64,
}
#[test]
fn bindgen_test_layout_VkBufferOpaqueCaptureAddressCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferOpaqueCaptureAddressCreateInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkBufferOpaqueCaptureAddressCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferOpaqueCaptureAddressCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkBufferOpaqueCaptureAddressCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBufferOpaqueCaptureAddressCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferOpaqueCaptureAddressCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBufferOpaqueCaptureAddressCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferOpaqueCaptureAddressCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_opaqueCaptureAddress() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBufferOpaqueCaptureAddressCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opaqueCaptureAddress) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferOpaqueCaptureAddressCreateInfo),
                "::",
                stringify!(opaqueCaptureAddress)
            )
        );
    }
    test_field_opaqueCaptureAddress();
}
impl Default for VkBufferOpaqueCaptureAddressCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryOpaqueCaptureAddressAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub opaqueCaptureAddress: u64,
}
#[test]
fn bindgen_test_layout_VkMemoryOpaqueCaptureAddressAllocateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryOpaqueCaptureAddressAllocateInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkMemoryOpaqueCaptureAddressAllocateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryOpaqueCaptureAddressAllocateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkMemoryOpaqueCaptureAddressAllocateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkMemoryOpaqueCaptureAddressAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryOpaqueCaptureAddressAllocateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkMemoryOpaqueCaptureAddressAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryOpaqueCaptureAddressAllocateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_opaqueCaptureAddress() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkMemoryOpaqueCaptureAddressAllocateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opaqueCaptureAddress) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryOpaqueCaptureAddressAllocateInfo),
                "::",
                stringify!(opaqueCaptureAddress)
            )
        );
    }
    test_field_opaqueCaptureAddress();
}
impl Default for VkMemoryOpaqueCaptureAddressAllocateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceMemoryOpaqueCaptureAddressInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub memory: VkDeviceMemory,
}
#[test]
fn bindgen_test_layout_VkDeviceMemoryOpaqueCaptureAddressInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceMemoryOpaqueCaptureAddressInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDeviceMemoryOpaqueCaptureAddressInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceMemoryOpaqueCaptureAddressInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceMemoryOpaqueCaptureAddressInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceMemoryOpaqueCaptureAddressInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceMemoryOpaqueCaptureAddressInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceMemoryOpaqueCaptureAddressInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceMemoryOpaqueCaptureAddressInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_memory() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceMemoryOpaqueCaptureAddressInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceMemoryOpaqueCaptureAddressInfo),
                "::",
                stringify!(memory)
            )
        );
    }
    test_field_memory();
}
impl Default for VkDeviceMemoryOpaqueCaptureAddressInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdDrawIndirectCount = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCmdDrawIndexedIndirectCount = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCreateRenderPass2 = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkRenderPassCreateInfo2,
        pAllocator: *const VkAllocationCallbacks,
        pRenderPass: *mut VkRenderPass,
    ) -> VkResult,
>;
pub type PFN_vkCmdBeginRenderPass2 = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pRenderPassBegin: *const VkRenderPassBeginInfo,
        pSubpassBeginInfo: *const VkSubpassBeginInfo,
    ),
>;
pub type PFN_vkCmdNextSubpass2 = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pSubpassBeginInfo: *const VkSubpassBeginInfo,
        pSubpassEndInfo: *const VkSubpassEndInfo,
    ),
>;
pub type PFN_vkCmdEndRenderPass2 = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pSubpassEndInfo: *const VkSubpassEndInfo),
>;
pub type PFN_vkResetQueryPool = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
    ),
>;
pub type PFN_vkGetSemaphoreCounterValue = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, semaphore: VkSemaphore, pValue: *mut u64) -> VkResult,
>;
pub type PFN_vkWaitSemaphores = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pWaitInfo: *const VkSemaphoreWaitInfo,
        timeout: u64,
    ) -> VkResult,
>;
pub type PFN_vkSignalSemaphore = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, pSignalInfo: *const VkSemaphoreSignalInfo) -> VkResult,
>;
pub type PFN_vkGetBufferDeviceAddress = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkBufferDeviceAddressInfo,
    ) -> VkDeviceAddress,
>;
pub type PFN_vkGetBufferOpaqueCaptureAddress = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> u64,
>;
pub type PFN_vkGetDeviceMemoryOpaqueCaptureAddress = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo,
    ) -> u64,
>;
extern "C" {
    pub fn vkCmdDrawIndirectCount(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawIndexedIndirectCount(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCreateRenderPass2(
        device: VkDevice,
        pCreateInfo: *const VkRenderPassCreateInfo2,
        pAllocator: *const VkAllocationCallbacks,
        pRenderPass: *mut VkRenderPass,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdBeginRenderPass2(
        commandBuffer: VkCommandBuffer,
        pRenderPassBegin: *const VkRenderPassBeginInfo,
        pSubpassBeginInfo: *const VkSubpassBeginInfo,
    );
}
extern "C" {
    pub fn vkCmdNextSubpass2(
        commandBuffer: VkCommandBuffer,
        pSubpassBeginInfo: *const VkSubpassBeginInfo,
        pSubpassEndInfo: *const VkSubpassEndInfo,
    );
}
extern "C" {
    pub fn vkCmdEndRenderPass2(
        commandBuffer: VkCommandBuffer,
        pSubpassEndInfo: *const VkSubpassEndInfo,
    );
}
extern "C" {
    pub fn vkResetQueryPool(
        device: VkDevice,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
    );
}
extern "C" {
    pub fn vkGetSemaphoreCounterValue(
        device: VkDevice,
        semaphore: VkSemaphore,
        pValue: *mut u64,
    ) -> VkResult;
}
extern "C" {
    pub fn vkWaitSemaphores(
        device: VkDevice,
        pWaitInfo: *const VkSemaphoreWaitInfo,
        timeout: u64,
    ) -> VkResult;
}
extern "C" {
    pub fn vkSignalSemaphore(
        device: VkDevice,
        pSignalInfo: *const VkSemaphoreSignalInfo,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetBufferDeviceAddress(
        device: VkDevice,
        pInfo: *const VkBufferDeviceAddressInfo,
    ) -> VkDeviceAddress;
}
extern "C" {
    pub fn vkGetBufferOpaqueCaptureAddress(
        device: VkDevice,
        pInfo: *const VkBufferDeviceAddressInfo,
    ) -> u64;
}
extern "C" {
    pub fn vkGetDeviceMemoryOpaqueCaptureAddress(
        device: VkDevice,
        pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo,
    ) -> u64;
}
pub type VkFlags64 = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPrivateDataSlot_T {
    _unused: [u8; 0],
}
pub type VkPrivateDataSlot = *mut VkPrivateDataSlot_T;
pub const VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT: VkPipelineCreationFeedbackFlagBits = 1;
pub const VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT:
    VkPipelineCreationFeedbackFlagBits = 2;
pub const VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT:
    VkPipelineCreationFeedbackFlagBits = 4;
pub const VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT: VkPipelineCreationFeedbackFlagBits = 1;
pub const VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT:
    VkPipelineCreationFeedbackFlagBits = 2;
pub const VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT:
    VkPipelineCreationFeedbackFlagBits = 4;
pub const VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM: VkPipelineCreationFeedbackFlagBits =
    2147483647;
pub type VkPipelineCreationFeedbackFlagBits = ::std::os::raw::c_int;
pub type VkPipelineCreationFeedbackFlags = VkFlags;
pub const VK_TOOL_PURPOSE_VALIDATION_BIT: VkToolPurposeFlagBits = 1;
pub const VK_TOOL_PURPOSE_PROFILING_BIT: VkToolPurposeFlagBits = 2;
pub const VK_TOOL_PURPOSE_TRACING_BIT: VkToolPurposeFlagBits = 4;
pub const VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT: VkToolPurposeFlagBits = 8;
pub const VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT: VkToolPurposeFlagBits = 16;
pub const VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT: VkToolPurposeFlagBits = 32;
pub const VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT: VkToolPurposeFlagBits = 64;
pub const VK_TOOL_PURPOSE_VALIDATION_BIT_EXT: VkToolPurposeFlagBits = 1;
pub const VK_TOOL_PURPOSE_PROFILING_BIT_EXT: VkToolPurposeFlagBits = 2;
pub const VK_TOOL_PURPOSE_TRACING_BIT_EXT: VkToolPurposeFlagBits = 4;
pub const VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT: VkToolPurposeFlagBits = 8;
pub const VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT: VkToolPurposeFlagBits = 16;
pub const VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM: VkToolPurposeFlagBits = 2147483647;
pub type VkToolPurposeFlagBits = ::std::os::raw::c_int;
pub type VkToolPurposeFlags = VkFlags;
pub type VkPrivateDataSlotCreateFlags = VkFlags;
pub type VkPipelineStageFlags2 = VkFlags64;
pub type VkPipelineStageFlagBits2 = VkFlags64;
pub const VK_PIPELINE_STAGE_2_NONE: VkPipelineStageFlagBits2 = 0;
pub const VK_PIPELINE_STAGE_2_NONE_KHR: VkPipelineStageFlagBits2 = 0;
pub const VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT: VkPipelineStageFlagBits2 = 1;
pub const VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR: VkPipelineStageFlagBits2 = 1;
pub const VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT: VkPipelineStageFlagBits2 = 2;
pub const VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR: VkPipelineStageFlagBits2 = 2;
pub const VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT: VkPipelineStageFlagBits2 = 4;
pub const VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR: VkPipelineStageFlagBits2 = 4;
pub const VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT: VkPipelineStageFlagBits2 = 8;
pub const VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR: VkPipelineStageFlagBits2 = 8;
pub const VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT: VkPipelineStageFlagBits2 = 16;
pub const VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR: VkPipelineStageFlagBits2 = 16;
pub const VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT: VkPipelineStageFlagBits2 = 32;
pub const VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR: VkPipelineStageFlagBits2 = 32;
pub const VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT: VkPipelineStageFlagBits2 = 64;
pub const VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR: VkPipelineStageFlagBits2 = 64;
pub const VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT: VkPipelineStageFlagBits2 = 128;
pub const VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR: VkPipelineStageFlagBits2 = 128;
pub const VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT: VkPipelineStageFlagBits2 = 256;
pub const VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR: VkPipelineStageFlagBits2 = 256;
pub const VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT: VkPipelineStageFlagBits2 = 512;
pub const VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR: VkPipelineStageFlagBits2 = 512;
pub const VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT: VkPipelineStageFlagBits2 = 1024;
pub const VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR: VkPipelineStageFlagBits2 = 1024;
pub const VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT: VkPipelineStageFlagBits2 = 2048;
pub const VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR: VkPipelineStageFlagBits2 = 2048;
pub const VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT: VkPipelineStageFlagBits2 = 4096;
pub const VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR: VkPipelineStageFlagBits2 = 4096;
pub const VK_PIPELINE_STAGE_2_TRANSFER_BIT: VkPipelineStageFlagBits2 = 4096;
pub const VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR: VkPipelineStageFlagBits2 = 4096;
pub const VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT: VkPipelineStageFlagBits2 = 8192;
pub const VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR: VkPipelineStageFlagBits2 = 8192;
pub const VK_PIPELINE_STAGE_2_HOST_BIT: VkPipelineStageFlagBits2 = 16384;
pub const VK_PIPELINE_STAGE_2_HOST_BIT_KHR: VkPipelineStageFlagBits2 = 16384;
pub const VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT: VkPipelineStageFlagBits2 = 32768;
pub const VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR: VkPipelineStageFlagBits2 = 32768;
pub const VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT: VkPipelineStageFlagBits2 = 65536;
pub const VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR: VkPipelineStageFlagBits2 = 65536;
pub const VK_PIPELINE_STAGE_2_COPY_BIT: VkPipelineStageFlagBits2 = 4294967296;
pub const VK_PIPELINE_STAGE_2_COPY_BIT_KHR: VkPipelineStageFlagBits2 = 4294967296;
pub const VK_PIPELINE_STAGE_2_RESOLVE_BIT: VkPipelineStageFlagBits2 = 8589934592;
pub const VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR: VkPipelineStageFlagBits2 = 8589934592;
pub const VK_PIPELINE_STAGE_2_BLIT_BIT: VkPipelineStageFlagBits2 = 17179869184;
pub const VK_PIPELINE_STAGE_2_BLIT_BIT_KHR: VkPipelineStageFlagBits2 = 17179869184;
pub const VK_PIPELINE_STAGE_2_CLEAR_BIT: VkPipelineStageFlagBits2 = 34359738368;
pub const VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR: VkPipelineStageFlagBits2 = 34359738368;
pub const VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT: VkPipelineStageFlagBits2 = 68719476736;
pub const VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR: VkPipelineStageFlagBits2 = 68719476736;
pub const VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT: VkPipelineStageFlagBits2 = 137438953472;
pub const VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR: VkPipelineStageFlagBits2 =
    137438953472;
pub const VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT: VkPipelineStageFlagBits2 =
    274877906944;
pub const VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR: VkPipelineStageFlagBits2 =
    274877906944;
pub const VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT: VkPipelineStageFlagBits2 = 16777216;
pub const VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT: VkPipelineStageFlagBits2 = 262144;
pub const VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV: VkPipelineStageFlagBits2 = 131072;
pub const VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: VkPipelineStageFlagBits2 =
    4194304;
pub const VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV: VkPipelineStageFlagBits2 = 4194304;
pub const VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR: VkPipelineStageFlagBits2 =
    33554432;
pub const VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR: VkPipelineStageFlagBits2 = 2097152;
pub const VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV: VkPipelineStageFlagBits2 = 2097152;
pub const VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV: VkPipelineStageFlagBits2 =
    33554432;
pub const VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT: VkPipelineStageFlagBits2 = 8388608;
pub const VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV: VkPipelineStageFlagBits2 = 524288;
pub const VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV: VkPipelineStageFlagBits2 = 1048576;
pub const VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT: VkPipelineStageFlagBits2 = 524288;
pub const VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT: VkPipelineStageFlagBits2 = 1048576;
pub const VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI: VkPipelineStageFlagBits2 = 549755813888;
pub const VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI: VkPipelineStageFlagBits2 = 1099511627776;
pub const VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR: VkPipelineStageFlagBits2 =
    268435456;
pub const VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT: VkPipelineStageFlagBits2 = 1073741824;
pub const VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV: VkPipelineStageFlagBits2 = 536870912;
pub type VkAccessFlags2 = VkFlags64;
pub type VkAccessFlagBits2 = VkFlags64;
pub const VK_ACCESS_2_NONE: VkAccessFlagBits2 = 0;
pub const VK_ACCESS_2_NONE_KHR: VkAccessFlagBits2 = 0;
pub const VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT: VkAccessFlagBits2 = 1;
pub const VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR: VkAccessFlagBits2 = 1;
pub const VK_ACCESS_2_INDEX_READ_BIT: VkAccessFlagBits2 = 2;
pub const VK_ACCESS_2_INDEX_READ_BIT_KHR: VkAccessFlagBits2 = 2;
pub const VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT: VkAccessFlagBits2 = 4;
pub const VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR: VkAccessFlagBits2 = 4;
pub const VK_ACCESS_2_UNIFORM_READ_BIT: VkAccessFlagBits2 = 8;
pub const VK_ACCESS_2_UNIFORM_READ_BIT_KHR: VkAccessFlagBits2 = 8;
pub const VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT: VkAccessFlagBits2 = 16;
pub const VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR: VkAccessFlagBits2 = 16;
pub const VK_ACCESS_2_SHADER_READ_BIT: VkAccessFlagBits2 = 32;
pub const VK_ACCESS_2_SHADER_READ_BIT_KHR: VkAccessFlagBits2 = 32;
pub const VK_ACCESS_2_SHADER_WRITE_BIT: VkAccessFlagBits2 = 64;
pub const VK_ACCESS_2_SHADER_WRITE_BIT_KHR: VkAccessFlagBits2 = 64;
pub const VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT: VkAccessFlagBits2 = 128;
pub const VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR: VkAccessFlagBits2 = 128;
pub const VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT: VkAccessFlagBits2 = 256;
pub const VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR: VkAccessFlagBits2 = 256;
pub const VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT: VkAccessFlagBits2 = 512;
pub const VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR: VkAccessFlagBits2 = 512;
pub const VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT: VkAccessFlagBits2 = 1024;
pub const VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR: VkAccessFlagBits2 = 1024;
pub const VK_ACCESS_2_TRANSFER_READ_BIT: VkAccessFlagBits2 = 2048;
pub const VK_ACCESS_2_TRANSFER_READ_BIT_KHR: VkAccessFlagBits2 = 2048;
pub const VK_ACCESS_2_TRANSFER_WRITE_BIT: VkAccessFlagBits2 = 4096;
pub const VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR: VkAccessFlagBits2 = 4096;
pub const VK_ACCESS_2_HOST_READ_BIT: VkAccessFlagBits2 = 8192;
pub const VK_ACCESS_2_HOST_READ_BIT_KHR: VkAccessFlagBits2 = 8192;
pub const VK_ACCESS_2_HOST_WRITE_BIT: VkAccessFlagBits2 = 16384;
pub const VK_ACCESS_2_HOST_WRITE_BIT_KHR: VkAccessFlagBits2 = 16384;
pub const VK_ACCESS_2_MEMORY_READ_BIT: VkAccessFlagBits2 = 32768;
pub const VK_ACCESS_2_MEMORY_READ_BIT_KHR: VkAccessFlagBits2 = 32768;
pub const VK_ACCESS_2_MEMORY_WRITE_BIT: VkAccessFlagBits2 = 65536;
pub const VK_ACCESS_2_MEMORY_WRITE_BIT_KHR: VkAccessFlagBits2 = 65536;
pub const VK_ACCESS_2_SHADER_SAMPLED_READ_BIT: VkAccessFlagBits2 = 4294967296;
pub const VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR: VkAccessFlagBits2 = 4294967296;
pub const VK_ACCESS_2_SHADER_STORAGE_READ_BIT: VkAccessFlagBits2 = 8589934592;
pub const VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR: VkAccessFlagBits2 = 8589934592;
pub const VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT: VkAccessFlagBits2 = 17179869184;
pub const VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR: VkAccessFlagBits2 = 17179869184;
pub const VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT: VkAccessFlagBits2 = 33554432;
pub const VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT: VkAccessFlagBits2 = 67108864;
pub const VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT: VkAccessFlagBits2 = 134217728;
pub const VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT: VkAccessFlagBits2 = 1048576;
pub const VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV: VkAccessFlagBits2 = 131072;
pub const VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV: VkAccessFlagBits2 = 262144;
pub const VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR: VkAccessFlagBits2 = 8388608;
pub const VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV: VkAccessFlagBits2 = 8388608;
pub const VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR: VkAccessFlagBits2 = 2097152;
pub const VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR: VkAccessFlagBits2 = 4194304;
pub const VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV: VkAccessFlagBits2 = 2097152;
pub const VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV: VkAccessFlagBits2 = 4194304;
pub const VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT: VkAccessFlagBits2 = 16777216;
pub const VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT: VkAccessFlagBits2 = 524288;
pub const VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT: VkAccessFlagBits2 = 2199023255552;
pub const VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI: VkAccessFlagBits2 = 549755813888;
pub const VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR: VkAccessFlagBits2 = 1099511627776;
pub const VK_ACCESS_2_MICROMAP_READ_BIT_EXT: VkAccessFlagBits2 = 17592186044416;
pub const VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT: VkAccessFlagBits2 = 35184372088832;
pub const VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV: VkAccessFlagBits2 = 4398046511104;
pub const VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV: VkAccessFlagBits2 = 8796093022208;
pub const VK_SUBMIT_PROTECTED_BIT: VkSubmitFlagBits = 1;
pub const VK_SUBMIT_PROTECTED_BIT_KHR: VkSubmitFlagBits = 1;
pub const VK_SUBMIT_FLAG_BITS_MAX_ENUM: VkSubmitFlagBits = 2147483647;
pub type VkSubmitFlagBits = ::std::os::raw::c_int;
pub type VkSubmitFlags = VkFlags;
pub const VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT: VkRenderingFlagBits = 1;
pub const VK_RENDERING_SUSPENDING_BIT: VkRenderingFlagBits = 2;
pub const VK_RENDERING_RESUMING_BIT: VkRenderingFlagBits = 4;
pub const VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT: VkRenderingFlagBits = 8;
pub const VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR: VkRenderingFlagBits = 1;
pub const VK_RENDERING_SUSPENDING_BIT_KHR: VkRenderingFlagBits = 2;
pub const VK_RENDERING_RESUMING_BIT_KHR: VkRenderingFlagBits = 4;
pub const VK_RENDERING_FLAG_BITS_MAX_ENUM: VkRenderingFlagBits = 2147483647;
pub type VkRenderingFlagBits = ::std::os::raw::c_int;
pub type VkRenderingFlags = VkFlags;
pub type VkFormatFeatureFlags2 = VkFlags64;
pub type VkFormatFeatureFlagBits2 = VkFlags64;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT: VkFormatFeatureFlagBits2 = 1;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR: VkFormatFeatureFlagBits2 = 1;
pub const VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT: VkFormatFeatureFlagBits2 = 2;
pub const VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR: VkFormatFeatureFlagBits2 = 2;
pub const VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT: VkFormatFeatureFlagBits2 = 4;
pub const VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR: VkFormatFeatureFlagBits2 = 4;
pub const VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT: VkFormatFeatureFlagBits2 = 8;
pub const VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR: VkFormatFeatureFlagBits2 = 8;
pub const VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT: VkFormatFeatureFlagBits2 = 16;
pub const VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR: VkFormatFeatureFlagBits2 = 16;
pub const VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT: VkFormatFeatureFlagBits2 = 32;
pub const VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR: VkFormatFeatureFlagBits2 = 32;
pub const VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT: VkFormatFeatureFlagBits2 = 64;
pub const VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR: VkFormatFeatureFlagBits2 = 64;
pub const VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT: VkFormatFeatureFlagBits2 = 128;
pub const VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR: VkFormatFeatureFlagBits2 = 128;
pub const VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT: VkFormatFeatureFlagBits2 = 256;
pub const VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR: VkFormatFeatureFlagBits2 = 256;
pub const VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT: VkFormatFeatureFlagBits2 = 512;
pub const VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR: VkFormatFeatureFlagBits2 = 512;
pub const VK_FORMAT_FEATURE_2_BLIT_SRC_BIT: VkFormatFeatureFlagBits2 = 1024;
pub const VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR: VkFormatFeatureFlagBits2 = 1024;
pub const VK_FORMAT_FEATURE_2_BLIT_DST_BIT: VkFormatFeatureFlagBits2 = 2048;
pub const VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR: VkFormatFeatureFlagBits2 = 2048;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT: VkFormatFeatureFlagBits2 = 4096;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR: VkFormatFeatureFlagBits2 = 4096;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT: VkFormatFeatureFlagBits2 = 8192;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT: VkFormatFeatureFlagBits2 = 8192;
pub const VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT: VkFormatFeatureFlagBits2 = 16384;
pub const VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR: VkFormatFeatureFlagBits2 = 16384;
pub const VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT: VkFormatFeatureFlagBits2 = 32768;
pub const VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR: VkFormatFeatureFlagBits2 = 32768;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT: VkFormatFeatureFlagBits2 = 65536;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR: VkFormatFeatureFlagBits2 = 65536;
pub const VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT: VkFormatFeatureFlagBits2 = 131072;
pub const VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR: VkFormatFeatureFlagBits2 = 131072;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT:
    VkFormatFeatureFlagBits2 = 262144;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR:
    VkFormatFeatureFlagBits2 = 262144;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT:
    VkFormatFeatureFlagBits2 = 524288;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR : VkFormatFeatureFlagBits2 = 524288 ;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT:
    VkFormatFeatureFlagBits2 = 1048576;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR : VkFormatFeatureFlagBits2 = 1048576 ;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT : VkFormatFeatureFlagBits2 = 2097152 ;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR : VkFormatFeatureFlagBits2 = 2097152 ;
pub const VK_FORMAT_FEATURE_2_DISJOINT_BIT: VkFormatFeatureFlagBits2 = 4194304;
pub const VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR: VkFormatFeatureFlagBits2 = 4194304;
pub const VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT: VkFormatFeatureFlagBits2 = 8388608;
pub const VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR: VkFormatFeatureFlagBits2 = 8388608;
pub const VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT: VkFormatFeatureFlagBits2 =
    2147483648;
pub const VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR: VkFormatFeatureFlagBits2 =
    2147483648;
pub const VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT: VkFormatFeatureFlagBits2 =
    4294967296;
pub const VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR: VkFormatFeatureFlagBits2 =
    4294967296;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT: VkFormatFeatureFlagBits2 =
    8589934592;
pub const VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR: VkFormatFeatureFlagBits2 =
    8589934592;
pub const VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR:
    VkFormatFeatureFlagBits2 = 536870912;
pub const VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT: VkFormatFeatureFlagBits2 = 16777216;
pub const VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR: VkFormatFeatureFlagBits2 =
    1073741824;
pub const VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV: VkFormatFeatureFlagBits2 =
    274877906944;
pub const VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM: VkFormatFeatureFlagBits2 = 17179869184;
pub const VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM: VkFormatFeatureFlagBits2 = 34359738368;
pub const VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM: VkFormatFeatureFlagBits2 = 68719476736;
pub const VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM: VkFormatFeatureFlagBits2 = 137438953472;
pub const VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV: VkFormatFeatureFlagBits2 = 1099511627776;
pub const VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV: VkFormatFeatureFlagBits2 = 2199023255552;
pub const VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV: VkFormatFeatureFlagBits2 = 4398046511104;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVulkan13Features {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub robustImageAccess: VkBool32,
    pub inlineUniformBlock: VkBool32,
    pub descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32,
    pub pipelineCreationCacheControl: VkBool32,
    pub privateData: VkBool32,
    pub shaderDemoteToHelperInvocation: VkBool32,
    pub shaderTerminateInvocation: VkBool32,
    pub subgroupSizeControl: VkBool32,
    pub computeFullSubgroups: VkBool32,
    pub synchronization2: VkBool32,
    pub textureCompressionASTC_HDR: VkBool32,
    pub shaderZeroInitializeWorkgroupMemory: VkBool32,
    pub dynamicRendering: VkBool32,
    pub shaderIntegerDotProduct: VkBool32,
    pub maintenance4: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVulkan13Features() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVulkan13Features>(),
        80usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceVulkan13Features))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVulkan13Features>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVulkan13Features)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_robustImageAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).robustImageAccess) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(robustImageAccess)
            )
        );
    }
    test_field_robustImageAccess();
    fn test_field_inlineUniformBlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inlineUniformBlock) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(inlineUniformBlock)
            )
        );
    }
    test_field_inlineUniformBlock();
    fn test_field_descriptorBindingInlineUniformBlockUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingInlineUniformBlockUpdateAfterBind)
                    as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(descriptorBindingInlineUniformBlockUpdateAfterBind)
            )
        );
    }
    test_field_descriptorBindingInlineUniformBlockUpdateAfterBind();
    fn test_field_pipelineCreationCacheControl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineCreationCacheControl) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(pipelineCreationCacheControl)
            )
        );
    }
    test_field_pipelineCreationCacheControl();
    fn test_field_privateData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).privateData) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(privateData)
            )
        );
    }
    test_field_privateData();
    fn test_field_shaderDemoteToHelperInvocation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDemoteToHelperInvocation) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(shaderDemoteToHelperInvocation)
            )
        );
    }
    test_field_shaderDemoteToHelperInvocation();
    fn test_field_shaderTerminateInvocation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderTerminateInvocation) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(shaderTerminateInvocation)
            )
        );
    }
    test_field_shaderTerminateInvocation();
    fn test_field_subgroupSizeControl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subgroupSizeControl) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(subgroupSizeControl)
            )
        );
    }
    test_field_subgroupSizeControl();
    fn test_field_computeFullSubgroups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).computeFullSubgroups) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(computeFullSubgroups)
            )
        );
    }
    test_field_computeFullSubgroups();
    fn test_field_synchronization2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).synchronization2) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(synchronization2)
            )
        );
    }
    test_field_synchronization2();
    fn test_field_textureCompressionASTC_HDR() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).textureCompressionASTC_HDR) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(textureCompressionASTC_HDR)
            )
        );
    }
    test_field_textureCompressionASTC_HDR();
    fn test_field_shaderZeroInitializeWorkgroupMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderZeroInitializeWorkgroupMemory) as usize
                    - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(shaderZeroInitializeWorkgroupMemory)
            )
        );
    }
    test_field_shaderZeroInitializeWorkgroupMemory();
    fn test_field_dynamicRendering() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dynamicRendering) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(dynamicRendering)
            )
        );
    }
    test_field_dynamicRendering();
    fn test_field_shaderIntegerDotProduct() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderIntegerDotProduct) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(shaderIntegerDotProduct)
            )
        );
    }
    test_field_shaderIntegerDotProduct();
    fn test_field_maintenance4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maintenance4) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Features),
                "::",
                stringify!(maintenance4)
            )
        );
    }
    test_field_maintenance4();
}
impl Default for VkPhysicalDeviceVulkan13Features {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVulkan13Properties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub minSubgroupSize: u32,
    pub maxSubgroupSize: u32,
    pub maxComputeWorkgroupSubgroups: u32,
    pub requiredSubgroupSizeStages: VkShaderStageFlags,
    pub maxInlineUniformBlockSize: u32,
    pub maxPerStageDescriptorInlineUniformBlocks: u32,
    pub maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32,
    pub maxDescriptorSetInlineUniformBlocks: u32,
    pub maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32,
    pub maxInlineUniformTotalSize: u32,
    pub integerDotProduct8BitUnsignedAccelerated: VkBool32,
    pub integerDotProduct8BitSignedAccelerated: VkBool32,
    pub integerDotProduct8BitMixedSignednessAccelerated: VkBool32,
    pub integerDotProduct4x8BitPackedUnsignedAccelerated: VkBool32,
    pub integerDotProduct4x8BitPackedSignedAccelerated: VkBool32,
    pub integerDotProduct4x8BitPackedMixedSignednessAccelerated: VkBool32,
    pub integerDotProduct16BitUnsignedAccelerated: VkBool32,
    pub integerDotProduct16BitSignedAccelerated: VkBool32,
    pub integerDotProduct16BitMixedSignednessAccelerated: VkBool32,
    pub integerDotProduct32BitUnsignedAccelerated: VkBool32,
    pub integerDotProduct32BitSignedAccelerated: VkBool32,
    pub integerDotProduct32BitMixedSignednessAccelerated: VkBool32,
    pub integerDotProduct64BitUnsignedAccelerated: VkBool32,
    pub integerDotProduct64BitSignedAccelerated: VkBool32,
    pub integerDotProduct64BitMixedSignednessAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating8BitSignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating16BitSignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating32BitSignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating64BitSignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: VkBool32,
    pub storageTexelBufferOffsetAlignmentBytes: VkDeviceSize,
    pub storageTexelBufferOffsetSingleTexelAlignment: VkBool32,
    pub uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize,
    pub uniformTexelBufferOffsetSingleTexelAlignment: VkBool32,
    pub maxBufferSize: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVulkan13Properties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVulkan13Properties>(),
        216usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceVulkan13Properties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVulkan13Properties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVulkan13Properties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_minSubgroupSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minSubgroupSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(minSubgroupSize)
            )
        );
    }
    test_field_minSubgroupSize();
    fn test_field_maxSubgroupSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSubgroupSize) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(maxSubgroupSize)
            )
        );
    }
    test_field_maxSubgroupSize();
    fn test_field_maxComputeWorkgroupSubgroups() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxComputeWorkgroupSubgroups) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(maxComputeWorkgroupSubgroups)
            )
        );
    }
    test_field_maxComputeWorkgroupSubgroups();
    fn test_field_requiredSubgroupSizeStages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).requiredSubgroupSizeStages) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(requiredSubgroupSizeStages)
            )
        );
    }
    test_field_requiredSubgroupSizeStages();
    fn test_field_maxInlineUniformBlockSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxInlineUniformBlockSize) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(maxInlineUniformBlockSize)
            )
        );
    }
    test_field_maxInlineUniformBlockSize();
    fn test_field_maxPerStageDescriptorInlineUniformBlocks() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorInlineUniformBlocks) as usize
                    - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(maxPerStageDescriptorInlineUniformBlocks)
            )
        );
    }
    test_field_maxPerStageDescriptorInlineUniformBlocks();
    fn test_field_maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks)
                    as usize
                    - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks)
            )
        );
    }
    test_field_maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks();
    fn test_field_maxDescriptorSetInlineUniformBlocks() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetInlineUniformBlocks) as usize
                    - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(maxDescriptorSetInlineUniformBlocks)
            )
        );
    }
    test_field_maxDescriptorSetInlineUniformBlocks();
    fn test_field_maxDescriptorSetUpdateAfterBindInlineUniformBlocks() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindInlineUniformBlocks)
                    as usize
                    - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindInlineUniformBlocks)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindInlineUniformBlocks();
    fn test_field_maxInlineUniformTotalSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxInlineUniformTotalSize) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(maxInlineUniformTotalSize)
            )
        );
    }
    test_field_maxInlineUniformTotalSize();
    fn test_field_integerDotProduct8BitUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct8BitUnsignedAccelerated) as usize
                    - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProduct8BitUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct8BitUnsignedAccelerated();
    fn test_field_integerDotProduct8BitSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct8BitSignedAccelerated) as usize
                    - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProduct8BitSignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct8BitSignedAccelerated();
    fn test_field_integerDotProduct8BitMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct8BitMixedSignednessAccelerated)
                    as usize
                    - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProduct8BitMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProduct8BitMixedSignednessAccelerated();
    fn test_field_integerDotProduct4x8BitPackedUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct4x8BitPackedUnsignedAccelerated)
                    as usize
                    - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProduct4x8BitPackedUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct4x8BitPackedUnsignedAccelerated();
    fn test_field_integerDotProduct4x8BitPackedSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct4x8BitPackedSignedAccelerated) as usize
                    - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProduct4x8BitPackedSignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct4x8BitPackedSignedAccelerated();
    fn test_field_integerDotProduct4x8BitPackedMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct4x8BitPackedMixedSignednessAccelerated)
                    as usize
                    - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProduct4x8BitPackedMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProduct4x8BitPackedMixedSignednessAccelerated();
    fn test_field_integerDotProduct16BitUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct16BitUnsignedAccelerated) as usize
                    - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProduct16BitUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct16BitUnsignedAccelerated();
    fn test_field_integerDotProduct16BitSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct16BitSignedAccelerated) as usize
                    - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProduct16BitSignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct16BitSignedAccelerated();
    fn test_field_integerDotProduct16BitMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct16BitMixedSignednessAccelerated)
                    as usize
                    - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProduct16BitMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProduct16BitMixedSignednessAccelerated();
    fn test_field_integerDotProduct32BitUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct32BitUnsignedAccelerated) as usize
                    - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProduct32BitUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct32BitUnsignedAccelerated();
    fn test_field_integerDotProduct32BitSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct32BitSignedAccelerated) as usize
                    - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProduct32BitSignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct32BitSignedAccelerated();
    fn test_field_integerDotProduct32BitMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct32BitMixedSignednessAccelerated)
                    as usize
                    - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProduct32BitMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProduct32BitMixedSignednessAccelerated();
    fn test_field_integerDotProduct64BitUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct64BitUnsignedAccelerated) as usize
                    - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProduct64BitUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct64BitUnsignedAccelerated();
    fn test_field_integerDotProduct64BitSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct64BitSignedAccelerated) as usize
                    - ptr as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProduct64BitSignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct64BitSignedAccelerated();
    fn test_field_integerDotProduct64BitMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct64BitMixedSignednessAccelerated)
                    as usize
                    - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProduct64BitMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProduct64BitMixedSignednessAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating8BitUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating8BitUnsignedAccelerated
                ) as usize
                    - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating8BitUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating8BitUnsignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating8BitSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating8BitSignedAccelerated
                ) as usize
                    - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating8BitSignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating8BitSignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated
                ) as usize
                    - ptr as usize
            },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated
                ) as usize
                    - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated
                ) as usize
                    - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                :: std :: ptr :: addr_of ! ((* ptr) . integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(
                    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated
                )
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating16BitUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating16BitUnsignedAccelerated
                ) as usize
                    - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating16BitUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating16BitUnsignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating16BitSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating16BitSignedAccelerated
                ) as usize
                    - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating16BitSignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating16BitSignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated
                ) as usize
                    - ptr as usize
            },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating32BitUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating32BitUnsignedAccelerated
                ) as usize
                    - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating32BitUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating32BitUnsignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating32BitSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating32BitSignedAccelerated
                ) as usize
                    - ptr as usize
            },
            156usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating32BitSignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating32BitSignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated
                ) as usize
                    - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating64BitUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating64BitUnsignedAccelerated
                ) as usize
                    - ptr as usize
            },
            164usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating64BitUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating64BitUnsignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating64BitSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating64BitSignedAccelerated
                ) as usize
                    - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating64BitSignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating64BitSignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated
                ) as usize
                    - ptr as usize
            },
            172usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated();
    fn test_field_storageTexelBufferOffsetAlignmentBytes() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storageTexelBufferOffsetAlignmentBytes) as usize
                    - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(storageTexelBufferOffsetAlignmentBytes)
            )
        );
    }
    test_field_storageTexelBufferOffsetAlignmentBytes();
    fn test_field_storageTexelBufferOffsetSingleTexelAlignment() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storageTexelBufferOffsetSingleTexelAlignment) as usize
                    - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(storageTexelBufferOffsetSingleTexelAlignment)
            )
        );
    }
    test_field_storageTexelBufferOffsetSingleTexelAlignment();
    fn test_field_uniformTexelBufferOffsetAlignmentBytes() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uniformTexelBufferOffsetAlignmentBytes) as usize
                    - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(uniformTexelBufferOffsetAlignmentBytes)
            )
        );
    }
    test_field_uniformTexelBufferOffsetAlignmentBytes();
    fn test_field_uniformTexelBufferOffsetSingleTexelAlignment() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uniformTexelBufferOffsetSingleTexelAlignment) as usize
                    - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(uniformTexelBufferOffsetSingleTexelAlignment)
            )
        );
    }
    test_field_uniformTexelBufferOffsetSingleTexelAlignment();
    fn test_field_maxBufferSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceVulkan13Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxBufferSize) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVulkan13Properties),
                "::",
                stringify!(maxBufferSize)
            )
        );
    }
    test_field_maxBufferSize();
}
impl Default for VkPhysicalDeviceVulkan13Properties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkPipelineCreationFeedback {
    pub flags: VkPipelineCreationFeedbackFlags,
    pub duration: u64,
}
#[test]
fn bindgen_test_layout_VkPipelineCreationFeedback() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineCreationFeedback>(),
        16usize,
        concat!("Size of: ", stringify!(VkPipelineCreationFeedback))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineCreationFeedback>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPipelineCreationFeedback))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineCreationFeedback>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCreationFeedback),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_duration() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineCreationFeedback>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCreationFeedback),
                "::",
                stringify!(duration)
            )
        );
    }
    test_field_duration();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCreationFeedbackCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pPipelineCreationFeedback: *mut VkPipelineCreationFeedback,
    pub pipelineStageCreationFeedbackCount: u32,
    pub pPipelineStageCreationFeedbacks: *mut VkPipelineCreationFeedback,
}
#[test]
fn bindgen_test_layout_VkPipelineCreationFeedbackCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineCreationFeedbackCreateInfo>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineCreationFeedbackCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineCreationFeedbackCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineCreationFeedbackCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCreationFeedbackCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCreationFeedbackCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCreationFeedbackCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCreationFeedbackCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pPipelineCreationFeedback() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCreationFeedbackCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pPipelineCreationFeedback) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCreationFeedbackCreateInfo),
                "::",
                stringify!(pPipelineCreationFeedback)
            )
        );
    }
    test_field_pPipelineCreationFeedback();
    fn test_field_pipelineStageCreationFeedbackCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCreationFeedbackCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineStageCreationFeedbackCount) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCreationFeedbackCreateInfo),
                "::",
                stringify!(pipelineStageCreationFeedbackCount)
            )
        );
    }
    test_field_pipelineStageCreationFeedbackCount();
    fn test_field_pPipelineStageCreationFeedbacks() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCreationFeedbackCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pPipelineStageCreationFeedbacks) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCreationFeedbackCreateInfo),
                "::",
                stringify!(pPipelineStageCreationFeedbacks)
            )
        );
    }
    test_field_pPipelineStageCreationFeedbacks();
}
impl Default for VkPipelineCreationFeedbackCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderTerminateInvocationFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderTerminateInvocation: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderTerminateInvocationFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderTerminateInvocationFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderTerminateInvocationFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderTerminateInvocationFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderTerminateInvocationFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderTerminateInvocationFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderTerminateInvocationFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderTerminateInvocationFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderTerminateInvocationFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderTerminateInvocation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderTerminateInvocationFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderTerminateInvocation) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderTerminateInvocationFeatures),
                "::",
                stringify!(shaderTerminateInvocation)
            )
        );
    }
    test_field_shaderTerminateInvocation();
}
impl Default for VkPhysicalDeviceShaderTerminateInvocationFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceToolProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub name: [::std::os::raw::c_char; 256usize],
    pub version: [::std::os::raw::c_char; 256usize],
    pub purposes: VkToolPurposeFlags,
    pub description: [::std::os::raw::c_char; 256usize],
    pub layer: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceToolProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceToolProperties>(),
        1048usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceToolProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceToolProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceToolProperties))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceToolProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceToolProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceToolProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceToolProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceToolProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceToolProperties),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceToolProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceToolProperties),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_purposes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceToolProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).purposes) as usize - ptr as usize
            },
            528usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceToolProperties),
                "::",
                stringify!(purposes)
            )
        );
    }
    test_field_purposes();
    fn test_field_description() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceToolProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize
            },
            532usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceToolProperties),
                "::",
                stringify!(description)
            )
        );
    }
    test_field_description();
    fn test_field_layer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceToolProperties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layer) as usize - ptr as usize
            },
            788usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceToolProperties),
                "::",
                stringify!(layer)
            )
        );
    }
    test_field_layer();
}
impl Default for VkPhysicalDeviceToolProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderDemoteToHelperInvocation: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderDemoteToHelperInvocation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDemoteToHelperInvocation) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures),
                "::",
                stringify!(shaderDemoteToHelperInvocation)
            )
        );
    }
    test_field_shaderDemoteToHelperInvocation();
}
impl Default for VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePrivateDataFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub privateData: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePrivateDataFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePrivateDataFeatures>(),
        24usize,
        concat!("Size of: ", stringify!(VkPhysicalDevicePrivateDataFeatures))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePrivateDataFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePrivateDataFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePrivateDataFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePrivateDataFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePrivateDataFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePrivateDataFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_privateData() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePrivateDataFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).privateData) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePrivateDataFeatures),
                "::",
                stringify!(privateData)
            )
        );
    }
    test_field_privateData();
}
impl Default for VkPhysicalDevicePrivateDataFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDevicePrivateDataCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub privateDataSlotRequestCount: u32,
}
#[test]
fn bindgen_test_layout_VkDevicePrivateDataCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDevicePrivateDataCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkDevicePrivateDataCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDevicePrivateDataCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDevicePrivateDataCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDevicePrivateDataCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDevicePrivateDataCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDevicePrivateDataCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDevicePrivateDataCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_privateDataSlotRequestCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDevicePrivateDataCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).privateDataSlotRequestCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDevicePrivateDataCreateInfo),
                "::",
                stringify!(privateDataSlotRequestCount)
            )
        );
    }
    test_field_privateDataSlotRequestCount();
}
impl Default for VkDevicePrivateDataCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPrivateDataSlotCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPrivateDataSlotCreateFlags,
}
#[test]
fn bindgen_test_layout_VkPrivateDataSlotCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPrivateDataSlotCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VkPrivateDataSlotCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPrivateDataSlotCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPrivateDataSlotCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPrivateDataSlotCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPrivateDataSlotCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPrivateDataSlotCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPrivateDataSlotCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPrivateDataSlotCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPrivateDataSlotCreateInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for VkPrivateDataSlotCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePipelineCreationCacheControlFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub pipelineCreationCacheControl: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePipelineCreationCacheControlFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePipelineCreationCacheControlFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePipelineCreationCacheControlFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePipelineCreationCacheControlFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePipelineCreationCacheControlFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePipelineCreationCacheControlFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineCreationCacheControlFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePipelineCreationCacheControlFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineCreationCacheControlFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pipelineCreationCacheControl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePipelineCreationCacheControlFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineCreationCacheControl) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineCreationCacheControlFeatures),
                "::",
                stringify!(pipelineCreationCacheControl)
            )
        );
    }
    test_field_pipelineCreationCacheControl();
}
impl Default for VkPhysicalDevicePipelineCreationCacheControlFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryBarrier2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcStageMask: VkPipelineStageFlags2,
    pub srcAccessMask: VkAccessFlags2,
    pub dstStageMask: VkPipelineStageFlags2,
    pub dstAccessMask: VkAccessFlags2,
}
#[test]
fn bindgen_test_layout_VkMemoryBarrier2() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryBarrier2>(),
        48usize,
        concat!("Size of: ", stringify!(VkMemoryBarrier2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryBarrier2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryBarrier2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryBarrier2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryBarrier2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcStageMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcStageMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryBarrier2),
                "::",
                stringify!(srcStageMask)
            )
        );
    }
    test_field_srcStageMask();
    fn test_field_srcAccessMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcAccessMask) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryBarrier2),
                "::",
                stringify!(srcAccessMask)
            )
        );
    }
    test_field_srcAccessMask();
    fn test_field_dstStageMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstStageMask) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryBarrier2),
                "::",
                stringify!(dstStageMask)
            )
        );
    }
    test_field_dstStageMask();
    fn test_field_dstAccessMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstAccessMask) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryBarrier2),
                "::",
                stringify!(dstAccessMask)
            )
        );
    }
    test_field_dstAccessMask();
}
impl Default for VkMemoryBarrier2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferMemoryBarrier2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcStageMask: VkPipelineStageFlags2,
    pub srcAccessMask: VkAccessFlags2,
    pub dstStageMask: VkPipelineStageFlags2,
    pub dstAccessMask: VkAccessFlags2,
    pub srcQueueFamilyIndex: u32,
    pub dstQueueFamilyIndex: u32,
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBufferMemoryBarrier2() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferMemoryBarrier2>(),
        80usize,
        concat!("Size of: ", stringify!(VkBufferMemoryBarrier2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferMemoryBarrier2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferMemoryBarrier2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcStageMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcStageMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier2),
                "::",
                stringify!(srcStageMask)
            )
        );
    }
    test_field_srcStageMask();
    fn test_field_srcAccessMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcAccessMask) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier2),
                "::",
                stringify!(srcAccessMask)
            )
        );
    }
    test_field_srcAccessMask();
    fn test_field_dstStageMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstStageMask) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier2),
                "::",
                stringify!(dstStageMask)
            )
        );
    }
    test_field_dstStageMask();
    fn test_field_dstAccessMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstAccessMask) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier2),
                "::",
                stringify!(dstAccessMask)
            )
        );
    }
    test_field_dstAccessMask();
    fn test_field_srcQueueFamilyIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcQueueFamilyIndex) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier2),
                "::",
                stringify!(srcQueueFamilyIndex)
            )
        );
    }
    test_field_srcQueueFamilyIndex();
    fn test_field_dstQueueFamilyIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstQueueFamilyIndex) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier2),
                "::",
                stringify!(dstQueueFamilyIndex)
            )
        );
    }
    test_field_dstQueueFamilyIndex();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier2),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier2),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferMemoryBarrier2),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
impl Default for VkBufferMemoryBarrier2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageMemoryBarrier2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcStageMask: VkPipelineStageFlags2,
    pub srcAccessMask: VkAccessFlags2,
    pub dstStageMask: VkPipelineStageFlags2,
    pub dstAccessMask: VkAccessFlags2,
    pub oldLayout: VkImageLayout,
    pub newLayout: VkImageLayout,
    pub srcQueueFamilyIndex: u32,
    pub dstQueueFamilyIndex: u32,
    pub image: VkImage,
    pub subresourceRange: VkImageSubresourceRange,
}
#[test]
fn bindgen_test_layout_VkImageMemoryBarrier2() {
    assert_eq!(
        ::std::mem::size_of::<VkImageMemoryBarrier2>(),
        96usize,
        concat!("Size of: ", stringify!(VkImageMemoryBarrier2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageMemoryBarrier2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageMemoryBarrier2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcStageMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcStageMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier2),
                "::",
                stringify!(srcStageMask)
            )
        );
    }
    test_field_srcStageMask();
    fn test_field_srcAccessMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcAccessMask) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier2),
                "::",
                stringify!(srcAccessMask)
            )
        );
    }
    test_field_srcAccessMask();
    fn test_field_dstStageMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstStageMask) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier2),
                "::",
                stringify!(dstStageMask)
            )
        );
    }
    test_field_dstStageMask();
    fn test_field_dstAccessMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstAccessMask) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier2),
                "::",
                stringify!(dstAccessMask)
            )
        );
    }
    test_field_dstAccessMask();
    fn test_field_oldLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).oldLayout) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier2),
                "::",
                stringify!(oldLayout)
            )
        );
    }
    test_field_oldLayout();
    fn test_field_newLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).newLayout) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier2),
                "::",
                stringify!(newLayout)
            )
        );
    }
    test_field_newLayout();
    fn test_field_srcQueueFamilyIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcQueueFamilyIndex) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier2),
                "::",
                stringify!(srcQueueFamilyIndex)
            )
        );
    }
    test_field_srcQueueFamilyIndex();
    fn test_field_dstQueueFamilyIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstQueueFamilyIndex) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier2),
                "::",
                stringify!(dstQueueFamilyIndex)
            )
        );
    }
    test_field_dstQueueFamilyIndex();
    fn test_field_image() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier2),
                "::",
                stringify!(image)
            )
        );
    }
    test_field_image();
    fn test_field_subresourceRange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageMemoryBarrier2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subresourceRange) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageMemoryBarrier2),
                "::",
                stringify!(subresourceRange)
            )
        );
    }
    test_field_subresourceRange();
}
impl Default for VkImageMemoryBarrier2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDependencyInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub dependencyFlags: VkDependencyFlags,
    pub memoryBarrierCount: u32,
    pub pMemoryBarriers: *const VkMemoryBarrier2,
    pub bufferMemoryBarrierCount: u32,
    pub pBufferMemoryBarriers: *const VkBufferMemoryBarrier2,
    pub imageMemoryBarrierCount: u32,
    pub pImageMemoryBarriers: *const VkImageMemoryBarrier2,
}
#[test]
fn bindgen_test_layout_VkDependencyInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDependencyInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VkDependencyInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDependencyInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDependencyInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDependencyInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDependencyInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDependencyInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDependencyInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_dependencyFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDependencyInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dependencyFlags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDependencyInfo),
                "::",
                stringify!(dependencyFlags)
            )
        );
    }
    test_field_dependencyFlags();
    fn test_field_memoryBarrierCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDependencyInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryBarrierCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDependencyInfo),
                "::",
                stringify!(memoryBarrierCount)
            )
        );
    }
    test_field_memoryBarrierCount();
    fn test_field_pMemoryBarriers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDependencyInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pMemoryBarriers) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDependencyInfo),
                "::",
                stringify!(pMemoryBarriers)
            )
        );
    }
    test_field_pMemoryBarriers();
    fn test_field_bufferMemoryBarrierCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDependencyInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferMemoryBarrierCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDependencyInfo),
                "::",
                stringify!(bufferMemoryBarrierCount)
            )
        );
    }
    test_field_bufferMemoryBarrierCount();
    fn test_field_pBufferMemoryBarriers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDependencyInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pBufferMemoryBarriers) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDependencyInfo),
                "::",
                stringify!(pBufferMemoryBarriers)
            )
        );
    }
    test_field_pBufferMemoryBarriers();
    fn test_field_imageMemoryBarrierCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDependencyInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageMemoryBarrierCount) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDependencyInfo),
                "::",
                stringify!(imageMemoryBarrierCount)
            )
        );
    }
    test_field_imageMemoryBarrierCount();
    fn test_field_pImageMemoryBarriers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDependencyInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pImageMemoryBarriers) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDependencyInfo),
                "::",
                stringify!(pImageMemoryBarriers)
            )
        );
    }
    test_field_pImageMemoryBarriers();
}
impl Default for VkDependencyInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSemaphoreSubmitInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub semaphore: VkSemaphore,
    pub value: u64,
    pub stageMask: VkPipelineStageFlags2,
    pub deviceIndex: u32,
}
#[test]
fn bindgen_test_layout_VkSemaphoreSubmitInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkSemaphoreSubmitInfo>(),
        48usize,
        concat!("Size of: ", stringify!(VkSemaphoreSubmitInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSemaphoreSubmitInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSemaphoreSubmitInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreSubmitInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreSubmitInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_semaphore() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).semaphore) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreSubmitInfo),
                "::",
                stringify!(semaphore)
            )
        );
    }
    test_field_semaphore();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreSubmitInfo),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_stageMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stageMask) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreSubmitInfo),
                "::",
                stringify!(stageMask)
            )
        );
    }
    test_field_stageMask();
    fn test_field_deviceIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceIndex) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreSubmitInfo),
                "::",
                stringify!(deviceIndex)
            )
        );
    }
    test_field_deviceIndex();
}
impl Default for VkSemaphoreSubmitInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBufferSubmitInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub commandBuffer: VkCommandBuffer,
    pub deviceMask: u32,
}
#[test]
fn bindgen_test_layout_VkCommandBufferSubmitInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkCommandBufferSubmitInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VkCommandBufferSubmitInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCommandBufferSubmitInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCommandBufferSubmitInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferSubmitInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferSubmitInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_commandBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).commandBuffer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferSubmitInfo),
                "::",
                stringify!(commandBuffer)
            )
        );
    }
    test_field_commandBuffer();
    fn test_field_deviceMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCommandBufferSubmitInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceMask) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferSubmitInfo),
                "::",
                stringify!(deviceMask)
            )
        );
    }
    test_field_deviceMask();
}
impl Default for VkCommandBufferSubmitInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubmitInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSubmitFlags,
    pub waitSemaphoreInfoCount: u32,
    pub pWaitSemaphoreInfos: *const VkSemaphoreSubmitInfo,
    pub commandBufferInfoCount: u32,
    pub pCommandBufferInfos: *const VkCommandBufferSubmitInfo,
    pub signalSemaphoreInfoCount: u32,
    pub pSignalSemaphoreInfos: *const VkSemaphoreSubmitInfo,
}
#[test]
fn bindgen_test_layout_VkSubmitInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkSubmitInfo2>(),
        64usize,
        concat!("Size of: ", stringify!(VkSubmitInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubmitInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubmitInfo2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo2),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_waitSemaphoreInfoCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).waitSemaphoreInfoCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo2),
                "::",
                stringify!(waitSemaphoreInfoCount)
            )
        );
    }
    test_field_waitSemaphoreInfoCount();
    fn test_field_pWaitSemaphoreInfos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pWaitSemaphoreInfos) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo2),
                "::",
                stringify!(pWaitSemaphoreInfos)
            )
        );
    }
    test_field_pWaitSemaphoreInfos();
    fn test_field_commandBufferInfoCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).commandBufferInfoCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo2),
                "::",
                stringify!(commandBufferInfoCount)
            )
        );
    }
    test_field_commandBufferInfoCount();
    fn test_field_pCommandBufferInfos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCommandBufferInfos) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo2),
                "::",
                stringify!(pCommandBufferInfos)
            )
        );
    }
    test_field_pCommandBufferInfos();
    fn test_field_signalSemaphoreInfoCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signalSemaphoreInfoCount) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo2),
                "::",
                stringify!(signalSemaphoreInfoCount)
            )
        );
    }
    test_field_signalSemaphoreInfoCount();
    fn test_field_pSignalSemaphoreInfos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubmitInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSignalSemaphoreInfos) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubmitInfo2),
                "::",
                stringify!(pSignalSemaphoreInfos)
            )
        );
    }
    test_field_pSignalSemaphoreInfos();
}
impl Default for VkSubmitInfo2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSynchronization2Features {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub synchronization2: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSynchronization2Features() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSynchronization2Features>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSynchronization2Features)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSynchronization2Features>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSynchronization2Features)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSynchronization2Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSynchronization2Features),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSynchronization2Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSynchronization2Features),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_synchronization2() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSynchronization2Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).synchronization2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSynchronization2Features),
                "::",
                stringify!(synchronization2)
            )
        );
    }
    test_field_synchronization2();
}
impl Default for VkPhysicalDeviceSynchronization2Features {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderZeroInitializeWorkgroupMemory: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderZeroInitializeWorkgroupMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderZeroInitializeWorkgroupMemory) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures),
                "::",
                stringify!(shaderZeroInitializeWorkgroupMemory)
            )
        );
    }
    test_field_shaderZeroInitializeWorkgroupMemory();
}
impl Default for VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceImageRobustnessFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub robustImageAccess: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceImageRobustnessFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceImageRobustnessFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceImageRobustnessFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceImageRobustnessFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceImageRobustnessFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImageRobustnessFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageRobustnessFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImageRobustnessFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageRobustnessFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_robustImageAccess() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImageRobustnessFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).robustImageAccess) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageRobustnessFeatures),
                "::",
                stringify!(robustImageAccess)
            )
        );
    }
    test_field_robustImageAccess();
}
impl Default for VkPhysicalDeviceImageRobustnessFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferCopy2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcOffset: VkDeviceSize,
    pub dstOffset: VkDeviceSize,
    pub size: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBufferCopy2() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferCopy2>(),
        40usize,
        concat!("Size of: ", stringify!(VkBufferCopy2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferCopy2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferCopy2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCopy2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCopy2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcOffset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCopy2),
                "::",
                stringify!(srcOffset)
            )
        );
    }
    test_field_srcOffset();
    fn test_field_dstOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstOffset) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCopy2),
                "::",
                stringify!(dstOffset)
            )
        );
    }
    test_field_dstOffset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCopy2),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
impl Default for VkBufferCopy2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCopyBufferInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcBuffer: VkBuffer,
    pub dstBuffer: VkBuffer,
    pub regionCount: u32,
    pub pRegions: *const VkBufferCopy2,
}
#[test]
fn bindgen_test_layout_VkCopyBufferInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkCopyBufferInfo2>(),
        48usize,
        concat!("Size of: ", stringify!(VkCopyBufferInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCopyBufferInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCopyBufferInfo2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyBufferInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyBufferInfo2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyBufferInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyBufferInfo2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyBufferInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcBuffer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyBufferInfo2),
                "::",
                stringify!(srcBuffer)
            )
        );
    }
    test_field_srcBuffer();
    fn test_field_dstBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyBufferInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstBuffer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyBufferInfo2),
                "::",
                stringify!(dstBuffer)
            )
        );
    }
    test_field_dstBuffer();
    fn test_field_regionCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyBufferInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regionCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyBufferInfo2),
                "::",
                stringify!(regionCount)
            )
        );
    }
    test_field_regionCount();
    fn test_field_pRegions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyBufferInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pRegions) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyBufferInfo2),
                "::",
                stringify!(pRegions)
            )
        );
    }
    test_field_pRegions();
}
impl Default for VkCopyBufferInfo2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageCopy2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffset: VkOffset3D,
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffset: VkOffset3D,
    pub extent: VkExtent3D,
}
#[test]
fn bindgen_test_layout_VkImageCopy2() {
    assert_eq!(
        ::std::mem::size_of::<VkImageCopy2>(),
        88usize,
        concat!("Size of: ", stringify!(VkImageCopy2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageCopy2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageCopy2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCopy2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCopy2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcSubresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcSubresource) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCopy2),
                "::",
                stringify!(srcSubresource)
            )
        );
    }
    test_field_srcSubresource();
    fn test_field_srcOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcOffset) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCopy2),
                "::",
                stringify!(srcOffset)
            )
        );
    }
    test_field_srcOffset();
    fn test_field_dstSubresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstSubresource) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCopy2),
                "::",
                stringify!(dstSubresource)
            )
        );
    }
    test_field_dstSubresource();
    fn test_field_dstOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstOffset) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCopy2),
                "::",
                stringify!(dstOffset)
            )
        );
    }
    test_field_dstOffset();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCopy2),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
}
impl Default for VkImageCopy2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCopyImageInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcImage: VkImage,
    pub srcImageLayout: VkImageLayout,
    pub dstImage: VkImage,
    pub dstImageLayout: VkImageLayout,
    pub regionCount: u32,
    pub pRegions: *const VkImageCopy2,
}
#[test]
fn bindgen_test_layout_VkCopyImageInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkCopyImageInfo2>(),
        56usize,
        concat!("Size of: ", stringify!(VkCopyImageInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCopyImageInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCopyImageInfo2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyImageInfo2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyImageInfo2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcImage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcImage) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyImageInfo2),
                "::",
                stringify!(srcImage)
            )
        );
    }
    test_field_srcImage();
    fn test_field_srcImageLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcImageLayout) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyImageInfo2),
                "::",
                stringify!(srcImageLayout)
            )
        );
    }
    test_field_srcImageLayout();
    fn test_field_dstImage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstImage) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyImageInfo2),
                "::",
                stringify!(dstImage)
            )
        );
    }
    test_field_dstImage();
    fn test_field_dstImageLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstImageLayout) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyImageInfo2),
                "::",
                stringify!(dstImageLayout)
            )
        );
    }
    test_field_dstImageLayout();
    fn test_field_regionCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regionCount) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyImageInfo2),
                "::",
                stringify!(regionCount)
            )
        );
    }
    test_field_regionCount();
    fn test_field_pRegions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pRegions) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyImageInfo2),
                "::",
                stringify!(pRegions)
            )
        );
    }
    test_field_pRegions();
}
impl Default for VkCopyImageInfo2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferImageCopy2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub bufferOffset: VkDeviceSize,
    pub bufferRowLength: u32,
    pub bufferImageHeight: u32,
    pub imageSubresource: VkImageSubresourceLayers,
    pub imageOffset: VkOffset3D,
    pub imageExtent: VkExtent3D,
}
#[test]
fn bindgen_test_layout_VkBufferImageCopy2() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferImageCopy2>(),
        72usize,
        concat!("Size of: ", stringify!(VkBufferImageCopy2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferImageCopy2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBufferImageCopy2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferImageCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferImageCopy2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferImageCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferImageCopy2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_bufferOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferImageCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferOffset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferImageCopy2),
                "::",
                stringify!(bufferOffset)
            )
        );
    }
    test_field_bufferOffset();
    fn test_field_bufferRowLength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferImageCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferRowLength) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferImageCopy2),
                "::",
                stringify!(bufferRowLength)
            )
        );
    }
    test_field_bufferRowLength();
    fn test_field_bufferImageHeight() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferImageCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferImageHeight) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferImageCopy2),
                "::",
                stringify!(bufferImageHeight)
            )
        );
    }
    test_field_bufferImageHeight();
    fn test_field_imageSubresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferImageCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageSubresource) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferImageCopy2),
                "::",
                stringify!(imageSubresource)
            )
        );
    }
    test_field_imageSubresource();
    fn test_field_imageOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferImageCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageOffset) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferImageCopy2),
                "::",
                stringify!(imageOffset)
            )
        );
    }
    test_field_imageOffset();
    fn test_field_imageExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBufferImageCopy2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageExtent) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferImageCopy2),
                "::",
                stringify!(imageExtent)
            )
        );
    }
    test_field_imageExtent();
}
impl Default for VkBufferImageCopy2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCopyBufferToImageInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcBuffer: VkBuffer,
    pub dstImage: VkImage,
    pub dstImageLayout: VkImageLayout,
    pub regionCount: u32,
    pub pRegions: *const VkBufferImageCopy2,
}
#[test]
fn bindgen_test_layout_VkCopyBufferToImageInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkCopyBufferToImageInfo2>(),
        48usize,
        concat!("Size of: ", stringify!(VkCopyBufferToImageInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCopyBufferToImageInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCopyBufferToImageInfo2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyBufferToImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyBufferToImageInfo2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyBufferToImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyBufferToImageInfo2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyBufferToImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcBuffer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyBufferToImageInfo2),
                "::",
                stringify!(srcBuffer)
            )
        );
    }
    test_field_srcBuffer();
    fn test_field_dstImage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyBufferToImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstImage) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyBufferToImageInfo2),
                "::",
                stringify!(dstImage)
            )
        );
    }
    test_field_dstImage();
    fn test_field_dstImageLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyBufferToImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstImageLayout) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyBufferToImageInfo2),
                "::",
                stringify!(dstImageLayout)
            )
        );
    }
    test_field_dstImageLayout();
    fn test_field_regionCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyBufferToImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regionCount) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyBufferToImageInfo2),
                "::",
                stringify!(regionCount)
            )
        );
    }
    test_field_regionCount();
    fn test_field_pRegions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyBufferToImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pRegions) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyBufferToImageInfo2),
                "::",
                stringify!(pRegions)
            )
        );
    }
    test_field_pRegions();
}
impl Default for VkCopyBufferToImageInfo2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCopyImageToBufferInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcImage: VkImage,
    pub srcImageLayout: VkImageLayout,
    pub dstBuffer: VkBuffer,
    pub regionCount: u32,
    pub pRegions: *const VkBufferImageCopy2,
}
#[test]
fn bindgen_test_layout_VkCopyImageToBufferInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkCopyImageToBufferInfo2>(),
        56usize,
        concat!("Size of: ", stringify!(VkCopyImageToBufferInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCopyImageToBufferInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCopyImageToBufferInfo2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyImageToBufferInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyImageToBufferInfo2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyImageToBufferInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyImageToBufferInfo2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcImage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyImageToBufferInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcImage) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyImageToBufferInfo2),
                "::",
                stringify!(srcImage)
            )
        );
    }
    test_field_srcImage();
    fn test_field_srcImageLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyImageToBufferInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcImageLayout) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyImageToBufferInfo2),
                "::",
                stringify!(srcImageLayout)
            )
        );
    }
    test_field_srcImageLayout();
    fn test_field_dstBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyImageToBufferInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstBuffer) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyImageToBufferInfo2),
                "::",
                stringify!(dstBuffer)
            )
        );
    }
    test_field_dstBuffer();
    fn test_field_regionCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyImageToBufferInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regionCount) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyImageToBufferInfo2),
                "::",
                stringify!(regionCount)
            )
        );
    }
    test_field_regionCount();
    fn test_field_pRegions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyImageToBufferInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pRegions) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyImageToBufferInfo2),
                "::",
                stringify!(pRegions)
            )
        );
    }
    test_field_pRegions();
}
impl Default for VkCopyImageToBufferInfo2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageBlit2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffsets: [VkOffset3D; 2usize],
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffsets: [VkOffset3D; 2usize],
}
#[test]
fn bindgen_test_layout_VkImageBlit2() {
    assert_eq!(
        ::std::mem::size_of::<VkImageBlit2>(),
        96usize,
        concat!("Size of: ", stringify!(VkImageBlit2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageBlit2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageBlit2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageBlit2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageBlit2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageBlit2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageBlit2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcSubresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageBlit2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcSubresource) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageBlit2),
                "::",
                stringify!(srcSubresource)
            )
        );
    }
    test_field_srcSubresource();
    fn test_field_srcOffsets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageBlit2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcOffsets) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageBlit2),
                "::",
                stringify!(srcOffsets)
            )
        );
    }
    test_field_srcOffsets();
    fn test_field_dstSubresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageBlit2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstSubresource) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageBlit2),
                "::",
                stringify!(dstSubresource)
            )
        );
    }
    test_field_dstSubresource();
    fn test_field_dstOffsets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageBlit2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstOffsets) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageBlit2),
                "::",
                stringify!(dstOffsets)
            )
        );
    }
    test_field_dstOffsets();
}
impl Default for VkImageBlit2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBlitImageInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcImage: VkImage,
    pub srcImageLayout: VkImageLayout,
    pub dstImage: VkImage,
    pub dstImageLayout: VkImageLayout,
    pub regionCount: u32,
    pub pRegions: *const VkImageBlit2,
    pub filter: VkFilter,
}
#[test]
fn bindgen_test_layout_VkBlitImageInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkBlitImageInfo2>(),
        64usize,
        concat!("Size of: ", stringify!(VkBlitImageInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBlitImageInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkBlitImageInfo2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBlitImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBlitImageInfo2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBlitImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBlitImageInfo2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcImage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBlitImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcImage) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBlitImageInfo2),
                "::",
                stringify!(srcImage)
            )
        );
    }
    test_field_srcImage();
    fn test_field_srcImageLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBlitImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcImageLayout) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBlitImageInfo2),
                "::",
                stringify!(srcImageLayout)
            )
        );
    }
    test_field_srcImageLayout();
    fn test_field_dstImage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBlitImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstImage) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBlitImageInfo2),
                "::",
                stringify!(dstImage)
            )
        );
    }
    test_field_dstImage();
    fn test_field_dstImageLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBlitImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstImageLayout) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBlitImageInfo2),
                "::",
                stringify!(dstImageLayout)
            )
        );
    }
    test_field_dstImageLayout();
    fn test_field_regionCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBlitImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regionCount) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBlitImageInfo2),
                "::",
                stringify!(regionCount)
            )
        );
    }
    test_field_regionCount();
    fn test_field_pRegions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBlitImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pRegions) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBlitImageInfo2),
                "::",
                stringify!(pRegions)
            )
        );
    }
    test_field_pRegions();
    fn test_field_filter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBlitImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBlitImageInfo2),
                "::",
                stringify!(filter)
            )
        );
    }
    test_field_filter();
}
impl Default for VkBlitImageInfo2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageResolve2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffset: VkOffset3D,
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffset: VkOffset3D,
    pub extent: VkExtent3D,
}
#[test]
fn bindgen_test_layout_VkImageResolve2() {
    assert_eq!(
        ::std::mem::size_of::<VkImageResolve2>(),
        88usize,
        concat!("Size of: ", stringify!(VkImageResolve2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageResolve2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageResolve2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageResolve2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageResolve2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageResolve2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageResolve2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcSubresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageResolve2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcSubresource) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageResolve2),
                "::",
                stringify!(srcSubresource)
            )
        );
    }
    test_field_srcSubresource();
    fn test_field_srcOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageResolve2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcOffset) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageResolve2),
                "::",
                stringify!(srcOffset)
            )
        );
    }
    test_field_srcOffset();
    fn test_field_dstSubresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageResolve2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstSubresource) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageResolve2),
                "::",
                stringify!(dstSubresource)
            )
        );
    }
    test_field_dstSubresource();
    fn test_field_dstOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageResolve2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstOffset) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageResolve2),
                "::",
                stringify!(dstOffset)
            )
        );
    }
    test_field_dstOffset();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageResolve2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageResolve2),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
}
impl Default for VkImageResolve2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkResolveImageInfo2 {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcImage: VkImage,
    pub srcImageLayout: VkImageLayout,
    pub dstImage: VkImage,
    pub dstImageLayout: VkImageLayout,
    pub regionCount: u32,
    pub pRegions: *const VkImageResolve2,
}
#[test]
fn bindgen_test_layout_VkResolveImageInfo2() {
    assert_eq!(
        ::std::mem::size_of::<VkResolveImageInfo2>(),
        56usize,
        concat!("Size of: ", stringify!(VkResolveImageInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<VkResolveImageInfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(VkResolveImageInfo2))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkResolveImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkResolveImageInfo2),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkResolveImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkResolveImageInfo2),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcImage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkResolveImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcImage) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkResolveImageInfo2),
                "::",
                stringify!(srcImage)
            )
        );
    }
    test_field_srcImage();
    fn test_field_srcImageLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkResolveImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcImageLayout) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkResolveImageInfo2),
                "::",
                stringify!(srcImageLayout)
            )
        );
    }
    test_field_srcImageLayout();
    fn test_field_dstImage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkResolveImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstImage) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkResolveImageInfo2),
                "::",
                stringify!(dstImage)
            )
        );
    }
    test_field_dstImage();
    fn test_field_dstImageLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkResolveImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstImageLayout) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkResolveImageInfo2),
                "::",
                stringify!(dstImageLayout)
            )
        );
    }
    test_field_dstImageLayout();
    fn test_field_regionCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkResolveImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regionCount) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkResolveImageInfo2),
                "::",
                stringify!(regionCount)
            )
        );
    }
    test_field_regionCount();
    fn test_field_pRegions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkResolveImageInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pRegions) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkResolveImageInfo2),
                "::",
                stringify!(pRegions)
            )
        );
    }
    test_field_pRegions();
}
impl Default for VkResolveImageInfo2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSubgroupSizeControlFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub subgroupSizeControl: VkBool32,
    pub computeFullSubgroups: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSubgroupSizeControlFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSubgroupSizeControlFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSubgroupSizeControlFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSubgroupSizeControlFeatures>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubgroupSizeControlFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSubgroupSizeControlFeatures>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubgroupSizeControlFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_subgroupSizeControl() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSubgroupSizeControlFeatures>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subgroupSizeControl) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubgroupSizeControlFeatures),
                "::",
                stringify!(subgroupSizeControl)
            )
        );
    }
    test_field_subgroupSizeControl();
    fn test_field_computeFullSubgroups() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSubgroupSizeControlFeatures>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).computeFullSubgroups) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubgroupSizeControlFeatures),
                "::",
                stringify!(computeFullSubgroups)
            )
        );
    }
    test_field_computeFullSubgroups();
}
impl Default for VkPhysicalDeviceSubgroupSizeControlFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSubgroupSizeControlProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub minSubgroupSize: u32,
    pub maxSubgroupSize: u32,
    pub maxComputeWorkgroupSubgroups: u32,
    pub requiredSubgroupSizeStages: VkShaderStageFlags,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSubgroupSizeControlProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSubgroupSizeControlProperties>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSubgroupSizeControlProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSubgroupSizeControlProperties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceSubgroupSizeControlProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubgroupSizeControlProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceSubgroupSizeControlProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubgroupSizeControlProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_minSubgroupSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceSubgroupSizeControlProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minSubgroupSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubgroupSizeControlProperties),
                "::",
                stringify!(minSubgroupSize)
            )
        );
    }
    test_field_minSubgroupSize();
    fn test_field_maxSubgroupSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceSubgroupSizeControlProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSubgroupSize) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubgroupSizeControlProperties),
                "::",
                stringify!(maxSubgroupSize)
            )
        );
    }
    test_field_maxSubgroupSize();
    fn test_field_maxComputeWorkgroupSubgroups() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceSubgroupSizeControlProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxComputeWorkgroupSubgroups) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubgroupSizeControlProperties),
                "::",
                stringify!(maxComputeWorkgroupSubgroups)
            )
        );
    }
    test_field_maxComputeWorkgroupSubgroups();
    fn test_field_requiredSubgroupSizeStages() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceSubgroupSizeControlProperties > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).requiredSubgroupSizeStages) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubgroupSizeControlProperties),
                "::",
                stringify!(requiredSubgroupSizeStages)
            )
        );
    }
    test_field_requiredSubgroupSizeStages();
}
impl Default for VkPhysicalDeviceSubgroupSizeControlProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineShaderStageRequiredSubgroupSizeCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub requiredSubgroupSize: u32,
}
#[test]
fn bindgen_test_layout_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineShaderStageRequiredSubgroupSizeCreateInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineShaderStageRequiredSubgroupSizeCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineShaderStageRequiredSubgroupSizeCreateInfo,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineShaderStageRequiredSubgroupSizeCreateInfo,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_requiredSubgroupSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineShaderStageRequiredSubgroupSizeCreateInfo,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).requiredSubgroupSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineShaderStageRequiredSubgroupSizeCreateInfo),
                "::",
                stringify!(requiredSubgroupSize)
            )
        );
    }
    test_field_requiredSubgroupSize();
}
impl Default for VkPipelineShaderStageRequiredSubgroupSizeCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceInlineUniformBlockFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub inlineUniformBlock: VkBool32,
    pub descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceInlineUniformBlockFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceInlineUniformBlockFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceInlineUniformBlockFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceInlineUniformBlockFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceInlineUniformBlockFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceInlineUniformBlockFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInlineUniformBlockFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceInlineUniformBlockFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInlineUniformBlockFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_inlineUniformBlock() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceInlineUniformBlockFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inlineUniformBlock) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInlineUniformBlockFeatures),
                "::",
                stringify!(inlineUniformBlock)
            )
        );
    }
    test_field_inlineUniformBlock();
    fn test_field_descriptorBindingInlineUniformBlockUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceInlineUniformBlockFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingInlineUniformBlockUpdateAfterBind)
                    as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInlineUniformBlockFeatures),
                "::",
                stringify!(descriptorBindingInlineUniformBlockUpdateAfterBind)
            )
        );
    }
    test_field_descriptorBindingInlineUniformBlockUpdateAfterBind();
}
impl Default for VkPhysicalDeviceInlineUniformBlockFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceInlineUniformBlockProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxInlineUniformBlockSize: u32,
    pub maxPerStageDescriptorInlineUniformBlocks: u32,
    pub maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: u32,
    pub maxDescriptorSetInlineUniformBlocks: u32,
    pub maxDescriptorSetUpdateAfterBindInlineUniformBlocks: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceInlineUniformBlockProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceInlineUniformBlockProperties>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceInlineUniformBlockProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceInlineUniformBlockProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceInlineUniformBlockProperties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceInlineUniformBlockProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInlineUniformBlockProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceInlineUniformBlockProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInlineUniformBlockProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxInlineUniformBlockSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceInlineUniformBlockProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxInlineUniformBlockSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInlineUniformBlockProperties),
                "::",
                stringify!(maxInlineUniformBlockSize)
            )
        );
    }
    test_field_maxInlineUniformBlockSize();
    fn test_field_maxPerStageDescriptorInlineUniformBlocks() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceInlineUniformBlockProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorInlineUniformBlocks) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInlineUniformBlockProperties),
                "::",
                stringify!(maxPerStageDescriptorInlineUniformBlocks)
            )
        );
    }
    test_field_maxPerStageDescriptorInlineUniformBlocks();
    fn test_field_maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceInlineUniformBlockProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks)
                    as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInlineUniformBlockProperties),
                "::",
                stringify!(maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks)
            )
        );
    }
    test_field_maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks();
    fn test_field_maxDescriptorSetInlineUniformBlocks() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceInlineUniformBlockProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetInlineUniformBlocks) as usize
                    - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInlineUniformBlockProperties),
                "::",
                stringify!(maxDescriptorSetInlineUniformBlocks)
            )
        );
    }
    test_field_maxDescriptorSetInlineUniformBlocks();
    fn test_field_maxDescriptorSetUpdateAfterBindInlineUniformBlocks() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceInlineUniformBlockProperties>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindInlineUniformBlocks)
                    as usize
                    - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInlineUniformBlockProperties),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindInlineUniformBlocks)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindInlineUniformBlocks();
}
impl Default for VkPhysicalDeviceInlineUniformBlockProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkWriteDescriptorSetInlineUniformBlock {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub dataSize: u32,
    pub pData: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkWriteDescriptorSetInlineUniformBlock() {
    assert_eq!(
        ::std::mem::size_of::<VkWriteDescriptorSetInlineUniformBlock>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkWriteDescriptorSetInlineUniformBlock)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkWriteDescriptorSetInlineUniformBlock>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkWriteDescriptorSetInlineUniformBlock)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkWriteDescriptorSetInlineUniformBlock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSetInlineUniformBlock),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkWriteDescriptorSetInlineUniformBlock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSetInlineUniformBlock),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_dataSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkWriteDescriptorSetInlineUniformBlock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSetInlineUniformBlock),
                "::",
                stringify!(dataSize)
            )
        );
    }
    test_field_dataSize();
    fn test_field_pData() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkWriteDescriptorSetInlineUniformBlock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pData) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSetInlineUniformBlock),
                "::",
                stringify!(pData)
            )
        );
    }
    test_field_pData();
}
impl Default for VkWriteDescriptorSetInlineUniformBlock {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorPoolInlineUniformBlockCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub maxInlineUniformBlockBindings: u32,
}
#[test]
fn bindgen_test_layout_VkDescriptorPoolInlineUniformBlockCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorPoolInlineUniformBlockCreateInfo>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDescriptorPoolInlineUniformBlockCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorPoolInlineUniformBlockCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDescriptorPoolInlineUniformBlockCreateInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorPoolInlineUniformBlockCreateInfo>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorPoolInlineUniformBlockCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorPoolInlineUniformBlockCreateInfo>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorPoolInlineUniformBlockCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxInlineUniformBlockBindings() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorPoolInlineUniformBlockCreateInfo>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxInlineUniformBlockBindings) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorPoolInlineUniformBlockCreateInfo),
                "::",
                stringify!(maxInlineUniformBlockBindings)
            )
        );
    }
    test_field_maxInlineUniformBlockBindings();
}
impl Default for VkDescriptorPoolInlineUniformBlockCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceTextureCompressionASTCHDRFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub textureCompressionASTC_HDR: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceTextureCompressionASTCHDRFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceTextureCompressionASTCHDRFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceTextureCompressionASTCHDRFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceTextureCompressionASTCHDRFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceTextureCompressionASTCHDRFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTextureCompressionASTCHDRFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTextureCompressionASTCHDRFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTextureCompressionASTCHDRFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTextureCompressionASTCHDRFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_textureCompressionASTC_HDR() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTextureCompressionASTCHDRFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).textureCompressionASTC_HDR) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTextureCompressionASTCHDRFeatures),
                "::",
                stringify!(textureCompressionASTC_HDR)
            )
        );
    }
    test_field_textureCompressionASTC_HDR();
}
impl Default for VkPhysicalDeviceTextureCompressionASTCHDRFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkRenderingAttachmentInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub imageView: VkImageView,
    pub imageLayout: VkImageLayout,
    pub resolveMode: VkResolveModeFlagBits,
    pub resolveImageView: VkImageView,
    pub resolveImageLayout: VkImageLayout,
    pub loadOp: VkAttachmentLoadOp,
    pub storeOp: VkAttachmentStoreOp,
    pub clearValue: VkClearValue,
}
#[test]
fn bindgen_test_layout_VkRenderingAttachmentInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderingAttachmentInfo>(),
        72usize,
        concat!("Size of: ", stringify!(VkRenderingAttachmentInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderingAttachmentInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkRenderingAttachmentInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingAttachmentInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingAttachmentInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingAttachmentInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingAttachmentInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_imageView() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingAttachmentInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageView) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingAttachmentInfo),
                "::",
                stringify!(imageView)
            )
        );
    }
    test_field_imageView();
    fn test_field_imageLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingAttachmentInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageLayout) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingAttachmentInfo),
                "::",
                stringify!(imageLayout)
            )
        );
    }
    test_field_imageLayout();
    fn test_field_resolveMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingAttachmentInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resolveMode) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingAttachmentInfo),
                "::",
                stringify!(resolveMode)
            )
        );
    }
    test_field_resolveMode();
    fn test_field_resolveImageView() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingAttachmentInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resolveImageView) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingAttachmentInfo),
                "::",
                stringify!(resolveImageView)
            )
        );
    }
    test_field_resolveImageView();
    fn test_field_resolveImageLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingAttachmentInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resolveImageLayout) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingAttachmentInfo),
                "::",
                stringify!(resolveImageLayout)
            )
        );
    }
    test_field_resolveImageLayout();
    fn test_field_loadOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingAttachmentInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).loadOp) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingAttachmentInfo),
                "::",
                stringify!(loadOp)
            )
        );
    }
    test_field_loadOp();
    fn test_field_storeOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingAttachmentInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storeOp) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingAttachmentInfo),
                "::",
                stringify!(storeOp)
            )
        );
    }
    test_field_storeOp();
    fn test_field_clearValue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingAttachmentInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clearValue) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingAttachmentInfo),
                "::",
                stringify!(clearValue)
            )
        );
    }
    test_field_clearValue();
}
impl Default for VkRenderingAttachmentInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderingInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkRenderingFlags,
    pub renderArea: VkRect2D,
    pub layerCount: u32,
    pub viewMask: u32,
    pub colorAttachmentCount: u32,
    pub pColorAttachments: *const VkRenderingAttachmentInfo,
    pub pDepthAttachment: *const VkRenderingAttachmentInfo,
    pub pStencilAttachment: *const VkRenderingAttachmentInfo,
}
#[test]
fn bindgen_test_layout_VkRenderingInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderingInfo>(),
        72usize,
        concat!("Size of: ", stringify!(VkRenderingInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderingInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkRenderingInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_renderArea() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).renderArea) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingInfo),
                "::",
                stringify!(renderArea)
            )
        );
    }
    test_field_renderArea();
    fn test_field_layerCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layerCount) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingInfo),
                "::",
                stringify!(layerCount)
            )
        );
    }
    test_field_layerCount();
    fn test_field_viewMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewMask) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingInfo),
                "::",
                stringify!(viewMask)
            )
        );
    }
    test_field_viewMask();
    fn test_field_colorAttachmentCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorAttachmentCount) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingInfo),
                "::",
                stringify!(colorAttachmentCount)
            )
        );
    }
    test_field_colorAttachmentCount();
    fn test_field_pColorAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pColorAttachments) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingInfo),
                "::",
                stringify!(pColorAttachments)
            )
        );
    }
    test_field_pColorAttachments();
    fn test_field_pDepthAttachment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDepthAttachment) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingInfo),
                "::",
                stringify!(pDepthAttachment)
            )
        );
    }
    test_field_pDepthAttachment();
    fn test_field_pStencilAttachment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pStencilAttachment) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingInfo),
                "::",
                stringify!(pStencilAttachment)
            )
        );
    }
    test_field_pStencilAttachment();
}
impl Default for VkRenderingInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRenderingCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub viewMask: u32,
    pub colorAttachmentCount: u32,
    pub pColorAttachmentFormats: *const VkFormat,
    pub depthAttachmentFormat: VkFormat,
    pub stencilAttachmentFormat: VkFormat,
}
#[test]
fn bindgen_test_layout_VkPipelineRenderingCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRenderingCreateInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VkPipelineRenderingCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRenderingCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPipelineRenderingCreateInfo))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineRenderingCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRenderingCreateInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineRenderingCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRenderingCreateInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_viewMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineRenderingCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRenderingCreateInfo),
                "::",
                stringify!(viewMask)
            )
        );
    }
    test_field_viewMask();
    fn test_field_colorAttachmentCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineRenderingCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorAttachmentCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRenderingCreateInfo),
                "::",
                stringify!(colorAttachmentCount)
            )
        );
    }
    test_field_colorAttachmentCount();
    fn test_field_pColorAttachmentFormats() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineRenderingCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pColorAttachmentFormats) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRenderingCreateInfo),
                "::",
                stringify!(pColorAttachmentFormats)
            )
        );
    }
    test_field_pColorAttachmentFormats();
    fn test_field_depthAttachmentFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineRenderingCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthAttachmentFormat) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRenderingCreateInfo),
                "::",
                stringify!(depthAttachmentFormat)
            )
        );
    }
    test_field_depthAttachmentFormat();
    fn test_field_stencilAttachmentFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineRenderingCreateInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stencilAttachmentFormat) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRenderingCreateInfo),
                "::",
                stringify!(stencilAttachmentFormat)
            )
        );
    }
    test_field_stencilAttachmentFormat();
}
impl Default for VkPipelineRenderingCreateInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDynamicRenderingFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub dynamicRendering: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDynamicRenderingFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDynamicRenderingFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDynamicRenderingFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDynamicRenderingFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDynamicRenderingFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDynamicRenderingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDynamicRenderingFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDynamicRenderingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDynamicRenderingFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_dynamicRendering() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDynamicRenderingFeatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dynamicRendering) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDynamicRenderingFeatures),
                "::",
                stringify!(dynamicRendering)
            )
        );
    }
    test_field_dynamicRendering();
}
impl Default for VkPhysicalDeviceDynamicRenderingFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBufferInheritanceRenderingInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkRenderingFlags,
    pub viewMask: u32,
    pub colorAttachmentCount: u32,
    pub pColorAttachmentFormats: *const VkFormat,
    pub depthAttachmentFormat: VkFormat,
    pub stencilAttachmentFormat: VkFormat,
    pub rasterizationSamples: VkSampleCountFlagBits,
}
#[test]
fn bindgen_test_layout_VkCommandBufferInheritanceRenderingInfo() {
    assert_eq!(
        ::std::mem::size_of::<VkCommandBufferInheritanceRenderingInfo>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(VkCommandBufferInheritanceRenderingInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkCommandBufferInheritanceRenderingInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkCommandBufferInheritanceRenderingInfo)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCommandBufferInheritanceRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceRenderingInfo),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCommandBufferInheritanceRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceRenderingInfo),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCommandBufferInheritanceRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceRenderingInfo),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_viewMask() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCommandBufferInheritanceRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewMask) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceRenderingInfo),
                "::",
                stringify!(viewMask)
            )
        );
    }
    test_field_viewMask();
    fn test_field_colorAttachmentCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCommandBufferInheritanceRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorAttachmentCount) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceRenderingInfo),
                "::",
                stringify!(colorAttachmentCount)
            )
        );
    }
    test_field_colorAttachmentCount();
    fn test_field_pColorAttachmentFormats() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCommandBufferInheritanceRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pColorAttachmentFormats) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceRenderingInfo),
                "::",
                stringify!(pColorAttachmentFormats)
            )
        );
    }
    test_field_pColorAttachmentFormats();
    fn test_field_depthAttachmentFormat() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCommandBufferInheritanceRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthAttachmentFormat) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceRenderingInfo),
                "::",
                stringify!(depthAttachmentFormat)
            )
        );
    }
    test_field_depthAttachmentFormat();
    fn test_field_stencilAttachmentFormat() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCommandBufferInheritanceRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stencilAttachmentFormat) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceRenderingInfo),
                "::",
                stringify!(stencilAttachmentFormat)
            )
        );
    }
    test_field_stencilAttachmentFormat();
    fn test_field_rasterizationSamples() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCommandBufferInheritanceRenderingInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rasterizationSamples) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceRenderingInfo),
                "::",
                stringify!(rasterizationSamples)
            )
        );
    }
    test_field_rasterizationSamples();
}
impl Default for VkCommandBufferInheritanceRenderingInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderIntegerDotProductFeatures {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderIntegerDotProduct: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderIntegerDotProductFeatures() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderIntegerDotProductFeatures>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderIntegerDotProductFeatures)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderIntegerDotProductFeatures>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderIntegerDotProductFeatures)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductFeatures),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductFeatures),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderIntegerDotProduct() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductFeatures,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderIntegerDotProduct) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductFeatures),
                "::",
                stringify!(shaderIntegerDotProduct)
            )
        );
    }
    test_field_shaderIntegerDotProduct();
}
impl Default for VkPhysicalDeviceShaderIntegerDotProductFeatures {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderIntegerDotProductProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub integerDotProduct8BitUnsignedAccelerated: VkBool32,
    pub integerDotProduct8BitSignedAccelerated: VkBool32,
    pub integerDotProduct8BitMixedSignednessAccelerated: VkBool32,
    pub integerDotProduct4x8BitPackedUnsignedAccelerated: VkBool32,
    pub integerDotProduct4x8BitPackedSignedAccelerated: VkBool32,
    pub integerDotProduct4x8BitPackedMixedSignednessAccelerated: VkBool32,
    pub integerDotProduct16BitUnsignedAccelerated: VkBool32,
    pub integerDotProduct16BitSignedAccelerated: VkBool32,
    pub integerDotProduct16BitMixedSignednessAccelerated: VkBool32,
    pub integerDotProduct32BitUnsignedAccelerated: VkBool32,
    pub integerDotProduct32BitSignedAccelerated: VkBool32,
    pub integerDotProduct32BitMixedSignednessAccelerated: VkBool32,
    pub integerDotProduct64BitUnsignedAccelerated: VkBool32,
    pub integerDotProduct64BitSignedAccelerated: VkBool32,
    pub integerDotProduct64BitMixedSignednessAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating8BitSignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating16BitSignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating32BitSignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating64BitSignedAccelerated: VkBool32,
    pub integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderIntegerDotProductProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderIntegerDotProductProperties>(),
        136usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderIntegerDotProductProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_integerDotProduct8BitUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct8BitUnsignedAccelerated) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProduct8BitUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct8BitUnsignedAccelerated();
    fn test_field_integerDotProduct8BitSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct8BitSignedAccelerated) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProduct8BitSignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct8BitSignedAccelerated();
    fn test_field_integerDotProduct8BitMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct8BitMixedSignednessAccelerated)
                    as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProduct8BitMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProduct8BitMixedSignednessAccelerated();
    fn test_field_integerDotProduct4x8BitPackedUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct4x8BitPackedUnsignedAccelerated)
                    as usize
                    - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProduct4x8BitPackedUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct4x8BitPackedUnsignedAccelerated();
    fn test_field_integerDotProduct4x8BitPackedSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct4x8BitPackedSignedAccelerated) as usize
                    - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProduct4x8BitPackedSignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct4x8BitPackedSignedAccelerated();
    fn test_field_integerDotProduct4x8BitPackedMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct4x8BitPackedMixedSignednessAccelerated)
                    as usize
                    - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProduct4x8BitPackedMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProduct4x8BitPackedMixedSignednessAccelerated();
    fn test_field_integerDotProduct16BitUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct16BitUnsignedAccelerated) as usize
                    - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProduct16BitUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct16BitUnsignedAccelerated();
    fn test_field_integerDotProduct16BitSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct16BitSignedAccelerated) as usize
                    - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProduct16BitSignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct16BitSignedAccelerated();
    fn test_field_integerDotProduct16BitMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct16BitMixedSignednessAccelerated)
                    as usize
                    - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProduct16BitMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProduct16BitMixedSignednessAccelerated();
    fn test_field_integerDotProduct32BitUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct32BitUnsignedAccelerated) as usize
                    - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProduct32BitUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct32BitUnsignedAccelerated();
    fn test_field_integerDotProduct32BitSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct32BitSignedAccelerated) as usize
                    - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProduct32BitSignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct32BitSignedAccelerated();
    fn test_field_integerDotProduct32BitMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct32BitMixedSignednessAccelerated)
                    as usize
                    - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProduct32BitMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProduct32BitMixedSignednessAccelerated();
    fn test_field_integerDotProduct64BitUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct64BitUnsignedAccelerated) as usize
                    - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProduct64BitUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct64BitUnsignedAccelerated();
    fn test_field_integerDotProduct64BitSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct64BitSignedAccelerated) as usize
                    - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProduct64BitSignedAccelerated)
            )
        );
    }
    test_field_integerDotProduct64BitSignedAccelerated();
    fn test_field_integerDotProduct64BitMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).integerDotProduct64BitMixedSignednessAccelerated)
                    as usize
                    - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProduct64BitMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProduct64BitMixedSignednessAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating8BitUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating8BitUnsignedAccelerated
                ) as usize
                    - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating8BitUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating8BitUnsignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating8BitSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating8BitSignedAccelerated
                ) as usize
                    - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating8BitSignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating8BitSignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated
                ) as usize
                    - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated
                ) as usize
                    - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated
                ) as usize
                    - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                :: std :: ptr :: addr_of ! ((* ptr) . integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(
                    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated
                )
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating16BitUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating16BitUnsignedAccelerated
                ) as usize
                    - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating16BitUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating16BitUnsignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating16BitSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating16BitSignedAccelerated
                ) as usize
                    - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating16BitSignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating16BitSignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated
                ) as usize
                    - ptr as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating32BitUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating32BitUnsignedAccelerated
                ) as usize
                    - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating32BitUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating32BitUnsignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating32BitSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating32BitSignedAccelerated
                ) as usize
                    - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating32BitSignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating32BitSignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated
                ) as usize
                    - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating64BitUnsignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating64BitUnsignedAccelerated
                ) as usize
                    - ptr as usize
            },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating64BitUnsignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating64BitUnsignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating64BitSignedAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating64BitSignedAccelerated
                ) as usize
                    - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating64BitSignedAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating64BitSignedAccelerated();
    fn test_field_integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerDotProductProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated
                ) as usize
                    - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerDotProductProperties),
                "::",
                stringify!(integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated)
            )
        );
    }
    test_field_integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated();
}
impl Default for VkPhysicalDeviceShaderIntegerDotProductProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceTexelBufferAlignmentProperties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub storageTexelBufferOffsetAlignmentBytes: VkDeviceSize,
    pub storageTexelBufferOffsetSingleTexelAlignment: VkBool32,
    pub uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize,
    pub uniformTexelBufferOffsetSingleTexelAlignment: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceTexelBufferAlignmentProperties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceTexelBufferAlignmentProperties>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentProperties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceTexelBufferAlignmentProperties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentProperties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTexelBufferAlignmentProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTexelBufferAlignmentProperties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTexelBufferAlignmentProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTexelBufferAlignmentProperties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_storageTexelBufferOffsetAlignmentBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTexelBufferAlignmentProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storageTexelBufferOffsetAlignmentBytes) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTexelBufferAlignmentProperties),
                "::",
                stringify!(storageTexelBufferOffsetAlignmentBytes)
            )
        );
    }
    test_field_storageTexelBufferOffsetAlignmentBytes();
    fn test_field_storageTexelBufferOffsetSingleTexelAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTexelBufferAlignmentProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storageTexelBufferOffsetSingleTexelAlignment) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTexelBufferAlignmentProperties),
                "::",
                stringify!(storageTexelBufferOffsetSingleTexelAlignment)
            )
        );
    }
    test_field_storageTexelBufferOffsetSingleTexelAlignment();
    fn test_field_uniformTexelBufferOffsetAlignmentBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTexelBufferAlignmentProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uniformTexelBufferOffsetAlignmentBytes) as usize
                    - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTexelBufferAlignmentProperties),
                "::",
                stringify!(uniformTexelBufferOffsetAlignmentBytes)
            )
        );
    }
    test_field_uniformTexelBufferOffsetAlignmentBytes();
    fn test_field_uniformTexelBufferOffsetSingleTexelAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTexelBufferAlignmentProperties,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uniformTexelBufferOffsetSingleTexelAlignment) as usize
                    - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTexelBufferAlignmentProperties),
                "::",
                stringify!(uniformTexelBufferOffsetSingleTexelAlignment)
            )
        );
    }
    test_field_uniformTexelBufferOffsetSingleTexelAlignment();
}
impl Default for VkPhysicalDeviceTexelBufferAlignmentProperties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFormatProperties3 {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub linearTilingFeatures: VkFormatFeatureFlags2,
    pub optimalTilingFeatures: VkFormatFeatureFlags2,
    pub bufferFeatures: VkFormatFeatureFlags2,
}
#[test]
fn bindgen_test_layout_VkFormatProperties3() {
    assert_eq!(
        ::std::mem::size_of::<VkFormatProperties3>(),
        40usize,
        concat!("Size of: ", stringify!(VkFormatProperties3))
    );
    assert_eq!(
        ::std::mem::align_of::<VkFormatProperties3>(),
        8usize,
        concat!("Alignment of ", stringify!(VkFormatProperties3))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFormatProperties3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFormatProperties3),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFormatProperties3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFormatProperties3),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_linearTilingFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFormatProperties3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).linearTilingFeatures) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFormatProperties3),
                "::",
                stringify!(linearTilingFeatures)
            )
        );
    }
    test_field_linearTilingFeatures();
    fn test_field_optimalTilingFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFormatProperties3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).optimalTilingFeatures) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFormatProperties3),
                "::",
                stringify!(optimalTilingFeatures)
            )
        );
    }
    test_field_optimalTilingFeatures();
    fn test_field_bufferFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFormatProperties3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferFeatures) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFormatProperties3),
                "::",
                stringify!(bufferFeatures)
            )
        );
    }
    test_field_bufferFeatures();
}
impl Default for VkFormatProperties3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMaintenance4Features {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maintenance4: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMaintenance4Features() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMaintenance4Features>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMaintenance4Features)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMaintenance4Features>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMaintenance4Features)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMaintenance4Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMaintenance4Features),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMaintenance4Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMaintenance4Features),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maintenance4() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMaintenance4Features>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maintenance4) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMaintenance4Features),
                "::",
                stringify!(maintenance4)
            )
        );
    }
    test_field_maintenance4();
}
impl Default for VkPhysicalDeviceMaintenance4Features {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMaintenance4Properties {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxBufferSize: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMaintenance4Properties() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMaintenance4Properties>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMaintenance4Properties)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMaintenance4Properties>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMaintenance4Properties)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMaintenance4Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMaintenance4Properties),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMaintenance4Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMaintenance4Properties),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxBufferSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMaintenance4Properties>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxBufferSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMaintenance4Properties),
                "::",
                stringify!(maxBufferSize)
            )
        );
    }
    test_field_maxBufferSize();
}
impl Default for VkPhysicalDeviceMaintenance4Properties {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceBufferMemoryRequirements {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pCreateInfo: *const VkBufferCreateInfo,
}
#[test]
fn bindgen_test_layout_VkDeviceBufferMemoryRequirements() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceBufferMemoryRequirements>(),
        24usize,
        concat!("Size of: ", stringify!(VkDeviceBufferMemoryRequirements))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceBufferMemoryRequirements>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceBufferMemoryRequirements)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceBufferMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceBufferMemoryRequirements),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceBufferMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceBufferMemoryRequirements),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pCreateInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceBufferMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCreateInfo) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceBufferMemoryRequirements),
                "::",
                stringify!(pCreateInfo)
            )
        );
    }
    test_field_pCreateInfo();
}
impl Default for VkDeviceBufferMemoryRequirements {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceImageMemoryRequirements {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pCreateInfo: *const VkImageCreateInfo,
    pub planeAspect: VkImageAspectFlagBits,
}
#[test]
fn bindgen_test_layout_VkDeviceImageMemoryRequirements() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceImageMemoryRequirements>(),
        32usize,
        concat!("Size of: ", stringify!(VkDeviceImageMemoryRequirements))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceImageMemoryRequirements>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceImageMemoryRequirements))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceImageMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceImageMemoryRequirements),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceImageMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceImageMemoryRequirements),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pCreateInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceImageMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCreateInfo) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceImageMemoryRequirements),
                "::",
                stringify!(pCreateInfo)
            )
        );
    }
    test_field_pCreateInfo();
    fn test_field_planeAspect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceImageMemoryRequirements>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).planeAspect) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceImageMemoryRequirements),
                "::",
                stringify!(planeAspect)
            )
        );
    }
    test_field_planeAspect();
}
impl Default for VkDeviceImageMemoryRequirements {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetPhysicalDeviceToolProperties = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pToolCount: *mut u32,
        pToolProperties: *mut VkPhysicalDeviceToolProperties,
    ) -> VkResult,
>;
pub type PFN_vkCreatePrivateDataSlot = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkPrivateDataSlotCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPrivateDataSlot: *mut VkPrivateDataSlot,
    ) -> VkResult,
>;
pub type PFN_vkDestroyPrivateDataSlot = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        privateDataSlot: VkPrivateDataSlot,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkSetPrivateData = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        objectType: VkObjectType,
        objectHandle: u64,
        privateDataSlot: VkPrivateDataSlot,
        data: u64,
    ) -> VkResult,
>;
pub type PFN_vkGetPrivateData = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        objectType: VkObjectType,
        objectHandle: u64,
        privateDataSlot: VkPrivateDataSlot,
        pData: *mut u64,
    ),
>;
pub type PFN_vkCmdSetEvent2 = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        pDependencyInfo: *const VkDependencyInfo,
    ),
>;
pub type PFN_vkCmdResetEvent2 = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        stageMask: VkPipelineStageFlags2,
    ),
>;
pub type PFN_vkCmdWaitEvents2 = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        eventCount: u32,
        pEvents: *const VkEvent,
        pDependencyInfos: *const VkDependencyInfo,
    ),
>;
pub type PFN_vkCmdPipelineBarrier2 = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pDependencyInfo: *const VkDependencyInfo),
>;
pub type PFN_vkCmdWriteTimestamp2 = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        stage: VkPipelineStageFlags2,
        queryPool: VkQueryPool,
        query: u32,
    ),
>;
pub type PFN_vkQueueSubmit2 = ::std::option::Option<
    unsafe extern "C" fn(
        queue: VkQueue,
        submitCount: u32,
        pSubmits: *const VkSubmitInfo2,
        fence: VkFence,
    ) -> VkResult,
>;
pub type PFN_vkCmdCopyBuffer2 = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2),
>;
pub type PFN_vkCmdCopyImage2 = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pCopyImageInfo: *const VkCopyImageInfo2),
>;
pub type PFN_vkCmdCopyBufferToImage2 = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pCopyBufferToImageInfo: *const VkCopyBufferToImageInfo2,
    ),
>;
pub type PFN_vkCmdCopyImageToBuffer2 = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pCopyImageToBufferInfo: *const VkCopyImageToBufferInfo2,
    ),
>;
pub type PFN_vkCmdBlitImage2 = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pBlitImageInfo: *const VkBlitImageInfo2),
>;
pub type PFN_vkCmdResolveImage2 = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pResolveImageInfo: *const VkResolveImageInfo2,
    ),
>;
pub type PFN_vkCmdBeginRendering = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo),
>;
pub type PFN_vkCmdEndRendering =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer)>;
pub type PFN_vkCmdSetCullMode = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags),
>;
pub type PFN_vkCmdSetFrontFace = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, frontFace: VkFrontFace),
>;
pub type PFN_vkCmdSetPrimitiveTopology = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology),
>;
pub type PFN_vkCmdSetViewportWithCount = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        viewportCount: u32,
        pViewports: *const VkViewport,
    ),
>;
pub type PFN_vkCmdSetScissorWithCount = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        scissorCount: u32,
        pScissors: *const VkRect2D,
    ),
>;
pub type PFN_vkCmdBindVertexBuffers2 = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstBinding: u32,
        bindingCount: u32,
        pBuffers: *const VkBuffer,
        pOffsets: *const VkDeviceSize,
        pSizes: *const VkDeviceSize,
        pStrides: *const VkDeviceSize,
    ),
>;
pub type PFN_vkCmdSetDepthTestEnable = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32),
>;
pub type PFN_vkCmdSetDepthWriteEnable = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32),
>;
pub type PFN_vkCmdSetDepthCompareOp = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp),
>;
pub type PFN_vkCmdSetDepthBoundsTestEnable = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32),
>;
pub type PFN_vkCmdSetStencilTestEnable = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32),
>;
pub type PFN_vkCmdSetStencilOp = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        failOp: VkStencilOp,
        passOp: VkStencilOp,
        depthFailOp: VkStencilOp,
        compareOp: VkCompareOp,
    ),
>;
pub type PFN_vkCmdSetRasterizerDiscardEnable = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32),
>;
pub type PFN_vkCmdSetDepthBiasEnable = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32),
>;
pub type PFN_vkCmdSetPrimitiveRestartEnable = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32),
>;
pub type PFN_vkGetDeviceBufferMemoryRequirements = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkDeviceBufferMemoryRequirements,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetDeviceImageMemoryRequirements = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkDeviceImageMemoryRequirements,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetDeviceImageSparseMemoryRequirements = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkDeviceImageMemoryRequirements,
        pSparseMemoryRequirementCount: *mut u32,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2,
    ),
>;
extern "C" {
    pub fn vkGetPhysicalDeviceToolProperties(
        physicalDevice: VkPhysicalDevice,
        pToolCount: *mut u32,
        pToolProperties: *mut VkPhysicalDeviceToolProperties,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreatePrivateDataSlot(
        device: VkDevice,
        pCreateInfo: *const VkPrivateDataSlotCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPrivateDataSlot: *mut VkPrivateDataSlot,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyPrivateDataSlot(
        device: VkDevice,
        privateDataSlot: VkPrivateDataSlot,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkSetPrivateData(
        device: VkDevice,
        objectType: VkObjectType,
        objectHandle: u64,
        privateDataSlot: VkPrivateDataSlot,
        data: u64,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPrivateData(
        device: VkDevice,
        objectType: VkObjectType,
        objectHandle: u64,
        privateDataSlot: VkPrivateDataSlot,
        pData: *mut u64,
    );
}
extern "C" {
    pub fn vkCmdSetEvent2(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        pDependencyInfo: *const VkDependencyInfo,
    );
}
extern "C" {
    pub fn vkCmdResetEvent2(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        stageMask: VkPipelineStageFlags2,
    );
}
extern "C" {
    pub fn vkCmdWaitEvents2(
        commandBuffer: VkCommandBuffer,
        eventCount: u32,
        pEvents: *const VkEvent,
        pDependencyInfos: *const VkDependencyInfo,
    );
}
extern "C" {
    pub fn vkCmdPipelineBarrier2(
        commandBuffer: VkCommandBuffer,
        pDependencyInfo: *const VkDependencyInfo,
    );
}
extern "C" {
    pub fn vkCmdWriteTimestamp2(
        commandBuffer: VkCommandBuffer,
        stage: VkPipelineStageFlags2,
        queryPool: VkQueryPool,
        query: u32,
    );
}
extern "C" {
    pub fn vkQueueSubmit2(
        queue: VkQueue,
        submitCount: u32,
        pSubmits: *const VkSubmitInfo2,
        fence: VkFence,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdCopyBuffer2(
        commandBuffer: VkCommandBuffer,
        pCopyBufferInfo: *const VkCopyBufferInfo2,
    );
}
extern "C" {
    pub fn vkCmdCopyImage2(commandBuffer: VkCommandBuffer, pCopyImageInfo: *const VkCopyImageInfo2);
}
extern "C" {
    pub fn vkCmdCopyBufferToImage2(
        commandBuffer: VkCommandBuffer,
        pCopyBufferToImageInfo: *const VkCopyBufferToImageInfo2,
    );
}
extern "C" {
    pub fn vkCmdCopyImageToBuffer2(
        commandBuffer: VkCommandBuffer,
        pCopyImageToBufferInfo: *const VkCopyImageToBufferInfo2,
    );
}
extern "C" {
    pub fn vkCmdBlitImage2(commandBuffer: VkCommandBuffer, pBlitImageInfo: *const VkBlitImageInfo2);
}
extern "C" {
    pub fn vkCmdResolveImage2(
        commandBuffer: VkCommandBuffer,
        pResolveImageInfo: *const VkResolveImageInfo2,
    );
}
extern "C" {
    pub fn vkCmdBeginRendering(
        commandBuffer: VkCommandBuffer,
        pRenderingInfo: *const VkRenderingInfo,
    );
}
extern "C" {
    pub fn vkCmdEndRendering(commandBuffer: VkCommandBuffer);
}
extern "C" {
    pub fn vkCmdSetCullMode(commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags);
}
extern "C" {
    pub fn vkCmdSetFrontFace(commandBuffer: VkCommandBuffer, frontFace: VkFrontFace);
}
extern "C" {
    pub fn vkCmdSetPrimitiveTopology(
        commandBuffer: VkCommandBuffer,
        primitiveTopology: VkPrimitiveTopology,
    );
}
extern "C" {
    pub fn vkCmdSetViewportWithCount(
        commandBuffer: VkCommandBuffer,
        viewportCount: u32,
        pViewports: *const VkViewport,
    );
}
extern "C" {
    pub fn vkCmdSetScissorWithCount(
        commandBuffer: VkCommandBuffer,
        scissorCount: u32,
        pScissors: *const VkRect2D,
    );
}
extern "C" {
    pub fn vkCmdBindVertexBuffers2(
        commandBuffer: VkCommandBuffer,
        firstBinding: u32,
        bindingCount: u32,
        pBuffers: *const VkBuffer,
        pOffsets: *const VkDeviceSize,
        pSizes: *const VkDeviceSize,
        pStrides: *const VkDeviceSize,
    );
}
extern "C" {
    pub fn vkCmdSetDepthTestEnable(commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32);
}
extern "C" {
    pub fn vkCmdSetDepthWriteEnable(commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32);
}
extern "C" {
    pub fn vkCmdSetDepthCompareOp(commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp);
}
extern "C" {
    pub fn vkCmdSetDepthBoundsTestEnable(
        commandBuffer: VkCommandBuffer,
        depthBoundsTestEnable: VkBool32,
    );
}
extern "C" {
    pub fn vkCmdSetStencilTestEnable(commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32);
}
extern "C" {
    pub fn vkCmdSetStencilOp(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        failOp: VkStencilOp,
        passOp: VkStencilOp,
        depthFailOp: VkStencilOp,
        compareOp: VkCompareOp,
    );
}
extern "C" {
    pub fn vkCmdSetRasterizerDiscardEnable(
        commandBuffer: VkCommandBuffer,
        rasterizerDiscardEnable: VkBool32,
    );
}
extern "C" {
    pub fn vkCmdSetDepthBiasEnable(commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32);
}
extern "C" {
    pub fn vkCmdSetPrimitiveRestartEnable(
        commandBuffer: VkCommandBuffer,
        primitiveRestartEnable: VkBool32,
    );
}
extern "C" {
    pub fn vkGetDeviceBufferMemoryRequirements(
        device: VkDevice,
        pInfo: *const VkDeviceBufferMemoryRequirements,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    );
}
extern "C" {
    pub fn vkGetDeviceImageMemoryRequirements(
        device: VkDevice,
        pInfo: *const VkDeviceImageMemoryRequirements,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    );
}
extern "C" {
    pub fn vkGetDeviceImageSparseMemoryRequirements(
        device: VkDevice,
        pInfo: *const VkDeviceImageMemoryRequirements,
        pSparseMemoryRequirementCount: *mut u32,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSurfaceKHR_T {
    _unused: [u8; 0],
}
pub type VkSurfaceKHR = *mut VkSurfaceKHR_T;
pub const VK_PRESENT_MODE_IMMEDIATE_KHR: VkPresentModeKHR = 0;
pub const VK_PRESENT_MODE_MAILBOX_KHR: VkPresentModeKHR = 1;
pub const VK_PRESENT_MODE_FIFO_KHR: VkPresentModeKHR = 2;
pub const VK_PRESENT_MODE_FIFO_RELAXED_KHR: VkPresentModeKHR = 3;
pub const VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR: VkPresentModeKHR = 1000111000;
pub const VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR: VkPresentModeKHR = 1000111001;
pub const VK_PRESENT_MODE_MAX_ENUM_KHR: VkPresentModeKHR = 2147483647;
pub type VkPresentModeKHR = ::std::os::raw::c_int;
pub const VK_COLOR_SPACE_SRGB_NONLINEAR_KHR: VkColorSpaceKHR = 0;
pub const VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT: VkColorSpaceKHR = 1000104001;
pub const VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT: VkColorSpaceKHR = 1000104002;
pub const VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT: VkColorSpaceKHR = 1000104003;
pub const VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT: VkColorSpaceKHR = 1000104004;
pub const VK_COLOR_SPACE_BT709_LINEAR_EXT: VkColorSpaceKHR = 1000104005;
pub const VK_COLOR_SPACE_BT709_NONLINEAR_EXT: VkColorSpaceKHR = 1000104006;
pub const VK_COLOR_SPACE_BT2020_LINEAR_EXT: VkColorSpaceKHR = 1000104007;
pub const VK_COLOR_SPACE_HDR10_ST2084_EXT: VkColorSpaceKHR = 1000104008;
pub const VK_COLOR_SPACE_DOLBYVISION_EXT: VkColorSpaceKHR = 1000104009;
pub const VK_COLOR_SPACE_HDR10_HLG_EXT: VkColorSpaceKHR = 1000104010;
pub const VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT: VkColorSpaceKHR = 1000104011;
pub const VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT: VkColorSpaceKHR = 1000104012;
pub const VK_COLOR_SPACE_PASS_THROUGH_EXT: VkColorSpaceKHR = 1000104013;
pub const VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT: VkColorSpaceKHR = 1000104014;
pub const VK_COLOR_SPACE_DISPLAY_NATIVE_AMD: VkColorSpaceKHR = 1000213000;
pub const VK_COLORSPACE_SRGB_NONLINEAR_KHR: VkColorSpaceKHR = 0;
pub const VK_COLOR_SPACE_DCI_P3_LINEAR_EXT: VkColorSpaceKHR = 1000104003;
pub const VK_COLOR_SPACE_MAX_ENUM_KHR: VkColorSpaceKHR = 2147483647;
pub type VkColorSpaceKHR = ::std::os::raw::c_int;
pub const VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR: VkSurfaceTransformFlagBitsKHR = 1;
pub const VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR: VkSurfaceTransformFlagBitsKHR = 2;
pub const VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR: VkSurfaceTransformFlagBitsKHR = 4;
pub const VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR: VkSurfaceTransformFlagBitsKHR = 8;
pub const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR: VkSurfaceTransformFlagBitsKHR = 16;
pub const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR: VkSurfaceTransformFlagBitsKHR =
    32;
pub const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR: VkSurfaceTransformFlagBitsKHR =
    64;
pub const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR: VkSurfaceTransformFlagBitsKHR =
    128;
pub const VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR: VkSurfaceTransformFlagBitsKHR = 256;
pub const VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR: VkSurfaceTransformFlagBitsKHR = 2147483647;
pub type VkSurfaceTransformFlagBitsKHR = ::std::os::raw::c_int;
pub const VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR: VkCompositeAlphaFlagBitsKHR = 1;
pub const VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR: VkCompositeAlphaFlagBitsKHR = 2;
pub const VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR: VkCompositeAlphaFlagBitsKHR = 4;
pub const VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR: VkCompositeAlphaFlagBitsKHR = 8;
pub const VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR: VkCompositeAlphaFlagBitsKHR = 2147483647;
pub type VkCompositeAlphaFlagBitsKHR = ::std::os::raw::c_int;
pub type VkCompositeAlphaFlagsKHR = VkFlags;
pub type VkSurfaceTransformFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSurfaceCapabilitiesKHR {
    pub minImageCount: u32,
    pub maxImageCount: u32,
    pub currentExtent: VkExtent2D,
    pub minImageExtent: VkExtent2D,
    pub maxImageExtent: VkExtent2D,
    pub maxImageArrayLayers: u32,
    pub supportedTransforms: VkSurfaceTransformFlagsKHR,
    pub currentTransform: VkSurfaceTransformFlagBitsKHR,
    pub supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
    pub supportedUsageFlags: VkImageUsageFlags,
}
#[test]
fn bindgen_test_layout_VkSurfaceCapabilitiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkSurfaceCapabilitiesKHR>(),
        52usize,
        concat!("Size of: ", stringify!(VkSurfaceCapabilitiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSurfaceCapabilitiesKHR>(),
        4usize,
        concat!("Alignment of ", stringify!(VkSurfaceCapabilitiesKHR))
    );
    fn test_field_minImageCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minImageCount) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilitiesKHR),
                "::",
                stringify!(minImageCount)
            )
        );
    }
    test_field_minImageCount();
    fn test_field_maxImageCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxImageCount) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilitiesKHR),
                "::",
                stringify!(maxImageCount)
            )
        );
    }
    test_field_maxImageCount();
    fn test_field_currentExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).currentExtent) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilitiesKHR),
                "::",
                stringify!(currentExtent)
            )
        );
    }
    test_field_currentExtent();
    fn test_field_minImageExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minImageExtent) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilitiesKHR),
                "::",
                stringify!(minImageExtent)
            )
        );
    }
    test_field_minImageExtent();
    fn test_field_maxImageExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxImageExtent) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilitiesKHR),
                "::",
                stringify!(maxImageExtent)
            )
        );
    }
    test_field_maxImageExtent();
    fn test_field_maxImageArrayLayers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxImageArrayLayers) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilitiesKHR),
                "::",
                stringify!(maxImageArrayLayers)
            )
        );
    }
    test_field_maxImageArrayLayers();
    fn test_field_supportedTransforms() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedTransforms) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilitiesKHR),
                "::",
                stringify!(supportedTransforms)
            )
        );
    }
    test_field_supportedTransforms();
    fn test_field_currentTransform() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).currentTransform) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilitiesKHR),
                "::",
                stringify!(currentTransform)
            )
        );
    }
    test_field_currentTransform();
    fn test_field_supportedCompositeAlpha() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedCompositeAlpha) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilitiesKHR),
                "::",
                stringify!(supportedCompositeAlpha)
            )
        );
    }
    test_field_supportedCompositeAlpha();
    fn test_field_supportedUsageFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedUsageFlags) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilitiesKHR),
                "::",
                stringify!(supportedUsageFlags)
            )
        );
    }
    test_field_supportedUsageFlags();
}
impl Default for VkSurfaceCapabilitiesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSurfaceFormatKHR {
    pub format: VkFormat,
    pub colorSpace: VkColorSpaceKHR,
}
#[test]
fn bindgen_test_layout_VkSurfaceFormatKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkSurfaceFormatKHR>(),
        8usize,
        concat!("Size of: ", stringify!(VkSurfaceFormatKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSurfaceFormatKHR>(),
        4usize,
        concat!("Alignment of ", stringify!(VkSurfaceFormatKHR))
    );
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceFormatKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceFormatKHR),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_colorSpace() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceFormatKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorSpace) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceFormatKHR),
                "::",
                stringify!(colorSpace)
            )
        );
    }
    test_field_colorSpace();
}
impl Default for VkSurfaceFormatKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkDestroySurfaceKHR = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        surface: VkSurfaceKHR,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetPhysicalDeviceSurfaceSupportKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        queueFamilyIndex: u32,
        surface: VkSurfaceKHR,
        pSupported: *mut VkBool32,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceCapabilities: *mut VkSurfaceCapabilitiesKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceSurfaceFormatsKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceFormatCount: *mut u32,
        pSurfaceFormats: *mut VkSurfaceFormatKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceSurfacePresentModesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pPresentModeCount: *mut u32,
        pPresentModes: *mut VkPresentModeKHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkDestroySurfaceKHR(
        instance: VkInstance,
        surface: VkSurfaceKHR,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceSupportKHR(
        physicalDevice: VkPhysicalDevice,
        queueFamilyIndex: u32,
        surface: VkSurfaceKHR,
        pSupported: *mut VkBool32,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceCapabilities: *mut VkSurfaceCapabilitiesKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceFormatsKHR(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceFormatCount: *mut u32,
        pSurfaceFormats: *mut VkSurfaceFormatKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceSurfacePresentModesKHR(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pPresentModeCount: *mut u32,
        pPresentModes: *mut VkPresentModeKHR,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSwapchainKHR_T {
    _unused: [u8; 0],
}
pub type VkSwapchainKHR = *mut VkSwapchainKHR_T;
pub const VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR: VkSwapchainCreateFlagBitsKHR = 1;
pub const VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR: VkSwapchainCreateFlagBitsKHR = 2;
pub const VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR: VkSwapchainCreateFlagBitsKHR = 4;
pub const VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR: VkSwapchainCreateFlagBitsKHR = 2147483647;
pub type VkSwapchainCreateFlagBitsKHR = ::std::os::raw::c_int;
pub type VkSwapchainCreateFlagsKHR = VkFlags;
pub const VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR: VkDeviceGroupPresentModeFlagBitsKHR = 1;
pub const VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR: VkDeviceGroupPresentModeFlagBitsKHR = 2;
pub const VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR: VkDeviceGroupPresentModeFlagBitsKHR = 4;
pub const VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR:
    VkDeviceGroupPresentModeFlagBitsKHR = 8;
pub const VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR: VkDeviceGroupPresentModeFlagBitsKHR =
    2147483647;
pub type VkDeviceGroupPresentModeFlagBitsKHR = ::std::os::raw::c_int;
pub type VkDeviceGroupPresentModeFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSwapchainCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSwapchainCreateFlagsKHR,
    pub surface: VkSurfaceKHR,
    pub minImageCount: u32,
    pub imageFormat: VkFormat,
    pub imageColorSpace: VkColorSpaceKHR,
    pub imageExtent: VkExtent2D,
    pub imageArrayLayers: u32,
    pub imageUsage: VkImageUsageFlags,
    pub imageSharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: *const u32,
    pub preTransform: VkSurfaceTransformFlagBitsKHR,
    pub compositeAlpha: VkCompositeAlphaFlagBitsKHR,
    pub presentMode: VkPresentModeKHR,
    pub clipped: VkBool32,
    pub oldSwapchain: VkSwapchainKHR,
}
#[test]
fn bindgen_test_layout_VkSwapchainCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkSwapchainCreateInfoKHR>(),
        104usize,
        concat!("Size of: ", stringify!(VkSwapchainCreateInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSwapchainCreateInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSwapchainCreateInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_surface() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).surface) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(surface)
            )
        );
    }
    test_field_surface();
    fn test_field_minImageCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minImageCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(minImageCount)
            )
        );
    }
    test_field_minImageCount();
    fn test_field_imageFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageFormat) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(imageFormat)
            )
        );
    }
    test_field_imageFormat();
    fn test_field_imageColorSpace() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageColorSpace) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(imageColorSpace)
            )
        );
    }
    test_field_imageColorSpace();
    fn test_field_imageExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageExtent) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(imageExtent)
            )
        );
    }
    test_field_imageExtent();
    fn test_field_imageArrayLayers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageArrayLayers) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(imageArrayLayers)
            )
        );
    }
    test_field_imageArrayLayers();
    fn test_field_imageUsage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageUsage) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(imageUsage)
            )
        );
    }
    test_field_imageUsage();
    fn test_field_imageSharingMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageSharingMode) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(imageSharingMode)
            )
        );
    }
    test_field_imageSharingMode();
    fn test_field_queueFamilyIndexCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queueFamilyIndexCount) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(queueFamilyIndexCount)
            )
        );
    }
    test_field_queueFamilyIndexCount();
    fn test_field_pQueueFamilyIndices() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pQueueFamilyIndices) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(pQueueFamilyIndices)
            )
        );
    }
    test_field_pQueueFamilyIndices();
    fn test_field_preTransform() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).preTransform) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(preTransform)
            )
        );
    }
    test_field_preTransform();
    fn test_field_compositeAlpha() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compositeAlpha) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(compositeAlpha)
            )
        );
    }
    test_field_compositeAlpha();
    fn test_field_presentMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).presentMode) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(presentMode)
            )
        );
    }
    test_field_presentMode();
    fn test_field_clipped() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clipped) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(clipped)
            )
        );
    }
    test_field_clipped();
    fn test_field_oldSwapchain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).oldSwapchain) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCreateInfoKHR),
                "::",
                stringify!(oldSwapchain)
            )
        );
    }
    test_field_oldSwapchain();
}
impl Default for VkSwapchainCreateInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPresentInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: u32,
    pub pWaitSemaphores: *const VkSemaphore,
    pub swapchainCount: u32,
    pub pSwapchains: *const VkSwapchainKHR,
    pub pImageIndices: *const u32,
    pub pResults: *mut VkResult,
}
#[test]
fn bindgen_test_layout_VkPresentInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPresentInfoKHR>(),
        64usize,
        concat!("Size of: ", stringify!(VkPresentInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPresentInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPresentInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_waitSemaphoreCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).waitSemaphoreCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentInfoKHR),
                "::",
                stringify!(waitSemaphoreCount)
            )
        );
    }
    test_field_waitSemaphoreCount();
    fn test_field_pWaitSemaphores() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pWaitSemaphores) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentInfoKHR),
                "::",
                stringify!(pWaitSemaphores)
            )
        );
    }
    test_field_pWaitSemaphores();
    fn test_field_swapchainCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).swapchainCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentInfoKHR),
                "::",
                stringify!(swapchainCount)
            )
        );
    }
    test_field_swapchainCount();
    fn test_field_pSwapchains() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSwapchains) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentInfoKHR),
                "::",
                stringify!(pSwapchains)
            )
        );
    }
    test_field_pSwapchains();
    fn test_field_pImageIndices() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pImageIndices) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentInfoKHR),
                "::",
                stringify!(pImageIndices)
            )
        );
    }
    test_field_pImageIndices();
    fn test_field_pResults() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pResults) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentInfoKHR),
                "::",
                stringify!(pResults)
            )
        );
    }
    test_field_pResults();
}
impl Default for VkPresentInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageSwapchainCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchain: VkSwapchainKHR,
}
#[test]
fn bindgen_test_layout_VkImageSwapchainCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkImageSwapchainCreateInfoKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkImageSwapchainCreateInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageSwapchainCreateInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageSwapchainCreateInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSwapchainCreateInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSwapchainCreateInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_swapchain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).swapchain) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSwapchainCreateInfoKHR),
                "::",
                stringify!(swapchain)
            )
        );
    }
    test_field_swapchain();
}
impl Default for VkImageSwapchainCreateInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindImageMemorySwapchainInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchain: VkSwapchainKHR,
    pub imageIndex: u32,
}
#[test]
fn bindgen_test_layout_VkBindImageMemorySwapchainInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkBindImageMemorySwapchainInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkBindImageMemorySwapchainInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindImageMemorySwapchainInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkBindImageMemorySwapchainInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImageMemorySwapchainInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImageMemorySwapchainInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImageMemorySwapchainInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImageMemorySwapchainInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_swapchain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImageMemorySwapchainInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).swapchain) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImageMemorySwapchainInfoKHR),
                "::",
                stringify!(swapchain)
            )
        );
    }
    test_field_swapchain();
    fn test_field_imageIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkBindImageMemorySwapchainInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageIndex) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindImageMemorySwapchainInfoKHR),
                "::",
                stringify!(imageIndex)
            )
        );
    }
    test_field_imageIndex();
}
impl Default for VkBindImageMemorySwapchainInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAcquireNextImageInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchain: VkSwapchainKHR,
    pub timeout: u64,
    pub semaphore: VkSemaphore,
    pub fence: VkFence,
    pub deviceMask: u32,
}
#[test]
fn bindgen_test_layout_VkAcquireNextImageInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAcquireNextImageInfoKHR>(),
        56usize,
        concat!("Size of: ", stringify!(VkAcquireNextImageInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAcquireNextImageInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAcquireNextImageInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAcquireNextImageInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAcquireNextImageInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAcquireNextImageInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAcquireNextImageInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_swapchain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAcquireNextImageInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).swapchain) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAcquireNextImageInfoKHR),
                "::",
                stringify!(swapchain)
            )
        );
    }
    test_field_swapchain();
    fn test_field_timeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAcquireNextImageInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAcquireNextImageInfoKHR),
                "::",
                stringify!(timeout)
            )
        );
    }
    test_field_timeout();
    fn test_field_semaphore() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAcquireNextImageInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).semaphore) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAcquireNextImageInfoKHR),
                "::",
                stringify!(semaphore)
            )
        );
    }
    test_field_semaphore();
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAcquireNextImageInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAcquireNextImageInfoKHR),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_deviceMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAcquireNextImageInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceMask) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAcquireNextImageInfoKHR),
                "::",
                stringify!(deviceMask)
            )
        );
    }
    test_field_deviceMask();
}
impl Default for VkAcquireNextImageInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGroupPresentCapabilitiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub presentMask: [u32; 32usize],
    pub modes: VkDeviceGroupPresentModeFlagsKHR,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupPresentCapabilitiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGroupPresentCapabilitiesKHR>(),
        152usize,
        concat!("Size of: ", stringify!(VkDeviceGroupPresentCapabilitiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGroupPresentCapabilitiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceGroupPresentCapabilitiesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceGroupPresentCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupPresentCapabilitiesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceGroupPresentCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupPresentCapabilitiesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_presentMask() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceGroupPresentCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).presentMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupPresentCapabilitiesKHR),
                "::",
                stringify!(presentMask)
            )
        );
    }
    test_field_presentMask();
    fn test_field_modes() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceGroupPresentCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).modes) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupPresentCapabilitiesKHR),
                "::",
                stringify!(modes)
            )
        );
    }
    test_field_modes();
}
impl Default for VkDeviceGroupPresentCapabilitiesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGroupPresentInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchainCount: u32,
    pub pDeviceMasks: *const u32,
    pub mode: VkDeviceGroupPresentModeFlagBitsKHR,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupPresentInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGroupPresentInfoKHR>(),
        40usize,
        concat!("Size of: ", stringify!(VkDeviceGroupPresentInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGroupPresentInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceGroupPresentInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupPresentInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupPresentInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_swapchainCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).swapchainCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupPresentInfoKHR),
                "::",
                stringify!(swapchainCount)
            )
        );
    }
    test_field_swapchainCount();
    fn test_field_pDeviceMasks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDeviceMasks) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupPresentInfoKHR),
                "::",
                stringify!(pDeviceMasks)
            )
        );
    }
    test_field_pDeviceMasks();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceGroupPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupPresentInfoKHR),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
}
impl Default for VkDeviceGroupPresentInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceGroupSwapchainCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub modes: VkDeviceGroupPresentModeFlagsKHR,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupSwapchainCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceGroupSwapchainCreateInfoKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkDeviceGroupSwapchainCreateInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceGroupSwapchainCreateInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceGroupSwapchainCreateInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceGroupSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupSwapchainCreateInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceGroupSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupSwapchainCreateInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_modes() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceGroupSwapchainCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).modes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceGroupSwapchainCreateInfoKHR),
                "::",
                stringify!(modes)
            )
        );
    }
    test_field_modes();
}
impl Default for VkDeviceGroupSwapchainCreateInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCreateSwapchainKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkSwapchainCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSwapchain: *mut VkSwapchainKHR,
    ) -> VkResult,
>;
pub type PFN_vkDestroySwapchainKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetSwapchainImagesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pSwapchainImageCount: *mut u32,
        pSwapchainImages: *mut VkImage,
    ) -> VkResult,
>;
pub type PFN_vkAcquireNextImageKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        timeout: u64,
        semaphore: VkSemaphore,
        fence: VkFence,
        pImageIndex: *mut u32,
    ) -> VkResult,
>;
pub type PFN_vkQueuePresentKHR = ::std::option::Option<
    unsafe extern "C" fn(queue: VkQueue, pPresentInfo: *const VkPresentInfoKHR) -> VkResult,
>;
pub type PFN_vkGetDeviceGroupPresentCapabilitiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pDeviceGroupPresentCapabilities: *mut VkDeviceGroupPresentCapabilitiesKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetDeviceGroupSurfacePresentModesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        surface: VkSurfaceKHR,
        pModes: *mut VkDeviceGroupPresentModeFlagsKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDevicePresentRectanglesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pRectCount: *mut u32,
        pRects: *mut VkRect2D,
    ) -> VkResult,
>;
pub type PFN_vkAcquireNextImage2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pAcquireInfo: *const VkAcquireNextImageInfoKHR,
        pImageIndex: *mut u32,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkCreateSwapchainKHR(
        device: VkDevice,
        pCreateInfo: *const VkSwapchainCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSwapchain: *mut VkSwapchainKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroySwapchainKHR(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetSwapchainImagesKHR(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pSwapchainImageCount: *mut u32,
        pSwapchainImages: *mut VkImage,
    ) -> VkResult;
}
extern "C" {
    pub fn vkAcquireNextImageKHR(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        timeout: u64,
        semaphore: VkSemaphore,
        fence: VkFence,
        pImageIndex: *mut u32,
    ) -> VkResult;
}
extern "C" {
    pub fn vkQueuePresentKHR(queue: VkQueue, pPresentInfo: *const VkPresentInfoKHR) -> VkResult;
}
extern "C" {
    pub fn vkGetDeviceGroupPresentCapabilitiesKHR(
        device: VkDevice,
        pDeviceGroupPresentCapabilities: *mut VkDeviceGroupPresentCapabilitiesKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDeviceGroupSurfacePresentModesKHR(
        device: VkDevice,
        surface: VkSurfaceKHR,
        pModes: *mut VkDeviceGroupPresentModeFlagsKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDevicePresentRectanglesKHR(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pRectCount: *mut u32,
        pRects: *mut VkRect2D,
    ) -> VkResult;
}
extern "C" {
    pub fn vkAcquireNextImage2KHR(
        device: VkDevice,
        pAcquireInfo: *const VkAcquireNextImageInfoKHR,
        pImageIndex: *mut u32,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayKHR_T {
    _unused: [u8; 0],
}
pub type VkDisplayKHR = *mut VkDisplayKHR_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayModeKHR_T {
    _unused: [u8; 0],
}
pub type VkDisplayModeKHR = *mut VkDisplayModeKHR_T;
pub type VkDisplayModeCreateFlagsKHR = VkFlags;
pub const VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR: VkDisplayPlaneAlphaFlagBitsKHR = 1;
pub const VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR: VkDisplayPlaneAlphaFlagBitsKHR = 2;
pub const VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR: VkDisplayPlaneAlphaFlagBitsKHR = 4;
pub const VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR: VkDisplayPlaneAlphaFlagBitsKHR =
    8;
pub const VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR: VkDisplayPlaneAlphaFlagBitsKHR =
    2147483647;
pub type VkDisplayPlaneAlphaFlagBitsKHR = ::std::os::raw::c_int;
pub type VkDisplayPlaneAlphaFlagsKHR = VkFlags;
pub type VkDisplaySurfaceCreateFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkDisplayModeParametersKHR {
    pub visibleRegion: VkExtent2D,
    pub refreshRate: u32,
}
#[test]
fn bindgen_test_layout_VkDisplayModeParametersKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayModeParametersKHR>(),
        12usize,
        concat!("Size of: ", stringify!(VkDisplayModeParametersKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayModeParametersKHR>(),
        4usize,
        concat!("Alignment of ", stringify!(VkDisplayModeParametersKHR))
    );
    fn test_field_visibleRegion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayModeParametersKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).visibleRegion) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayModeParametersKHR),
                "::",
                stringify!(visibleRegion)
            )
        );
    }
    test_field_visibleRegion();
    fn test_field_refreshRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayModeParametersKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).refreshRate) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayModeParametersKHR),
                "::",
                stringify!(refreshRate)
            )
        );
    }
    test_field_refreshRate();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayModeCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDisplayModeCreateFlagsKHR,
    pub parameters: VkDisplayModeParametersKHR,
}
#[test]
fn bindgen_test_layout_VkDisplayModeCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayModeCreateInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkDisplayModeCreateInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayModeCreateInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayModeCreateInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayModeCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayModeCreateInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayModeCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayModeCreateInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayModeCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayModeCreateInfoKHR),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_parameters() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayModeCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parameters) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayModeCreateInfoKHR),
                "::",
                stringify!(parameters)
            )
        );
    }
    test_field_parameters();
}
impl Default for VkDisplayModeCreateInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayModePropertiesKHR {
    pub displayMode: VkDisplayModeKHR,
    pub parameters: VkDisplayModeParametersKHR,
}
#[test]
fn bindgen_test_layout_VkDisplayModePropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayModePropertiesKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkDisplayModePropertiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayModePropertiesKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayModePropertiesKHR))
    );
    fn test_field_displayMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayModePropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayMode) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayModePropertiesKHR),
                "::",
                stringify!(displayMode)
            )
        );
    }
    test_field_displayMode();
    fn test_field_parameters() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayModePropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parameters) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayModePropertiesKHR),
                "::",
                stringify!(parameters)
            )
        );
    }
    test_field_parameters();
}
impl Default for VkDisplayModePropertiesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkDisplayPlaneCapabilitiesKHR {
    pub supportedAlpha: VkDisplayPlaneAlphaFlagsKHR,
    pub minSrcPosition: VkOffset2D,
    pub maxSrcPosition: VkOffset2D,
    pub minSrcExtent: VkExtent2D,
    pub maxSrcExtent: VkExtent2D,
    pub minDstPosition: VkOffset2D,
    pub maxDstPosition: VkOffset2D,
    pub minDstExtent: VkExtent2D,
    pub maxDstExtent: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkDisplayPlaneCapabilitiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayPlaneCapabilitiesKHR>(),
        68usize,
        concat!("Size of: ", stringify!(VkDisplayPlaneCapabilitiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayPlaneCapabilitiesKHR>(),
        4usize,
        concat!("Alignment of ", stringify!(VkDisplayPlaneCapabilitiesKHR))
    );
    fn test_field_supportedAlpha() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedAlpha) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneCapabilitiesKHR),
                "::",
                stringify!(supportedAlpha)
            )
        );
    }
    test_field_supportedAlpha();
    fn test_field_minSrcPosition() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minSrcPosition) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneCapabilitiesKHR),
                "::",
                stringify!(minSrcPosition)
            )
        );
    }
    test_field_minSrcPosition();
    fn test_field_maxSrcPosition() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSrcPosition) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneCapabilitiesKHR),
                "::",
                stringify!(maxSrcPosition)
            )
        );
    }
    test_field_maxSrcPosition();
    fn test_field_minSrcExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minSrcExtent) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneCapabilitiesKHR),
                "::",
                stringify!(minSrcExtent)
            )
        );
    }
    test_field_minSrcExtent();
    fn test_field_maxSrcExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSrcExtent) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneCapabilitiesKHR),
                "::",
                stringify!(maxSrcExtent)
            )
        );
    }
    test_field_maxSrcExtent();
    fn test_field_minDstPosition() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minDstPosition) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneCapabilitiesKHR),
                "::",
                stringify!(minDstPosition)
            )
        );
    }
    test_field_minDstPosition();
    fn test_field_maxDstPosition() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDstPosition) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneCapabilitiesKHR),
                "::",
                stringify!(maxDstPosition)
            )
        );
    }
    test_field_maxDstPosition();
    fn test_field_minDstExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minDstExtent) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneCapabilitiesKHR),
                "::",
                stringify!(minDstExtent)
            )
        );
    }
    test_field_minDstExtent();
    fn test_field_maxDstExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDstExtent) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneCapabilitiesKHR),
                "::",
                stringify!(maxDstExtent)
            )
        );
    }
    test_field_maxDstExtent();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayPlanePropertiesKHR {
    pub currentDisplay: VkDisplayKHR,
    pub currentStackIndex: u32,
}
#[test]
fn bindgen_test_layout_VkDisplayPlanePropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayPlanePropertiesKHR>(),
        16usize,
        concat!("Size of: ", stringify!(VkDisplayPlanePropertiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayPlanePropertiesKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayPlanePropertiesKHR))
    );
    fn test_field_currentDisplay() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlanePropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).currentDisplay) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlanePropertiesKHR),
                "::",
                stringify!(currentDisplay)
            )
        );
    }
    test_field_currentDisplay();
    fn test_field_currentStackIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlanePropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).currentStackIndex) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlanePropertiesKHR),
                "::",
                stringify!(currentStackIndex)
            )
        );
    }
    test_field_currentStackIndex();
}
impl Default for VkDisplayPlanePropertiesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayPropertiesKHR {
    pub display: VkDisplayKHR,
    pub displayName: *const ::std::os::raw::c_char,
    pub physicalDimensions: VkExtent2D,
    pub physicalResolution: VkExtent2D,
    pub supportedTransforms: VkSurfaceTransformFlagsKHR,
    pub planeReorderPossible: VkBool32,
    pub persistentContent: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDisplayPropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayPropertiesKHR>(),
        48usize,
        concat!("Size of: ", stringify!(VkDisplayPropertiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayPropertiesKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayPropertiesKHR))
    );
    fn test_field_display() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).display) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPropertiesKHR),
                "::",
                stringify!(display)
            )
        );
    }
    test_field_display();
    fn test_field_displayName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayName) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPropertiesKHR),
                "::",
                stringify!(displayName)
            )
        );
    }
    test_field_displayName();
    fn test_field_physicalDimensions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).physicalDimensions) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPropertiesKHR),
                "::",
                stringify!(physicalDimensions)
            )
        );
    }
    test_field_physicalDimensions();
    fn test_field_physicalResolution() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).physicalResolution) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPropertiesKHR),
                "::",
                stringify!(physicalResolution)
            )
        );
    }
    test_field_physicalResolution();
    fn test_field_supportedTransforms() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedTransforms) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPropertiesKHR),
                "::",
                stringify!(supportedTransforms)
            )
        );
    }
    test_field_supportedTransforms();
    fn test_field_planeReorderPossible() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).planeReorderPossible) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPropertiesKHR),
                "::",
                stringify!(planeReorderPossible)
            )
        );
    }
    test_field_planeReorderPossible();
    fn test_field_persistentContent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).persistentContent) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPropertiesKHR),
                "::",
                stringify!(persistentContent)
            )
        );
    }
    test_field_persistentContent();
}
impl Default for VkDisplayPropertiesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplaySurfaceCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDisplaySurfaceCreateFlagsKHR,
    pub displayMode: VkDisplayModeKHR,
    pub planeIndex: u32,
    pub planeStackIndex: u32,
    pub transform: VkSurfaceTransformFlagBitsKHR,
    pub globalAlpha: f32,
    pub alphaMode: VkDisplayPlaneAlphaFlagBitsKHR,
    pub imageExtent: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkDisplaySurfaceCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplaySurfaceCreateInfoKHR>(),
        64usize,
        concat!("Size of: ", stringify!(VkDisplaySurfaceCreateInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplaySurfaceCreateInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplaySurfaceCreateInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplaySurfaceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplaySurfaceCreateInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplaySurfaceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplaySurfaceCreateInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplaySurfaceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplaySurfaceCreateInfoKHR),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_displayMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplaySurfaceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayMode) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplaySurfaceCreateInfoKHR),
                "::",
                stringify!(displayMode)
            )
        );
    }
    test_field_displayMode();
    fn test_field_planeIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplaySurfaceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).planeIndex) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplaySurfaceCreateInfoKHR),
                "::",
                stringify!(planeIndex)
            )
        );
    }
    test_field_planeIndex();
    fn test_field_planeStackIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplaySurfaceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).planeStackIndex) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplaySurfaceCreateInfoKHR),
                "::",
                stringify!(planeStackIndex)
            )
        );
    }
    test_field_planeStackIndex();
    fn test_field_transform() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplaySurfaceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transform) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplaySurfaceCreateInfoKHR),
                "::",
                stringify!(transform)
            )
        );
    }
    test_field_transform();
    fn test_field_globalAlpha() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplaySurfaceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).globalAlpha) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplaySurfaceCreateInfoKHR),
                "::",
                stringify!(globalAlpha)
            )
        );
    }
    test_field_globalAlpha();
    fn test_field_alphaMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplaySurfaceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alphaMode) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplaySurfaceCreateInfoKHR),
                "::",
                stringify!(alphaMode)
            )
        );
    }
    test_field_alphaMode();
    fn test_field_imageExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplaySurfaceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageExtent) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplaySurfaceCreateInfoKHR),
                "::",
                stringify!(imageExtent)
            )
        );
    }
    test_field_imageExtent();
}
impl Default for VkDisplaySurfaceCreateInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetPhysicalDeviceDisplayPropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayPropertiesKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayPlanePropertiesKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetDisplayPlaneSupportedDisplaysKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        planeIndex: u32,
        pDisplayCount: *mut u32,
        pDisplays: *mut VkDisplayKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetDisplayModePropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        display: VkDisplayKHR,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayModePropertiesKHR,
    ) -> VkResult,
>;
pub type PFN_vkCreateDisplayModeKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        display: VkDisplayKHR,
        pCreateInfo: *const VkDisplayModeCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pMode: *mut VkDisplayModeKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetDisplayPlaneCapabilitiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        mode: VkDisplayModeKHR,
        planeIndex: u32,
        pCapabilities: *mut VkDisplayPlaneCapabilitiesKHR,
    ) -> VkResult,
>;
pub type PFN_vkCreateDisplayPlaneSurfaceKHR = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pCreateInfo: *const VkDisplaySurfaceCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSurface: *mut VkSurfaceKHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPhysicalDeviceDisplayPropertiesKHR(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayPropertiesKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayPlanePropertiesKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDisplayPlaneSupportedDisplaysKHR(
        physicalDevice: VkPhysicalDevice,
        planeIndex: u32,
        pDisplayCount: *mut u32,
        pDisplays: *mut VkDisplayKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDisplayModePropertiesKHR(
        physicalDevice: VkPhysicalDevice,
        display: VkDisplayKHR,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayModePropertiesKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreateDisplayModeKHR(
        physicalDevice: VkPhysicalDevice,
        display: VkDisplayKHR,
        pCreateInfo: *const VkDisplayModeCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pMode: *mut VkDisplayModeKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDisplayPlaneCapabilitiesKHR(
        physicalDevice: VkPhysicalDevice,
        mode: VkDisplayModeKHR,
        planeIndex: u32,
        pCapabilities: *mut VkDisplayPlaneCapabilitiesKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreateDisplayPlaneSurfaceKHR(
        instance: VkInstance,
        pCreateInfo: *const VkDisplaySurfaceCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSurface: *mut VkSurfaceKHR,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayPresentInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcRect: VkRect2D,
    pub dstRect: VkRect2D,
    pub persistent: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDisplayPresentInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayPresentInfoKHR>(),
        56usize,
        concat!("Size of: ", stringify!(VkDisplayPresentInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayPresentInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayPresentInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPresentInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPresentInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcRect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcRect) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPresentInfoKHR),
                "::",
                stringify!(srcRect)
            )
        );
    }
    test_field_srcRect();
    fn test_field_dstRect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstRect) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPresentInfoKHR),
                "::",
                stringify!(dstRect)
            )
        );
    }
    test_field_dstRect();
    fn test_field_persistent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPresentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).persistent) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPresentInfoKHR),
                "::",
                stringify!(persistent)
            )
        );
    }
    test_field_persistent();
}
impl Default for VkDisplayPresentInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCreateSharedSwapchainsKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchainCount: u32,
        pCreateInfos: *const VkSwapchainCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSwapchains: *mut VkSwapchainKHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkCreateSharedSwapchainsKHR(
        device: VkDevice,
        swapchainCount: u32,
        pCreateInfos: *const VkSwapchainCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pSwapchains: *mut VkSwapchainKHR,
    ) -> VkResult;
}
pub type VkRenderingFlagsKHR = VkRenderingFlags;
pub use self::VkRenderingFlagBits as VkRenderingFlagBitsKHR;
pub type VkRenderingInfoKHR = VkRenderingInfo;
pub type VkRenderingAttachmentInfoKHR = VkRenderingAttachmentInfo;
pub type VkPipelineRenderingCreateInfoKHR = VkPipelineRenderingCreateInfo;
pub type VkPhysicalDeviceDynamicRenderingFeaturesKHR = VkPhysicalDeviceDynamicRenderingFeatures;
pub type VkCommandBufferInheritanceRenderingInfoKHR = VkCommandBufferInheritanceRenderingInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderingFragmentShadingRateAttachmentInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub imageView: VkImageView,
    pub imageLayout: VkImageLayout,
    pub shadingRateAttachmentTexelSize: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkRenderingFragmentShadingRateAttachmentInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderingFragmentShadingRateAttachmentInfoKHR>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkRenderingFragmentShadingRateAttachmentInfoKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderingFragmentShadingRateAttachmentInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRenderingFragmentShadingRateAttachmentInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkRenderingFragmentShadingRateAttachmentInfoKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingFragmentShadingRateAttachmentInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkRenderingFragmentShadingRateAttachmentInfoKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingFragmentShadingRateAttachmentInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_imageView() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkRenderingFragmentShadingRateAttachmentInfoKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageView) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingFragmentShadingRateAttachmentInfoKHR),
                "::",
                stringify!(imageView)
            )
        );
    }
    test_field_imageView();
    fn test_field_imageLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkRenderingFragmentShadingRateAttachmentInfoKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageLayout) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingFragmentShadingRateAttachmentInfoKHR),
                "::",
                stringify!(imageLayout)
            )
        );
    }
    test_field_imageLayout();
    fn test_field_shadingRateAttachmentTexelSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkRenderingFragmentShadingRateAttachmentInfoKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shadingRateAttachmentTexelSize) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingFragmentShadingRateAttachmentInfoKHR),
                "::",
                stringify!(shadingRateAttachmentTexelSize)
            )
        );
    }
    test_field_shadingRateAttachmentTexelSize();
}
impl Default for VkRenderingFragmentShadingRateAttachmentInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderingFragmentDensityMapAttachmentInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub imageView: VkImageView,
    pub imageLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkRenderingFragmentDensityMapAttachmentInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderingFragmentDensityMapAttachmentInfoEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkRenderingFragmentDensityMapAttachmentInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderingFragmentDensityMapAttachmentInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRenderingFragmentDensityMapAttachmentInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkRenderingFragmentDensityMapAttachmentInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingFragmentDensityMapAttachmentInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkRenderingFragmentDensityMapAttachmentInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingFragmentDensityMapAttachmentInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_imageView() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkRenderingFragmentDensityMapAttachmentInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageView) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingFragmentDensityMapAttachmentInfoEXT),
                "::",
                stringify!(imageView)
            )
        );
    }
    test_field_imageView();
    fn test_field_imageLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkRenderingFragmentDensityMapAttachmentInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageLayout) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderingFragmentDensityMapAttachmentInfoEXT),
                "::",
                stringify!(imageLayout)
            )
        );
    }
    test_field_imageLayout();
}
impl Default for VkRenderingFragmentDensityMapAttachmentInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAttachmentSampleCountInfoAMD {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub colorAttachmentCount: u32,
    pub pColorAttachmentSamples: *const VkSampleCountFlagBits,
    pub depthStencilAttachmentSamples: VkSampleCountFlagBits,
}
#[test]
fn bindgen_test_layout_VkAttachmentSampleCountInfoAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkAttachmentSampleCountInfoAMD>(),
        40usize,
        concat!("Size of: ", stringify!(VkAttachmentSampleCountInfoAMD))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAttachmentSampleCountInfoAMD>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAttachmentSampleCountInfoAMD))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentSampleCountInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentSampleCountInfoAMD),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentSampleCountInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentSampleCountInfoAMD),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_colorAttachmentCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentSampleCountInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorAttachmentCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentSampleCountInfoAMD),
                "::",
                stringify!(colorAttachmentCount)
            )
        );
    }
    test_field_colorAttachmentCount();
    fn test_field_pColorAttachmentSamples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentSampleCountInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pColorAttachmentSamples) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentSampleCountInfoAMD),
                "::",
                stringify!(pColorAttachmentSamples)
            )
        );
    }
    test_field_pColorAttachmentSamples();
    fn test_field_depthStencilAttachmentSamples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentSampleCountInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthStencilAttachmentSamples) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentSampleCountInfoAMD),
                "::",
                stringify!(depthStencilAttachmentSamples)
            )
        );
    }
    test_field_depthStencilAttachmentSamples();
}
impl Default for VkAttachmentSampleCountInfoAMD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkAttachmentSampleCountInfoNV = VkAttachmentSampleCountInfoAMD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMultiviewPerViewAttributesInfoNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub perViewAttributes: VkBool32,
    pub perViewAttributesPositionXOnly: VkBool32,
}
#[test]
fn bindgen_test_layout_VkMultiviewPerViewAttributesInfoNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkMultiviewPerViewAttributesInfoNVX>(),
        24usize,
        concat!("Size of: ", stringify!(VkMultiviewPerViewAttributesInfoNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMultiviewPerViewAttributesInfoNVX>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkMultiviewPerViewAttributesInfoNVX)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkMultiviewPerViewAttributesInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMultiviewPerViewAttributesInfoNVX),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkMultiviewPerViewAttributesInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMultiviewPerViewAttributesInfoNVX),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_perViewAttributes() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkMultiviewPerViewAttributesInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).perViewAttributes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMultiviewPerViewAttributesInfoNVX),
                "::",
                stringify!(perViewAttributes)
            )
        );
    }
    test_field_perViewAttributes();
    fn test_field_perViewAttributesPositionXOnly() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkMultiviewPerViewAttributesInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).perViewAttributesPositionXOnly) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMultiviewPerViewAttributesInfoNVX),
                "::",
                stringify!(perViewAttributesPositionXOnly)
            )
        );
    }
    test_field_perViewAttributesPositionXOnly();
}
impl Default for VkMultiviewPerViewAttributesInfoNVX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdBeginRenderingKHR = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pRenderingInfo: *const VkRenderingInfo),
>;
pub type PFN_vkCmdEndRenderingKHR =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer)>;
extern "C" {
    pub fn vkCmdBeginRenderingKHR(
        commandBuffer: VkCommandBuffer,
        pRenderingInfo: *const VkRenderingInfo,
    );
}
extern "C" {
    pub fn vkCmdEndRenderingKHR(commandBuffer: VkCommandBuffer);
}
pub type VkRenderPassMultiviewCreateInfoKHR = VkRenderPassMultiviewCreateInfo;
pub type VkPhysicalDeviceMultiviewFeaturesKHR = VkPhysicalDeviceMultiviewFeatures;
pub type VkPhysicalDeviceMultiviewPropertiesKHR = VkPhysicalDeviceMultiviewProperties;
pub type VkPhysicalDeviceFeatures2KHR = VkPhysicalDeviceFeatures2;
pub type VkPhysicalDeviceProperties2KHR = VkPhysicalDeviceProperties2;
pub type VkFormatProperties2KHR = VkFormatProperties2;
pub type VkImageFormatProperties2KHR = VkImageFormatProperties2;
pub type VkPhysicalDeviceImageFormatInfo2KHR = VkPhysicalDeviceImageFormatInfo2;
pub type VkQueueFamilyProperties2KHR = VkQueueFamilyProperties2;
pub type VkPhysicalDeviceMemoryProperties2KHR = VkPhysicalDeviceMemoryProperties2;
pub type VkSparseImageFormatProperties2KHR = VkSparseImageFormatProperties2;
pub type VkPhysicalDeviceSparseImageFormatInfo2KHR = VkPhysicalDeviceSparseImageFormatInfo2;
pub type PFN_vkGetPhysicalDeviceFeatures2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pFeatures: *mut VkPhysicalDeviceFeatures2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceFormatProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        pFormatProperties: *mut VkFormatProperties2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceImageFormatProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2,
        pImageFormatProperties: *mut VkImageFormatProperties2,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pQueueFamilyPropertyCount: *mut u32,
        pQueueFamilyProperties: *mut VkQueueFamilyProperties2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceMemoryProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2,
    ),
>;
pub type PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2,
        pPropertyCount: *mut u32,
        pProperties: *mut VkSparseImageFormatProperties2,
    ),
>;
extern "C" {
    pub fn vkGetPhysicalDeviceFeatures2KHR(
        physicalDevice: VkPhysicalDevice,
        pFeatures: *mut VkPhysicalDeviceFeatures2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        pProperties: *mut VkPhysicalDeviceProperties2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceFormatProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        pFormatProperties: *mut VkFormatProperties2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceImageFormatProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2,
        pImageFormatProperties: *mut VkImageFormatProperties2,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceQueueFamilyProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        pQueueFamilyPropertyCount: *mut u32,
        pQueueFamilyProperties: *mut VkQueueFamilyProperties2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceMemoryProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2,
        pPropertyCount: *mut u32,
        pProperties: *mut VkSparseImageFormatProperties2,
    );
}
pub type VkPeerMemoryFeatureFlagsKHR = VkPeerMemoryFeatureFlags;
pub use self::VkPeerMemoryFeatureFlagBits as VkPeerMemoryFeatureFlagBitsKHR;
pub type VkMemoryAllocateFlagsKHR = VkMemoryAllocateFlags;
pub use self::VkMemoryAllocateFlagBits as VkMemoryAllocateFlagBitsKHR;
pub type VkMemoryAllocateFlagsInfoKHR = VkMemoryAllocateFlagsInfo;
pub type VkDeviceGroupRenderPassBeginInfoKHR = VkDeviceGroupRenderPassBeginInfo;
pub type VkDeviceGroupCommandBufferBeginInfoKHR = VkDeviceGroupCommandBufferBeginInfo;
pub type VkDeviceGroupSubmitInfoKHR = VkDeviceGroupSubmitInfo;
pub type VkDeviceGroupBindSparseInfoKHR = VkDeviceGroupBindSparseInfo;
pub type VkBindBufferMemoryDeviceGroupInfoKHR = VkBindBufferMemoryDeviceGroupInfo;
pub type VkBindImageMemoryDeviceGroupInfoKHR = VkBindImageMemoryDeviceGroupInfo;
pub type PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        heapIndex: u32,
        localDeviceIndex: u32,
        remoteDeviceIndex: u32,
        pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags,
    ),
>;
pub type PFN_vkCmdSetDeviceMaskKHR =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer, deviceMask: u32)>;
pub type PFN_vkCmdDispatchBaseKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        baseGroupX: u32,
        baseGroupY: u32,
        baseGroupZ: u32,
        groupCountX: u32,
        groupCountY: u32,
        groupCountZ: u32,
    ),
>;
extern "C" {
    pub fn vkGetDeviceGroupPeerMemoryFeaturesKHR(
        device: VkDevice,
        heapIndex: u32,
        localDeviceIndex: u32,
        remoteDeviceIndex: u32,
        pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlags,
    );
}
extern "C" {
    pub fn vkCmdSetDeviceMaskKHR(commandBuffer: VkCommandBuffer, deviceMask: u32);
}
extern "C" {
    pub fn vkCmdDispatchBaseKHR(
        commandBuffer: VkCommandBuffer,
        baseGroupX: u32,
        baseGroupY: u32,
        baseGroupZ: u32,
        groupCountX: u32,
        groupCountY: u32,
        groupCountZ: u32,
    );
}
pub type VkCommandPoolTrimFlagsKHR = VkCommandPoolTrimFlags;
pub type PFN_vkTrimCommandPoolKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        commandPool: VkCommandPool,
        flags: VkCommandPoolTrimFlags,
    ),
>;
extern "C" {
    pub fn vkTrimCommandPoolKHR(
        device: VkDevice,
        commandPool: VkCommandPool,
        flags: VkCommandPoolTrimFlags,
    );
}
pub type VkPhysicalDeviceGroupPropertiesKHR = VkPhysicalDeviceGroupProperties;
pub type VkDeviceGroupDeviceCreateInfoKHR = VkDeviceGroupDeviceCreateInfo;
pub type PFN_vkEnumeratePhysicalDeviceGroupsKHR = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pPhysicalDeviceGroupCount: *mut u32,
        pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkEnumeratePhysicalDeviceGroupsKHR(
        instance: VkInstance,
        pPhysicalDeviceGroupCount: *mut u32,
        pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupProperties,
    ) -> VkResult;
}
pub type VkExternalMemoryHandleTypeFlagsKHR = VkExternalMemoryHandleTypeFlags;
pub use self::VkExternalMemoryHandleTypeFlagBits as VkExternalMemoryHandleTypeFlagBitsKHR;
pub type VkExternalMemoryFeatureFlagsKHR = VkExternalMemoryFeatureFlags;
pub use self::VkExternalMemoryFeatureFlagBits as VkExternalMemoryFeatureFlagBitsKHR;
pub type VkExternalMemoryPropertiesKHR = VkExternalMemoryProperties;
pub type VkPhysicalDeviceExternalImageFormatInfoKHR = VkPhysicalDeviceExternalImageFormatInfo;
pub type VkExternalImageFormatPropertiesKHR = VkExternalImageFormatProperties;
pub type VkPhysicalDeviceExternalBufferInfoKHR = VkPhysicalDeviceExternalBufferInfo;
pub type VkExternalBufferPropertiesKHR = VkExternalBufferProperties;
pub type VkPhysicalDeviceIDPropertiesKHR = VkPhysicalDeviceIDProperties;
pub type PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo,
        pExternalBufferProperties: *mut VkExternalBufferProperties,
    ),
>;
extern "C" {
    pub fn vkGetPhysicalDeviceExternalBufferPropertiesKHR(
        physicalDevice: VkPhysicalDevice,
        pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfo,
        pExternalBufferProperties: *mut VkExternalBufferProperties,
    );
}
pub type VkExternalMemoryImageCreateInfoKHR = VkExternalMemoryImageCreateInfo;
pub type VkExternalMemoryBufferCreateInfoKHR = VkExternalMemoryBufferCreateInfo;
pub type VkExportMemoryAllocateInfoKHR = VkExportMemoryAllocateInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImportMemoryFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleType: VkExternalMemoryHandleTypeFlagBits,
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_VkImportMemoryFdInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkImportMemoryFdInfoKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkImportMemoryFdInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImportMemoryFdInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImportMemoryFdInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportMemoryFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportMemoryFdInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportMemoryFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportMemoryFdInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_handleType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportMemoryFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportMemoryFdInfoKHR),
                "::",
                stringify!(handleType)
            )
        );
    }
    test_field_handleType();
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportMemoryFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportMemoryFdInfoKHR),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
}
impl Default for VkImportMemoryFdInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryFdPropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryTypeBits: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryFdPropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryFdPropertiesKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkMemoryFdPropertiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryFdPropertiesKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryFdPropertiesKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryFdPropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryFdPropertiesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryFdPropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryFdPropertiesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_memoryTypeBits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryFdPropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryTypeBits) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryFdPropertiesKHR),
                "::",
                stringify!(memoryTypeBits)
            )
        );
    }
    test_field_memoryTypeBits();
}
impl Default for VkMemoryFdPropertiesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryGetFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub memory: VkDeviceMemory,
    pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
#[test]
fn bindgen_test_layout_VkMemoryGetFdInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryGetFdInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkMemoryGetFdInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryGetFdInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryGetFdInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryGetFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryGetFdInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryGetFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryGetFdInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_memory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryGetFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryGetFdInfoKHR),
                "::",
                stringify!(memory)
            )
        );
    }
    test_field_memory();
    fn test_field_handleType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryGetFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleType) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryGetFdInfoKHR),
                "::",
                stringify!(handleType)
            )
        );
    }
    test_field_handleType();
}
impl Default for VkMemoryGetFdInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetMemoryFdKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pGetFdInfo: *const VkMemoryGetFdInfoKHR,
        pFd: *mut ::std::os::raw::c_int,
    ) -> VkResult,
>;
pub type PFN_vkGetMemoryFdPropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        handleType: VkExternalMemoryHandleTypeFlagBits,
        fd: ::std::os::raw::c_int,
        pMemoryFdProperties: *mut VkMemoryFdPropertiesKHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetMemoryFdKHR(
        device: VkDevice,
        pGetFdInfo: *const VkMemoryGetFdInfoKHR,
        pFd: *mut ::std::os::raw::c_int,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetMemoryFdPropertiesKHR(
        device: VkDevice,
        handleType: VkExternalMemoryHandleTypeFlagBits,
        fd: ::std::os::raw::c_int,
        pMemoryFdProperties: *mut VkMemoryFdPropertiesKHR,
    ) -> VkResult;
}
pub type VkExternalSemaphoreHandleTypeFlagsKHR = VkExternalSemaphoreHandleTypeFlags;
pub use self::VkExternalSemaphoreHandleTypeFlagBits as VkExternalSemaphoreHandleTypeFlagBitsKHR;
pub type VkExternalSemaphoreFeatureFlagsKHR = VkExternalSemaphoreFeatureFlags;
pub use self::VkExternalSemaphoreFeatureFlagBits as VkExternalSemaphoreFeatureFlagBitsKHR;
pub type VkPhysicalDeviceExternalSemaphoreInfoKHR = VkPhysicalDeviceExternalSemaphoreInfo;
pub type VkExternalSemaphorePropertiesKHR = VkExternalSemaphoreProperties;
pub type PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo,
        pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties,
    ),
>;
extern "C" {
    pub fn vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
        physicalDevice: VkPhysicalDevice,
        pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfo,
        pExternalSemaphoreProperties: *mut VkExternalSemaphoreProperties,
    );
}
pub type VkSemaphoreImportFlagsKHR = VkSemaphoreImportFlags;
pub use self::VkSemaphoreImportFlagBits as VkSemaphoreImportFlagBitsKHR;
pub type VkExportSemaphoreCreateInfoKHR = VkExportSemaphoreCreateInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImportSemaphoreFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub semaphore: VkSemaphore,
    pub flags: VkSemaphoreImportFlags,
    pub handleType: VkExternalSemaphoreHandleTypeFlagBits,
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_VkImportSemaphoreFdInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkImportSemaphoreFdInfoKHR>(),
        40usize,
        concat!("Size of: ", stringify!(VkImportSemaphoreFdInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImportSemaphoreFdInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImportSemaphoreFdInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportSemaphoreFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportSemaphoreFdInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportSemaphoreFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportSemaphoreFdInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_semaphore() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportSemaphoreFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).semaphore) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportSemaphoreFdInfoKHR),
                "::",
                stringify!(semaphore)
            )
        );
    }
    test_field_semaphore();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportSemaphoreFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportSemaphoreFdInfoKHR),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_handleType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportSemaphoreFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleType) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportSemaphoreFdInfoKHR),
                "::",
                stringify!(handleType)
            )
        );
    }
    test_field_handleType();
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportSemaphoreFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportSemaphoreFdInfoKHR),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
}
impl Default for VkImportSemaphoreFdInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSemaphoreGetFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub semaphore: VkSemaphore,
    pub handleType: VkExternalSemaphoreHandleTypeFlagBits,
}
#[test]
fn bindgen_test_layout_VkSemaphoreGetFdInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkSemaphoreGetFdInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkSemaphoreGetFdInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSemaphoreGetFdInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSemaphoreGetFdInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreGetFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreGetFdInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreGetFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreGetFdInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_semaphore() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreGetFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).semaphore) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreGetFdInfoKHR),
                "::",
                stringify!(semaphore)
            )
        );
    }
    test_field_semaphore();
    fn test_field_handleType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSemaphoreGetFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleType) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSemaphoreGetFdInfoKHR),
                "::",
                stringify!(handleType)
            )
        );
    }
    test_field_handleType();
}
impl Default for VkSemaphoreGetFdInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkImportSemaphoreFdKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pImportSemaphoreFdInfo: *const VkImportSemaphoreFdInfoKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetSemaphoreFdKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pGetFdInfo: *const VkSemaphoreGetFdInfoKHR,
        pFd: *mut ::std::os::raw::c_int,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkImportSemaphoreFdKHR(
        device: VkDevice,
        pImportSemaphoreFdInfo: *const VkImportSemaphoreFdInfoKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetSemaphoreFdKHR(
        device: VkDevice,
        pGetFdInfo: *const VkSemaphoreGetFdInfoKHR,
        pFd: *mut ::std::os::raw::c_int,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePushDescriptorPropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxPushDescriptors: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePushDescriptorPropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePushDescriptorPropertiesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePushDescriptorPropertiesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePushDescriptorPropertiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePushDescriptorPropertiesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePushDescriptorPropertiesKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePushDescriptorPropertiesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePushDescriptorPropertiesKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePushDescriptorPropertiesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxPushDescriptors() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePushDescriptorPropertiesKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPushDescriptors) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePushDescriptorPropertiesKHR),
                "::",
                stringify!(maxPushDescriptors)
            )
        );
    }
    test_field_maxPushDescriptors();
}
impl Default for VkPhysicalDevicePushDescriptorPropertiesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdPushDescriptorSetKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        layout: VkPipelineLayout,
        set: u32,
        descriptorWriteCount: u32,
        pDescriptorWrites: *const VkWriteDescriptorSet,
    ),
>;
pub type PFN_vkCmdPushDescriptorSetWithTemplateKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        layout: VkPipelineLayout,
        set: u32,
        pData: *const ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn vkCmdPushDescriptorSetKHR(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        layout: VkPipelineLayout,
        set: u32,
        descriptorWriteCount: u32,
        pDescriptorWrites: *const VkWriteDescriptorSet,
    );
}
extern "C" {
    pub fn vkCmdPushDescriptorSetWithTemplateKHR(
        commandBuffer: VkCommandBuffer,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        layout: VkPipelineLayout,
        set: u32,
        pData: *const ::std::os::raw::c_void,
    );
}
pub type VkPhysicalDeviceShaderFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;
pub type VkPhysicalDeviceFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features;
pub type VkPhysicalDevice16BitStorageFeaturesKHR = VkPhysicalDevice16BitStorageFeatures;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkRectLayerKHR {
    pub offset: VkOffset2D,
    pub extent: VkExtent2D,
    pub layer: u32,
}
#[test]
fn bindgen_test_layout_VkRectLayerKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkRectLayerKHR>(),
        20usize,
        concat!("Size of: ", stringify!(VkRectLayerKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRectLayerKHR>(),
        4usize,
        concat!("Alignment of ", stringify!(VkRectLayerKHR))
    );
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRectLayerKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRectLayerKHR),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_extent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRectLayerKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRectLayerKHR),
                "::",
                stringify!(extent)
            )
        );
    }
    test_field_extent();
    fn test_field_layer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRectLayerKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRectLayerKHR),
                "::",
                stringify!(layer)
            )
        );
    }
    test_field_layer();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPresentRegionKHR {
    pub rectangleCount: u32,
    pub pRectangles: *const VkRectLayerKHR,
}
#[test]
fn bindgen_test_layout_VkPresentRegionKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPresentRegionKHR>(),
        16usize,
        concat!("Size of: ", stringify!(VkPresentRegionKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPresentRegionKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPresentRegionKHR))
    );
    fn test_field_rectangleCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentRegionKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rectangleCount) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentRegionKHR),
                "::",
                stringify!(rectangleCount)
            )
        );
    }
    test_field_rectangleCount();
    fn test_field_pRectangles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentRegionKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pRectangles) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentRegionKHR),
                "::",
                stringify!(pRectangles)
            )
        );
    }
    test_field_pRectangles();
}
impl Default for VkPresentRegionKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPresentRegionsKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchainCount: u32,
    pub pRegions: *const VkPresentRegionKHR,
}
#[test]
fn bindgen_test_layout_VkPresentRegionsKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPresentRegionsKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkPresentRegionsKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPresentRegionsKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPresentRegionsKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentRegionsKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentRegionsKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentRegionsKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentRegionsKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_swapchainCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentRegionsKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).swapchainCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentRegionsKHR),
                "::",
                stringify!(swapchainCount)
            )
        );
    }
    test_field_swapchainCount();
    fn test_field_pRegions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentRegionsKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pRegions) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentRegionsKHR),
                "::",
                stringify!(pRegions)
            )
        );
    }
    test_field_pRegions();
}
impl Default for VkPresentRegionsKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkDescriptorUpdateTemplateKHR = VkDescriptorUpdateTemplate;
pub use self::VkDescriptorUpdateTemplateType as VkDescriptorUpdateTemplateTypeKHR;
pub type VkDescriptorUpdateTemplateCreateFlagsKHR = VkDescriptorUpdateTemplateCreateFlags;
pub type VkDescriptorUpdateTemplateEntryKHR = VkDescriptorUpdateTemplateEntry;
pub type VkDescriptorUpdateTemplateCreateInfoKHR = VkDescriptorUpdateTemplateCreateInfo;
pub type PFN_vkCreateDescriptorUpdateTemplateKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate,
    ) -> VkResult,
>;
pub type PFN_vkDestroyDescriptorUpdateTemplateKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkUpdateDescriptorSetWithTemplateKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorSet: VkDescriptorSet,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        pData: *const ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn vkCreateDescriptorUpdateTemplateKHR(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplate,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyDescriptorUpdateTemplateKHR(
        device: VkDevice,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkUpdateDescriptorSetWithTemplateKHR(
        device: VkDevice,
        descriptorSet: VkDescriptorSet,
        descriptorUpdateTemplate: VkDescriptorUpdateTemplate,
        pData: *const ::std::os::raw::c_void,
    );
}
pub type VkPhysicalDeviceImagelessFramebufferFeaturesKHR =
    VkPhysicalDeviceImagelessFramebufferFeatures;
pub type VkFramebufferAttachmentsCreateInfoKHR = VkFramebufferAttachmentsCreateInfo;
pub type VkFramebufferAttachmentImageInfoKHR = VkFramebufferAttachmentImageInfo;
pub type VkRenderPassAttachmentBeginInfoKHR = VkRenderPassAttachmentBeginInfo;
pub type VkRenderPassCreateInfo2KHR = VkRenderPassCreateInfo2;
pub type VkAttachmentDescription2KHR = VkAttachmentDescription2;
pub type VkAttachmentReference2KHR = VkAttachmentReference2;
pub type VkSubpassDescription2KHR = VkSubpassDescription2;
pub type VkSubpassDependency2KHR = VkSubpassDependency2;
pub type VkSubpassBeginInfoKHR = VkSubpassBeginInfo;
pub type VkSubpassEndInfoKHR = VkSubpassEndInfo;
pub type PFN_vkCreateRenderPass2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkRenderPassCreateInfo2,
        pAllocator: *const VkAllocationCallbacks,
        pRenderPass: *mut VkRenderPass,
    ) -> VkResult,
>;
pub type PFN_vkCmdBeginRenderPass2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pRenderPassBegin: *const VkRenderPassBeginInfo,
        pSubpassBeginInfo: *const VkSubpassBeginInfo,
    ),
>;
pub type PFN_vkCmdNextSubpass2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pSubpassBeginInfo: *const VkSubpassBeginInfo,
        pSubpassEndInfo: *const VkSubpassEndInfo,
    ),
>;
pub type PFN_vkCmdEndRenderPass2KHR = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pSubpassEndInfo: *const VkSubpassEndInfo),
>;
extern "C" {
    pub fn vkCreateRenderPass2KHR(
        device: VkDevice,
        pCreateInfo: *const VkRenderPassCreateInfo2,
        pAllocator: *const VkAllocationCallbacks,
        pRenderPass: *mut VkRenderPass,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdBeginRenderPass2KHR(
        commandBuffer: VkCommandBuffer,
        pRenderPassBegin: *const VkRenderPassBeginInfo,
        pSubpassBeginInfo: *const VkSubpassBeginInfo,
    );
}
extern "C" {
    pub fn vkCmdNextSubpass2KHR(
        commandBuffer: VkCommandBuffer,
        pSubpassBeginInfo: *const VkSubpassBeginInfo,
        pSubpassEndInfo: *const VkSubpassEndInfo,
    );
}
extern "C" {
    pub fn vkCmdEndRenderPass2KHR(
        commandBuffer: VkCommandBuffer,
        pSubpassEndInfo: *const VkSubpassEndInfo,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSharedPresentSurfaceCapabilitiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub sharedPresentSupportedUsageFlags: VkImageUsageFlags,
}
#[test]
fn bindgen_test_layout_VkSharedPresentSurfaceCapabilitiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkSharedPresentSurfaceCapabilitiesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkSharedPresentSurfaceCapabilitiesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkSharedPresentSurfaceCapabilitiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSharedPresentSurfaceCapabilitiesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSharedPresentSurfaceCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSharedPresentSurfaceCapabilitiesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSharedPresentSurfaceCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSharedPresentSurfaceCapabilitiesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_sharedPresentSupportedUsageFlags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSharedPresentSurfaceCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedPresentSupportedUsageFlags) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSharedPresentSurfaceCapabilitiesKHR),
                "::",
                stringify!(sharedPresentSupportedUsageFlags)
            )
        );
    }
    test_field_sharedPresentSupportedUsageFlags();
}
impl Default for VkSharedPresentSurfaceCapabilitiesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetSwapchainStatusKHR = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, swapchain: VkSwapchainKHR) -> VkResult,
>;
extern "C" {
    pub fn vkGetSwapchainStatusKHR(device: VkDevice, swapchain: VkSwapchainKHR) -> VkResult;
}
pub type VkExternalFenceHandleTypeFlagsKHR = VkExternalFenceHandleTypeFlags;
pub use self::VkExternalFenceHandleTypeFlagBits as VkExternalFenceHandleTypeFlagBitsKHR;
pub type VkExternalFenceFeatureFlagsKHR = VkExternalFenceFeatureFlags;
pub use self::VkExternalFenceFeatureFlagBits as VkExternalFenceFeatureFlagBitsKHR;
pub type VkPhysicalDeviceExternalFenceInfoKHR = VkPhysicalDeviceExternalFenceInfo;
pub type VkExternalFencePropertiesKHR = VkExternalFenceProperties;
pub type PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo,
        pExternalFenceProperties: *mut VkExternalFenceProperties,
    ),
>;
extern "C" {
    pub fn vkGetPhysicalDeviceExternalFencePropertiesKHR(
        physicalDevice: VkPhysicalDevice,
        pExternalFenceInfo: *const VkPhysicalDeviceExternalFenceInfo,
        pExternalFenceProperties: *mut VkExternalFenceProperties,
    );
}
pub type VkFenceImportFlagsKHR = VkFenceImportFlags;
pub use self::VkFenceImportFlagBits as VkFenceImportFlagBitsKHR;
pub type VkExportFenceCreateInfoKHR = VkExportFenceCreateInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImportFenceFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub fence: VkFence,
    pub flags: VkFenceImportFlags,
    pub handleType: VkExternalFenceHandleTypeFlagBits,
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_VkImportFenceFdInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkImportFenceFdInfoKHR>(),
        40usize,
        concat!("Size of: ", stringify!(VkImportFenceFdInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImportFenceFdInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImportFenceFdInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportFenceFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportFenceFdInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportFenceFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportFenceFdInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportFenceFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportFenceFdInfoKHR),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportFenceFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportFenceFdInfoKHR),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_handleType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportFenceFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleType) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportFenceFdInfoKHR),
                "::",
                stringify!(handleType)
            )
        );
    }
    test_field_handleType();
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportFenceFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportFenceFdInfoKHR),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
}
impl Default for VkImportFenceFdInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFenceGetFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub fence: VkFence,
    pub handleType: VkExternalFenceHandleTypeFlagBits,
}
#[test]
fn bindgen_test_layout_VkFenceGetFdInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkFenceGetFdInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkFenceGetFdInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkFenceGetFdInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkFenceGetFdInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFenceGetFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFenceGetFdInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFenceGetFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFenceGetFdInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_fence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFenceGetFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fence) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFenceGetFdInfoKHR),
                "::",
                stringify!(fence)
            )
        );
    }
    test_field_fence();
    fn test_field_handleType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkFenceGetFdInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleType) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFenceGetFdInfoKHR),
                "::",
                stringify!(handleType)
            )
        );
    }
    test_field_handleType();
}
impl Default for VkFenceGetFdInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkImportFenceFdKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pImportFenceFdInfo: *const VkImportFenceFdInfoKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetFenceFdKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pGetFdInfo: *const VkFenceGetFdInfoKHR,
        pFd: *mut ::std::os::raw::c_int,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkImportFenceFdKHR(
        device: VkDevice,
        pImportFenceFdInfo: *const VkImportFenceFdInfoKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetFenceFdKHR(
        device: VkDevice,
        pGetFdInfo: *const VkFenceGetFdInfoKHR,
        pFd: *mut ::std::os::raw::c_int,
    ) -> VkResult;
}
pub const VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR: VkPerformanceCounterUnitKHR = 0;
pub const VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR: VkPerformanceCounterUnitKHR = 1;
pub const VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR: VkPerformanceCounterUnitKHR = 2;
pub const VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR: VkPerformanceCounterUnitKHR = 3;
pub const VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR: VkPerformanceCounterUnitKHR = 4;
pub const VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR: VkPerformanceCounterUnitKHR = 5;
pub const VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR: VkPerformanceCounterUnitKHR = 6;
pub const VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR: VkPerformanceCounterUnitKHR = 7;
pub const VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR: VkPerformanceCounterUnitKHR = 8;
pub const VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR: VkPerformanceCounterUnitKHR = 9;
pub const VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR: VkPerformanceCounterUnitKHR = 10;
pub const VK_PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR: VkPerformanceCounterUnitKHR = 2147483647;
pub type VkPerformanceCounterUnitKHR = ::std::os::raw::c_int;
pub const VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR: VkPerformanceCounterScopeKHR = 0;
pub const VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR: VkPerformanceCounterScopeKHR = 1;
pub const VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR: VkPerformanceCounterScopeKHR = 2;
pub const VK_QUERY_SCOPE_COMMAND_BUFFER_KHR: VkPerformanceCounterScopeKHR = 0;
pub const VK_QUERY_SCOPE_RENDER_PASS_KHR: VkPerformanceCounterScopeKHR = 1;
pub const VK_QUERY_SCOPE_COMMAND_KHR: VkPerformanceCounterScopeKHR = 2;
pub const VK_PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR: VkPerformanceCounterScopeKHR = 2147483647;
pub type VkPerformanceCounterScopeKHR = ::std::os::raw::c_int;
pub const VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR: VkPerformanceCounterStorageKHR = 0;
pub const VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR: VkPerformanceCounterStorageKHR = 1;
pub const VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR: VkPerformanceCounterStorageKHR = 2;
pub const VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR: VkPerformanceCounterStorageKHR = 3;
pub const VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR: VkPerformanceCounterStorageKHR = 4;
pub const VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR: VkPerformanceCounterStorageKHR = 5;
pub const VK_PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR: VkPerformanceCounterStorageKHR = 2147483647;
pub type VkPerformanceCounterStorageKHR = ::std::os::raw::c_int;
pub const VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR:
    VkPerformanceCounterDescriptionFlagBitsKHR = 1;
pub const VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR:
    VkPerformanceCounterDescriptionFlagBitsKHR = 2;
pub const VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR:
    VkPerformanceCounterDescriptionFlagBitsKHR = 1;
pub const VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR:
    VkPerformanceCounterDescriptionFlagBitsKHR = 2;
pub const VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR:
    VkPerformanceCounterDescriptionFlagBitsKHR = 2147483647;
pub type VkPerformanceCounterDescriptionFlagBitsKHR = ::std::os::raw::c_int;
pub type VkPerformanceCounterDescriptionFlagsKHR = VkFlags;
pub const VK_ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR: VkAcquireProfilingLockFlagBitsKHR =
    2147483647;
pub type VkAcquireProfilingLockFlagBitsKHR = ::std::os::raw::c_int;
pub type VkAcquireProfilingLockFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePerformanceQueryFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub performanceCounterQueryPools: VkBool32,
    pub performanceCounterMultipleQueryPools: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePerformanceQueryFeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePerformanceQueryFeaturesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePerformanceQueryFeaturesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePerformanceQueryFeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePerformanceQueryFeaturesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePerformanceQueryFeaturesKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePerformanceQueryFeaturesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePerformanceQueryFeaturesKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePerformanceQueryFeaturesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_performanceCounterQueryPools() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePerformanceQueryFeaturesKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).performanceCounterQueryPools) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePerformanceQueryFeaturesKHR),
                "::",
                stringify!(performanceCounterQueryPools)
            )
        );
    }
    test_field_performanceCounterQueryPools();
    fn test_field_performanceCounterMultipleQueryPools() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePerformanceQueryFeaturesKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).performanceCounterMultipleQueryPools) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePerformanceQueryFeaturesKHR),
                "::",
                stringify!(performanceCounterMultipleQueryPools)
            )
        );
    }
    test_field_performanceCounterMultipleQueryPools();
}
impl Default for VkPhysicalDevicePerformanceQueryFeaturesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePerformanceQueryPropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub allowCommandBufferQueryCopies: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePerformanceQueryPropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePerformanceQueryPropertiesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePerformanceQueryPropertiesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePerformanceQueryPropertiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePerformanceQueryPropertiesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDevicePerformanceQueryPropertiesKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePerformanceQueryPropertiesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDevicePerformanceQueryPropertiesKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePerformanceQueryPropertiesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_allowCommandBufferQueryCopies() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDevicePerformanceQueryPropertiesKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allowCommandBufferQueryCopies) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePerformanceQueryPropertiesKHR),
                "::",
                stringify!(allowCommandBufferQueryCopies)
            )
        );
    }
    test_field_allowCommandBufferQueryCopies();
}
impl Default for VkPhysicalDevicePerformanceQueryPropertiesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPerformanceCounterKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub unit: VkPerformanceCounterUnitKHR,
    pub scope: VkPerformanceCounterScopeKHR,
    pub storage: VkPerformanceCounterStorageKHR,
    pub uuid: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_VkPerformanceCounterKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceCounterKHR>(),
        48usize,
        concat!("Size of: ", stringify!(VkPerformanceCounterKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceCounterKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPerformanceCounterKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceCounterKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceCounterKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_unit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceCounterKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unit) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterKHR),
                "::",
                stringify!(unit)
            )
        );
    }
    test_field_unit();
    fn test_field_scope() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceCounterKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scope) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterKHR),
                "::",
                stringify!(scope)
            )
        );
    }
    test_field_scope();
    fn test_field_storage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceCounterKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storage) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterKHR),
                "::",
                stringify!(storage)
            )
        );
    }
    test_field_storage();
    fn test_field_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceCounterKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterKHR),
                "::",
                stringify!(uuid)
            )
        );
    }
    test_field_uuid();
}
impl Default for VkPerformanceCounterKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPerformanceCounterDescriptionKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub flags: VkPerformanceCounterDescriptionFlagsKHR,
    pub name: [::std::os::raw::c_char; 256usize],
    pub category: [::std::os::raw::c_char; 256usize],
    pub description: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_VkPerformanceCounterDescriptionKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceCounterDescriptionKHR>(),
        792usize,
        concat!("Size of: ", stringify!(VkPerformanceCounterDescriptionKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceCounterDescriptionKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPerformanceCounterDescriptionKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPerformanceCounterDescriptionKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterDescriptionKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPerformanceCounterDescriptionKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterDescriptionKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPerformanceCounterDescriptionKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterDescriptionKHR),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPerformanceCounterDescriptionKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterDescriptionKHR),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_category() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPerformanceCounterDescriptionKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).category) as usize - ptr as usize
            },
            276usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterDescriptionKHR),
                "::",
                stringify!(category)
            )
        );
    }
    test_field_category();
    fn test_field_description() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPerformanceCounterDescriptionKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize
            },
            532usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterDescriptionKHR),
                "::",
                stringify!(description)
            )
        );
    }
    test_field_description();
}
impl Default for VkPerformanceCounterDescriptionKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueryPoolPerformanceCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub queueFamilyIndex: u32,
    pub counterIndexCount: u32,
    pub pCounterIndices: *const u32,
}
#[test]
fn bindgen_test_layout_VkQueryPoolPerformanceCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkQueryPoolPerformanceCreateInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkQueryPoolPerformanceCreateInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkQueryPoolPerformanceCreateInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkQueryPoolPerformanceCreateInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueryPoolPerformanceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueryPoolPerformanceCreateInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueryPoolPerformanceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueryPoolPerformanceCreateInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_queueFamilyIndex() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueryPoolPerformanceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queueFamilyIndex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueryPoolPerformanceCreateInfoKHR),
                "::",
                stringify!(queueFamilyIndex)
            )
        );
    }
    test_field_queueFamilyIndex();
    fn test_field_counterIndexCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueryPoolPerformanceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).counterIndexCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueryPoolPerformanceCreateInfoKHR),
                "::",
                stringify!(counterIndexCount)
            )
        );
    }
    test_field_counterIndexCount();
    fn test_field_pCounterIndices() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueryPoolPerformanceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCounterIndices) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueryPoolPerformanceCreateInfoKHR),
                "::",
                stringify!(pCounterIndices)
            )
        );
    }
    test_field_pCounterIndices();
}
impl Default for VkQueryPoolPerformanceCreateInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkPerformanceCounterResultKHR {
    pub int32: i32,
    pub int64: i64,
    pub uint32: u32,
    pub uint64: u64,
    pub float32: f32,
    pub float64: f64,
}
#[test]
fn bindgen_test_layout_VkPerformanceCounterResultKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceCounterResultKHR>(),
        8usize,
        concat!("Size of: ", stringify!(VkPerformanceCounterResultKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceCounterResultKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPerformanceCounterResultKHR))
    );
    fn test_field_int32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceCounterResultKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).int32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterResultKHR),
                "::",
                stringify!(int32)
            )
        );
    }
    test_field_int32();
    fn test_field_int64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceCounterResultKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).int64) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterResultKHR),
                "::",
                stringify!(int64)
            )
        );
    }
    test_field_int64();
    fn test_field_uint32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceCounterResultKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uint32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterResultKHR),
                "::",
                stringify!(uint32)
            )
        );
    }
    test_field_uint32();
    fn test_field_uint64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceCounterResultKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uint64) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterResultKHR),
                "::",
                stringify!(uint64)
            )
        );
    }
    test_field_uint64();
    fn test_field_float32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceCounterResultKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).float32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterResultKHR),
                "::",
                stringify!(float32)
            )
        );
    }
    test_field_float32();
    fn test_field_float64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceCounterResultKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).float64) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceCounterResultKHR),
                "::",
                stringify!(float64)
            )
        );
    }
    test_field_float64();
}
impl Default for VkPerformanceCounterResultKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAcquireProfilingLockInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkAcquireProfilingLockFlagsKHR,
    pub timeout: u64,
}
#[test]
fn bindgen_test_layout_VkAcquireProfilingLockInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAcquireProfilingLockInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkAcquireProfilingLockInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAcquireProfilingLockInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAcquireProfilingLockInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAcquireProfilingLockInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAcquireProfilingLockInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAcquireProfilingLockInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAcquireProfilingLockInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAcquireProfilingLockInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAcquireProfilingLockInfoKHR),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_timeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAcquireProfilingLockInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAcquireProfilingLockInfoKHR),
                "::",
                stringify!(timeout)
            )
        );
    }
    test_field_timeout();
}
impl Default for VkAcquireProfilingLockInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPerformanceQuerySubmitInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub counterPassIndex: u32,
}
#[test]
fn bindgen_test_layout_VkPerformanceQuerySubmitInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceQuerySubmitInfoKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkPerformanceQuerySubmitInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceQuerySubmitInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPerformanceQuerySubmitInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceQuerySubmitInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceQuerySubmitInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceQuerySubmitInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceQuerySubmitInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_counterPassIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceQuerySubmitInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).counterPassIndex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceQuerySubmitInfoKHR),
                "::",
                stringify!(counterPassIndex)
            )
        );
    }
    test_field_counterPassIndex();
}
impl Default for VkPerformanceQuerySubmitInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR =
    ::std::option::Option<
        unsafe extern "C" fn(
            physicalDevice: VkPhysicalDevice,
            queueFamilyIndex: u32,
            pCounterCount: *mut u32,
            pCounters: *mut VkPerformanceCounterKHR,
            pCounterDescriptions: *mut VkPerformanceCounterDescriptionKHR,
        ) -> VkResult,
    >;
pub type PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPerformanceQueryCreateInfo: *const VkQueryPoolPerformanceCreateInfoKHR,
        pNumPasses: *mut u32,
    ),
>;
pub type PFN_vkAcquireProfilingLockKHR = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, pInfo: *const VkAcquireProfilingLockInfoKHR) -> VkResult,
>;
pub type PFN_vkReleaseProfilingLockKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice)>;
extern "C" {
    pub fn vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
        physicalDevice: VkPhysicalDevice,
        queueFamilyIndex: u32,
        pCounterCount: *mut u32,
        pCounters: *mut VkPerformanceCounterKHR,
        pCounterDescriptions: *mut VkPerformanceCounterDescriptionKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(
        physicalDevice: VkPhysicalDevice,
        pPerformanceQueryCreateInfo: *const VkQueryPoolPerformanceCreateInfoKHR,
        pNumPasses: *mut u32,
    );
}
extern "C" {
    pub fn vkAcquireProfilingLockKHR(
        device: VkDevice,
        pInfo: *const VkAcquireProfilingLockInfoKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkReleaseProfilingLockKHR(device: VkDevice);
}
pub use self::VkPointClippingBehavior as VkPointClippingBehaviorKHR;
pub use self::VkTessellationDomainOrigin as VkTessellationDomainOriginKHR;
pub type VkPhysicalDevicePointClippingPropertiesKHR = VkPhysicalDevicePointClippingProperties;
pub type VkRenderPassInputAttachmentAspectCreateInfoKHR =
    VkRenderPassInputAttachmentAspectCreateInfo;
pub type VkInputAttachmentAspectReferenceKHR = VkInputAttachmentAspectReference;
pub type VkImageViewUsageCreateInfoKHR = VkImageViewUsageCreateInfo;
pub type VkPipelineTessellationDomainOriginStateCreateInfoKHR =
    VkPipelineTessellationDomainOriginStateCreateInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSurfaceInfo2KHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub surface: VkSurfaceKHR,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSurfaceInfo2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSurfaceInfo2KHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceSurfaceInfo2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSurfaceInfo2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPhysicalDeviceSurfaceInfo2KHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceSurfaceInfo2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSurfaceInfo2KHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceSurfaceInfo2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSurfaceInfo2KHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_surface() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceSurfaceInfo2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).surface) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSurfaceInfo2KHR),
                "::",
                stringify!(surface)
            )
        );
    }
    test_field_surface();
}
impl Default for VkPhysicalDeviceSurfaceInfo2KHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSurfaceCapabilities2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub surfaceCapabilities: VkSurfaceCapabilitiesKHR,
}
#[test]
fn bindgen_test_layout_VkSurfaceCapabilities2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkSurfaceCapabilities2KHR>(),
        72usize,
        concat!("Size of: ", stringify!(VkSurfaceCapabilities2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSurfaceCapabilities2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSurfaceCapabilities2KHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilities2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilities2KHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilities2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilities2KHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_surfaceCapabilities() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilities2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).surfaceCapabilities) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilities2KHR),
                "::",
                stringify!(surfaceCapabilities)
            )
        );
    }
    test_field_surfaceCapabilities();
}
impl Default for VkSurfaceCapabilities2KHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSurfaceFormat2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub surfaceFormat: VkSurfaceFormatKHR,
}
#[test]
fn bindgen_test_layout_VkSurfaceFormat2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkSurfaceFormat2KHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkSurfaceFormat2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSurfaceFormat2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSurfaceFormat2KHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceFormat2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceFormat2KHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceFormat2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceFormat2KHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_surfaceFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceFormat2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).surfaceFormat) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceFormat2KHR),
                "::",
                stringify!(surfaceFormat)
            )
        );
    }
    test_field_surfaceFormat();
}
impl Default for VkSurfaceFormat2KHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR,
        pSurfaceCapabilities: *mut VkSurfaceCapabilities2KHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceSurfaceFormats2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR,
        pSurfaceFormatCount: *mut u32,
        pSurfaceFormats: *mut VkSurfaceFormat2KHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceCapabilities2KHR(
        physicalDevice: VkPhysicalDevice,
        pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR,
        pSurfaceCapabilities: *mut VkSurfaceCapabilities2KHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceFormats2KHR(
        physicalDevice: VkPhysicalDevice,
        pSurfaceInfo: *const VkPhysicalDeviceSurfaceInfo2KHR,
        pSurfaceFormatCount: *mut u32,
        pSurfaceFormats: *mut VkSurfaceFormat2KHR,
    ) -> VkResult;
}
pub type VkPhysicalDeviceVariablePointerFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;
pub type VkPhysicalDeviceVariablePointersFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayProperties2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub displayProperties: VkDisplayPropertiesKHR,
}
#[test]
fn bindgen_test_layout_VkDisplayProperties2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayProperties2KHR>(),
        64usize,
        concat!("Size of: ", stringify!(VkDisplayProperties2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayProperties2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayProperties2KHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayProperties2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayProperties2KHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayProperties2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayProperties2KHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_displayProperties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayProperties2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayProperties) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayProperties2KHR),
                "::",
                stringify!(displayProperties)
            )
        );
    }
    test_field_displayProperties();
}
impl Default for VkDisplayProperties2KHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayPlaneProperties2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub displayPlaneProperties: VkDisplayPlanePropertiesKHR,
}
#[test]
fn bindgen_test_layout_VkDisplayPlaneProperties2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayPlaneProperties2KHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkDisplayPlaneProperties2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayPlaneProperties2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayPlaneProperties2KHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneProperties2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneProperties2KHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneProperties2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneProperties2KHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_displayPlaneProperties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneProperties2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPlaneProperties) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneProperties2KHR),
                "::",
                stringify!(displayPlaneProperties)
            )
        );
    }
    test_field_displayPlaneProperties();
}
impl Default for VkDisplayPlaneProperties2KHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayModeProperties2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub displayModeProperties: VkDisplayModePropertiesKHR,
}
#[test]
fn bindgen_test_layout_VkDisplayModeProperties2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayModeProperties2KHR>(),
        40usize,
        concat!("Size of: ", stringify!(VkDisplayModeProperties2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayModeProperties2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayModeProperties2KHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayModeProperties2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayModeProperties2KHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayModeProperties2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayModeProperties2KHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_displayModeProperties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayModeProperties2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayModeProperties) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayModeProperties2KHR),
                "::",
                stringify!(displayModeProperties)
            )
        );
    }
    test_field_displayModeProperties();
}
impl Default for VkDisplayModeProperties2KHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayPlaneInfo2KHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub mode: VkDisplayModeKHR,
    pub planeIndex: u32,
}
#[test]
fn bindgen_test_layout_VkDisplayPlaneInfo2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayPlaneInfo2KHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkDisplayPlaneInfo2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayPlaneInfo2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayPlaneInfo2KHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneInfo2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneInfo2KHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneInfo2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneInfo2KHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneInfo2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneInfo2KHR),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_planeIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneInfo2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).planeIndex) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneInfo2KHR),
                "::",
                stringify!(planeIndex)
            )
        );
    }
    test_field_planeIndex();
}
impl Default for VkDisplayPlaneInfo2KHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayPlaneCapabilities2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub capabilities: VkDisplayPlaneCapabilitiesKHR,
}
#[test]
fn bindgen_test_layout_VkDisplayPlaneCapabilities2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayPlaneCapabilities2KHR>(),
        88usize,
        concat!("Size of: ", stringify!(VkDisplayPlaneCapabilities2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayPlaneCapabilities2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayPlaneCapabilities2KHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneCapabilities2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneCapabilities2KHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneCapabilities2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneCapabilities2KHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_capabilities() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPlaneCapabilities2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capabilities) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPlaneCapabilities2KHR),
                "::",
                stringify!(capabilities)
            )
        );
    }
    test_field_capabilities();
}
impl Default for VkDisplayPlaneCapabilities2KHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetPhysicalDeviceDisplayProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayProperties2KHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayPlaneProperties2KHR,
    ) -> VkResult,
>;
pub type PFN_vkGetDisplayModeProperties2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        display: VkDisplayKHR,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayModeProperties2KHR,
    ) -> VkResult,
>;
pub type PFN_vkGetDisplayPlaneCapabilities2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pDisplayPlaneInfo: *const VkDisplayPlaneInfo2KHR,
        pCapabilities: *mut VkDisplayPlaneCapabilities2KHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPhysicalDeviceDisplayProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayProperties2KHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayPlaneProperties2KHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDisplayModeProperties2KHR(
        physicalDevice: VkPhysicalDevice,
        display: VkDisplayKHR,
        pPropertyCount: *mut u32,
        pProperties: *mut VkDisplayModeProperties2KHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDisplayPlaneCapabilities2KHR(
        physicalDevice: VkPhysicalDevice,
        pDisplayPlaneInfo: *const VkDisplayPlaneInfo2KHR,
        pCapabilities: *mut VkDisplayPlaneCapabilities2KHR,
    ) -> VkResult;
}
pub type VkMemoryDedicatedRequirementsKHR = VkMemoryDedicatedRequirements;
pub type VkMemoryDedicatedAllocateInfoKHR = VkMemoryDedicatedAllocateInfo;
pub type VkBufferMemoryRequirementsInfo2KHR = VkBufferMemoryRequirementsInfo2;
pub type VkImageMemoryRequirementsInfo2KHR = VkImageMemoryRequirementsInfo2;
pub type VkImageSparseMemoryRequirementsInfo2KHR = VkImageSparseMemoryRequirementsInfo2;
pub type VkMemoryRequirements2KHR = VkMemoryRequirements2;
pub type VkSparseImageMemoryRequirements2KHR = VkSparseImageMemoryRequirements2;
pub type PFN_vkGetImageMemoryRequirements2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkImageMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetBufferMemoryRequirements2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkBufferMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetImageSparseMemoryRequirements2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkImageSparseMemoryRequirementsInfo2,
        pSparseMemoryRequirementCount: *mut u32,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2,
    ),
>;
extern "C" {
    pub fn vkGetImageMemoryRequirements2KHR(
        device: VkDevice,
        pInfo: *const VkImageMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    );
}
extern "C" {
    pub fn vkGetBufferMemoryRequirements2KHR(
        device: VkDevice,
        pInfo: *const VkBufferMemoryRequirementsInfo2,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    );
}
extern "C" {
    pub fn vkGetImageSparseMemoryRequirements2KHR(
        device: VkDevice,
        pInfo: *const VkImageSparseMemoryRequirementsInfo2,
        pSparseMemoryRequirementCount: *mut u32,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2,
    );
}
pub type VkImageFormatListCreateInfoKHR = VkImageFormatListCreateInfo;
pub type VkSamplerYcbcrConversionKHR = VkSamplerYcbcrConversion;
pub use self::VkChromaLocation as VkChromaLocationKHR;
pub use self::VkSamplerYcbcrModelConversion as VkSamplerYcbcrModelConversionKHR;
pub use self::VkSamplerYcbcrRange as VkSamplerYcbcrRangeKHR;
pub type VkSamplerYcbcrConversionCreateInfoKHR = VkSamplerYcbcrConversionCreateInfo;
pub type VkSamplerYcbcrConversionInfoKHR = VkSamplerYcbcrConversionInfo;
pub type VkBindImagePlaneMemoryInfoKHR = VkBindImagePlaneMemoryInfo;
pub type VkImagePlaneMemoryRequirementsInfoKHR = VkImagePlaneMemoryRequirementsInfo;
pub type VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR =
    VkPhysicalDeviceSamplerYcbcrConversionFeatures;
pub type VkSamplerYcbcrConversionImageFormatPropertiesKHR =
    VkSamplerYcbcrConversionImageFormatProperties;
pub type PFN_vkCreateSamplerYcbcrConversionKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pYcbcrConversion: *mut VkSamplerYcbcrConversion,
    ) -> VkResult,
>;
pub type PFN_vkDestroySamplerYcbcrConversionKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        ycbcrConversion: VkSamplerYcbcrConversion,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
extern "C" {
    pub fn vkCreateSamplerYcbcrConversionKHR(
        device: VkDevice,
        pCreateInfo: *const VkSamplerYcbcrConversionCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pYcbcrConversion: *mut VkSamplerYcbcrConversion,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroySamplerYcbcrConversionKHR(
        device: VkDevice,
        ycbcrConversion: VkSamplerYcbcrConversion,
        pAllocator: *const VkAllocationCallbacks,
    );
}
pub type VkBindBufferMemoryInfoKHR = VkBindBufferMemoryInfo;
pub type VkBindImageMemoryInfoKHR = VkBindImageMemoryInfo;
pub type PFN_vkBindBufferMemory2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindBufferMemoryInfo,
    ) -> VkResult,
>;
pub type PFN_vkBindImageMemory2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindImageMemoryInfo,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkBindBufferMemory2KHR(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindBufferMemoryInfo,
    ) -> VkResult;
}
extern "C" {
    pub fn vkBindImageMemory2KHR(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindImageMemoryInfo,
    ) -> VkResult;
}
pub type VkPhysicalDeviceMaintenance3PropertiesKHR = VkPhysicalDeviceMaintenance3Properties;
pub type VkDescriptorSetLayoutSupportKHR = VkDescriptorSetLayoutSupport;
pub type PFN_vkGetDescriptorSetLayoutSupportKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
        pSupport: *mut VkDescriptorSetLayoutSupport,
    ),
>;
extern "C" {
    pub fn vkGetDescriptorSetLayoutSupportKHR(
        device: VkDevice,
        pCreateInfo: *const VkDescriptorSetLayoutCreateInfo,
        pSupport: *mut VkDescriptorSetLayoutSupport,
    );
}
pub type PFN_vkCmdDrawIndirectCountKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCmdDrawIndexedIndirectCountKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    ),
>;
extern "C" {
    pub fn vkCmdDrawIndirectCountKHR(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawIndexedIndirectCountKHR(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    );
}
pub type VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR =
    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures;
pub type VkPhysicalDevice8BitStorageFeaturesKHR = VkPhysicalDevice8BitStorageFeatures;
pub type VkPhysicalDeviceShaderAtomicInt64FeaturesKHR = VkPhysicalDeviceShaderAtomicInt64Features;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderClockFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderSubgroupClock: VkBool32,
    pub shaderDeviceClock: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderClockFeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderClockFeaturesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderClockFeaturesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderClockFeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderClockFeaturesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderClockFeaturesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderClockFeaturesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderClockFeaturesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderClockFeaturesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderSubgroupClock() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderClockFeaturesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSubgroupClock) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderClockFeaturesKHR),
                "::",
                stringify!(shaderSubgroupClock)
            )
        );
    }
    test_field_shaderSubgroupClock();
    fn test_field_shaderDeviceClock() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderClockFeaturesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderDeviceClock) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderClockFeaturesKHR),
                "::",
                stringify!(shaderDeviceClock)
            )
        );
    }
    test_field_shaderDeviceClock();
}
impl Default for VkPhysicalDeviceShaderClockFeaturesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR: VkQueueGlobalPriorityKHR = 128;
pub const VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR: VkQueueGlobalPriorityKHR = 256;
pub const VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR: VkQueueGlobalPriorityKHR = 512;
pub const VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR: VkQueueGlobalPriorityKHR = 1024;
pub const VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT: VkQueueGlobalPriorityKHR = 128;
pub const VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT: VkQueueGlobalPriorityKHR = 256;
pub const VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT: VkQueueGlobalPriorityKHR = 512;
pub const VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT: VkQueueGlobalPriorityKHR = 1024;
pub const VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM_KHR: VkQueueGlobalPriorityKHR = 2147483647;
pub type VkQueueGlobalPriorityKHR = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceQueueGlobalPriorityCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub globalPriority: VkQueueGlobalPriorityKHR,
}
#[test]
fn bindgen_test_layout_VkDeviceQueueGlobalPriorityCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceQueueGlobalPriorityCreateInfoKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDeviceQueueGlobalPriorityCreateInfoKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceQueueGlobalPriorityCreateInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceQueueGlobalPriorityCreateInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceQueueGlobalPriorityCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceQueueGlobalPriorityCreateInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceQueueGlobalPriorityCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceQueueGlobalPriorityCreateInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_globalPriority() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceQueueGlobalPriorityCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).globalPriority) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceQueueGlobalPriorityCreateInfoKHR),
                "::",
                stringify!(globalPriority)
            )
        );
    }
    test_field_globalPriority();
}
impl Default for VkDeviceQueueGlobalPriorityCreateInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub globalPriorityQuery: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_globalPriorityQuery() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).globalPriorityQuery) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR),
                "::",
                stringify!(globalPriorityQuery)
            )
        );
    }
    test_field_globalPriorityQuery();
}
impl Default for VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueueFamilyGlobalPriorityPropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub priorityCount: u32,
    pub priorities: [VkQueueGlobalPriorityKHR; 16usize],
}
#[test]
fn bindgen_test_layout_VkQueueFamilyGlobalPriorityPropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkQueueFamilyGlobalPriorityPropertiesKHR>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(VkQueueFamilyGlobalPriorityPropertiesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkQueueFamilyGlobalPriorityPropertiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkQueueFamilyGlobalPriorityPropertiesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueueFamilyGlobalPriorityPropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyGlobalPriorityPropertiesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueueFamilyGlobalPriorityPropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyGlobalPriorityPropertiesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_priorityCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueueFamilyGlobalPriorityPropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).priorityCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyGlobalPriorityPropertiesKHR),
                "::",
                stringify!(priorityCount)
            )
        );
    }
    test_field_priorityCount();
    fn test_field_priorities() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueueFamilyGlobalPriorityPropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).priorities) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyGlobalPriorityPropertiesKHR),
                "::",
                stringify!(priorities)
            )
        );
    }
    test_field_priorities();
}
impl Default for VkQueueFamilyGlobalPriorityPropertiesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub use self::VkDriverId as VkDriverIdKHR;
pub type VkConformanceVersionKHR = VkConformanceVersion;
pub type VkPhysicalDeviceDriverPropertiesKHR = VkPhysicalDeviceDriverProperties;
pub use self::VkShaderFloatControlsIndependence as VkShaderFloatControlsIndependenceKHR;
pub type VkPhysicalDeviceFloatControlsPropertiesKHR = VkPhysicalDeviceFloatControlsProperties;
pub use self::VkResolveModeFlagBits as VkResolveModeFlagBitsKHR;
pub type VkResolveModeFlagsKHR = VkResolveModeFlags;
pub type VkSubpassDescriptionDepthStencilResolveKHR = VkSubpassDescriptionDepthStencilResolve;
pub type VkPhysicalDeviceDepthStencilResolvePropertiesKHR =
    VkPhysicalDeviceDepthStencilResolveProperties;
pub use self::VkSemaphoreType as VkSemaphoreTypeKHR;
pub use self::VkSemaphoreWaitFlagBits as VkSemaphoreWaitFlagBitsKHR;
pub type VkSemaphoreWaitFlagsKHR = VkSemaphoreWaitFlags;
pub type VkPhysicalDeviceTimelineSemaphoreFeaturesKHR = VkPhysicalDeviceTimelineSemaphoreFeatures;
pub type VkPhysicalDeviceTimelineSemaphorePropertiesKHR =
    VkPhysicalDeviceTimelineSemaphoreProperties;
pub type VkSemaphoreTypeCreateInfoKHR = VkSemaphoreTypeCreateInfo;
pub type VkTimelineSemaphoreSubmitInfoKHR = VkTimelineSemaphoreSubmitInfo;
pub type VkSemaphoreWaitInfoKHR = VkSemaphoreWaitInfo;
pub type VkSemaphoreSignalInfoKHR = VkSemaphoreSignalInfo;
pub type PFN_vkGetSemaphoreCounterValueKHR = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, semaphore: VkSemaphore, pValue: *mut u64) -> VkResult,
>;
pub type PFN_vkWaitSemaphoresKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pWaitInfo: *const VkSemaphoreWaitInfo,
        timeout: u64,
    ) -> VkResult,
>;
pub type PFN_vkSignalSemaphoreKHR = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, pSignalInfo: *const VkSemaphoreSignalInfo) -> VkResult,
>;
extern "C" {
    pub fn vkGetSemaphoreCounterValueKHR(
        device: VkDevice,
        semaphore: VkSemaphore,
        pValue: *mut u64,
    ) -> VkResult;
}
extern "C" {
    pub fn vkWaitSemaphoresKHR(
        device: VkDevice,
        pWaitInfo: *const VkSemaphoreWaitInfo,
        timeout: u64,
    ) -> VkResult;
}
extern "C" {
    pub fn vkSignalSemaphoreKHR(
        device: VkDevice,
        pSignalInfo: *const VkSemaphoreSignalInfo,
    ) -> VkResult;
}
pub type VkPhysicalDeviceVulkanMemoryModelFeaturesKHR = VkPhysicalDeviceVulkanMemoryModelFeatures;
pub type VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR =
    VkPhysicalDeviceShaderTerminateInvocationFeatures;
pub const VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR: VkFragmentShadingRateCombinerOpKHR = 0;
pub const VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR: VkFragmentShadingRateCombinerOpKHR = 1;
pub const VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR: VkFragmentShadingRateCombinerOpKHR = 2;
pub const VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR: VkFragmentShadingRateCombinerOpKHR = 3;
pub const VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR: VkFragmentShadingRateCombinerOpKHR = 4;
pub const VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_ENUM_KHR: VkFragmentShadingRateCombinerOpKHR =
    2147483647;
pub type VkFragmentShadingRateCombinerOpKHR = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFragmentShadingRateAttachmentInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pFragmentShadingRateAttachment: *const VkAttachmentReference2,
    pub shadingRateAttachmentTexelSize: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkFragmentShadingRateAttachmentInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkFragmentShadingRateAttachmentInfoKHR>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkFragmentShadingRateAttachmentInfoKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkFragmentShadingRateAttachmentInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkFragmentShadingRateAttachmentInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkFragmentShadingRateAttachmentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFragmentShadingRateAttachmentInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkFragmentShadingRateAttachmentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFragmentShadingRateAttachmentInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pFragmentShadingRateAttachment() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkFragmentShadingRateAttachmentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pFragmentShadingRateAttachment) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFragmentShadingRateAttachmentInfoKHR),
                "::",
                stringify!(pFragmentShadingRateAttachment)
            )
        );
    }
    test_field_pFragmentShadingRateAttachment();
    fn test_field_shadingRateAttachmentTexelSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkFragmentShadingRateAttachmentInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shadingRateAttachmentTexelSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFragmentShadingRateAttachmentInfoKHR),
                "::",
                stringify!(shadingRateAttachmentTexelSize)
            )
        );
    }
    test_field_shadingRateAttachmentTexelSize();
}
impl Default for VkFragmentShadingRateAttachmentInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineFragmentShadingRateStateCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub fragmentSize: VkExtent2D,
    pub combinerOps: [VkFragmentShadingRateCombinerOpKHR; 2usize],
}
#[test]
fn bindgen_test_layout_VkPipelineFragmentShadingRateStateCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineFragmentShadingRateStateCreateInfoKHR>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineFragmentShadingRateStateCreateInfoKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineFragmentShadingRateStateCreateInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineFragmentShadingRateStateCreateInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineFragmentShadingRateStateCreateInfoKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineFragmentShadingRateStateCreateInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineFragmentShadingRateStateCreateInfoKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineFragmentShadingRateStateCreateInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_fragmentSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineFragmentShadingRateStateCreateInfoKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineFragmentShadingRateStateCreateInfoKHR),
                "::",
                stringify!(fragmentSize)
            )
        );
    }
    test_field_fragmentSize();
    fn test_field_combinerOps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineFragmentShadingRateStateCreateInfoKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).combinerOps) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineFragmentShadingRateStateCreateInfoKHR),
                "::",
                stringify!(combinerOps)
            )
        );
    }
    test_field_combinerOps();
}
impl Default for VkPipelineFragmentShadingRateStateCreateInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentShadingRateFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub pipelineFragmentShadingRate: VkBool32,
    pub primitiveFragmentShadingRate: VkBool32,
    pub attachmentFragmentShadingRate: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentShadingRateFeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentShadingRateFeaturesKHR>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentShadingRateFeaturesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentShadingRateFeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentShadingRateFeaturesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRateFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateFeaturesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRateFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateFeaturesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pipelineFragmentShadingRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRateFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineFragmentShadingRate) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateFeaturesKHR),
                "::",
                stringify!(pipelineFragmentShadingRate)
            )
        );
    }
    test_field_pipelineFragmentShadingRate();
    fn test_field_primitiveFragmentShadingRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRateFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).primitiveFragmentShadingRate) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateFeaturesKHR),
                "::",
                stringify!(primitiveFragmentShadingRate)
            )
        );
    }
    test_field_primitiveFragmentShadingRate();
    fn test_field_attachmentFragmentShadingRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRateFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attachmentFragmentShadingRate) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateFeaturesKHR),
                "::",
                stringify!(attachmentFragmentShadingRate)
            )
        );
    }
    test_field_attachmentFragmentShadingRate();
}
impl Default for VkPhysicalDeviceFragmentShadingRateFeaturesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentShadingRatePropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub minFragmentShadingRateAttachmentTexelSize: VkExtent2D,
    pub maxFragmentShadingRateAttachmentTexelSize: VkExtent2D,
    pub maxFragmentShadingRateAttachmentTexelSizeAspectRatio: u32,
    pub primitiveFragmentShadingRateWithMultipleViewports: VkBool32,
    pub layeredShadingRateAttachments: VkBool32,
    pub fragmentShadingRateNonTrivialCombinerOps: VkBool32,
    pub maxFragmentSize: VkExtent2D,
    pub maxFragmentSizeAspectRatio: u32,
    pub maxFragmentShadingRateCoverageSamples: u32,
    pub maxFragmentShadingRateRasterizationSamples: VkSampleCountFlagBits,
    pub fragmentShadingRateWithShaderDepthStencilWrites: VkBool32,
    pub fragmentShadingRateWithSampleMask: VkBool32,
    pub fragmentShadingRateWithShaderSampleMask: VkBool32,
    pub fragmentShadingRateWithConservativeRasterization: VkBool32,
    pub fragmentShadingRateWithFragmentShaderInterlock: VkBool32,
    pub fragmentShadingRateWithCustomSampleLocations: VkBool32,
    pub fragmentShadingRateStrictMultiplyCombiner: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentShadingRatePropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentShadingRatePropertiesKHR>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentShadingRatePropertiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_minFragmentShadingRateAttachmentTexelSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minFragmentShadingRateAttachmentTexelSize) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(minFragmentShadingRateAttachmentTexelSize)
            )
        );
    }
    test_field_minFragmentShadingRateAttachmentTexelSize();
    fn test_field_maxFragmentShadingRateAttachmentTexelSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFragmentShadingRateAttachmentTexelSize) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(maxFragmentShadingRateAttachmentTexelSize)
            )
        );
    }
    test_field_maxFragmentShadingRateAttachmentTexelSize();
    fn test_field_maxFragmentShadingRateAttachmentTexelSizeAspectRatio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFragmentShadingRateAttachmentTexelSizeAspectRatio)
                    as usize
                    - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(maxFragmentShadingRateAttachmentTexelSizeAspectRatio)
            )
        );
    }
    test_field_maxFragmentShadingRateAttachmentTexelSizeAspectRatio();
    fn test_field_primitiveFragmentShadingRateWithMultipleViewports() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).primitiveFragmentShadingRateWithMultipleViewports)
                    as usize
                    - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(primitiveFragmentShadingRateWithMultipleViewports)
            )
        );
    }
    test_field_primitiveFragmentShadingRateWithMultipleViewports();
    fn test_field_layeredShadingRateAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layeredShadingRateAttachments) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(layeredShadingRateAttachments)
            )
        );
    }
    test_field_layeredShadingRateAttachments();
    fn test_field_fragmentShadingRateNonTrivialCombinerOps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentShadingRateNonTrivialCombinerOps) as usize
                    - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(fragmentShadingRateNonTrivialCombinerOps)
            )
        );
    }
    test_field_fragmentShadingRateNonTrivialCombinerOps();
    fn test_field_maxFragmentSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFragmentSize) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(maxFragmentSize)
            )
        );
    }
    test_field_maxFragmentSize();
    fn test_field_maxFragmentSizeAspectRatio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFragmentSizeAspectRatio) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(maxFragmentSizeAspectRatio)
            )
        );
    }
    test_field_maxFragmentSizeAspectRatio();
    fn test_field_maxFragmentShadingRateCoverageSamples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFragmentShadingRateCoverageSamples) as usize
                    - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(maxFragmentShadingRateCoverageSamples)
            )
        );
    }
    test_field_maxFragmentShadingRateCoverageSamples();
    fn test_field_maxFragmentShadingRateRasterizationSamples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFragmentShadingRateRasterizationSamples) as usize
                    - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(maxFragmentShadingRateRasterizationSamples)
            )
        );
    }
    test_field_maxFragmentShadingRateRasterizationSamples();
    fn test_field_fragmentShadingRateWithShaderDepthStencilWrites() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentShadingRateWithShaderDepthStencilWrites)
                    as usize
                    - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(fragmentShadingRateWithShaderDepthStencilWrites)
            )
        );
    }
    test_field_fragmentShadingRateWithShaderDepthStencilWrites();
    fn test_field_fragmentShadingRateWithSampleMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentShadingRateWithSampleMask) as usize
                    - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(fragmentShadingRateWithSampleMask)
            )
        );
    }
    test_field_fragmentShadingRateWithSampleMask();
    fn test_field_fragmentShadingRateWithShaderSampleMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentShadingRateWithShaderSampleMask) as usize
                    - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(fragmentShadingRateWithShaderSampleMask)
            )
        );
    }
    test_field_fragmentShadingRateWithShaderSampleMask();
    fn test_field_fragmentShadingRateWithConservativeRasterization() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentShadingRateWithConservativeRasterization)
                    as usize
                    - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(fragmentShadingRateWithConservativeRasterization)
            )
        );
    }
    test_field_fragmentShadingRateWithConservativeRasterization();
    fn test_field_fragmentShadingRateWithFragmentShaderInterlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentShadingRateWithFragmentShaderInterlock) as usize
                    - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(fragmentShadingRateWithFragmentShaderInterlock)
            )
        );
    }
    test_field_fragmentShadingRateWithFragmentShaderInterlock();
    fn test_field_fragmentShadingRateWithCustomSampleLocations() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentShadingRateWithCustomSampleLocations) as usize
                    - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(fragmentShadingRateWithCustomSampleLocations)
            )
        );
    }
    test_field_fragmentShadingRateWithCustomSampleLocations();
    fn test_field_fragmentShadingRateStrictMultiplyCombiner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentShadingRateStrictMultiplyCombiner) as usize
                    - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRatePropertiesKHR),
                "::",
                stringify!(fragmentShadingRateStrictMultiplyCombiner)
            )
        );
    }
    test_field_fragmentShadingRateStrictMultiplyCombiner();
}
impl Default for VkPhysicalDeviceFragmentShadingRatePropertiesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentShadingRateKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub sampleCounts: VkSampleCountFlags,
    pub fragmentSize: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentShadingRateKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentShadingRateKHR>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentShadingRateKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentShadingRateKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentShadingRateKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFragmentShadingRateKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFragmentShadingRateKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_sampleCounts() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFragmentShadingRateKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleCounts) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateKHR),
                "::",
                stringify!(sampleCounts)
            )
        );
    }
    test_field_sampleCounts();
    fn test_field_fragmentSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceFragmentShadingRateKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentSize) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateKHR),
                "::",
                stringify!(fragmentSize)
            )
        );
    }
    test_field_fragmentSize();
}
impl Default for VkPhysicalDeviceFragmentShadingRateKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pFragmentShadingRateCount: *mut u32,
        pFragmentShadingRates: *mut VkPhysicalDeviceFragmentShadingRateKHR,
    ) -> VkResult,
>;
pub type PFN_vkCmdSetFragmentShadingRateKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pFragmentSize: *const VkExtent2D,
        combinerOps: *const VkFragmentShadingRateCombinerOpKHR,
    ),
>;
extern "C" {
    pub fn vkGetPhysicalDeviceFragmentShadingRatesKHR(
        physicalDevice: VkPhysicalDevice,
        pFragmentShadingRateCount: *mut u32,
        pFragmentShadingRates: *mut VkPhysicalDeviceFragmentShadingRateKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdSetFragmentShadingRateKHR(
        commandBuffer: VkCommandBuffer,
        pFragmentSize: *const VkExtent2D,
        combinerOps: *const VkFragmentShadingRateCombinerOpKHR,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSurfaceProtectedCapabilitiesKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub supportsProtected: VkBool32,
}
#[test]
fn bindgen_test_layout_VkSurfaceProtectedCapabilitiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkSurfaceProtectedCapabilitiesKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkSurfaceProtectedCapabilitiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSurfaceProtectedCapabilitiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSurfaceProtectedCapabilitiesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceProtectedCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceProtectedCapabilitiesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceProtectedCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceProtectedCapabilitiesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_supportsProtected() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceProtectedCapabilitiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportsProtected) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceProtectedCapabilitiesKHR),
                "::",
                stringify!(supportsProtected)
            )
        );
    }
    test_field_supportsProtected();
}
impl Default for VkSurfaceProtectedCapabilitiesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR =
    VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures;
pub type VkAttachmentReferenceStencilLayoutKHR = VkAttachmentReferenceStencilLayout;
pub type VkAttachmentDescriptionStencilLayoutKHR = VkAttachmentDescriptionStencilLayout;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePresentWaitFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub presentWait: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePresentWaitFeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePresentWaitFeaturesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePresentWaitFeaturesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePresentWaitFeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePresentWaitFeaturesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePresentWaitFeaturesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePresentWaitFeaturesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePresentWaitFeaturesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePresentWaitFeaturesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_presentWait() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePresentWaitFeaturesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).presentWait) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePresentWaitFeaturesKHR),
                "::",
                stringify!(presentWait)
            )
        );
    }
    test_field_presentWait();
}
impl Default for VkPhysicalDevicePresentWaitFeaturesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkWaitForPresentKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        presentId: u64,
        timeout: u64,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkWaitForPresentKHR(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        presentId: u64,
        timeout: u64,
    ) -> VkResult;
}
pub type VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR =
    VkPhysicalDeviceUniformBufferStandardLayoutFeatures;
pub type VkPhysicalDeviceBufferDeviceAddressFeaturesKHR =
    VkPhysicalDeviceBufferDeviceAddressFeatures;
pub type VkBufferDeviceAddressInfoKHR = VkBufferDeviceAddressInfo;
pub type VkBufferOpaqueCaptureAddressCreateInfoKHR = VkBufferOpaqueCaptureAddressCreateInfo;
pub type VkMemoryOpaqueCaptureAddressAllocateInfoKHR = VkMemoryOpaqueCaptureAddressAllocateInfo;
pub type VkDeviceMemoryOpaqueCaptureAddressInfoKHR = VkDeviceMemoryOpaqueCaptureAddressInfo;
pub type PFN_vkGetBufferDeviceAddressKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkBufferDeviceAddressInfo,
    ) -> VkDeviceAddress,
>;
pub type PFN_vkGetBufferOpaqueCaptureAddressKHR = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, pInfo: *const VkBufferDeviceAddressInfo) -> u64,
>;
pub type PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo,
    ) -> u64,
>;
extern "C" {
    pub fn vkGetBufferDeviceAddressKHR(
        device: VkDevice,
        pInfo: *const VkBufferDeviceAddressInfo,
    ) -> VkDeviceAddress;
}
extern "C" {
    pub fn vkGetBufferOpaqueCaptureAddressKHR(
        device: VkDevice,
        pInfo: *const VkBufferDeviceAddressInfo,
    ) -> u64;
}
extern "C" {
    pub fn vkGetDeviceMemoryOpaqueCaptureAddressKHR(
        device: VkDevice,
        pInfo: *const VkDeviceMemoryOpaqueCaptureAddressInfo,
    ) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeferredOperationKHR_T {
    _unused: [u8; 0],
}
pub type VkDeferredOperationKHR = *mut VkDeferredOperationKHR_T;
pub type PFN_vkCreateDeferredOperationKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pAllocator: *const VkAllocationCallbacks,
        pDeferredOperation: *mut VkDeferredOperationKHR,
    ) -> VkResult,
>;
pub type PFN_vkDestroyDeferredOperationKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        operation: VkDeferredOperationKHR,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetDeferredOperationMaxConcurrencyKHR = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, operation: VkDeferredOperationKHR) -> u32,
>;
pub type PFN_vkGetDeferredOperationResultKHR = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, operation: VkDeferredOperationKHR) -> VkResult,
>;
pub type PFN_vkDeferredOperationJoinKHR = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, operation: VkDeferredOperationKHR) -> VkResult,
>;
extern "C" {
    pub fn vkCreateDeferredOperationKHR(
        device: VkDevice,
        pAllocator: *const VkAllocationCallbacks,
        pDeferredOperation: *mut VkDeferredOperationKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyDeferredOperationKHR(
        device: VkDevice,
        operation: VkDeferredOperationKHR,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetDeferredOperationMaxConcurrencyKHR(
        device: VkDevice,
        operation: VkDeferredOperationKHR,
    ) -> u32;
}
extern "C" {
    pub fn vkGetDeferredOperationResultKHR(
        device: VkDevice,
        operation: VkDeferredOperationKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDeferredOperationJoinKHR(
        device: VkDevice,
        operation: VkDeferredOperationKHR,
    ) -> VkResult;
}
pub const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR:
    VkPipelineExecutableStatisticFormatKHR = 0;
pub const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR:
    VkPipelineExecutableStatisticFormatKHR = 1;
pub const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR:
    VkPipelineExecutableStatisticFormatKHR = 2;
pub const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR:
    VkPipelineExecutableStatisticFormatKHR = 3;
pub const VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR:
    VkPipelineExecutableStatisticFormatKHR = 2147483647;
pub type VkPipelineExecutableStatisticFormatKHR = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub pipelineExecutableInfo: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pipelineExecutableInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineExecutableInfo) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR),
                "::",
                stringify!(pipelineExecutableInfo)
            )
        );
    }
    test_field_pipelineExecutableInfo();
}
impl Default for VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pipeline: VkPipeline,
}
#[test]
fn bindgen_test_layout_VkPipelineInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineInfoKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkPipelineInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPipelineInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pipeline() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipeline) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineInfoKHR),
                "::",
                stringify!(pipeline)
            )
        );
    }
    test_field_pipeline();
}
impl Default for VkPipelineInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineExecutablePropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub stages: VkShaderStageFlags,
    pub name: [::std::os::raw::c_char; 256usize],
    pub description: [::std::os::raw::c_char; 256usize],
    pub subgroupSize: u32,
}
#[test]
fn bindgen_test_layout_VkPipelineExecutablePropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineExecutablePropertiesKHR>(),
        536usize,
        concat!("Size of: ", stringify!(VkPipelineExecutablePropertiesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineExecutablePropertiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineExecutablePropertiesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineExecutablePropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutablePropertiesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineExecutablePropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutablePropertiesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_stages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineExecutablePropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stages) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutablePropertiesKHR),
                "::",
                stringify!(stages)
            )
        );
    }
    test_field_stages();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineExecutablePropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutablePropertiesKHR),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_description() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineExecutablePropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize
            },
            276usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutablePropertiesKHR),
                "::",
                stringify!(description)
            )
        );
    }
    test_field_description();
    fn test_field_subgroupSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineExecutablePropertiesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subgroupSize) as usize - ptr as usize
            },
            532usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutablePropertiesKHR),
                "::",
                stringify!(subgroupSize)
            )
        );
    }
    test_field_subgroupSize();
}
impl Default for VkPipelineExecutablePropertiesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineExecutableInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pipeline: VkPipeline,
    pub executableIndex: u32,
}
#[test]
fn bindgen_test_layout_VkPipelineExecutableInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineExecutableInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkPipelineExecutableInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineExecutableInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPipelineExecutableInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineExecutableInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineExecutableInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pipeline() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineExecutableInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipeline) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableInfoKHR),
                "::",
                stringify!(pipeline)
            )
        );
    }
    test_field_pipeline();
    fn test_field_executableIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineExecutableInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).executableIndex) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableInfoKHR),
                "::",
                stringify!(executableIndex)
            )
        );
    }
    test_field_executableIndex();
}
impl Default for VkPipelineExecutableInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkPipelineExecutableStatisticValueKHR {
    pub b32: VkBool32,
    pub i64_: i64,
    pub u64_: u64,
    pub f64_: f64,
}
#[test]
fn bindgen_test_layout_VkPipelineExecutableStatisticValueKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineExecutableStatisticValueKHR>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineExecutableStatisticValueKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineExecutableStatisticValueKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineExecutableStatisticValueKHR)
        )
    );
    fn test_field_b32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineExecutableStatisticValueKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).b32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableStatisticValueKHR),
                "::",
                stringify!(b32)
            )
        );
    }
    test_field_b32();
    fn test_field_i64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineExecutableStatisticValueKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).i64_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableStatisticValueKHR),
                "::",
                stringify!(i64_)
            )
        );
    }
    test_field_i64();
    fn test_field_u64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineExecutableStatisticValueKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableStatisticValueKHR),
                "::",
                stringify!(u64_)
            )
        );
    }
    test_field_u64();
    fn test_field_f64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineExecutableStatisticValueKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).f64_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableStatisticValueKHR),
                "::",
                stringify!(f64_)
            )
        );
    }
    test_field_f64();
}
impl Default for VkPipelineExecutableStatisticValueKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPipelineExecutableStatisticKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub name: [::std::os::raw::c_char; 256usize],
    pub description: [::std::os::raw::c_char; 256usize],
    pub format: VkPipelineExecutableStatisticFormatKHR,
    pub value: VkPipelineExecutableStatisticValueKHR,
}
#[test]
fn bindgen_test_layout_VkPipelineExecutableStatisticKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineExecutableStatisticKHR>(),
        544usize,
        concat!("Size of: ", stringify!(VkPipelineExecutableStatisticKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineExecutableStatisticKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineExecutableStatisticKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineExecutableStatisticKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableStatisticKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineExecutableStatisticKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableStatisticKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineExecutableStatisticKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableStatisticKHR),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_description() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineExecutableStatisticKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableStatisticKHR),
                "::",
                stringify!(description)
            )
        );
    }
    test_field_description();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineExecutableStatisticKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            528usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableStatisticKHR),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineExecutableStatisticKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableStatisticKHR),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
impl Default for VkPipelineExecutableStatisticKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineExecutableInternalRepresentationKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub name: [::std::os::raw::c_char; 256usize],
    pub description: [::std::os::raw::c_char; 256usize],
    pub isText: VkBool32,
    pub dataSize: usize,
    pub pData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkPipelineExecutableInternalRepresentationKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineExecutableInternalRepresentationKHR>(),
        552usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineExecutableInternalRepresentationKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineExecutableInternalRepresentationKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineExecutableInternalRepresentationKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineExecutableInternalRepresentationKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableInternalRepresentationKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineExecutableInternalRepresentationKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableInternalRepresentationKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineExecutableInternalRepresentationKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableInternalRepresentationKHR),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_description() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineExecutableInternalRepresentationKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableInternalRepresentationKHR),
                "::",
                stringify!(description)
            )
        );
    }
    test_field_description();
    fn test_field_isText() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineExecutableInternalRepresentationKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isText) as usize - ptr as usize
            },
            528usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableInternalRepresentationKHR),
                "::",
                stringify!(isText)
            )
        );
    }
    test_field_isText();
    fn test_field_dataSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineExecutableInternalRepresentationKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataSize) as usize - ptr as usize
            },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableInternalRepresentationKHR),
                "::",
                stringify!(dataSize)
            )
        );
    }
    test_field_dataSize();
    fn test_field_pData() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineExecutableInternalRepresentationKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pData) as usize - ptr as usize
            },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineExecutableInternalRepresentationKHR),
                "::",
                stringify!(pData)
            )
        );
    }
    test_field_pData();
}
impl Default for VkPipelineExecutableInternalRepresentationKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetPipelineExecutablePropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pPipelineInfo: *const VkPipelineInfoKHR,
        pExecutableCount: *mut u32,
        pProperties: *mut VkPipelineExecutablePropertiesKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPipelineExecutableStatisticsKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pExecutableInfo: *const VkPipelineExecutableInfoKHR,
        pStatisticCount: *mut u32,
        pStatistics: *mut VkPipelineExecutableStatisticKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetPipelineExecutableInternalRepresentationsKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pExecutableInfo: *const VkPipelineExecutableInfoKHR,
        pInternalRepresentationCount: *mut u32,
        pInternalRepresentations: *mut VkPipelineExecutableInternalRepresentationKHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPipelineExecutablePropertiesKHR(
        device: VkDevice,
        pPipelineInfo: *const VkPipelineInfoKHR,
        pExecutableCount: *mut u32,
        pProperties: *mut VkPipelineExecutablePropertiesKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPipelineExecutableStatisticsKHR(
        device: VkDevice,
        pExecutableInfo: *const VkPipelineExecutableInfoKHR,
        pStatisticCount: *mut u32,
        pStatistics: *mut VkPipelineExecutableStatisticKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPipelineExecutableInternalRepresentationsKHR(
        device: VkDevice,
        pExecutableInfo: *const VkPipelineExecutableInfoKHR,
        pInternalRepresentationCount: *mut u32,
        pInternalRepresentations: *mut VkPipelineExecutableInternalRepresentationKHR,
    ) -> VkResult;
}
pub type VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR =
    VkPhysicalDeviceShaderIntegerDotProductFeatures;
pub type VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR =
    VkPhysicalDeviceShaderIntegerDotProductProperties;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineLibraryCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub libraryCount: u32,
    pub pLibraries: *const VkPipeline,
}
#[test]
fn bindgen_test_layout_VkPipelineLibraryCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineLibraryCreateInfoKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkPipelineLibraryCreateInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineLibraryCreateInfoKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPipelineLibraryCreateInfoKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineLibraryCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineLibraryCreateInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineLibraryCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineLibraryCreateInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_libraryCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineLibraryCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).libraryCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineLibraryCreateInfoKHR),
                "::",
                stringify!(libraryCount)
            )
        );
    }
    test_field_libraryCount();
    fn test_field_pLibraries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineLibraryCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pLibraries) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineLibraryCreateInfoKHR),
                "::",
                stringify!(pLibraries)
            )
        );
    }
    test_field_pLibraries();
}
impl Default for VkPipelineLibraryCreateInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPresentIdKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchainCount: u32,
    pub pPresentIds: *const u64,
}
#[test]
fn bindgen_test_layout_VkPresentIdKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPresentIdKHR>(),
        32usize,
        concat!("Size of: ", stringify!(VkPresentIdKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPresentIdKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPresentIdKHR))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentIdKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentIdKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentIdKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentIdKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_swapchainCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentIdKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).swapchainCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentIdKHR),
                "::",
                stringify!(swapchainCount)
            )
        );
    }
    test_field_swapchainCount();
    fn test_field_pPresentIds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentIdKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pPresentIds) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentIdKHR),
                "::",
                stringify!(pPresentIds)
            )
        );
    }
    test_field_pPresentIds();
}
impl Default for VkPresentIdKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePresentIdFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub presentId: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePresentIdFeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePresentIdFeaturesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePresentIdFeaturesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePresentIdFeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePresentIdFeaturesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePresentIdFeaturesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePresentIdFeaturesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePresentIdFeaturesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePresentIdFeaturesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_presentId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePresentIdFeaturesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).presentId) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePresentIdFeaturesKHR),
                "::",
                stringify!(presentId)
            )
        );
    }
    test_field_presentId();
}
impl Default for VkPhysicalDevicePresentIdFeaturesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPipelineStageFlags2KHR = VkPipelineStageFlags2;
pub type VkPipelineStageFlagBits2KHR = VkPipelineStageFlagBits2;
pub type VkAccessFlags2KHR = VkAccessFlags2;
pub type VkAccessFlagBits2KHR = VkAccessFlagBits2;
pub use self::VkSubmitFlagBits as VkSubmitFlagBitsKHR;
pub type VkSubmitFlagsKHR = VkSubmitFlags;
pub type VkMemoryBarrier2KHR = VkMemoryBarrier2;
pub type VkBufferMemoryBarrier2KHR = VkBufferMemoryBarrier2;
pub type VkImageMemoryBarrier2KHR = VkImageMemoryBarrier2;
pub type VkDependencyInfoKHR = VkDependencyInfo;
pub type VkSubmitInfo2KHR = VkSubmitInfo2;
pub type VkSemaphoreSubmitInfoKHR = VkSemaphoreSubmitInfo;
pub type VkCommandBufferSubmitInfoKHR = VkCommandBufferSubmitInfo;
pub type VkPhysicalDeviceSynchronization2FeaturesKHR = VkPhysicalDeviceSynchronization2Features;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueueFamilyCheckpointProperties2NV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub checkpointExecutionStageMask: VkPipelineStageFlags2,
}
#[test]
fn bindgen_test_layout_VkQueueFamilyCheckpointProperties2NV() {
    assert_eq!(
        ::std::mem::size_of::<VkQueueFamilyCheckpointProperties2NV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkQueueFamilyCheckpointProperties2NV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkQueueFamilyCheckpointProperties2NV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkQueueFamilyCheckpointProperties2NV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueueFamilyCheckpointProperties2NV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyCheckpointProperties2NV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueueFamilyCheckpointProperties2NV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyCheckpointProperties2NV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_checkpointExecutionStageMask() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueueFamilyCheckpointProperties2NV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).checkpointExecutionStageMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyCheckpointProperties2NV),
                "::",
                stringify!(checkpointExecutionStageMask)
            )
        );
    }
    test_field_checkpointExecutionStageMask();
}
impl Default for VkQueueFamilyCheckpointProperties2NV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCheckpointData2NV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub stage: VkPipelineStageFlags2,
    pub pCheckpointMarker: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkCheckpointData2NV() {
    assert_eq!(
        ::std::mem::size_of::<VkCheckpointData2NV>(),
        32usize,
        concat!("Size of: ", stringify!(VkCheckpointData2NV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCheckpointData2NV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCheckpointData2NV))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCheckpointData2NV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCheckpointData2NV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCheckpointData2NV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCheckpointData2NV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_stage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCheckpointData2NV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stage) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCheckpointData2NV),
                "::",
                stringify!(stage)
            )
        );
    }
    test_field_stage();
    fn test_field_pCheckpointMarker() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCheckpointData2NV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCheckpointMarker) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCheckpointData2NV),
                "::",
                stringify!(pCheckpointMarker)
            )
        );
    }
    test_field_pCheckpointMarker();
}
impl Default for VkCheckpointData2NV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdSetEvent2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        pDependencyInfo: *const VkDependencyInfo,
    ),
>;
pub type PFN_vkCmdResetEvent2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        stageMask: VkPipelineStageFlags2,
    ),
>;
pub type PFN_vkCmdWaitEvents2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        eventCount: u32,
        pEvents: *const VkEvent,
        pDependencyInfos: *const VkDependencyInfo,
    ),
>;
pub type PFN_vkCmdPipelineBarrier2KHR = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pDependencyInfo: *const VkDependencyInfo),
>;
pub type PFN_vkCmdWriteTimestamp2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        stage: VkPipelineStageFlags2,
        queryPool: VkQueryPool,
        query: u32,
    ),
>;
pub type PFN_vkQueueSubmit2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        queue: VkQueue,
        submitCount: u32,
        pSubmits: *const VkSubmitInfo2,
        fence: VkFence,
    ) -> VkResult,
>;
pub type PFN_vkCmdWriteBufferMarker2AMD = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        stage: VkPipelineStageFlags2,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        marker: u32,
    ),
>;
pub type PFN_vkGetQueueCheckpointData2NV = ::std::option::Option<
    unsafe extern "C" fn(
        queue: VkQueue,
        pCheckpointDataCount: *mut u32,
        pCheckpointData: *mut VkCheckpointData2NV,
    ),
>;
extern "C" {
    pub fn vkCmdSetEvent2KHR(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        pDependencyInfo: *const VkDependencyInfo,
    );
}
extern "C" {
    pub fn vkCmdResetEvent2KHR(
        commandBuffer: VkCommandBuffer,
        event: VkEvent,
        stageMask: VkPipelineStageFlags2,
    );
}
extern "C" {
    pub fn vkCmdWaitEvents2KHR(
        commandBuffer: VkCommandBuffer,
        eventCount: u32,
        pEvents: *const VkEvent,
        pDependencyInfos: *const VkDependencyInfo,
    );
}
extern "C" {
    pub fn vkCmdPipelineBarrier2KHR(
        commandBuffer: VkCommandBuffer,
        pDependencyInfo: *const VkDependencyInfo,
    );
}
extern "C" {
    pub fn vkCmdWriteTimestamp2KHR(
        commandBuffer: VkCommandBuffer,
        stage: VkPipelineStageFlags2,
        queryPool: VkQueryPool,
        query: u32,
    );
}
extern "C" {
    pub fn vkQueueSubmit2KHR(
        queue: VkQueue,
        submitCount: u32,
        pSubmits: *const VkSubmitInfo2,
        fence: VkFence,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdWriteBufferMarker2AMD(
        commandBuffer: VkCommandBuffer,
        stage: VkPipelineStageFlags2,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        marker: u32,
    );
}
extern "C" {
    pub fn vkGetQueueCheckpointData2NV(
        queue: VkQueue,
        pCheckpointDataCount: *mut u32,
        pCheckpointData: *mut VkCheckpointData2NV,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub fragmentShaderBarycentric: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_fragmentShaderBarycentric() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentShaderBarycentric) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR),
                "::",
                stringify!(fragmentShaderBarycentric)
            )
        );
    }
    test_field_fragmentShaderBarycentric();
}
impl Default for VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub triStripVertexOrderIndependentOfProvokingVertex: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_triStripVertexOrderIndependentOfProvokingVertex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).triStripVertexOrderIndependentOfProvokingVertex)
                    as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR),
                "::",
                stringify!(triStripVertexOrderIndependentOfProvokingVertex)
            )
        );
    }
    test_field_triStripVertexOrderIndependentOfProvokingVertex();
}
impl Default for VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderSubgroupUniformControlFlow: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderSubgroupUniformControlFlow() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSubgroupUniformControlFlow) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR),
                "::",
                stringify!(shaderSubgroupUniformControlFlow)
            )
        );
    }
    test_field_shaderSubgroupUniformControlFlow();
}
impl Default for VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR =
    VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub workgroupMemoryExplicitLayout: VkBool32,
    pub workgroupMemoryExplicitLayoutScalarBlockLayout: VkBool32,
    pub workgroupMemoryExplicitLayout8BitAccess: VkBool32,
    pub workgroupMemoryExplicitLayout16BitAccess: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_workgroupMemoryExplicitLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).workgroupMemoryExplicitLayout) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR),
                "::",
                stringify!(workgroupMemoryExplicitLayout)
            )
        );
    }
    test_field_workgroupMemoryExplicitLayout();
    fn test_field_workgroupMemoryExplicitLayoutScalarBlockLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).workgroupMemoryExplicitLayoutScalarBlockLayout) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR),
                "::",
                stringify!(workgroupMemoryExplicitLayoutScalarBlockLayout)
            )
        );
    }
    test_field_workgroupMemoryExplicitLayoutScalarBlockLayout();
    fn test_field_workgroupMemoryExplicitLayout8BitAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).workgroupMemoryExplicitLayout8BitAccess) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR),
                "::",
                stringify!(workgroupMemoryExplicitLayout8BitAccess)
            )
        );
    }
    test_field_workgroupMemoryExplicitLayout8BitAccess();
    fn test_field_workgroupMemoryExplicitLayout16BitAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).workgroupMemoryExplicitLayout16BitAccess) as usize
                    - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR),
                "::",
                stringify!(workgroupMemoryExplicitLayout16BitAccess)
            )
        );
    }
    test_field_workgroupMemoryExplicitLayout16BitAccess();
}
impl Default for VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkCopyBufferInfo2KHR = VkCopyBufferInfo2;
pub type VkCopyImageInfo2KHR = VkCopyImageInfo2;
pub type VkCopyBufferToImageInfo2KHR = VkCopyBufferToImageInfo2;
pub type VkCopyImageToBufferInfo2KHR = VkCopyImageToBufferInfo2;
pub type VkBlitImageInfo2KHR = VkBlitImageInfo2;
pub type VkResolveImageInfo2KHR = VkResolveImageInfo2;
pub type VkBufferCopy2KHR = VkBufferCopy2;
pub type VkImageCopy2KHR = VkImageCopy2;
pub type VkImageBlit2KHR = VkImageBlit2;
pub type VkBufferImageCopy2KHR = VkBufferImageCopy2;
pub type VkImageResolve2KHR = VkImageResolve2;
pub type PFN_vkCmdCopyBuffer2KHR = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pCopyBufferInfo: *const VkCopyBufferInfo2),
>;
pub type PFN_vkCmdCopyImage2KHR = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pCopyImageInfo: *const VkCopyImageInfo2),
>;
pub type PFN_vkCmdCopyBufferToImage2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pCopyBufferToImageInfo: *const VkCopyBufferToImageInfo2,
    ),
>;
pub type PFN_vkCmdCopyImageToBuffer2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pCopyImageToBufferInfo: *const VkCopyImageToBufferInfo2,
    ),
>;
pub type PFN_vkCmdBlitImage2KHR = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pBlitImageInfo: *const VkBlitImageInfo2),
>;
pub type PFN_vkCmdResolveImage2KHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pResolveImageInfo: *const VkResolveImageInfo2,
    ),
>;
extern "C" {
    pub fn vkCmdCopyBuffer2KHR(
        commandBuffer: VkCommandBuffer,
        pCopyBufferInfo: *const VkCopyBufferInfo2,
    );
}
extern "C" {
    pub fn vkCmdCopyImage2KHR(
        commandBuffer: VkCommandBuffer,
        pCopyImageInfo: *const VkCopyImageInfo2,
    );
}
extern "C" {
    pub fn vkCmdCopyBufferToImage2KHR(
        commandBuffer: VkCommandBuffer,
        pCopyBufferToImageInfo: *const VkCopyBufferToImageInfo2,
    );
}
extern "C" {
    pub fn vkCmdCopyImageToBuffer2KHR(
        commandBuffer: VkCommandBuffer,
        pCopyImageToBufferInfo: *const VkCopyImageToBufferInfo2,
    );
}
extern "C" {
    pub fn vkCmdBlitImage2KHR(
        commandBuffer: VkCommandBuffer,
        pBlitImageInfo: *const VkBlitImageInfo2,
    );
}
extern "C" {
    pub fn vkCmdResolveImage2KHR(
        commandBuffer: VkCommandBuffer,
        pResolveImageInfo: *const VkResolveImageInfo2,
    );
}
pub type VkFormatFeatureFlags2KHR = VkFormatFeatureFlags2;
pub type VkFormatFeatureFlagBits2KHR = VkFormatFeatureFlagBits2;
pub type VkFormatProperties3KHR = VkFormatProperties3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub rayTracingMaintenance1: VkBool32,
    pub rayTracingPipelineTraceRaysIndirect2: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_rayTracingMaintenance1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rayTracingMaintenance1) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR),
                "::",
                stringify!(rayTracingMaintenance1)
            )
        );
    }
    test_field_rayTracingMaintenance1();
    fn test_field_rayTracingPipelineTraceRaysIndirect2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rayTracingPipelineTraceRaysIndirect2) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR),
                "::",
                stringify!(rayTracingPipelineTraceRaysIndirect2)
            )
        );
    }
    test_field_rayTracingPipelineTraceRaysIndirect2();
}
impl Default for VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkTraceRaysIndirectCommand2KHR {
    pub raygenShaderRecordAddress: VkDeviceAddress,
    pub raygenShaderRecordSize: VkDeviceSize,
    pub missShaderBindingTableAddress: VkDeviceAddress,
    pub missShaderBindingTableSize: VkDeviceSize,
    pub missShaderBindingTableStride: VkDeviceSize,
    pub hitShaderBindingTableAddress: VkDeviceAddress,
    pub hitShaderBindingTableSize: VkDeviceSize,
    pub hitShaderBindingTableStride: VkDeviceSize,
    pub callableShaderBindingTableAddress: VkDeviceAddress,
    pub callableShaderBindingTableSize: VkDeviceSize,
    pub callableShaderBindingTableStride: VkDeviceSize,
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
#[test]
fn bindgen_test_layout_VkTraceRaysIndirectCommand2KHR() {
    assert_eq!(
        ::std::mem::size_of::<VkTraceRaysIndirectCommand2KHR>(),
        104usize,
        concat!("Size of: ", stringify!(VkTraceRaysIndirectCommand2KHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkTraceRaysIndirectCommand2KHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkTraceRaysIndirectCommand2KHR))
    );
    fn test_field_raygenShaderRecordAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommand2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raygenShaderRecordAddress) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommand2KHR),
                "::",
                stringify!(raygenShaderRecordAddress)
            )
        );
    }
    test_field_raygenShaderRecordAddress();
    fn test_field_raygenShaderRecordSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommand2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raygenShaderRecordSize) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommand2KHR),
                "::",
                stringify!(raygenShaderRecordSize)
            )
        );
    }
    test_field_raygenShaderRecordSize();
    fn test_field_missShaderBindingTableAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommand2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).missShaderBindingTableAddress) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommand2KHR),
                "::",
                stringify!(missShaderBindingTableAddress)
            )
        );
    }
    test_field_missShaderBindingTableAddress();
    fn test_field_missShaderBindingTableSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommand2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).missShaderBindingTableSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommand2KHR),
                "::",
                stringify!(missShaderBindingTableSize)
            )
        );
    }
    test_field_missShaderBindingTableSize();
    fn test_field_missShaderBindingTableStride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommand2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).missShaderBindingTableStride) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommand2KHR),
                "::",
                stringify!(missShaderBindingTableStride)
            )
        );
    }
    test_field_missShaderBindingTableStride();
    fn test_field_hitShaderBindingTableAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommand2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hitShaderBindingTableAddress) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommand2KHR),
                "::",
                stringify!(hitShaderBindingTableAddress)
            )
        );
    }
    test_field_hitShaderBindingTableAddress();
    fn test_field_hitShaderBindingTableSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommand2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hitShaderBindingTableSize) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommand2KHR),
                "::",
                stringify!(hitShaderBindingTableSize)
            )
        );
    }
    test_field_hitShaderBindingTableSize();
    fn test_field_hitShaderBindingTableStride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommand2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hitShaderBindingTableStride) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommand2KHR),
                "::",
                stringify!(hitShaderBindingTableStride)
            )
        );
    }
    test_field_hitShaderBindingTableStride();
    fn test_field_callableShaderBindingTableAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommand2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).callableShaderBindingTableAddress) as usize
                    - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommand2KHR),
                "::",
                stringify!(callableShaderBindingTableAddress)
            )
        );
    }
    test_field_callableShaderBindingTableAddress();
    fn test_field_callableShaderBindingTableSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommand2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).callableShaderBindingTableSize) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommand2KHR),
                "::",
                stringify!(callableShaderBindingTableSize)
            )
        );
    }
    test_field_callableShaderBindingTableSize();
    fn test_field_callableShaderBindingTableStride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommand2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).callableShaderBindingTableStride) as usize
                    - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommand2KHR),
                "::",
                stringify!(callableShaderBindingTableStride)
            )
        );
    }
    test_field_callableShaderBindingTableStride();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommand2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommand2KHR),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommand2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommand2KHR),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommand2KHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommand2KHR),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
}
pub type PFN_vkCmdTraceRaysIndirect2KHR = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, indirectDeviceAddress: VkDeviceAddress),
>;
extern "C" {
    pub fn vkCmdTraceRaysIndirect2KHR(
        commandBuffer: VkCommandBuffer,
        indirectDeviceAddress: VkDeviceAddress,
    );
}
pub type VkPhysicalDeviceMaintenance4FeaturesKHR = VkPhysicalDeviceMaintenance4Features;
pub type VkPhysicalDeviceMaintenance4PropertiesKHR = VkPhysicalDeviceMaintenance4Properties;
pub type VkDeviceBufferMemoryRequirementsKHR = VkDeviceBufferMemoryRequirements;
pub type VkDeviceImageMemoryRequirementsKHR = VkDeviceImageMemoryRequirements;
pub type PFN_vkGetDeviceBufferMemoryRequirementsKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkDeviceBufferMemoryRequirements,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetDeviceImageMemoryRequirementsKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkDeviceImageMemoryRequirements,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkGetDeviceImageSparseMemoryRequirementsKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkDeviceImageMemoryRequirements,
        pSparseMemoryRequirementCount: *mut u32,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2,
    ),
>;
extern "C" {
    pub fn vkGetDeviceBufferMemoryRequirementsKHR(
        device: VkDevice,
        pInfo: *const VkDeviceBufferMemoryRequirements,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    );
}
extern "C" {
    pub fn vkGetDeviceImageMemoryRequirementsKHR(
        device: VkDevice,
        pInfo: *const VkDeviceImageMemoryRequirements,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    );
}
extern "C" {
    pub fn vkGetDeviceImageSparseMemoryRequirementsKHR(
        device: VkDevice,
        pInfo: *const VkDeviceImageMemoryRequirements,
        pSparseMemoryRequirementCount: *mut u32,
        pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements2,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugReportCallbackEXT_T {
    _unused: [u8; 0],
}
pub type VkDebugReportCallbackEXT = *mut VkDebugReportCallbackEXT_T;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT: VkDebugReportObjectTypeEXT = 0;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT: VkDebugReportObjectTypeEXT = 1;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT: VkDebugReportObjectTypeEXT = 2;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT: VkDebugReportObjectTypeEXT = 3;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT: VkDebugReportObjectTypeEXT = 4;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT: VkDebugReportObjectTypeEXT = 5;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT: VkDebugReportObjectTypeEXT = 6;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT: VkDebugReportObjectTypeEXT = 7;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT: VkDebugReportObjectTypeEXT = 8;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT: VkDebugReportObjectTypeEXT = 9;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT: VkDebugReportObjectTypeEXT = 10;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT: VkDebugReportObjectTypeEXT = 11;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT: VkDebugReportObjectTypeEXT = 12;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT: VkDebugReportObjectTypeEXT = 13;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT: VkDebugReportObjectTypeEXT = 14;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT: VkDebugReportObjectTypeEXT = 15;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT: VkDebugReportObjectTypeEXT = 16;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT: VkDebugReportObjectTypeEXT = 17;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT: VkDebugReportObjectTypeEXT = 18;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT: VkDebugReportObjectTypeEXT = 19;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT: VkDebugReportObjectTypeEXT = 20;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT: VkDebugReportObjectTypeEXT = 21;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT: VkDebugReportObjectTypeEXT = 22;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT: VkDebugReportObjectTypeEXT = 23;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT: VkDebugReportObjectTypeEXT = 24;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT: VkDebugReportObjectTypeEXT = 25;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT: VkDebugReportObjectTypeEXT = 26;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT: VkDebugReportObjectTypeEXT = 27;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT: VkDebugReportObjectTypeEXT =
    28;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT: VkDebugReportObjectTypeEXT = 29;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT: VkDebugReportObjectTypeEXT = 30;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT: VkDebugReportObjectTypeEXT = 33;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT: VkDebugReportObjectTypeEXT =
    1000156000;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT: VkDebugReportObjectTypeEXT =
    1000085000;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT: VkDebugReportObjectTypeEXT = 1000029000;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT: VkDebugReportObjectTypeEXT = 1000029001;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT: VkDebugReportObjectTypeEXT =
    1000150000;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT: VkDebugReportObjectTypeEXT =
    1000165000;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT: VkDebugReportObjectTypeEXT =
    1000366000;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT: VkDebugReportObjectTypeEXT = 28;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT: VkDebugReportObjectTypeEXT = 33;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT:
    VkDebugReportObjectTypeEXT = 1000085000;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT: VkDebugReportObjectTypeEXT =
    1000156000;
pub const VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT: VkDebugReportObjectTypeEXT = 2147483647;
pub type VkDebugReportObjectTypeEXT = ::std::os::raw::c_int;
pub const VK_DEBUG_REPORT_INFORMATION_BIT_EXT: VkDebugReportFlagBitsEXT = 1;
pub const VK_DEBUG_REPORT_WARNING_BIT_EXT: VkDebugReportFlagBitsEXT = 2;
pub const VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT: VkDebugReportFlagBitsEXT = 4;
pub const VK_DEBUG_REPORT_ERROR_BIT_EXT: VkDebugReportFlagBitsEXT = 8;
pub const VK_DEBUG_REPORT_DEBUG_BIT_EXT: VkDebugReportFlagBitsEXT = 16;
pub const VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT: VkDebugReportFlagBitsEXT = 2147483647;
pub type VkDebugReportFlagBitsEXT = ::std::os::raw::c_int;
pub type VkDebugReportFlagsEXT = VkFlags;
pub type PFN_vkDebugReportCallbackEXT = ::std::option::Option<
    unsafe extern "C" fn(
        flags: VkDebugReportFlagsEXT,
        objectType: VkDebugReportObjectTypeEXT,
        object: u64,
        location: usize,
        messageCode: i32,
        pLayerPrefix: *const ::std::os::raw::c_char,
        pMessage: *const ::std::os::raw::c_char,
        pUserData: *mut ::std::os::raw::c_void,
    ) -> VkBool32,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugReportCallbackCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDebugReportFlagsEXT,
    pub pfnCallback: PFN_vkDebugReportCallbackEXT,
    pub pUserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkDebugReportCallbackCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugReportCallbackCreateInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkDebugReportCallbackCreateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugReportCallbackCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDebugReportCallbackCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugReportCallbackCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugReportCallbackCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugReportCallbackCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugReportCallbackCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugReportCallbackCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugReportCallbackCreateInfoEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_pfnCallback() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugReportCallbackCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pfnCallback) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugReportCallbackCreateInfoEXT),
                "::",
                stringify!(pfnCallback)
            )
        );
    }
    test_field_pfnCallback();
    fn test_field_pUserData() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugReportCallbackCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugReportCallbackCreateInfoEXT),
                "::",
                stringify!(pUserData)
            )
        );
    }
    test_field_pUserData();
}
impl Default for VkDebugReportCallbackCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCreateDebugReportCallbackEXT = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pCallback: *mut VkDebugReportCallbackEXT,
    ) -> VkResult,
>;
pub type PFN_vkDestroyDebugReportCallbackEXT = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        callback: VkDebugReportCallbackEXT,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkDebugReportMessageEXT = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        flags: VkDebugReportFlagsEXT,
        objectType: VkDebugReportObjectTypeEXT,
        object: u64,
        location: usize,
        messageCode: i32,
        pLayerPrefix: *const ::std::os::raw::c_char,
        pMessage: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    pub fn vkCreateDebugReportCallbackEXT(
        instance: VkInstance,
        pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pCallback: *mut VkDebugReportCallbackEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyDebugReportCallbackEXT(
        instance: VkInstance,
        callback: VkDebugReportCallbackEXT,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkDebugReportMessageEXT(
        instance: VkInstance,
        flags: VkDebugReportFlagsEXT,
        objectType: VkDebugReportObjectTypeEXT,
        object: u64,
        location: usize,
        messageCode: i32,
        pLayerPrefix: *const ::std::os::raw::c_char,
        pMessage: *const ::std::os::raw::c_char,
    );
}
pub const VK_RASTERIZATION_ORDER_STRICT_AMD: VkRasterizationOrderAMD = 0;
pub const VK_RASTERIZATION_ORDER_RELAXED_AMD: VkRasterizationOrderAMD = 1;
pub const VK_RASTERIZATION_ORDER_MAX_ENUM_AMD: VkRasterizationOrderAMD = 2147483647;
pub type VkRasterizationOrderAMD = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRasterizationStateRasterizationOrderAMD {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub rasterizationOrder: VkRasterizationOrderAMD,
}
#[test]
fn bindgen_test_layout_VkPipelineRasterizationStateRasterizationOrderAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRasterizationStateRasterizationOrderAMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineRasterizationStateRasterizationOrderAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRasterizationStateRasterizationOrderAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineRasterizationStateRasterizationOrderAMD)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationStateRasterizationOrderAMD,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateRasterizationOrderAMD),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationStateRasterizationOrderAMD,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateRasterizationOrderAMD),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_rasterizationOrder() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationStateRasterizationOrderAMD,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rasterizationOrder) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateRasterizationOrderAMD),
                "::",
                stringify!(rasterizationOrder)
            )
        );
    }
    test_field_rasterizationOrder();
}
impl Default for VkPipelineRasterizationStateRasterizationOrderAMD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugMarkerObjectNameInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub objectType: VkDebugReportObjectTypeEXT,
    pub object: u64,
    pub pObjectName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VkDebugMarkerObjectNameInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugMarkerObjectNameInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkDebugMarkerObjectNameInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugMarkerObjectNameInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDebugMarkerObjectNameInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugMarkerObjectNameInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugMarkerObjectNameInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugMarkerObjectNameInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugMarkerObjectNameInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_objectType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugMarkerObjectNameInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objectType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugMarkerObjectNameInfoEXT),
                "::",
                stringify!(objectType)
            )
        );
    }
    test_field_objectType();
    fn test_field_object() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugMarkerObjectNameInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugMarkerObjectNameInfoEXT),
                "::",
                stringify!(object)
            )
        );
    }
    test_field_object();
    fn test_field_pObjectName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugMarkerObjectNameInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pObjectName) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugMarkerObjectNameInfoEXT),
                "::",
                stringify!(pObjectName)
            )
        );
    }
    test_field_pObjectName();
}
impl Default for VkDebugMarkerObjectNameInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugMarkerObjectTagInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub objectType: VkDebugReportObjectTypeEXT,
    pub object: u64,
    pub tagName: u64,
    pub tagSize: usize,
    pub pTag: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkDebugMarkerObjectTagInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugMarkerObjectTagInfoEXT>(),
        56usize,
        concat!("Size of: ", stringify!(VkDebugMarkerObjectTagInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugMarkerObjectTagInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDebugMarkerObjectTagInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugMarkerObjectTagInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugMarkerObjectTagInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugMarkerObjectTagInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugMarkerObjectTagInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_objectType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugMarkerObjectTagInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objectType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugMarkerObjectTagInfoEXT),
                "::",
                stringify!(objectType)
            )
        );
    }
    test_field_objectType();
    fn test_field_object() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugMarkerObjectTagInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugMarkerObjectTagInfoEXT),
                "::",
                stringify!(object)
            )
        );
    }
    test_field_object();
    fn test_field_tagName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugMarkerObjectTagInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tagName) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugMarkerObjectTagInfoEXT),
                "::",
                stringify!(tagName)
            )
        );
    }
    test_field_tagName();
    fn test_field_tagSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugMarkerObjectTagInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tagSize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugMarkerObjectTagInfoEXT),
                "::",
                stringify!(tagSize)
            )
        );
    }
    test_field_tagSize();
    fn test_field_pTag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugMarkerObjectTagInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pTag) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugMarkerObjectTagInfoEXT),
                "::",
                stringify!(pTag)
            )
        );
    }
    test_field_pTag();
}
impl Default for VkDebugMarkerObjectTagInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugMarkerMarkerInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pMarkerName: *const ::std::os::raw::c_char,
    pub color: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_VkDebugMarkerMarkerInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugMarkerMarkerInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkDebugMarkerMarkerInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugMarkerMarkerInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDebugMarkerMarkerInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugMarkerMarkerInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugMarkerMarkerInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugMarkerMarkerInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugMarkerMarkerInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pMarkerName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugMarkerMarkerInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pMarkerName) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugMarkerMarkerInfoEXT),
                "::",
                stringify!(pMarkerName)
            )
        );
    }
    test_field_pMarkerName();
    fn test_field_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugMarkerMarkerInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugMarkerMarkerInfoEXT),
                "::",
                stringify!(color)
            )
        );
    }
    test_field_color();
}
impl Default for VkDebugMarkerMarkerInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkDebugMarkerSetObjectTagEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pTagInfo: *const VkDebugMarkerObjectTagInfoEXT,
    ) -> VkResult,
>;
pub type PFN_vkDebugMarkerSetObjectNameEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pNameInfo: *const VkDebugMarkerObjectNameInfoEXT,
    ) -> VkResult,
>;
pub type PFN_vkCmdDebugMarkerBeginEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pMarkerInfo: *const VkDebugMarkerMarkerInfoEXT,
    ),
>;
pub type PFN_vkCmdDebugMarkerEndEXT =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer)>;
pub type PFN_vkCmdDebugMarkerInsertEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pMarkerInfo: *const VkDebugMarkerMarkerInfoEXT,
    ),
>;
extern "C" {
    pub fn vkDebugMarkerSetObjectTagEXT(
        device: VkDevice,
        pTagInfo: *const VkDebugMarkerObjectTagInfoEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDebugMarkerSetObjectNameEXT(
        device: VkDevice,
        pNameInfo: *const VkDebugMarkerObjectNameInfoEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdDebugMarkerBeginEXT(
        commandBuffer: VkCommandBuffer,
        pMarkerInfo: *const VkDebugMarkerMarkerInfoEXT,
    );
}
extern "C" {
    pub fn vkCmdDebugMarkerEndEXT(commandBuffer: VkCommandBuffer);
}
extern "C" {
    pub fn vkCmdDebugMarkerInsertEXT(
        commandBuffer: VkCommandBuffer,
        pMarkerInfo: *const VkDebugMarkerMarkerInfoEXT,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDedicatedAllocationImageCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub dedicatedAllocation: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDedicatedAllocationImageCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkDedicatedAllocationImageCreateInfoNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDedicatedAllocationImageCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDedicatedAllocationImageCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDedicatedAllocationImageCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDedicatedAllocationImageCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDedicatedAllocationImageCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDedicatedAllocationImageCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDedicatedAllocationImageCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_dedicatedAllocation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDedicatedAllocationImageCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dedicatedAllocation) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDedicatedAllocationImageCreateInfoNV),
                "::",
                stringify!(dedicatedAllocation)
            )
        );
    }
    test_field_dedicatedAllocation();
}
impl Default for VkDedicatedAllocationImageCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDedicatedAllocationBufferCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub dedicatedAllocation: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDedicatedAllocationBufferCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkDedicatedAllocationBufferCreateInfoNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDedicatedAllocationBufferCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDedicatedAllocationBufferCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDedicatedAllocationBufferCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDedicatedAllocationBufferCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDedicatedAllocationBufferCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDedicatedAllocationBufferCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDedicatedAllocationBufferCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_dedicatedAllocation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDedicatedAllocationBufferCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dedicatedAllocation) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDedicatedAllocationBufferCreateInfoNV),
                "::",
                stringify!(dedicatedAllocation)
            )
        );
    }
    test_field_dedicatedAllocation();
}
impl Default for VkDedicatedAllocationBufferCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDedicatedAllocationMemoryAllocateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
    pub buffer: VkBuffer,
}
#[test]
fn bindgen_test_layout_VkDedicatedAllocationMemoryAllocateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkDedicatedAllocationMemoryAllocateInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkDedicatedAllocationMemoryAllocateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDedicatedAllocationMemoryAllocateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDedicatedAllocationMemoryAllocateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDedicatedAllocationMemoryAllocateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDedicatedAllocationMemoryAllocateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDedicatedAllocationMemoryAllocateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDedicatedAllocationMemoryAllocateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_image() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDedicatedAllocationMemoryAllocateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDedicatedAllocationMemoryAllocateInfoNV),
                "::",
                stringify!(image)
            )
        );
    }
    test_field_image();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDedicatedAllocationMemoryAllocateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDedicatedAllocationMemoryAllocateInfoNV),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
}
impl Default for VkDedicatedAllocationMemoryAllocateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPipelineRasterizationStateStreamCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceTransformFeedbackFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub transformFeedback: VkBool32,
    pub geometryStreams: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceTransformFeedbackFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceTransformFeedbackFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceTransformFeedbackFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceTransformFeedbackFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceTransformFeedbackFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceTransformFeedbackFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTransformFeedbackFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceTransformFeedbackFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTransformFeedbackFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_transformFeedback() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceTransformFeedbackFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformFeedback) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTransformFeedbackFeaturesEXT),
                "::",
                stringify!(transformFeedback)
            )
        );
    }
    test_field_transformFeedback();
    fn test_field_geometryStreams() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceTransformFeedbackFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).geometryStreams) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTransformFeedbackFeaturesEXT),
                "::",
                stringify!(geometryStreams)
            )
        );
    }
    test_field_geometryStreams();
}
impl Default for VkPhysicalDeviceTransformFeedbackFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceTransformFeedbackPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxTransformFeedbackStreams: u32,
    pub maxTransformFeedbackBuffers: u32,
    pub maxTransformFeedbackBufferSize: VkDeviceSize,
    pub maxTransformFeedbackStreamDataSize: u32,
    pub maxTransformFeedbackBufferDataSize: u32,
    pub maxTransformFeedbackBufferDataStride: u32,
    pub transformFeedbackQueries: VkBool32,
    pub transformFeedbackStreamsLinesTriangles: VkBool32,
    pub transformFeedbackRasterizationStreamSelect: VkBool32,
    pub transformFeedbackDraw: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceTransformFeedbackPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceTransformFeedbackPropertiesEXT>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceTransformFeedbackPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTransformFeedbackPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTransformFeedbackPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxTransformFeedbackStreams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTransformFeedbackPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTransformFeedbackStreams) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
                "::",
                stringify!(maxTransformFeedbackStreams)
            )
        );
    }
    test_field_maxTransformFeedbackStreams();
    fn test_field_maxTransformFeedbackBuffers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTransformFeedbackPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTransformFeedbackBuffers) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
                "::",
                stringify!(maxTransformFeedbackBuffers)
            )
        );
    }
    test_field_maxTransformFeedbackBuffers();
    fn test_field_maxTransformFeedbackBufferSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTransformFeedbackPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTransformFeedbackBufferSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
                "::",
                stringify!(maxTransformFeedbackBufferSize)
            )
        );
    }
    test_field_maxTransformFeedbackBufferSize();
    fn test_field_maxTransformFeedbackStreamDataSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTransformFeedbackPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTransformFeedbackStreamDataSize) as usize
                    - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
                "::",
                stringify!(maxTransformFeedbackStreamDataSize)
            )
        );
    }
    test_field_maxTransformFeedbackStreamDataSize();
    fn test_field_maxTransformFeedbackBufferDataSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTransformFeedbackPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTransformFeedbackBufferDataSize) as usize
                    - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
                "::",
                stringify!(maxTransformFeedbackBufferDataSize)
            )
        );
    }
    test_field_maxTransformFeedbackBufferDataSize();
    fn test_field_maxTransformFeedbackBufferDataStride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTransformFeedbackPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTransformFeedbackBufferDataStride) as usize
                    - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
                "::",
                stringify!(maxTransformFeedbackBufferDataStride)
            )
        );
    }
    test_field_maxTransformFeedbackBufferDataStride();
    fn test_field_transformFeedbackQueries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTransformFeedbackPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformFeedbackQueries) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
                "::",
                stringify!(transformFeedbackQueries)
            )
        );
    }
    test_field_transformFeedbackQueries();
    fn test_field_transformFeedbackStreamsLinesTriangles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTransformFeedbackPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformFeedbackStreamsLinesTriangles) as usize
                    - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
                "::",
                stringify!(transformFeedbackStreamsLinesTriangles)
            )
        );
    }
    test_field_transformFeedbackStreamsLinesTriangles();
    fn test_field_transformFeedbackRasterizationStreamSelect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTransformFeedbackPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformFeedbackRasterizationStreamSelect) as usize
                    - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
                "::",
                stringify!(transformFeedbackRasterizationStreamSelect)
            )
        );
    }
    test_field_transformFeedbackRasterizationStreamSelect();
    fn test_field_transformFeedbackDraw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTransformFeedbackPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformFeedbackDraw) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTransformFeedbackPropertiesEXT),
                "::",
                stringify!(transformFeedbackDraw)
            )
        );
    }
    test_field_transformFeedbackDraw();
}
impl Default for VkPhysicalDeviceTransformFeedbackPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRasterizationStateStreamCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineRasterizationStateStreamCreateFlagsEXT,
    pub rasterizationStream: u32,
}
#[test]
fn bindgen_test_layout_VkPipelineRasterizationStateStreamCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRasterizationStateStreamCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineRasterizationStateStreamCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRasterizationStateStreamCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineRasterizationStateStreamCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationStateStreamCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateStreamCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationStateStreamCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateStreamCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationStateStreamCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateStreamCreateInfoEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_rasterizationStream() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationStateStreamCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rasterizationStream) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationStateStreamCreateInfoEXT),
                "::",
                stringify!(rasterizationStream)
            )
        );
    }
    test_field_rasterizationStream();
}
impl Default for VkPipelineRasterizationStateStreamCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdBindTransformFeedbackBuffersEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstBinding: u32,
        bindingCount: u32,
        pBuffers: *const VkBuffer,
        pOffsets: *const VkDeviceSize,
        pSizes: *const VkDeviceSize,
    ),
>;
pub type PFN_vkCmdBeginTransformFeedbackEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstCounterBuffer: u32,
        counterBufferCount: u32,
        pCounterBuffers: *const VkBuffer,
        pCounterBufferOffsets: *const VkDeviceSize,
    ),
>;
pub type PFN_vkCmdEndTransformFeedbackEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstCounterBuffer: u32,
        counterBufferCount: u32,
        pCounterBuffers: *const VkBuffer,
        pCounterBufferOffsets: *const VkDeviceSize,
    ),
>;
pub type PFN_vkCmdBeginQueryIndexedEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        query: u32,
        flags: VkQueryControlFlags,
        index: u32,
    ),
>;
pub type PFN_vkCmdEndQueryIndexedEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        query: u32,
        index: u32,
    ),
>;
pub type PFN_vkCmdDrawIndirectByteCountEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        instanceCount: u32,
        firstInstance: u32,
        counterBuffer: VkBuffer,
        counterBufferOffset: VkDeviceSize,
        counterOffset: u32,
        vertexStride: u32,
    ),
>;
extern "C" {
    pub fn vkCmdBindTransformFeedbackBuffersEXT(
        commandBuffer: VkCommandBuffer,
        firstBinding: u32,
        bindingCount: u32,
        pBuffers: *const VkBuffer,
        pOffsets: *const VkDeviceSize,
        pSizes: *const VkDeviceSize,
    );
}
extern "C" {
    pub fn vkCmdBeginTransformFeedbackEXT(
        commandBuffer: VkCommandBuffer,
        firstCounterBuffer: u32,
        counterBufferCount: u32,
        pCounterBuffers: *const VkBuffer,
        pCounterBufferOffsets: *const VkDeviceSize,
    );
}
extern "C" {
    pub fn vkCmdEndTransformFeedbackEXT(
        commandBuffer: VkCommandBuffer,
        firstCounterBuffer: u32,
        counterBufferCount: u32,
        pCounterBuffers: *const VkBuffer,
        pCounterBufferOffsets: *const VkDeviceSize,
    );
}
extern "C" {
    pub fn vkCmdBeginQueryIndexedEXT(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        query: u32,
        flags: VkQueryControlFlags,
        index: u32,
    );
}
extern "C" {
    pub fn vkCmdEndQueryIndexedEXT(
        commandBuffer: VkCommandBuffer,
        queryPool: VkQueryPool,
        query: u32,
        index: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawIndirectByteCountEXT(
        commandBuffer: VkCommandBuffer,
        instanceCount: u32,
        firstInstance: u32,
        counterBuffer: VkBuffer,
        counterBufferOffset: VkDeviceSize,
        counterOffset: u32,
        vertexStride: u32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCuModuleNVX_T {
    _unused: [u8; 0],
}
pub type VkCuModuleNVX = *mut VkCuModuleNVX_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCuFunctionNVX_T {
    _unused: [u8; 0],
}
pub type VkCuFunctionNVX = *mut VkCuFunctionNVX_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCuModuleCreateInfoNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub dataSize: usize,
    pub pData: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkCuModuleCreateInfoNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkCuModuleCreateInfoNVX>(),
        32usize,
        concat!("Size of: ", stringify!(VkCuModuleCreateInfoNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCuModuleCreateInfoNVX>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCuModuleCreateInfoNVX))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuModuleCreateInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuModuleCreateInfoNVX),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuModuleCreateInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuModuleCreateInfoNVX),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_dataSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuModuleCreateInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuModuleCreateInfoNVX),
                "::",
                stringify!(dataSize)
            )
        );
    }
    test_field_dataSize();
    fn test_field_pData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuModuleCreateInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pData) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuModuleCreateInfoNVX),
                "::",
                stringify!(pData)
            )
        );
    }
    test_field_pData();
}
impl Default for VkCuModuleCreateInfoNVX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCuFunctionCreateInfoNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub module: VkCuModuleNVX,
    pub pName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VkCuFunctionCreateInfoNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkCuFunctionCreateInfoNVX>(),
        32usize,
        concat!("Size of: ", stringify!(VkCuFunctionCreateInfoNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCuFunctionCreateInfoNVX>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCuFunctionCreateInfoNVX))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuFunctionCreateInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuFunctionCreateInfoNVX),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuFunctionCreateInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuFunctionCreateInfoNVX),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_module() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuFunctionCreateInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).module) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuFunctionCreateInfoNVX),
                "::",
                stringify!(module)
            )
        );
    }
    test_field_module();
    fn test_field_pName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuFunctionCreateInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pName) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuFunctionCreateInfoNVX),
                "::",
                stringify!(pName)
            )
        );
    }
    test_field_pName();
}
impl Default for VkCuFunctionCreateInfoNVX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCuLaunchInfoNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub function: VkCuFunctionNVX,
    pub gridDimX: u32,
    pub gridDimY: u32,
    pub gridDimZ: u32,
    pub blockDimX: u32,
    pub blockDimY: u32,
    pub blockDimZ: u32,
    pub sharedMemBytes: u32,
    pub paramCount: usize,
    pub pParams: *const *const ::std::os::raw::c_void,
    pub extraCount: usize,
    pub pExtras: *const *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkCuLaunchInfoNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkCuLaunchInfoNVX>(),
        88usize,
        concat!("Size of: ", stringify!(VkCuLaunchInfoNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCuLaunchInfoNVX>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCuLaunchInfoNVX))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuLaunchInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuLaunchInfoNVX),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuLaunchInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuLaunchInfoNVX),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_function() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuLaunchInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuLaunchInfoNVX),
                "::",
                stringify!(function)
            )
        );
    }
    test_field_function();
    fn test_field_gridDimX() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuLaunchInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridDimX) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuLaunchInfoNVX),
                "::",
                stringify!(gridDimX)
            )
        );
    }
    test_field_gridDimX();
    fn test_field_gridDimY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuLaunchInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridDimY) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuLaunchInfoNVX),
                "::",
                stringify!(gridDimY)
            )
        );
    }
    test_field_gridDimY();
    fn test_field_gridDimZ() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuLaunchInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gridDimZ) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuLaunchInfoNVX),
                "::",
                stringify!(gridDimZ)
            )
        );
    }
    test_field_gridDimZ();
    fn test_field_blockDimX() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuLaunchInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockDimX) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuLaunchInfoNVX),
                "::",
                stringify!(blockDimX)
            )
        );
    }
    test_field_blockDimX();
    fn test_field_blockDimY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuLaunchInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockDimY) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuLaunchInfoNVX),
                "::",
                stringify!(blockDimY)
            )
        );
    }
    test_field_blockDimY();
    fn test_field_blockDimZ() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuLaunchInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blockDimZ) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuLaunchInfoNVX),
                "::",
                stringify!(blockDimZ)
            )
        );
    }
    test_field_blockDimZ();
    fn test_field_sharedMemBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuLaunchInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharedMemBytes) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuLaunchInfoNVX),
                "::",
                stringify!(sharedMemBytes)
            )
        );
    }
    test_field_sharedMemBytes();
    fn test_field_paramCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuLaunchInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).paramCount) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuLaunchInfoNVX),
                "::",
                stringify!(paramCount)
            )
        );
    }
    test_field_paramCount();
    fn test_field_pParams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuLaunchInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pParams) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuLaunchInfoNVX),
                "::",
                stringify!(pParams)
            )
        );
    }
    test_field_pParams();
    fn test_field_extraCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuLaunchInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extraCount) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuLaunchInfoNVX),
                "::",
                stringify!(extraCount)
            )
        );
    }
    test_field_extraCount();
    fn test_field_pExtras() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCuLaunchInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pExtras) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCuLaunchInfoNVX),
                "::",
                stringify!(pExtras)
            )
        );
    }
    test_field_pExtras();
}
impl Default for VkCuLaunchInfoNVX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCreateCuModuleNVX = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkCuModuleCreateInfoNVX,
        pAllocator: *const VkAllocationCallbacks,
        pModule: *mut VkCuModuleNVX,
    ) -> VkResult,
>;
pub type PFN_vkCreateCuFunctionNVX = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkCuFunctionCreateInfoNVX,
        pAllocator: *const VkAllocationCallbacks,
        pFunction: *mut VkCuFunctionNVX,
    ) -> VkResult,
>;
pub type PFN_vkDestroyCuModuleNVX = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        module: VkCuModuleNVX,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkDestroyCuFunctionNVX = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        function: VkCuFunctionNVX,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCmdCuLaunchKernelNVX = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pLaunchInfo: *const VkCuLaunchInfoNVX),
>;
extern "C" {
    pub fn vkCreateCuModuleNVX(
        device: VkDevice,
        pCreateInfo: *const VkCuModuleCreateInfoNVX,
        pAllocator: *const VkAllocationCallbacks,
        pModule: *mut VkCuModuleNVX,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreateCuFunctionNVX(
        device: VkDevice,
        pCreateInfo: *const VkCuFunctionCreateInfoNVX,
        pAllocator: *const VkAllocationCallbacks,
        pFunction: *mut VkCuFunctionNVX,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyCuModuleNVX(
        device: VkDevice,
        module: VkCuModuleNVX,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkDestroyCuFunctionNVX(
        device: VkDevice,
        function: VkCuFunctionNVX,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCmdCuLaunchKernelNVX(
        commandBuffer: VkCommandBuffer,
        pLaunchInfo: *const VkCuLaunchInfoNVX,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageViewHandleInfoNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub imageView: VkImageView,
    pub descriptorType: VkDescriptorType,
    pub sampler: VkSampler,
}
#[test]
fn bindgen_test_layout_VkImageViewHandleInfoNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkImageViewHandleInfoNVX>(),
        40usize,
        concat!("Size of: ", stringify!(VkImageViewHandleInfoNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageViewHandleInfoNVX>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageViewHandleInfoNVX))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewHandleInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewHandleInfoNVX),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewHandleInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewHandleInfoNVX),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_imageView() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewHandleInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageView) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewHandleInfoNVX),
                "::",
                stringify!(imageView)
            )
        );
    }
    test_field_imageView();
    fn test_field_descriptorType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewHandleInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorType) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewHandleInfoNVX),
                "::",
                stringify!(descriptorType)
            )
        );
    }
    test_field_descriptorType();
    fn test_field_sampler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewHandleInfoNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampler) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewHandleInfoNVX),
                "::",
                stringify!(sampler)
            )
        );
    }
    test_field_sampler();
}
impl Default for VkImageViewHandleInfoNVX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageViewAddressPropertiesNVX {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub deviceAddress: VkDeviceAddress,
    pub size: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkImageViewAddressPropertiesNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkImageViewAddressPropertiesNVX>(),
        32usize,
        concat!("Size of: ", stringify!(VkImageViewAddressPropertiesNVX))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageViewAddressPropertiesNVX>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageViewAddressPropertiesNVX))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewAddressPropertiesNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewAddressPropertiesNVX),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewAddressPropertiesNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewAddressPropertiesNVX),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_deviceAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewAddressPropertiesNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceAddress) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewAddressPropertiesNVX),
                "::",
                stringify!(deviceAddress)
            )
        );
    }
    test_field_deviceAddress();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewAddressPropertiesNVX>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewAddressPropertiesNVX),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
impl Default for VkImageViewAddressPropertiesNVX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetImageViewHandleNVX = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, pInfo: *const VkImageViewHandleInfoNVX) -> u32,
>;
pub type PFN_vkGetImageViewAddressNVX = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        imageView: VkImageView,
        pProperties: *mut VkImageViewAddressPropertiesNVX,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetImageViewHandleNVX(device: VkDevice, pInfo: *const VkImageViewHandleInfoNVX)
        -> u32;
}
extern "C" {
    pub fn vkGetImageViewAddressNVX(
        device: VkDevice,
        imageView: VkImageView,
        pProperties: *mut VkImageViewAddressPropertiesNVX,
    ) -> VkResult;
}
pub type PFN_vkCmdDrawIndirectCountAMD = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCmdDrawIndexedIndirectCountAMD = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    ),
>;
extern "C" {
    pub fn vkCmdDrawIndirectCountAMD(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawIndexedIndirectCountAMD(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkTextureLODGatherFormatPropertiesAMD {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub supportsTextureGatherLODBiasAMD: VkBool32,
}
#[test]
fn bindgen_test_layout_VkTextureLODGatherFormatPropertiesAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkTextureLODGatherFormatPropertiesAMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkTextureLODGatherFormatPropertiesAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkTextureLODGatherFormatPropertiesAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkTextureLODGatherFormatPropertiesAMD)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkTextureLODGatherFormatPropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTextureLODGatherFormatPropertiesAMD),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkTextureLODGatherFormatPropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTextureLODGatherFormatPropertiesAMD),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_supportsTextureGatherLODBiasAMD() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkTextureLODGatherFormatPropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportsTextureGatherLODBiasAMD) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTextureLODGatherFormatPropertiesAMD),
                "::",
                stringify!(supportsTextureGatherLODBiasAMD)
            )
        );
    }
    test_field_supportsTextureGatherLODBiasAMD();
}
impl Default for VkTextureLODGatherFormatPropertiesAMD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_SHADER_INFO_TYPE_STATISTICS_AMD: VkShaderInfoTypeAMD = 0;
pub const VK_SHADER_INFO_TYPE_BINARY_AMD: VkShaderInfoTypeAMD = 1;
pub const VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD: VkShaderInfoTypeAMD = 2;
pub const VK_SHADER_INFO_TYPE_MAX_ENUM_AMD: VkShaderInfoTypeAMD = 2147483647;
pub type VkShaderInfoTypeAMD = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkShaderResourceUsageAMD {
    pub numUsedVgprs: u32,
    pub numUsedSgprs: u32,
    pub ldsSizePerLocalWorkGroup: u32,
    pub ldsUsageSizeInBytes: usize,
    pub scratchMemUsageInBytes: usize,
}
#[test]
fn bindgen_test_layout_VkShaderResourceUsageAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkShaderResourceUsageAMD>(),
        32usize,
        concat!("Size of: ", stringify!(VkShaderResourceUsageAMD))
    );
    assert_eq!(
        ::std::mem::align_of::<VkShaderResourceUsageAMD>(),
        8usize,
        concat!("Alignment of ", stringify!(VkShaderResourceUsageAMD))
    );
    fn test_field_numUsedVgprs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderResourceUsageAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numUsedVgprs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderResourceUsageAMD),
                "::",
                stringify!(numUsedVgprs)
            )
        );
    }
    test_field_numUsedVgprs();
    fn test_field_numUsedSgprs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderResourceUsageAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numUsedSgprs) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderResourceUsageAMD),
                "::",
                stringify!(numUsedSgprs)
            )
        );
    }
    test_field_numUsedSgprs();
    fn test_field_ldsSizePerLocalWorkGroup() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderResourceUsageAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ldsSizePerLocalWorkGroup) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderResourceUsageAMD),
                "::",
                stringify!(ldsSizePerLocalWorkGroup)
            )
        );
    }
    test_field_ldsSizePerLocalWorkGroup();
    fn test_field_ldsUsageSizeInBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderResourceUsageAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ldsUsageSizeInBytes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderResourceUsageAMD),
                "::",
                stringify!(ldsUsageSizeInBytes)
            )
        );
    }
    test_field_ldsUsageSizeInBytes();
    fn test_field_scratchMemUsageInBytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderResourceUsageAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scratchMemUsageInBytes) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderResourceUsageAMD),
                "::",
                stringify!(scratchMemUsageInBytes)
            )
        );
    }
    test_field_scratchMemUsageInBytes();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkShaderStatisticsInfoAMD {
    pub shaderStageMask: VkShaderStageFlags,
    pub resourceUsage: VkShaderResourceUsageAMD,
    pub numPhysicalVgprs: u32,
    pub numPhysicalSgprs: u32,
    pub numAvailableVgprs: u32,
    pub numAvailableSgprs: u32,
    pub computeWorkGroupSize: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_VkShaderStatisticsInfoAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkShaderStatisticsInfoAMD>(),
        72usize,
        concat!("Size of: ", stringify!(VkShaderStatisticsInfoAMD))
    );
    assert_eq!(
        ::std::mem::align_of::<VkShaderStatisticsInfoAMD>(),
        8usize,
        concat!("Alignment of ", stringify!(VkShaderStatisticsInfoAMD))
    );
    fn test_field_shaderStageMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderStatisticsInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderStageMask) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderStatisticsInfoAMD),
                "::",
                stringify!(shaderStageMask)
            )
        );
    }
    test_field_shaderStageMask();
    fn test_field_resourceUsage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderStatisticsInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resourceUsage) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderStatisticsInfoAMD),
                "::",
                stringify!(resourceUsage)
            )
        );
    }
    test_field_resourceUsage();
    fn test_field_numPhysicalVgprs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderStatisticsInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numPhysicalVgprs) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderStatisticsInfoAMD),
                "::",
                stringify!(numPhysicalVgprs)
            )
        );
    }
    test_field_numPhysicalVgprs();
    fn test_field_numPhysicalSgprs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderStatisticsInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numPhysicalSgprs) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderStatisticsInfoAMD),
                "::",
                stringify!(numPhysicalSgprs)
            )
        );
    }
    test_field_numPhysicalSgprs();
    fn test_field_numAvailableVgprs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderStatisticsInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numAvailableVgprs) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderStatisticsInfoAMD),
                "::",
                stringify!(numAvailableVgprs)
            )
        );
    }
    test_field_numAvailableVgprs();
    fn test_field_numAvailableSgprs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderStatisticsInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numAvailableSgprs) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderStatisticsInfoAMD),
                "::",
                stringify!(numAvailableSgprs)
            )
        );
    }
    test_field_numAvailableSgprs();
    fn test_field_computeWorkGroupSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderStatisticsInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).computeWorkGroupSize) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderStatisticsInfoAMD),
                "::",
                stringify!(computeWorkGroupSize)
            )
        );
    }
    test_field_computeWorkGroupSize();
}
pub type PFN_vkGetShaderInfoAMD = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipeline: VkPipeline,
        shaderStage: VkShaderStageFlagBits,
        infoType: VkShaderInfoTypeAMD,
        pInfoSize: *mut usize,
        pInfo: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetShaderInfoAMD(
        device: VkDevice,
        pipeline: VkPipeline,
        shaderStage: VkShaderStageFlagBits,
        infoType: VkShaderInfoTypeAMD,
        pInfoSize: *mut usize,
        pInfo: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceCornerSampledImageFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub cornerSampledImage: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceCornerSampledImageFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceCornerSampledImageFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceCornerSampledImageFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceCornerSampledImageFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceCornerSampledImageFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCornerSampledImageFeaturesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCornerSampledImageFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCornerSampledImageFeaturesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCornerSampledImageFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_cornerSampledImage() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCornerSampledImageFeaturesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cornerSampledImage) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCornerSampledImageFeaturesNV),
                "::",
                stringify!(cornerSampledImage)
            )
        );
    }
    test_field_cornerSampledImage();
}
impl Default for VkPhysicalDeviceCornerSampledImageFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV: VkExternalMemoryHandleTypeFlagBitsNV =
    1;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV:
    VkExternalMemoryHandleTypeFlagBitsNV = 2;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV: VkExternalMemoryHandleTypeFlagBitsNV =
    4;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV:
    VkExternalMemoryHandleTypeFlagBitsNV = 8;
pub const VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV:
    VkExternalMemoryHandleTypeFlagBitsNV = 2147483647;
pub type VkExternalMemoryHandleTypeFlagBitsNV = ::std::os::raw::c_int;
pub type VkExternalMemoryHandleTypeFlagsNV = VkFlags;
pub const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV: VkExternalMemoryFeatureFlagBitsNV = 1;
pub const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV: VkExternalMemoryFeatureFlagBitsNV = 2;
pub const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV: VkExternalMemoryFeatureFlagBitsNV = 4;
pub const VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV: VkExternalMemoryFeatureFlagBitsNV =
    2147483647;
pub type VkExternalMemoryFeatureFlagBitsNV = ::std::os::raw::c_int;
pub type VkExternalMemoryFeatureFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkExternalImageFormatPropertiesNV {
    pub imageFormatProperties: VkImageFormatProperties,
    pub externalMemoryFeatures: VkExternalMemoryFeatureFlagsNV,
    pub exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagsNV,
    pub compatibleHandleTypes: VkExternalMemoryHandleTypeFlagsNV,
}
#[test]
fn bindgen_test_layout_VkExternalImageFormatPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalImageFormatPropertiesNV>(),
        48usize,
        concat!("Size of: ", stringify!(VkExternalImageFormatPropertiesNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalImageFormatPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkExternalImageFormatPropertiesNV)
        )
    );
    fn test_field_imageFormatProperties() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalImageFormatPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageFormatProperties) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalImageFormatPropertiesNV),
                "::",
                stringify!(imageFormatProperties)
            )
        );
    }
    test_field_imageFormatProperties();
    fn test_field_externalMemoryFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalImageFormatPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).externalMemoryFeatures) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalImageFormatPropertiesNV),
                "::",
                stringify!(externalMemoryFeatures)
            )
        );
    }
    test_field_externalMemoryFeatures();
    fn test_field_exportFromImportedHandleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalImageFormatPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).exportFromImportedHandleTypes) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalImageFormatPropertiesNV),
                "::",
                stringify!(exportFromImportedHandleTypes)
            )
        );
    }
    test_field_exportFromImportedHandleTypes();
    fn test_field_compatibleHandleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalImageFormatPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compatibleHandleTypes) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalImageFormatPropertiesNV),
                "::",
                stringify!(compatibleHandleTypes)
            )
        );
    }
    test_field_compatibleHandleTypes();
}
pub type PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        type_: VkImageType,
        tiling: VkImageTiling,
        usage: VkImageUsageFlags,
        flags: VkImageCreateFlags,
        externalHandleType: VkExternalMemoryHandleTypeFlagsNV,
        pExternalImageFormatProperties: *mut VkExternalImageFormatPropertiesNV,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
        physicalDevice: VkPhysicalDevice,
        format: VkFormat,
        type_: VkImageType,
        tiling: VkImageTiling,
        usage: VkImageUsageFlags,
        flags: VkImageCreateFlags,
        externalHandleType: VkExternalMemoryHandleTypeFlagsNV,
        pExternalImageFormatProperties: *mut VkExternalImageFormatPropertiesNV,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExternalMemoryImageCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlagsNV,
}
#[test]
fn bindgen_test_layout_VkExternalMemoryImageCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkExternalMemoryImageCreateInfoNV>(),
        24usize,
        concat!("Size of: ", stringify!(VkExternalMemoryImageCreateInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExternalMemoryImageCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkExternalMemoryImageCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalMemoryImageCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalMemoryImageCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalMemoryImageCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalMemoryImageCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_handleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExternalMemoryImageCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleTypes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExternalMemoryImageCreateInfoNV),
                "::",
                stringify!(handleTypes)
            )
        );
    }
    test_field_handleTypes();
}
impl Default for VkExternalMemoryImageCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkExportMemoryAllocateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlagsNV,
}
#[test]
fn bindgen_test_layout_VkExportMemoryAllocateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkExportMemoryAllocateInfoNV>(),
        24usize,
        concat!("Size of: ", stringify!(VkExportMemoryAllocateInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkExportMemoryAllocateInfoNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkExportMemoryAllocateInfoNV))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExportMemoryAllocateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExportMemoryAllocateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExportMemoryAllocateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExportMemoryAllocateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_handleTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkExportMemoryAllocateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleTypes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkExportMemoryAllocateInfoNV),
                "::",
                stringify!(handleTypes)
            )
        );
    }
    test_field_handleTypes();
}
impl Default for VkExportMemoryAllocateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_VALIDATION_CHECK_ALL_EXT: VkValidationCheckEXT = 0;
pub const VK_VALIDATION_CHECK_SHADERS_EXT: VkValidationCheckEXT = 1;
pub const VK_VALIDATION_CHECK_MAX_ENUM_EXT: VkValidationCheckEXT = 2147483647;
pub type VkValidationCheckEXT = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkValidationFlagsEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub disabledValidationCheckCount: u32,
    pub pDisabledValidationChecks: *const VkValidationCheckEXT,
}
#[test]
fn bindgen_test_layout_VkValidationFlagsEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkValidationFlagsEXT>(),
        32usize,
        concat!("Size of: ", stringify!(VkValidationFlagsEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkValidationFlagsEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkValidationFlagsEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkValidationFlagsEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkValidationFlagsEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkValidationFlagsEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkValidationFlagsEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_disabledValidationCheckCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkValidationFlagsEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).disabledValidationCheckCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkValidationFlagsEXT),
                "::",
                stringify!(disabledValidationCheckCount)
            )
        );
    }
    test_field_disabledValidationCheckCount();
    fn test_field_pDisabledValidationChecks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkValidationFlagsEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDisabledValidationChecks) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkValidationFlagsEXT),
                "::",
                stringify!(pDisabledValidationChecks)
            )
        );
    }
    test_field_pDisabledValidationChecks();
}
impl Default for VkValidationFlagsEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT =
    VkPhysicalDeviceTextureCompressionASTCHDRFeatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageViewASTCDecodeModeEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub decodeMode: VkFormat,
}
#[test]
fn bindgen_test_layout_VkImageViewASTCDecodeModeEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkImageViewASTCDecodeModeEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkImageViewASTCDecodeModeEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageViewASTCDecodeModeEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageViewASTCDecodeModeEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewASTCDecodeModeEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewASTCDecodeModeEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewASTCDecodeModeEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewASTCDecodeModeEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_decodeMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewASTCDecodeModeEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).decodeMode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewASTCDecodeModeEXT),
                "::",
                stringify!(decodeMode)
            )
        );
    }
    test_field_decodeMode();
}
impl Default for VkImageViewASTCDecodeModeEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceASTCDecodeFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub decodeModeSharedExponent: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceASTCDecodeFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceASTCDecodeFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceASTCDecodeFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceASTCDecodeFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceASTCDecodeFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceASTCDecodeFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceASTCDecodeFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceASTCDecodeFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceASTCDecodeFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_decodeModeSharedExponent() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceASTCDecodeFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).decodeModeSharedExponent) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceASTCDecodeFeaturesEXT),
                "::",
                stringify!(decodeModeSharedExponent)
            )
        );
    }
    test_field_decodeModeSharedExponent();
}
impl Default for VkPhysicalDeviceASTCDecodeFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT:
    VkPipelineRobustnessBufferBehaviorEXT = 0;
pub const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT:
    VkPipelineRobustnessBufferBehaviorEXT = 1;
pub const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT:
    VkPipelineRobustnessBufferBehaviorEXT = 2;
pub const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT:
    VkPipelineRobustnessBufferBehaviorEXT = 3;
pub const VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_MAX_ENUM_EXT:
    VkPipelineRobustnessBufferBehaviorEXT = 2147483647;
pub type VkPipelineRobustnessBufferBehaviorEXT = ::std::os::raw::c_int;
pub const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT:
    VkPipelineRobustnessImageBehaviorEXT = 0;
pub const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT: VkPipelineRobustnessImageBehaviorEXT =
    1;
pub const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT:
    VkPipelineRobustnessImageBehaviorEXT = 2;
pub const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT:
    VkPipelineRobustnessImageBehaviorEXT = 3;
pub const VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_MAX_ENUM_EXT: VkPipelineRobustnessImageBehaviorEXT =
    2147483647;
pub type VkPipelineRobustnessImageBehaviorEXT = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePipelineRobustnessFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub pipelineRobustness: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePipelineRobustnessFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePipelineRobustnessFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePipelineRobustnessFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePipelineRobustnessFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePipelineRobustnessFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDevicePipelineRobustnessFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineRobustnessFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDevicePipelineRobustnessFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineRobustnessFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pipelineRobustness() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDevicePipelineRobustnessFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineRobustness) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineRobustnessFeaturesEXT),
                "::",
                stringify!(pipelineRobustness)
            )
        );
    }
    test_field_pipelineRobustness();
}
impl Default for VkPhysicalDevicePipelineRobustnessFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePipelineRobustnessPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehaviorEXT,
    pub defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehaviorEXT,
    pub defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehaviorEXT,
    pub defaultRobustnessImages: VkPipelineRobustnessImageBehaviorEXT,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePipelineRobustnessPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePipelineRobustnessPropertiesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePipelineRobustnessPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePipelineRobustnessPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePipelineRobustnessPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePipelineRobustnessPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineRobustnessPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePipelineRobustnessPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineRobustnessPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_defaultRobustnessStorageBuffers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePipelineRobustnessPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defaultRobustnessStorageBuffers) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineRobustnessPropertiesEXT),
                "::",
                stringify!(defaultRobustnessStorageBuffers)
            )
        );
    }
    test_field_defaultRobustnessStorageBuffers();
    fn test_field_defaultRobustnessUniformBuffers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePipelineRobustnessPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defaultRobustnessUniformBuffers) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineRobustnessPropertiesEXT),
                "::",
                stringify!(defaultRobustnessUniformBuffers)
            )
        );
    }
    test_field_defaultRobustnessUniformBuffers();
    fn test_field_defaultRobustnessVertexInputs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePipelineRobustnessPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defaultRobustnessVertexInputs) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineRobustnessPropertiesEXT),
                "::",
                stringify!(defaultRobustnessVertexInputs)
            )
        );
    }
    test_field_defaultRobustnessVertexInputs();
    fn test_field_defaultRobustnessImages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePipelineRobustnessPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defaultRobustnessImages) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineRobustnessPropertiesEXT),
                "::",
                stringify!(defaultRobustnessImages)
            )
        );
    }
    test_field_defaultRobustnessImages();
}
impl Default for VkPhysicalDevicePipelineRobustnessPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRobustnessCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub storageBuffers: VkPipelineRobustnessBufferBehaviorEXT,
    pub uniformBuffers: VkPipelineRobustnessBufferBehaviorEXT,
    pub vertexInputs: VkPipelineRobustnessBufferBehaviorEXT,
    pub images: VkPipelineRobustnessImageBehaviorEXT,
}
#[test]
fn bindgen_test_layout_VkPipelineRobustnessCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRobustnessCreateInfoEXT>(),
        32usize,
        concat!("Size of: ", stringify!(VkPipelineRobustnessCreateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRobustnessCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineRobustnessCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineRobustnessCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRobustnessCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineRobustnessCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRobustnessCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_storageBuffers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineRobustnessCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storageBuffers) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRobustnessCreateInfoEXT),
                "::",
                stringify!(storageBuffers)
            )
        );
    }
    test_field_storageBuffers();
    fn test_field_uniformBuffers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineRobustnessCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uniformBuffers) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRobustnessCreateInfoEXT),
                "::",
                stringify!(uniformBuffers)
            )
        );
    }
    test_field_uniformBuffers();
    fn test_field_vertexInputs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineRobustnessCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexInputs) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRobustnessCreateInfoEXT),
                "::",
                stringify!(vertexInputs)
            )
        );
    }
    test_field_vertexInputs();
    fn test_field_images() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineRobustnessCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).images) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRobustnessCreateInfoEXT),
                "::",
                stringify!(images)
            )
        );
    }
    test_field_images();
}
impl Default for VkPipelineRobustnessCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT: VkConditionalRenderingFlagBitsEXT = 1;
pub const VK_CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT: VkConditionalRenderingFlagBitsEXT =
    2147483647;
pub type VkConditionalRenderingFlagBitsEXT = ::std::os::raw::c_int;
pub type VkConditionalRenderingFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkConditionalRenderingBeginInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub flags: VkConditionalRenderingFlagsEXT,
}
#[test]
fn bindgen_test_layout_VkConditionalRenderingBeginInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkConditionalRenderingBeginInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkConditionalRenderingBeginInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkConditionalRenderingBeginInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkConditionalRenderingBeginInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkConditionalRenderingBeginInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkConditionalRenderingBeginInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkConditionalRenderingBeginInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkConditionalRenderingBeginInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkConditionalRenderingBeginInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkConditionalRenderingBeginInfoEXT),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkConditionalRenderingBeginInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkConditionalRenderingBeginInfoEXT),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkConditionalRenderingBeginInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkConditionalRenderingBeginInfoEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for VkConditionalRenderingBeginInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceConditionalRenderingFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub conditionalRendering: VkBool32,
    pub inheritedConditionalRendering: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceConditionalRenderingFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceConditionalRenderingFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceConditionalRenderingFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceConditionalRenderingFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceConditionalRenderingFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceConditionalRenderingFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceConditionalRenderingFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceConditionalRenderingFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceConditionalRenderingFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_conditionalRendering() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceConditionalRenderingFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).conditionalRendering) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceConditionalRenderingFeaturesEXT),
                "::",
                stringify!(conditionalRendering)
            )
        );
    }
    test_field_conditionalRendering();
    fn test_field_inheritedConditionalRendering() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceConditionalRenderingFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inheritedConditionalRendering) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceConditionalRenderingFeaturesEXT),
                "::",
                stringify!(inheritedConditionalRendering)
            )
        );
    }
    test_field_inheritedConditionalRendering();
}
impl Default for VkPhysicalDeviceConditionalRenderingFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBufferInheritanceConditionalRenderingInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub conditionalRenderingEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkCommandBufferInheritanceConditionalRenderingInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkCommandBufferInheritanceConditionalRenderingInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkCommandBufferInheritanceConditionalRenderingInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkCommandBufferInheritanceConditionalRenderingInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkCommandBufferInheritanceConditionalRenderingInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkCommandBufferInheritanceConditionalRenderingInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceConditionalRenderingInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkCommandBufferInheritanceConditionalRenderingInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceConditionalRenderingInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_conditionalRenderingEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkCommandBufferInheritanceConditionalRenderingInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).conditionalRenderingEnable) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceConditionalRenderingInfoEXT),
                "::",
                stringify!(conditionalRenderingEnable)
            )
        );
    }
    test_field_conditionalRenderingEnable();
}
impl Default for VkCommandBufferInheritanceConditionalRenderingInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdBeginConditionalRenderingEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pConditionalRenderingBegin: *const VkConditionalRenderingBeginInfoEXT,
    ),
>;
pub type PFN_vkCmdEndConditionalRenderingEXT =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer)>;
extern "C" {
    pub fn vkCmdBeginConditionalRenderingEXT(
        commandBuffer: VkCommandBuffer,
        pConditionalRenderingBegin: *const VkConditionalRenderingBeginInfoEXT,
    );
}
extern "C" {
    pub fn vkCmdEndConditionalRenderingEXT(commandBuffer: VkCommandBuffer);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkViewportWScalingNV {
    pub xcoeff: f32,
    pub ycoeff: f32,
}
#[test]
fn bindgen_test_layout_VkViewportWScalingNV() {
    assert_eq!(
        ::std::mem::size_of::<VkViewportWScalingNV>(),
        8usize,
        concat!("Size of: ", stringify!(VkViewportWScalingNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkViewportWScalingNV>(),
        4usize,
        concat!("Alignment of ", stringify!(VkViewportWScalingNV))
    );
    fn test_field_xcoeff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkViewportWScalingNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xcoeff) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkViewportWScalingNV),
                "::",
                stringify!(xcoeff)
            )
        );
    }
    test_field_xcoeff();
    fn test_field_ycoeff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkViewportWScalingNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ycoeff) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkViewportWScalingNV),
                "::",
                stringify!(ycoeff)
            )
        );
    }
    test_field_ycoeff();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineViewportWScalingStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub viewportWScalingEnable: VkBool32,
    pub viewportCount: u32,
    pub pViewportWScalings: *const VkViewportWScalingNV,
}
#[test]
fn bindgen_test_layout_VkPipelineViewportWScalingStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineViewportWScalingStateCreateInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineViewportWScalingStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineViewportWScalingStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineViewportWScalingStateCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineViewportWScalingStateCreateInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportWScalingStateCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineViewportWScalingStateCreateInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportWScalingStateCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_viewportWScalingEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineViewportWScalingStateCreateInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewportWScalingEnable) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportWScalingStateCreateInfoNV),
                "::",
                stringify!(viewportWScalingEnable)
            )
        );
    }
    test_field_viewportWScalingEnable();
    fn test_field_viewportCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineViewportWScalingStateCreateInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewportCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportWScalingStateCreateInfoNV),
                "::",
                stringify!(viewportCount)
            )
        );
    }
    test_field_viewportCount();
    fn test_field_pViewportWScalings() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineViewportWScalingStateCreateInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pViewportWScalings) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportWScalingStateCreateInfoNV),
                "::",
                stringify!(pViewportWScalings)
            )
        );
    }
    test_field_pViewportWScalings();
}
impl Default for VkPipelineViewportWScalingStateCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdSetViewportWScalingNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstViewport: u32,
        viewportCount: u32,
        pViewportWScalings: *const VkViewportWScalingNV,
    ),
>;
extern "C" {
    pub fn vkCmdSetViewportWScalingNV(
        commandBuffer: VkCommandBuffer,
        firstViewport: u32,
        viewportCount: u32,
        pViewportWScalings: *const VkViewportWScalingNV,
    );
}
pub type PFN_vkReleaseDisplayEXT = ::std::option::Option<
    unsafe extern "C" fn(physicalDevice: VkPhysicalDevice, display: VkDisplayKHR) -> VkResult,
>;
extern "C" {
    pub fn vkReleaseDisplayEXT(physicalDevice: VkPhysicalDevice, display: VkDisplayKHR)
        -> VkResult;
}
pub const VK_SURFACE_COUNTER_VBLANK_BIT_EXT: VkSurfaceCounterFlagBitsEXT = 1;
pub const VK_SURFACE_COUNTER_VBLANK_EXT: VkSurfaceCounterFlagBitsEXT = 1;
pub const VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT: VkSurfaceCounterFlagBitsEXT = 2147483647;
pub type VkSurfaceCounterFlagBitsEXT = ::std::os::raw::c_int;
pub type VkSurfaceCounterFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSurfaceCapabilities2EXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub minImageCount: u32,
    pub maxImageCount: u32,
    pub currentExtent: VkExtent2D,
    pub minImageExtent: VkExtent2D,
    pub maxImageExtent: VkExtent2D,
    pub maxImageArrayLayers: u32,
    pub supportedTransforms: VkSurfaceTransformFlagsKHR,
    pub currentTransform: VkSurfaceTransformFlagBitsKHR,
    pub supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
    pub supportedUsageFlags: VkImageUsageFlags,
    pub supportedSurfaceCounters: VkSurfaceCounterFlagsEXT,
}
#[test]
fn bindgen_test_layout_VkSurfaceCapabilities2EXT() {
    assert_eq!(
        ::std::mem::size_of::<VkSurfaceCapabilities2EXT>(),
        72usize,
        concat!("Size of: ", stringify!(VkSurfaceCapabilities2EXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSurfaceCapabilities2EXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSurfaceCapabilities2EXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilities2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilities2EXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilities2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilities2EXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_minImageCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilities2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minImageCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilities2EXT),
                "::",
                stringify!(minImageCount)
            )
        );
    }
    test_field_minImageCount();
    fn test_field_maxImageCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilities2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxImageCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilities2EXT),
                "::",
                stringify!(maxImageCount)
            )
        );
    }
    test_field_maxImageCount();
    fn test_field_currentExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilities2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).currentExtent) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilities2EXT),
                "::",
                stringify!(currentExtent)
            )
        );
    }
    test_field_currentExtent();
    fn test_field_minImageExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilities2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minImageExtent) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilities2EXT),
                "::",
                stringify!(minImageExtent)
            )
        );
    }
    test_field_minImageExtent();
    fn test_field_maxImageExtent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilities2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxImageExtent) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilities2EXT),
                "::",
                stringify!(maxImageExtent)
            )
        );
    }
    test_field_maxImageExtent();
    fn test_field_maxImageArrayLayers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilities2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxImageArrayLayers) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilities2EXT),
                "::",
                stringify!(maxImageArrayLayers)
            )
        );
    }
    test_field_maxImageArrayLayers();
    fn test_field_supportedTransforms() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilities2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedTransforms) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilities2EXT),
                "::",
                stringify!(supportedTransforms)
            )
        );
    }
    test_field_supportedTransforms();
    fn test_field_currentTransform() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilities2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).currentTransform) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilities2EXT),
                "::",
                stringify!(currentTransform)
            )
        );
    }
    test_field_currentTransform();
    fn test_field_supportedCompositeAlpha() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilities2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedCompositeAlpha) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilities2EXT),
                "::",
                stringify!(supportedCompositeAlpha)
            )
        );
    }
    test_field_supportedCompositeAlpha();
    fn test_field_supportedUsageFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilities2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedUsageFlags) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilities2EXT),
                "::",
                stringify!(supportedUsageFlags)
            )
        );
    }
    test_field_supportedUsageFlags();
    fn test_field_supportedSurfaceCounters() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSurfaceCapabilities2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedSurfaceCounters) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilities2EXT),
                "::",
                stringify!(supportedSurfaceCounters)
            )
        );
    }
    test_field_supportedSurfaceCounters();
}
impl Default for VkSurfaceCapabilities2EXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceCapabilities: *mut VkSurfaceCapabilities2EXT,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceCapabilities2EXT(
        physicalDevice: VkPhysicalDevice,
        surface: VkSurfaceKHR,
        pSurfaceCapabilities: *mut VkSurfaceCapabilities2EXT,
    ) -> VkResult;
}
pub const VK_DISPLAY_POWER_STATE_OFF_EXT: VkDisplayPowerStateEXT = 0;
pub const VK_DISPLAY_POWER_STATE_SUSPEND_EXT: VkDisplayPowerStateEXT = 1;
pub const VK_DISPLAY_POWER_STATE_ON_EXT: VkDisplayPowerStateEXT = 2;
pub const VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT: VkDisplayPowerStateEXT = 2147483647;
pub type VkDisplayPowerStateEXT = ::std::os::raw::c_int;
pub const VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT: VkDeviceEventTypeEXT = 0;
pub const VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT: VkDeviceEventTypeEXT = 2147483647;
pub type VkDeviceEventTypeEXT = ::std::os::raw::c_int;
pub const VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT: VkDisplayEventTypeEXT = 0;
pub const VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT: VkDisplayEventTypeEXT = 2147483647;
pub type VkDisplayEventTypeEXT = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayPowerInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub powerState: VkDisplayPowerStateEXT,
}
#[test]
fn bindgen_test_layout_VkDisplayPowerInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayPowerInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkDisplayPowerInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayPowerInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayPowerInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPowerInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPowerInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPowerInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPowerInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_powerState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayPowerInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).powerState) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayPowerInfoEXT),
                "::",
                stringify!(powerState)
            )
        );
    }
    test_field_powerState();
}
impl Default for VkDisplayPowerInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceEventInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub deviceEvent: VkDeviceEventTypeEXT,
}
#[test]
fn bindgen_test_layout_VkDeviceEventInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceEventInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkDeviceEventInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceEventInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceEventInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceEventInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceEventInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceEventInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceEventInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_deviceEvent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceEventInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceEvent) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceEventInfoEXT),
                "::",
                stringify!(deviceEvent)
            )
        );
    }
    test_field_deviceEvent();
}
impl Default for VkDeviceEventInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayEventInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub displayEvent: VkDisplayEventTypeEXT,
}
#[test]
fn bindgen_test_layout_VkDisplayEventInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayEventInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkDisplayEventInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayEventInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDisplayEventInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayEventInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayEventInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayEventInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayEventInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_displayEvent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDisplayEventInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayEvent) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayEventInfoEXT),
                "::",
                stringify!(displayEvent)
            )
        );
    }
    test_field_displayEvent();
}
impl Default for VkDisplayEventInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSwapchainCounterCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub surfaceCounters: VkSurfaceCounterFlagsEXT,
}
#[test]
fn bindgen_test_layout_VkSwapchainCounterCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkSwapchainCounterCreateInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkSwapchainCounterCreateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSwapchainCounterCreateInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSwapchainCounterCreateInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCounterCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCounterCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCounterCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCounterCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_surfaceCounters() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSwapchainCounterCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).surfaceCounters) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainCounterCreateInfoEXT),
                "::",
                stringify!(surfaceCounters)
            )
        );
    }
    test_field_surfaceCounters();
}
impl Default for VkSwapchainCounterCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkDisplayPowerControlEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        display: VkDisplayKHR,
        pDisplayPowerInfo: *const VkDisplayPowerInfoEXT,
    ) -> VkResult,
>;
pub type PFN_vkRegisterDeviceEventEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pDeviceEventInfo: *const VkDeviceEventInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pFence: *mut VkFence,
    ) -> VkResult,
>;
pub type PFN_vkRegisterDisplayEventEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        display: VkDisplayKHR,
        pDisplayEventInfo: *const VkDisplayEventInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pFence: *mut VkFence,
    ) -> VkResult,
>;
pub type PFN_vkGetSwapchainCounterEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        counter: VkSurfaceCounterFlagBitsEXT,
        pCounterValue: *mut u64,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkDisplayPowerControlEXT(
        device: VkDevice,
        display: VkDisplayKHR,
        pDisplayPowerInfo: *const VkDisplayPowerInfoEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkRegisterDeviceEventEXT(
        device: VkDevice,
        pDeviceEventInfo: *const VkDeviceEventInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pFence: *mut VkFence,
    ) -> VkResult;
}
extern "C" {
    pub fn vkRegisterDisplayEventEXT(
        device: VkDevice,
        display: VkDisplayKHR,
        pDisplayEventInfo: *const VkDisplayEventInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pFence: *mut VkFence,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetSwapchainCounterEXT(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        counter: VkSurfaceCounterFlagBitsEXT,
        pCounterValue: *mut u64,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkRefreshCycleDurationGOOGLE {
    pub refreshDuration: u64,
}
#[test]
fn bindgen_test_layout_VkRefreshCycleDurationGOOGLE() {
    assert_eq!(
        ::std::mem::size_of::<VkRefreshCycleDurationGOOGLE>(),
        8usize,
        concat!("Size of: ", stringify!(VkRefreshCycleDurationGOOGLE))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRefreshCycleDurationGOOGLE>(),
        8usize,
        concat!("Alignment of ", stringify!(VkRefreshCycleDurationGOOGLE))
    );
    fn test_field_refreshDuration() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRefreshCycleDurationGOOGLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).refreshDuration) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRefreshCycleDurationGOOGLE),
                "::",
                stringify!(refreshDuration)
            )
        );
    }
    test_field_refreshDuration();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkPastPresentationTimingGOOGLE {
    pub presentID: u32,
    pub desiredPresentTime: u64,
    pub actualPresentTime: u64,
    pub earliestPresentTime: u64,
    pub presentMargin: u64,
}
#[test]
fn bindgen_test_layout_VkPastPresentationTimingGOOGLE() {
    assert_eq!(
        ::std::mem::size_of::<VkPastPresentationTimingGOOGLE>(),
        40usize,
        concat!("Size of: ", stringify!(VkPastPresentationTimingGOOGLE))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPastPresentationTimingGOOGLE>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPastPresentationTimingGOOGLE))
    );
    fn test_field_presentID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPastPresentationTimingGOOGLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).presentID) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPastPresentationTimingGOOGLE),
                "::",
                stringify!(presentID)
            )
        );
    }
    test_field_presentID();
    fn test_field_desiredPresentTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPastPresentationTimingGOOGLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).desiredPresentTime) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPastPresentationTimingGOOGLE),
                "::",
                stringify!(desiredPresentTime)
            )
        );
    }
    test_field_desiredPresentTime();
    fn test_field_actualPresentTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPastPresentationTimingGOOGLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).actualPresentTime) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPastPresentationTimingGOOGLE),
                "::",
                stringify!(actualPresentTime)
            )
        );
    }
    test_field_actualPresentTime();
    fn test_field_earliestPresentTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPastPresentationTimingGOOGLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).earliestPresentTime) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPastPresentationTimingGOOGLE),
                "::",
                stringify!(earliestPresentTime)
            )
        );
    }
    test_field_earliestPresentTime();
    fn test_field_presentMargin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPastPresentationTimingGOOGLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).presentMargin) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPastPresentationTimingGOOGLE),
                "::",
                stringify!(presentMargin)
            )
        );
    }
    test_field_presentMargin();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkPresentTimeGOOGLE {
    pub presentID: u32,
    pub desiredPresentTime: u64,
}
#[test]
fn bindgen_test_layout_VkPresentTimeGOOGLE() {
    assert_eq!(
        ::std::mem::size_of::<VkPresentTimeGOOGLE>(),
        16usize,
        concat!("Size of: ", stringify!(VkPresentTimeGOOGLE))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPresentTimeGOOGLE>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPresentTimeGOOGLE))
    );
    fn test_field_presentID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentTimeGOOGLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).presentID) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentTimeGOOGLE),
                "::",
                stringify!(presentID)
            )
        );
    }
    test_field_presentID();
    fn test_field_desiredPresentTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentTimeGOOGLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).desiredPresentTime) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentTimeGOOGLE),
                "::",
                stringify!(desiredPresentTime)
            )
        );
    }
    test_field_desiredPresentTime();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPresentTimesInfoGOOGLE {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchainCount: u32,
    pub pTimes: *const VkPresentTimeGOOGLE,
}
#[test]
fn bindgen_test_layout_VkPresentTimesInfoGOOGLE() {
    assert_eq!(
        ::std::mem::size_of::<VkPresentTimesInfoGOOGLE>(),
        32usize,
        concat!("Size of: ", stringify!(VkPresentTimesInfoGOOGLE))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPresentTimesInfoGOOGLE>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPresentTimesInfoGOOGLE))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentTimesInfoGOOGLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentTimesInfoGOOGLE),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentTimesInfoGOOGLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentTimesInfoGOOGLE),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_swapchainCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentTimesInfoGOOGLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).swapchainCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentTimesInfoGOOGLE),
                "::",
                stringify!(swapchainCount)
            )
        );
    }
    test_field_swapchainCount();
    fn test_field_pTimes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPresentTimesInfoGOOGLE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pTimes) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPresentTimesInfoGOOGLE),
                "::",
                stringify!(pTimes)
            )
        );
    }
    test_field_pTimes();
}
impl Default for VkPresentTimesInfoGOOGLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetRefreshCycleDurationGOOGLE = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pDisplayTimingProperties: *mut VkRefreshCycleDurationGOOGLE,
    ) -> VkResult,
>;
pub type PFN_vkGetPastPresentationTimingGOOGLE = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pPresentationTimingCount: *mut u32,
        pPresentationTimings: *mut VkPastPresentationTimingGOOGLE,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetRefreshCycleDurationGOOGLE(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pDisplayTimingProperties: *mut VkRefreshCycleDurationGOOGLE,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPastPresentationTimingGOOGLE(
        device: VkDevice,
        swapchain: VkSwapchainKHR,
        pPresentationTimingCount: *mut u32,
        pPresentationTimings: *mut VkPastPresentationTimingGOOGLE,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub perViewPositionAllComponents: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_perViewPositionAllComponents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).perViewPositionAllComponents) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX),
                "::",
                stringify!(perViewPositionAllComponents)
            )
        );
    }
    test_field_perViewPositionAllComponents();
}
impl Default for VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV: VkViewportCoordinateSwizzleNV = 0;
pub const VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV: VkViewportCoordinateSwizzleNV = 1;
pub const VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV: VkViewportCoordinateSwizzleNV = 2;
pub const VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV: VkViewportCoordinateSwizzleNV = 3;
pub const VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV: VkViewportCoordinateSwizzleNV = 4;
pub const VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV: VkViewportCoordinateSwizzleNV = 5;
pub const VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV: VkViewportCoordinateSwizzleNV = 6;
pub const VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV: VkViewportCoordinateSwizzleNV = 7;
pub const VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV: VkViewportCoordinateSwizzleNV = 2147483647;
pub type VkViewportCoordinateSwizzleNV = ::std::os::raw::c_int;
pub type VkPipelineViewportSwizzleStateCreateFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkViewportSwizzleNV {
    pub x: VkViewportCoordinateSwizzleNV,
    pub y: VkViewportCoordinateSwizzleNV,
    pub z: VkViewportCoordinateSwizzleNV,
    pub w: VkViewportCoordinateSwizzleNV,
}
#[test]
fn bindgen_test_layout_VkViewportSwizzleNV() {
    assert_eq!(
        ::std::mem::size_of::<VkViewportSwizzleNV>(),
        16usize,
        concat!("Size of: ", stringify!(VkViewportSwizzleNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkViewportSwizzleNV>(),
        4usize,
        concat!("Alignment of ", stringify!(VkViewportSwizzleNV))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkViewportSwizzleNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkViewportSwizzleNV),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkViewportSwizzleNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkViewportSwizzleNV),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_z() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkViewportSwizzleNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkViewportSwizzleNV),
                "::",
                stringify!(z)
            )
        );
    }
    test_field_z();
    fn test_field_w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkViewportSwizzleNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkViewportSwizzleNV),
                "::",
                stringify!(w)
            )
        );
    }
    test_field_w();
}
impl Default for VkViewportSwizzleNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineViewportSwizzleStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineViewportSwizzleStateCreateFlagsNV,
    pub viewportCount: u32,
    pub pViewportSwizzles: *const VkViewportSwizzleNV,
}
#[test]
fn bindgen_test_layout_VkPipelineViewportSwizzleStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineViewportSwizzleStateCreateInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineViewportSwizzleStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineViewportSwizzleStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineViewportSwizzleStateCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineViewportSwizzleStateCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportSwizzleStateCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineViewportSwizzleStateCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportSwizzleStateCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineViewportSwizzleStateCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportSwizzleStateCreateInfoNV),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_viewportCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineViewportSwizzleStateCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewportCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportSwizzleStateCreateInfoNV),
                "::",
                stringify!(viewportCount)
            )
        );
    }
    test_field_viewportCount();
    fn test_field_pViewportSwizzles() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineViewportSwizzleStateCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pViewportSwizzles) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportSwizzleStateCreateInfoNV),
                "::",
                stringify!(pViewportSwizzles)
            )
        );
    }
    test_field_pViewportSwizzles();
}
impl Default for VkPipelineViewportSwizzleStateCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT: VkDiscardRectangleModeEXT = 0;
pub const VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT: VkDiscardRectangleModeEXT = 1;
pub const VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT: VkDiscardRectangleModeEXT = 2147483647;
pub type VkDiscardRectangleModeEXT = ::std::os::raw::c_int;
pub type VkPipelineDiscardRectangleStateCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDiscardRectanglePropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxDiscardRectangles: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDiscardRectanglePropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDiscardRectanglePropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDiscardRectanglePropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDiscardRectanglePropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDiscardRectanglePropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDiscardRectanglePropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDiscardRectanglePropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDiscardRectanglePropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDiscardRectanglePropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxDiscardRectangles() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDiscardRectanglePropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDiscardRectangles) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDiscardRectanglePropertiesEXT),
                "::",
                stringify!(maxDiscardRectangles)
            )
        );
    }
    test_field_maxDiscardRectangles();
}
impl Default for VkPhysicalDeviceDiscardRectanglePropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineDiscardRectangleStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineDiscardRectangleStateCreateFlagsEXT,
    pub discardRectangleMode: VkDiscardRectangleModeEXT,
    pub discardRectangleCount: u32,
    pub pDiscardRectangles: *const VkRect2D,
}
#[test]
fn bindgen_test_layout_VkPipelineDiscardRectangleStateCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineDiscardRectangleStateCreateInfoEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineDiscardRectangleStateCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineDiscardRectangleStateCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineDiscardRectangleStateCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDiscardRectangleStateCreateInfoEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDiscardRectangleStateCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDiscardRectangleStateCreateInfoEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDiscardRectangleStateCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDiscardRectangleStateCreateInfoEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDiscardRectangleStateCreateInfoEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_discardRectangleMode() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDiscardRectangleStateCreateInfoEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).discardRectangleMode) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDiscardRectangleStateCreateInfoEXT),
                "::",
                stringify!(discardRectangleMode)
            )
        );
    }
    test_field_discardRectangleMode();
    fn test_field_discardRectangleCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDiscardRectangleStateCreateInfoEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).discardRectangleCount) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDiscardRectangleStateCreateInfoEXT),
                "::",
                stringify!(discardRectangleCount)
            )
        );
    }
    test_field_discardRectangleCount();
    fn test_field_pDiscardRectangles() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineDiscardRectangleStateCreateInfoEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDiscardRectangles) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineDiscardRectangleStateCreateInfoEXT),
                "::",
                stringify!(pDiscardRectangles)
            )
        );
    }
    test_field_pDiscardRectangles();
}
impl Default for VkPipelineDiscardRectangleStateCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdSetDiscardRectangleEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstDiscardRectangle: u32,
        discardRectangleCount: u32,
        pDiscardRectangles: *const VkRect2D,
    ),
>;
extern "C" {
    pub fn vkCmdSetDiscardRectangleEXT(
        commandBuffer: VkCommandBuffer,
        firstDiscardRectangle: u32,
        discardRectangleCount: u32,
        pDiscardRectangles: *const VkRect2D,
    );
}
pub const VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT: VkConservativeRasterizationModeEXT = 0;
pub const VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT: VkConservativeRasterizationModeEXT =
    1;
pub const VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT: VkConservativeRasterizationModeEXT =
    2;
pub const VK_CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT: VkConservativeRasterizationModeEXT =
    2147483647;
pub type VkConservativeRasterizationModeEXT = ::std::os::raw::c_int;
pub type VkPipelineRasterizationConservativeStateCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub primitiveOverestimationSize: f32,
    pub maxExtraPrimitiveOverestimationSize: f32,
    pub extraPrimitiveOverestimationSizeGranularity: f32,
    pub primitiveUnderestimation: VkBool32,
    pub conservativePointAndLineRasterization: VkBool32,
    pub degenerateTrianglesRasterized: VkBool32,
    pub degenerateLinesRasterized: VkBool32,
    pub fullyCoveredFragmentShaderInputVariable: VkBool32,
    pub conservativeRasterizationPostDepthCoverage: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceConservativeRasterizationPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceConservativeRasterizationPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceConservativeRasterizationPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_primitiveOverestimationSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceConservativeRasterizationPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).primitiveOverestimationSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
                "::",
                stringify!(primitiveOverestimationSize)
            )
        );
    }
    test_field_primitiveOverestimationSize();
    fn test_field_maxExtraPrimitiveOverestimationSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceConservativeRasterizationPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxExtraPrimitiveOverestimationSize) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
                "::",
                stringify!(maxExtraPrimitiveOverestimationSize)
            )
        );
    }
    test_field_maxExtraPrimitiveOverestimationSize();
    fn test_field_extraPrimitiveOverestimationSizeGranularity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceConservativeRasterizationPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extraPrimitiveOverestimationSizeGranularity) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
                "::",
                stringify!(extraPrimitiveOverestimationSizeGranularity)
            )
        );
    }
    test_field_extraPrimitiveOverestimationSizeGranularity();
    fn test_field_primitiveUnderestimation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceConservativeRasterizationPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).primitiveUnderestimation) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
                "::",
                stringify!(primitiveUnderestimation)
            )
        );
    }
    test_field_primitiveUnderestimation();
    fn test_field_conservativePointAndLineRasterization() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceConservativeRasterizationPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).conservativePointAndLineRasterization) as usize
                    - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
                "::",
                stringify!(conservativePointAndLineRasterization)
            )
        );
    }
    test_field_conservativePointAndLineRasterization();
    fn test_field_degenerateTrianglesRasterized() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceConservativeRasterizationPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).degenerateTrianglesRasterized) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
                "::",
                stringify!(degenerateTrianglesRasterized)
            )
        );
    }
    test_field_degenerateTrianglesRasterized();
    fn test_field_degenerateLinesRasterized() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceConservativeRasterizationPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).degenerateLinesRasterized) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
                "::",
                stringify!(degenerateLinesRasterized)
            )
        );
    }
    test_field_degenerateLinesRasterized();
    fn test_field_fullyCoveredFragmentShaderInputVariable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceConservativeRasterizationPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fullyCoveredFragmentShaderInputVariable) as usize
                    - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
                "::",
                stringify!(fullyCoveredFragmentShaderInputVariable)
            )
        );
    }
    test_field_fullyCoveredFragmentShaderInputVariable();
    fn test_field_conservativeRasterizationPostDepthCoverage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceConservativeRasterizationPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).conservativeRasterizationPostDepthCoverage) as usize
                    - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceConservativeRasterizationPropertiesEXT),
                "::",
                stringify!(conservativeRasterizationPostDepthCoverage)
            )
        );
    }
    test_field_conservativeRasterizationPostDepthCoverage();
}
impl Default for VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRasterizationConservativeStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineRasterizationConservativeStateCreateFlagsEXT,
    pub conservativeRasterizationMode: VkConservativeRasterizationModeEXT,
    pub extraPrimitiveOverestimationSize: f32,
}
#[test]
fn bindgen_test_layout_VkPipelineRasterizationConservativeStateCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRasterizationConservativeStateCreateInfoEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineRasterizationConservativeStateCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRasterizationConservativeStateCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineRasterizationConservativeStateCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationConservativeStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationConservativeStateCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationConservativeStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationConservativeStateCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationConservativeStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationConservativeStateCreateInfoEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_conservativeRasterizationMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationConservativeStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).conservativeRasterizationMode) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationConservativeStateCreateInfoEXT),
                "::",
                stringify!(conservativeRasterizationMode)
            )
        );
    }
    test_field_conservativeRasterizationMode();
    fn test_field_extraPrimitiveOverestimationSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationConservativeStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extraPrimitiveOverestimationSize) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationConservativeStateCreateInfoEXT),
                "::",
                stringify!(extraPrimitiveOverestimationSize)
            )
        );
    }
    test_field_extraPrimitiveOverestimationSize();
}
impl Default for VkPipelineRasterizationConservativeStateCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPipelineRasterizationDepthClipStateCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDepthClipEnableFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub depthClipEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDepthClipEnableFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDepthClipEnableFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDepthClipEnableFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDepthClipEnableFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDepthClipEnableFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDepthClipEnableFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDepthClipEnableFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDepthClipEnableFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDepthClipEnableFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_depthClipEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDepthClipEnableFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthClipEnable) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDepthClipEnableFeaturesEXT),
                "::",
                stringify!(depthClipEnable)
            )
        );
    }
    test_field_depthClipEnable();
}
impl Default for VkPhysicalDeviceDepthClipEnableFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRasterizationDepthClipStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineRasterizationDepthClipStateCreateFlagsEXT,
    pub depthClipEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPipelineRasterizationDepthClipStateCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRasterizationDepthClipStateCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineRasterizationDepthClipStateCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRasterizationDepthClipStateCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineRasterizationDepthClipStateCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationDepthClipStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationDepthClipStateCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationDepthClipStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationDepthClipStateCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationDepthClipStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationDepthClipStateCreateInfoEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_depthClipEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationDepthClipStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthClipEnable) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationDepthClipStateCreateInfoEXT),
                "::",
                stringify!(depthClipEnable)
            )
        );
    }
    test_field_depthClipEnable();
}
impl Default for VkPipelineRasterizationDepthClipStateCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkXYColorEXT {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_VkXYColorEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkXYColorEXT>(),
        8usize,
        concat!("Size of: ", stringify!(VkXYColorEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkXYColorEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(VkXYColorEXT))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkXYColorEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkXYColorEXT),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkXYColorEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkXYColorEXT),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkHdrMetadataEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub displayPrimaryRed: VkXYColorEXT,
    pub displayPrimaryGreen: VkXYColorEXT,
    pub displayPrimaryBlue: VkXYColorEXT,
    pub whitePoint: VkXYColorEXT,
    pub maxLuminance: f32,
    pub minLuminance: f32,
    pub maxContentLightLevel: f32,
    pub maxFrameAverageLightLevel: f32,
}
#[test]
fn bindgen_test_layout_VkHdrMetadataEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkHdrMetadataEXT>(),
        64usize,
        concat!("Size of: ", stringify!(VkHdrMetadataEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkHdrMetadataEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkHdrMetadataEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkHdrMetadataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkHdrMetadataEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkHdrMetadataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkHdrMetadataEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_displayPrimaryRed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkHdrMetadataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimaryRed) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkHdrMetadataEXT),
                "::",
                stringify!(displayPrimaryRed)
            )
        );
    }
    test_field_displayPrimaryRed();
    fn test_field_displayPrimaryGreen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkHdrMetadataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimaryGreen) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkHdrMetadataEXT),
                "::",
                stringify!(displayPrimaryGreen)
            )
        );
    }
    test_field_displayPrimaryGreen();
    fn test_field_displayPrimaryBlue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkHdrMetadataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).displayPrimaryBlue) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkHdrMetadataEXT),
                "::",
                stringify!(displayPrimaryBlue)
            )
        );
    }
    test_field_displayPrimaryBlue();
    fn test_field_whitePoint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkHdrMetadataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).whitePoint) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkHdrMetadataEXT),
                "::",
                stringify!(whitePoint)
            )
        );
    }
    test_field_whitePoint();
    fn test_field_maxLuminance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkHdrMetadataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxLuminance) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkHdrMetadataEXT),
                "::",
                stringify!(maxLuminance)
            )
        );
    }
    test_field_maxLuminance();
    fn test_field_minLuminance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkHdrMetadataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minLuminance) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkHdrMetadataEXT),
                "::",
                stringify!(minLuminance)
            )
        );
    }
    test_field_minLuminance();
    fn test_field_maxContentLightLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkHdrMetadataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxContentLightLevel) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkHdrMetadataEXT),
                "::",
                stringify!(maxContentLightLevel)
            )
        );
    }
    test_field_maxContentLightLevel();
    fn test_field_maxFrameAverageLightLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkHdrMetadataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFrameAverageLightLevel) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkHdrMetadataEXT),
                "::",
                stringify!(maxFrameAverageLightLevel)
            )
        );
    }
    test_field_maxFrameAverageLightLevel();
}
impl Default for VkHdrMetadataEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkSetHdrMetadataEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        swapchainCount: u32,
        pSwapchains: *const VkSwapchainKHR,
        pMetadata: *const VkHdrMetadataEXT,
    ),
>;
extern "C" {
    pub fn vkSetHdrMetadataEXT(
        device: VkDevice,
        swapchainCount: u32,
        pSwapchains: *const VkSwapchainKHR,
        pMetadata: *const VkHdrMetadataEXT,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugUtilsMessengerEXT_T {
    _unused: [u8; 0],
}
pub type VkDebugUtilsMessengerEXT = *mut VkDebugUtilsMessengerEXT_T;
pub type VkDebugUtilsMessengerCallbackDataFlagsEXT = VkFlags;
pub const VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT: VkDebugUtilsMessageSeverityFlagBitsEXT =
    1;
pub const VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT: VkDebugUtilsMessageSeverityFlagBitsEXT = 16;
pub const VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT: VkDebugUtilsMessageSeverityFlagBitsEXT =
    256;
pub const VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT: VkDebugUtilsMessageSeverityFlagBitsEXT =
    4096;
pub const VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT:
    VkDebugUtilsMessageSeverityFlagBitsEXT = 2147483647;
pub type VkDebugUtilsMessageSeverityFlagBitsEXT = ::std::os::raw::c_int;
pub const VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT: VkDebugUtilsMessageTypeFlagBitsEXT = 1;
pub const VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT: VkDebugUtilsMessageTypeFlagBitsEXT = 2;
pub const VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT: VkDebugUtilsMessageTypeFlagBitsEXT = 4;
pub const VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT:
    VkDebugUtilsMessageTypeFlagBitsEXT = 8;
pub const VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT: VkDebugUtilsMessageTypeFlagBitsEXT =
    2147483647;
pub type VkDebugUtilsMessageTypeFlagBitsEXT = ::std::os::raw::c_int;
pub type VkDebugUtilsMessageTypeFlagsEXT = VkFlags;
pub type VkDebugUtilsMessageSeverityFlagsEXT = VkFlags;
pub type VkDebugUtilsMessengerCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugUtilsLabelEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pLabelName: *const ::std::os::raw::c_char,
    pub color: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_VkDebugUtilsLabelEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugUtilsLabelEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkDebugUtilsLabelEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugUtilsLabelEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDebugUtilsLabelEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugUtilsLabelEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsLabelEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugUtilsLabelEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsLabelEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pLabelName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugUtilsLabelEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pLabelName) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsLabelEXT),
                "::",
                stringify!(pLabelName)
            )
        );
    }
    test_field_pLabelName();
    fn test_field_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugUtilsLabelEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsLabelEXT),
                "::",
                stringify!(color)
            )
        );
    }
    test_field_color();
}
impl Default for VkDebugUtilsLabelEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugUtilsObjectNameInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub objectType: VkObjectType,
    pub objectHandle: u64,
    pub pObjectName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VkDebugUtilsObjectNameInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugUtilsObjectNameInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkDebugUtilsObjectNameInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugUtilsObjectNameInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDebugUtilsObjectNameInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugUtilsObjectNameInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsObjectNameInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugUtilsObjectNameInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsObjectNameInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_objectType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugUtilsObjectNameInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objectType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsObjectNameInfoEXT),
                "::",
                stringify!(objectType)
            )
        );
    }
    test_field_objectType();
    fn test_field_objectHandle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugUtilsObjectNameInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objectHandle) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsObjectNameInfoEXT),
                "::",
                stringify!(objectHandle)
            )
        );
    }
    test_field_objectHandle();
    fn test_field_pObjectName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugUtilsObjectNameInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pObjectName) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsObjectNameInfoEXT),
                "::",
                stringify!(pObjectName)
            )
        );
    }
    test_field_pObjectName();
}
impl Default for VkDebugUtilsObjectNameInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugUtilsMessengerCallbackDataEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDebugUtilsMessengerCallbackDataFlagsEXT,
    pub pMessageIdName: *const ::std::os::raw::c_char,
    pub messageIdNumber: i32,
    pub pMessage: *const ::std::os::raw::c_char,
    pub queueLabelCount: u32,
    pub pQueueLabels: *const VkDebugUtilsLabelEXT,
    pub cmdBufLabelCount: u32,
    pub pCmdBufLabels: *const VkDebugUtilsLabelEXT,
    pub objectCount: u32,
    pub pObjects: *const VkDebugUtilsObjectNameInfoEXT,
}
#[test]
fn bindgen_test_layout_VkDebugUtilsMessengerCallbackDataEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugUtilsMessengerCallbackDataEXT>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(VkDebugUtilsMessengerCallbackDataEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugUtilsMessengerCallbackDataEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDebugUtilsMessengerCallbackDataEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCallbackDataEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCallbackDataEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCallbackDataEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_pMessageIdName() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pMessageIdName) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCallbackDataEXT),
                "::",
                stringify!(pMessageIdName)
            )
        );
    }
    test_field_pMessageIdName();
    fn test_field_messageIdNumber() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).messageIdNumber) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCallbackDataEXT),
                "::",
                stringify!(messageIdNumber)
            )
        );
    }
    test_field_messageIdNumber();
    fn test_field_pMessage() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pMessage) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCallbackDataEXT),
                "::",
                stringify!(pMessage)
            )
        );
    }
    test_field_pMessage();
    fn test_field_queueLabelCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queueLabelCount) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCallbackDataEXT),
                "::",
                stringify!(queueLabelCount)
            )
        );
    }
    test_field_queueLabelCount();
    fn test_field_pQueueLabels() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pQueueLabels) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCallbackDataEXT),
                "::",
                stringify!(pQueueLabels)
            )
        );
    }
    test_field_pQueueLabels();
    fn test_field_cmdBufLabelCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmdBufLabelCount) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCallbackDataEXT),
                "::",
                stringify!(cmdBufLabelCount)
            )
        );
    }
    test_field_cmdBufLabelCount();
    fn test_field_pCmdBufLabels() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCmdBufLabels) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCallbackDataEXT),
                "::",
                stringify!(pCmdBufLabels)
            )
        );
    }
    test_field_pCmdBufLabels();
    fn test_field_objectCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objectCount) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCallbackDataEXT),
                "::",
                stringify!(objectCount)
            )
        );
    }
    test_field_objectCount();
    fn test_field_pObjects() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pObjects) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCallbackDataEXT),
                "::",
                stringify!(pObjects)
            )
        );
    }
    test_field_pObjects();
}
impl Default for VkDebugUtilsMessengerCallbackDataEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkDebugUtilsMessengerCallbackEXT = ::std::option::Option<
    unsafe extern "C" fn(
        messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT,
        messageTypes: VkDebugUtilsMessageTypeFlagsEXT,
        pCallbackData: *const VkDebugUtilsMessengerCallbackDataEXT,
        pUserData: *mut ::std::os::raw::c_void,
    ) -> VkBool32,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugUtilsMessengerCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDebugUtilsMessengerCreateFlagsEXT,
    pub messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT,
    pub messageType: VkDebugUtilsMessageTypeFlagsEXT,
    pub pfnUserCallback: PFN_vkDebugUtilsMessengerCallbackEXT,
    pub pUserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkDebugUtilsMessengerCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugUtilsMessengerCreateInfoEXT>(),
        48usize,
        concat!("Size of: ", stringify!(VkDebugUtilsMessengerCreateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugUtilsMessengerCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDebugUtilsMessengerCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCreateInfoEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_messageSeverity() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).messageSeverity) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCreateInfoEXT),
                "::",
                stringify!(messageSeverity)
            )
        );
    }
    test_field_messageSeverity();
    fn test_field_messageType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).messageType) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCreateInfoEXT),
                "::",
                stringify!(messageType)
            )
        );
    }
    test_field_messageType();
    fn test_field_pfnUserCallback() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pfnUserCallback) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCreateInfoEXT),
                "::",
                stringify!(pfnUserCallback)
            )
        );
    }
    test_field_pfnUserCallback();
    fn test_field_pUserData() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDebugUtilsMessengerCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsMessengerCreateInfoEXT),
                "::",
                stringify!(pUserData)
            )
        );
    }
    test_field_pUserData();
}
impl Default for VkDebugUtilsMessengerCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugUtilsObjectTagInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub objectType: VkObjectType,
    pub objectHandle: u64,
    pub tagName: u64,
    pub tagSize: usize,
    pub pTag: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkDebugUtilsObjectTagInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDebugUtilsObjectTagInfoEXT>(),
        56usize,
        concat!("Size of: ", stringify!(VkDebugUtilsObjectTagInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDebugUtilsObjectTagInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDebugUtilsObjectTagInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugUtilsObjectTagInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsObjectTagInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugUtilsObjectTagInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsObjectTagInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_objectType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugUtilsObjectTagInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objectType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsObjectTagInfoEXT),
                "::",
                stringify!(objectType)
            )
        );
    }
    test_field_objectType();
    fn test_field_objectHandle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugUtilsObjectTagInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objectHandle) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsObjectTagInfoEXT),
                "::",
                stringify!(objectHandle)
            )
        );
    }
    test_field_objectHandle();
    fn test_field_tagName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugUtilsObjectTagInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tagName) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsObjectTagInfoEXT),
                "::",
                stringify!(tagName)
            )
        );
    }
    test_field_tagName();
    fn test_field_tagSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugUtilsObjectTagInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tagSize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsObjectTagInfoEXT),
                "::",
                stringify!(tagSize)
            )
        );
    }
    test_field_tagSize();
    fn test_field_pTag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDebugUtilsObjectTagInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pTag) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDebugUtilsObjectTagInfoEXT),
                "::",
                stringify!(pTag)
            )
        );
    }
    test_field_pTag();
}
impl Default for VkDebugUtilsObjectTagInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkSetDebugUtilsObjectNameEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pNameInfo: *const VkDebugUtilsObjectNameInfoEXT,
    ) -> VkResult,
>;
pub type PFN_vkSetDebugUtilsObjectTagEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pTagInfo: *const VkDebugUtilsObjectTagInfoEXT,
    ) -> VkResult,
>;
pub type PFN_vkQueueBeginDebugUtilsLabelEXT = ::std::option::Option<
    unsafe extern "C" fn(queue: VkQueue, pLabelInfo: *const VkDebugUtilsLabelEXT),
>;
pub type PFN_vkQueueEndDebugUtilsLabelEXT =
    ::std::option::Option<unsafe extern "C" fn(queue: VkQueue)>;
pub type PFN_vkQueueInsertDebugUtilsLabelEXT = ::std::option::Option<
    unsafe extern "C" fn(queue: VkQueue, pLabelInfo: *const VkDebugUtilsLabelEXT),
>;
pub type PFN_vkCmdBeginDebugUtilsLabelEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pLabelInfo: *const VkDebugUtilsLabelEXT),
>;
pub type PFN_vkCmdEndDebugUtilsLabelEXT =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer)>;
pub type PFN_vkCmdInsertDebugUtilsLabelEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pLabelInfo: *const VkDebugUtilsLabelEXT),
>;
pub type PFN_vkCreateDebugUtilsMessengerEXT = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pCreateInfo: *const VkDebugUtilsMessengerCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pMessenger: *mut VkDebugUtilsMessengerEXT,
    ) -> VkResult,
>;
pub type PFN_vkDestroyDebugUtilsMessengerEXT = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        messenger: VkDebugUtilsMessengerEXT,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkSubmitDebugUtilsMessageEXT = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT,
        messageTypes: VkDebugUtilsMessageTypeFlagsEXT,
        pCallbackData: *const VkDebugUtilsMessengerCallbackDataEXT,
    ),
>;
extern "C" {
    pub fn vkSetDebugUtilsObjectNameEXT(
        device: VkDevice,
        pNameInfo: *const VkDebugUtilsObjectNameInfoEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkSetDebugUtilsObjectTagEXT(
        device: VkDevice,
        pTagInfo: *const VkDebugUtilsObjectTagInfoEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkQueueBeginDebugUtilsLabelEXT(queue: VkQueue, pLabelInfo: *const VkDebugUtilsLabelEXT);
}
extern "C" {
    pub fn vkQueueEndDebugUtilsLabelEXT(queue: VkQueue);
}
extern "C" {
    pub fn vkQueueInsertDebugUtilsLabelEXT(queue: VkQueue, pLabelInfo: *const VkDebugUtilsLabelEXT);
}
extern "C" {
    pub fn vkCmdBeginDebugUtilsLabelEXT(
        commandBuffer: VkCommandBuffer,
        pLabelInfo: *const VkDebugUtilsLabelEXT,
    );
}
extern "C" {
    pub fn vkCmdEndDebugUtilsLabelEXT(commandBuffer: VkCommandBuffer);
}
extern "C" {
    pub fn vkCmdInsertDebugUtilsLabelEXT(
        commandBuffer: VkCommandBuffer,
        pLabelInfo: *const VkDebugUtilsLabelEXT,
    );
}
extern "C" {
    pub fn vkCreateDebugUtilsMessengerEXT(
        instance: VkInstance,
        pCreateInfo: *const VkDebugUtilsMessengerCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pMessenger: *mut VkDebugUtilsMessengerEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyDebugUtilsMessengerEXT(
        instance: VkInstance,
        messenger: VkDebugUtilsMessengerEXT,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkSubmitDebugUtilsMessageEXT(
        instance: VkInstance,
        messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT,
        messageTypes: VkDebugUtilsMessageTypeFlagsEXT,
        pCallbackData: *const VkDebugUtilsMessengerCallbackDataEXT,
    );
}
pub use self::VkSamplerReductionMode as VkSamplerReductionModeEXT;
pub type VkSamplerReductionModeCreateInfoEXT = VkSamplerReductionModeCreateInfo;
pub type VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT =
    VkPhysicalDeviceSamplerFilterMinmaxProperties;
pub type VkPhysicalDeviceInlineUniformBlockFeaturesEXT = VkPhysicalDeviceInlineUniformBlockFeatures;
pub type VkPhysicalDeviceInlineUniformBlockPropertiesEXT =
    VkPhysicalDeviceInlineUniformBlockProperties;
pub type VkWriteDescriptorSetInlineUniformBlockEXT = VkWriteDescriptorSetInlineUniformBlock;
pub type VkDescriptorPoolInlineUniformBlockCreateInfoEXT =
    VkDescriptorPoolInlineUniformBlockCreateInfo;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkSampleLocationEXT {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_VkSampleLocationEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkSampleLocationEXT>(),
        8usize,
        concat!("Size of: ", stringify!(VkSampleLocationEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSampleLocationEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(VkSampleLocationEXT))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSampleLocationEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSampleLocationEXT),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSampleLocationEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSampleLocationEXT),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSampleLocationsInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub sampleLocationsPerPixel: VkSampleCountFlagBits,
    pub sampleLocationGridSize: VkExtent2D,
    pub sampleLocationsCount: u32,
    pub pSampleLocations: *const VkSampleLocationEXT,
}
#[test]
fn bindgen_test_layout_VkSampleLocationsInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkSampleLocationsInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkSampleLocationsInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSampleLocationsInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSampleLocationsInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSampleLocationsInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSampleLocationsInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSampleLocationsInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSampleLocationsInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_sampleLocationsPerPixel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSampleLocationsInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleLocationsPerPixel) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSampleLocationsInfoEXT),
                "::",
                stringify!(sampleLocationsPerPixel)
            )
        );
    }
    test_field_sampleLocationsPerPixel();
    fn test_field_sampleLocationGridSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSampleLocationsInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleLocationGridSize) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSampleLocationsInfoEXT),
                "::",
                stringify!(sampleLocationGridSize)
            )
        );
    }
    test_field_sampleLocationGridSize();
    fn test_field_sampleLocationsCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSampleLocationsInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleLocationsCount) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSampleLocationsInfoEXT),
                "::",
                stringify!(sampleLocationsCount)
            )
        );
    }
    test_field_sampleLocationsCount();
    fn test_field_pSampleLocations() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSampleLocationsInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSampleLocations) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSampleLocationsInfoEXT),
                "::",
                stringify!(pSampleLocations)
            )
        );
    }
    test_field_pSampleLocations();
}
impl Default for VkSampleLocationsInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAttachmentSampleLocationsEXT {
    pub attachmentIndex: u32,
    pub sampleLocationsInfo: VkSampleLocationsInfoEXT,
}
#[test]
fn bindgen_test_layout_VkAttachmentSampleLocationsEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkAttachmentSampleLocationsEXT>(),
        48usize,
        concat!("Size of: ", stringify!(VkAttachmentSampleLocationsEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAttachmentSampleLocationsEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAttachmentSampleLocationsEXT))
    );
    fn test_field_attachmentIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentSampleLocationsEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attachmentIndex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentSampleLocationsEXT),
                "::",
                stringify!(attachmentIndex)
            )
        );
    }
    test_field_attachmentIndex();
    fn test_field_sampleLocationsInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAttachmentSampleLocationsEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleLocationsInfo) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAttachmentSampleLocationsEXT),
                "::",
                stringify!(sampleLocationsInfo)
            )
        );
    }
    test_field_sampleLocationsInfo();
}
impl Default for VkAttachmentSampleLocationsEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassSampleLocationsEXT {
    pub subpassIndex: u32,
    pub sampleLocationsInfo: VkSampleLocationsInfoEXT,
}
#[test]
fn bindgen_test_layout_VkSubpassSampleLocationsEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassSampleLocationsEXT>(),
        48usize,
        concat!("Size of: ", stringify!(VkSubpassSampleLocationsEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassSampleLocationsEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubpassSampleLocationsEXT))
    );
    fn test_field_subpassIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassSampleLocationsEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subpassIndex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassSampleLocationsEXT),
                "::",
                stringify!(subpassIndex)
            )
        );
    }
    test_field_subpassIndex();
    fn test_field_sampleLocationsInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubpassSampleLocationsEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleLocationsInfo) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassSampleLocationsEXT),
                "::",
                stringify!(sampleLocationsInfo)
            )
        );
    }
    test_field_sampleLocationsInfo();
}
impl Default for VkSubpassSampleLocationsEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassSampleLocationsBeginInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub attachmentInitialSampleLocationsCount: u32,
    pub pAttachmentInitialSampleLocations: *const VkAttachmentSampleLocationsEXT,
    pub postSubpassSampleLocationsCount: u32,
    pub pPostSubpassSampleLocations: *const VkSubpassSampleLocationsEXT,
}
#[test]
fn bindgen_test_layout_VkRenderPassSampleLocationsBeginInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassSampleLocationsBeginInfoEXT>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkRenderPassSampleLocationsBeginInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassSampleLocationsBeginInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRenderPassSampleLocationsBeginInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassSampleLocationsBeginInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassSampleLocationsBeginInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassSampleLocationsBeginInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassSampleLocationsBeginInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_attachmentInitialSampleLocationsCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassSampleLocationsBeginInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attachmentInitialSampleLocationsCount) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassSampleLocationsBeginInfoEXT),
                "::",
                stringify!(attachmentInitialSampleLocationsCount)
            )
        );
    }
    test_field_attachmentInitialSampleLocationsCount();
    fn test_field_pAttachmentInitialSampleLocations() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassSampleLocationsBeginInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pAttachmentInitialSampleLocations) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassSampleLocationsBeginInfoEXT),
                "::",
                stringify!(pAttachmentInitialSampleLocations)
            )
        );
    }
    test_field_pAttachmentInitialSampleLocations();
    fn test_field_postSubpassSampleLocationsCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassSampleLocationsBeginInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).postSubpassSampleLocationsCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassSampleLocationsBeginInfoEXT),
                "::",
                stringify!(postSubpassSampleLocationsCount)
            )
        );
    }
    test_field_postSubpassSampleLocationsCount();
    fn test_field_pPostSubpassSampleLocations() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassSampleLocationsBeginInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pPostSubpassSampleLocations) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassSampleLocationsBeginInfoEXT),
                "::",
                stringify!(pPostSubpassSampleLocations)
            )
        );
    }
    test_field_pPostSubpassSampleLocations();
}
impl Default for VkRenderPassSampleLocationsBeginInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineSampleLocationsStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub sampleLocationsEnable: VkBool32,
    pub sampleLocationsInfo: VkSampleLocationsInfoEXT,
}
#[test]
fn bindgen_test_layout_VkPipelineSampleLocationsStateCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineSampleLocationsStateCreateInfoEXT>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineSampleLocationsStateCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineSampleLocationsStateCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineSampleLocationsStateCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineSampleLocationsStateCreateInfoEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineSampleLocationsStateCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineSampleLocationsStateCreateInfoEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineSampleLocationsStateCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_sampleLocationsEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineSampleLocationsStateCreateInfoEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleLocationsEnable) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineSampleLocationsStateCreateInfoEXT),
                "::",
                stringify!(sampleLocationsEnable)
            )
        );
    }
    test_field_sampleLocationsEnable();
    fn test_field_sampleLocationsInfo() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineSampleLocationsStateCreateInfoEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleLocationsInfo) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineSampleLocationsStateCreateInfoEXT),
                "::",
                stringify!(sampleLocationsInfo)
            )
        );
    }
    test_field_sampleLocationsInfo();
}
impl Default for VkPipelineSampleLocationsStateCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSampleLocationsPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub sampleLocationSampleCounts: VkSampleCountFlags,
    pub maxSampleLocationGridSize: VkExtent2D,
    pub sampleLocationCoordinateRange: [f32; 2usize],
    pub sampleLocationSubPixelBits: u32,
    pub variableSampleLocations: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSampleLocationsPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSampleLocationsPropertiesEXT>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSampleLocationsPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSampleLocationsPropertiesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSampleLocationsPropertiesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_sampleLocationSampleCounts() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSampleLocationsPropertiesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleLocationSampleCounts) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT),
                "::",
                stringify!(sampleLocationSampleCounts)
            )
        );
    }
    test_field_sampleLocationSampleCounts();
    fn test_field_maxSampleLocationGridSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSampleLocationsPropertiesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSampleLocationGridSize) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT),
                "::",
                stringify!(maxSampleLocationGridSize)
            )
        );
    }
    test_field_maxSampleLocationGridSize();
    fn test_field_sampleLocationCoordinateRange() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSampleLocationsPropertiesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleLocationCoordinateRange) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT),
                "::",
                stringify!(sampleLocationCoordinateRange)
            )
        );
    }
    test_field_sampleLocationCoordinateRange();
    fn test_field_sampleLocationSubPixelBits() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSampleLocationsPropertiesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleLocationSubPixelBits) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT),
                "::",
                stringify!(sampleLocationSubPixelBits)
            )
        );
    }
    test_field_sampleLocationSubPixelBits();
    fn test_field_variableSampleLocations() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSampleLocationsPropertiesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).variableSampleLocations) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSampleLocationsPropertiesEXT),
                "::",
                stringify!(variableSampleLocations)
            )
        );
    }
    test_field_variableSampleLocations();
}
impl Default for VkPhysicalDeviceSampleLocationsPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMultisamplePropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxSampleLocationGridSize: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkMultisamplePropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMultisamplePropertiesEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkMultisamplePropertiesEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMultisamplePropertiesEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMultisamplePropertiesEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMultisamplePropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMultisamplePropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMultisamplePropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMultisamplePropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxSampleLocationGridSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMultisamplePropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSampleLocationGridSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMultisamplePropertiesEXT),
                "::",
                stringify!(maxSampleLocationGridSize)
            )
        );
    }
    test_field_maxSampleLocationGridSize();
}
impl Default for VkMultisamplePropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdSetSampleLocationsEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pSampleLocationsInfo: *const VkSampleLocationsInfoEXT,
    ),
>;
pub type PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        samples: VkSampleCountFlagBits,
        pMultisampleProperties: *mut VkMultisamplePropertiesEXT,
    ),
>;
extern "C" {
    pub fn vkCmdSetSampleLocationsEXT(
        commandBuffer: VkCommandBuffer,
        pSampleLocationsInfo: *const VkSampleLocationsInfoEXT,
    );
}
extern "C" {
    pub fn vkGetPhysicalDeviceMultisamplePropertiesEXT(
        physicalDevice: VkPhysicalDevice,
        samples: VkSampleCountFlagBits,
        pMultisampleProperties: *mut VkMultisamplePropertiesEXT,
    );
}
pub const VK_BLEND_OVERLAP_UNCORRELATED_EXT: VkBlendOverlapEXT = 0;
pub const VK_BLEND_OVERLAP_DISJOINT_EXT: VkBlendOverlapEXT = 1;
pub const VK_BLEND_OVERLAP_CONJOINT_EXT: VkBlendOverlapEXT = 2;
pub const VK_BLEND_OVERLAP_MAX_ENUM_EXT: VkBlendOverlapEXT = 2147483647;
pub type VkBlendOverlapEXT = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub advancedBlendCoherentOperations: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_advancedBlendCoherentOperations() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).advancedBlendCoherentOperations) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT),
                "::",
                stringify!(advancedBlendCoherentOperations)
            )
        );
    }
    test_field_advancedBlendCoherentOperations();
}
impl Default for VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub advancedBlendMaxColorAttachments: u32,
    pub advancedBlendIndependentBlend: VkBool32,
    pub advancedBlendNonPremultipliedSrcColor: VkBool32,
    pub advancedBlendNonPremultipliedDstColor: VkBool32,
    pub advancedBlendCorrelatedOverlap: VkBool32,
    pub advancedBlendAllOperations: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_advancedBlendMaxColorAttachments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).advancedBlendMaxColorAttachments) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT),
                "::",
                stringify!(advancedBlendMaxColorAttachments)
            )
        );
    }
    test_field_advancedBlendMaxColorAttachments();
    fn test_field_advancedBlendIndependentBlend() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).advancedBlendIndependentBlend) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT),
                "::",
                stringify!(advancedBlendIndependentBlend)
            )
        );
    }
    test_field_advancedBlendIndependentBlend();
    fn test_field_advancedBlendNonPremultipliedSrcColor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).advancedBlendNonPremultipliedSrcColor) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT),
                "::",
                stringify!(advancedBlendNonPremultipliedSrcColor)
            )
        );
    }
    test_field_advancedBlendNonPremultipliedSrcColor();
    fn test_field_advancedBlendNonPremultipliedDstColor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).advancedBlendNonPremultipliedDstColor) as usize
                    - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT),
                "::",
                stringify!(advancedBlendNonPremultipliedDstColor)
            )
        );
    }
    test_field_advancedBlendNonPremultipliedDstColor();
    fn test_field_advancedBlendCorrelatedOverlap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).advancedBlendCorrelatedOverlap) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT),
                "::",
                stringify!(advancedBlendCorrelatedOverlap)
            )
        );
    }
    test_field_advancedBlendCorrelatedOverlap();
    fn test_field_advancedBlendAllOperations() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).advancedBlendAllOperations) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT),
                "::",
                stringify!(advancedBlendAllOperations)
            )
        );
    }
    test_field_advancedBlendAllOperations();
}
impl Default for VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineColorBlendAdvancedStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcPremultiplied: VkBool32,
    pub dstPremultiplied: VkBool32,
    pub blendOverlap: VkBlendOverlapEXT,
}
#[test]
fn bindgen_test_layout_VkPipelineColorBlendAdvancedStateCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineColorBlendAdvancedStateCreateInfoEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineColorBlendAdvancedStateCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineColorBlendAdvancedStateCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineColorBlendAdvancedStateCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineColorBlendAdvancedStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendAdvancedStateCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineColorBlendAdvancedStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendAdvancedStateCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_srcPremultiplied() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineColorBlendAdvancedStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPremultiplied) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendAdvancedStateCreateInfoEXT),
                "::",
                stringify!(srcPremultiplied)
            )
        );
    }
    test_field_srcPremultiplied();
    fn test_field_dstPremultiplied() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineColorBlendAdvancedStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPremultiplied) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendAdvancedStateCreateInfoEXT),
                "::",
                stringify!(dstPremultiplied)
            )
        );
    }
    test_field_dstPremultiplied();
    fn test_field_blendOverlap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineColorBlendAdvancedStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blendOverlap) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorBlendAdvancedStateCreateInfoEXT),
                "::",
                stringify!(blendOverlap)
            )
        );
    }
    test_field_blendOverlap();
}
impl Default for VkPipelineColorBlendAdvancedStateCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPipelineCoverageToColorStateCreateFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCoverageToColorStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCoverageToColorStateCreateFlagsNV,
    pub coverageToColorEnable: VkBool32,
    pub coverageToColorLocation: u32,
}
#[test]
fn bindgen_test_layout_VkPipelineCoverageToColorStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineCoverageToColorStateCreateInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineCoverageToColorStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineCoverageToColorStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineCoverageToColorStateCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCoverageToColorStateCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCoverageToColorStateCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCoverageToColorStateCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCoverageToColorStateCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCoverageToColorStateCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCoverageToColorStateCreateInfoNV),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_coverageToColorEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCoverageToColorStateCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).coverageToColorEnable) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCoverageToColorStateCreateInfoNV),
                "::",
                stringify!(coverageToColorEnable)
            )
        );
    }
    test_field_coverageToColorEnable();
    fn test_field_coverageToColorLocation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCoverageToColorStateCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).coverageToColorLocation) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCoverageToColorStateCreateInfoNV),
                "::",
                stringify!(coverageToColorLocation)
            )
        );
    }
    test_field_coverageToColorLocation();
}
impl Default for VkPipelineCoverageToColorStateCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_COVERAGE_MODULATION_MODE_NONE_NV: VkCoverageModulationModeNV = 0;
pub const VK_COVERAGE_MODULATION_MODE_RGB_NV: VkCoverageModulationModeNV = 1;
pub const VK_COVERAGE_MODULATION_MODE_ALPHA_NV: VkCoverageModulationModeNV = 2;
pub const VK_COVERAGE_MODULATION_MODE_RGBA_NV: VkCoverageModulationModeNV = 3;
pub const VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV: VkCoverageModulationModeNV = 2147483647;
pub type VkCoverageModulationModeNV = ::std::os::raw::c_int;
pub type VkPipelineCoverageModulationStateCreateFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCoverageModulationStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCoverageModulationStateCreateFlagsNV,
    pub coverageModulationMode: VkCoverageModulationModeNV,
    pub coverageModulationTableEnable: VkBool32,
    pub coverageModulationTableCount: u32,
    pub pCoverageModulationTable: *const f32,
}
#[test]
fn bindgen_test_layout_VkPipelineCoverageModulationStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineCoverageModulationStateCreateInfoNV>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineCoverageModulationStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineCoverageModulationStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineCoverageModulationStateCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineCoverageModulationStateCreateInfoNV > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCoverageModulationStateCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineCoverageModulationStateCreateInfoNV > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCoverageModulationStateCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineCoverageModulationStateCreateInfoNV > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCoverageModulationStateCreateInfoNV),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_coverageModulationMode() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineCoverageModulationStateCreateInfoNV > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).coverageModulationMode) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCoverageModulationStateCreateInfoNV),
                "::",
                stringify!(coverageModulationMode)
            )
        );
    }
    test_field_coverageModulationMode();
    fn test_field_coverageModulationTableEnable() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineCoverageModulationStateCreateInfoNV > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).coverageModulationTableEnable) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCoverageModulationStateCreateInfoNV),
                "::",
                stringify!(coverageModulationTableEnable)
            )
        );
    }
    test_field_coverageModulationTableEnable();
    fn test_field_coverageModulationTableCount() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineCoverageModulationStateCreateInfoNV > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).coverageModulationTableCount) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCoverageModulationStateCreateInfoNV),
                "::",
                stringify!(coverageModulationTableCount)
            )
        );
    }
    test_field_coverageModulationTableCount();
    fn test_field_pCoverageModulationTable() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineCoverageModulationStateCreateInfoNV > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCoverageModulationTable) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCoverageModulationStateCreateInfoNV),
                "::",
                stringify!(pCoverageModulationTable)
            )
        );
    }
    test_field_pCoverageModulationTable();
}
impl Default for VkPipelineCoverageModulationStateCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderSMBuiltinsPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderSMCount: u32,
    pub shaderWarpsPerSM: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderSMCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSMCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV),
                "::",
                stringify!(shaderSMCount)
            )
        );
    }
    test_field_shaderSMCount();
    fn test_field_shaderWarpsPerSM() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderWarpsPerSM) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV),
                "::",
                stringify!(shaderWarpsPerSM)
            )
        );
    }
    test_field_shaderWarpsPerSM();
}
impl Default for VkPhysicalDeviceShaderSMBuiltinsPropertiesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderSMBuiltinsFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderSMBuiltins: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderSMBuiltins() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSMBuiltins) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV),
                "::",
                stringify!(shaderSMBuiltins)
            )
        );
    }
    test_field_shaderSMBuiltins();
}
impl Default for VkPhysicalDeviceShaderSMBuiltinsFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkDrmFormatModifierPropertiesEXT {
    pub drmFormatModifier: u64,
    pub drmFormatModifierPlaneCount: u32,
    pub drmFormatModifierTilingFeatures: VkFormatFeatureFlags,
}
#[test]
fn bindgen_test_layout_VkDrmFormatModifierPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDrmFormatModifierPropertiesEXT>(),
        16usize,
        concat!("Size of: ", stringify!(VkDrmFormatModifierPropertiesEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDrmFormatModifierPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDrmFormatModifierPropertiesEXT)
        )
    );
    fn test_field_drmFormatModifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrmFormatModifierPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drmFormatModifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrmFormatModifierPropertiesEXT),
                "::",
                stringify!(drmFormatModifier)
            )
        );
    }
    test_field_drmFormatModifier();
    fn test_field_drmFormatModifierPlaneCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrmFormatModifierPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drmFormatModifierPlaneCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrmFormatModifierPropertiesEXT),
                "::",
                stringify!(drmFormatModifierPlaneCount)
            )
        );
    }
    test_field_drmFormatModifierPlaneCount();
    fn test_field_drmFormatModifierTilingFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrmFormatModifierPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drmFormatModifierTilingFeatures) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrmFormatModifierPropertiesEXT),
                "::",
                stringify!(drmFormatModifierTilingFeatures)
            )
        );
    }
    test_field_drmFormatModifierTilingFeatures();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDrmFormatModifierPropertiesListEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub drmFormatModifierCount: u32,
    pub pDrmFormatModifierProperties: *mut VkDrmFormatModifierPropertiesEXT,
}
#[test]
fn bindgen_test_layout_VkDrmFormatModifierPropertiesListEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDrmFormatModifierPropertiesListEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkDrmFormatModifierPropertiesListEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDrmFormatModifierPropertiesListEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDrmFormatModifierPropertiesListEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDrmFormatModifierPropertiesListEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrmFormatModifierPropertiesListEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDrmFormatModifierPropertiesListEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrmFormatModifierPropertiesListEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_drmFormatModifierCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDrmFormatModifierPropertiesListEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drmFormatModifierCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrmFormatModifierPropertiesListEXT),
                "::",
                stringify!(drmFormatModifierCount)
            )
        );
    }
    test_field_drmFormatModifierCount();
    fn test_field_pDrmFormatModifierProperties() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDrmFormatModifierPropertiesListEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDrmFormatModifierProperties) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrmFormatModifierPropertiesListEXT),
                "::",
                stringify!(pDrmFormatModifierProperties)
            )
        );
    }
    test_field_pDrmFormatModifierProperties();
}
impl Default for VkDrmFormatModifierPropertiesListEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub drmFormatModifier: u64,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: *const u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceImageDrmFormatModifierInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceImageDrmFormatModifierInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceImageDrmFormatModifierInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceImageDrmFormatModifierInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageDrmFormatModifierInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceImageDrmFormatModifierInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageDrmFormatModifierInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_drmFormatModifier() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceImageDrmFormatModifierInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drmFormatModifier) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageDrmFormatModifierInfoEXT),
                "::",
                stringify!(drmFormatModifier)
            )
        );
    }
    test_field_drmFormatModifier();
    fn test_field_sharingMode() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceImageDrmFormatModifierInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sharingMode) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageDrmFormatModifierInfoEXT),
                "::",
                stringify!(sharingMode)
            )
        );
    }
    test_field_sharingMode();
    fn test_field_queueFamilyIndexCount() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceImageDrmFormatModifierInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).queueFamilyIndexCount) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageDrmFormatModifierInfoEXT),
                "::",
                stringify!(queueFamilyIndexCount)
            )
        );
    }
    test_field_queueFamilyIndexCount();
    fn test_field_pQueueFamilyIndices() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceImageDrmFormatModifierInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pQueueFamilyIndices) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageDrmFormatModifierInfoEXT),
                "::",
                stringify!(pQueueFamilyIndices)
            )
        );
    }
    test_field_pQueueFamilyIndices();
}
impl Default for VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageDrmFormatModifierListCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub drmFormatModifierCount: u32,
    pub pDrmFormatModifiers: *const u64,
}
#[test]
fn bindgen_test_layout_VkImageDrmFormatModifierListCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkImageDrmFormatModifierListCreateInfoEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkImageDrmFormatModifierListCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageDrmFormatModifierListCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkImageDrmFormatModifierListCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageDrmFormatModifierListCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageDrmFormatModifierListCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageDrmFormatModifierListCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageDrmFormatModifierListCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_drmFormatModifierCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageDrmFormatModifierListCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drmFormatModifierCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageDrmFormatModifierListCreateInfoEXT),
                "::",
                stringify!(drmFormatModifierCount)
            )
        );
    }
    test_field_drmFormatModifierCount();
    fn test_field_pDrmFormatModifiers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageDrmFormatModifierListCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDrmFormatModifiers) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageDrmFormatModifierListCreateInfoEXT),
                "::",
                stringify!(pDrmFormatModifiers)
            )
        );
    }
    test_field_pDrmFormatModifiers();
}
impl Default for VkImageDrmFormatModifierListCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageDrmFormatModifierExplicitCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub drmFormatModifier: u64,
    pub drmFormatModifierPlaneCount: u32,
    pub pPlaneLayouts: *const VkSubresourceLayout,
}
#[test]
fn bindgen_test_layout_VkImageDrmFormatModifierExplicitCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkImageDrmFormatModifierExplicitCreateInfoEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkImageDrmFormatModifierExplicitCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageDrmFormatModifierExplicitCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkImageDrmFormatModifierExplicitCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkImageDrmFormatModifierExplicitCreateInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageDrmFormatModifierExplicitCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkImageDrmFormatModifierExplicitCreateInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageDrmFormatModifierExplicitCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_drmFormatModifier() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkImageDrmFormatModifierExplicitCreateInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drmFormatModifier) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageDrmFormatModifierExplicitCreateInfoEXT),
                "::",
                stringify!(drmFormatModifier)
            )
        );
    }
    test_field_drmFormatModifier();
    fn test_field_drmFormatModifierPlaneCount() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkImageDrmFormatModifierExplicitCreateInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drmFormatModifierPlaneCount) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageDrmFormatModifierExplicitCreateInfoEXT),
                "::",
                stringify!(drmFormatModifierPlaneCount)
            )
        );
    }
    test_field_drmFormatModifierPlaneCount();
    fn test_field_pPlaneLayouts() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkImageDrmFormatModifierExplicitCreateInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pPlaneLayouts) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageDrmFormatModifierExplicitCreateInfoEXT),
                "::",
                stringify!(pPlaneLayouts)
            )
        );
    }
    test_field_pPlaneLayouts();
}
impl Default for VkImageDrmFormatModifierExplicitCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageDrmFormatModifierPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub drmFormatModifier: u64,
}
#[test]
fn bindgen_test_layout_VkImageDrmFormatModifierPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkImageDrmFormatModifierPropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkImageDrmFormatModifierPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageDrmFormatModifierPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkImageDrmFormatModifierPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageDrmFormatModifierPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageDrmFormatModifierPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageDrmFormatModifierPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageDrmFormatModifierPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_drmFormatModifier() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageDrmFormatModifierPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drmFormatModifier) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageDrmFormatModifierPropertiesEXT),
                "::",
                stringify!(drmFormatModifier)
            )
        );
    }
    test_field_drmFormatModifier();
}
impl Default for VkImageDrmFormatModifierPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkDrmFormatModifierProperties2EXT {
    pub drmFormatModifier: u64,
    pub drmFormatModifierPlaneCount: u32,
    pub drmFormatModifierTilingFeatures: VkFormatFeatureFlags2,
}
#[test]
fn bindgen_test_layout_VkDrmFormatModifierProperties2EXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDrmFormatModifierProperties2EXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkDrmFormatModifierProperties2EXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDrmFormatModifierProperties2EXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDrmFormatModifierProperties2EXT)
        )
    );
    fn test_field_drmFormatModifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrmFormatModifierProperties2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drmFormatModifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrmFormatModifierProperties2EXT),
                "::",
                stringify!(drmFormatModifier)
            )
        );
    }
    test_field_drmFormatModifier();
    fn test_field_drmFormatModifierPlaneCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrmFormatModifierProperties2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drmFormatModifierPlaneCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrmFormatModifierProperties2EXT),
                "::",
                stringify!(drmFormatModifierPlaneCount)
            )
        );
    }
    test_field_drmFormatModifierPlaneCount();
    fn test_field_drmFormatModifierTilingFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrmFormatModifierProperties2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drmFormatModifierTilingFeatures) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrmFormatModifierProperties2EXT),
                "::",
                stringify!(drmFormatModifierTilingFeatures)
            )
        );
    }
    test_field_drmFormatModifierTilingFeatures();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDrmFormatModifierPropertiesList2EXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub drmFormatModifierCount: u32,
    pub pDrmFormatModifierProperties: *mut VkDrmFormatModifierProperties2EXT,
}
#[test]
fn bindgen_test_layout_VkDrmFormatModifierPropertiesList2EXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDrmFormatModifierPropertiesList2EXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkDrmFormatModifierPropertiesList2EXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDrmFormatModifierPropertiesList2EXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDrmFormatModifierPropertiesList2EXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDrmFormatModifierPropertiesList2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrmFormatModifierPropertiesList2EXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDrmFormatModifierPropertiesList2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrmFormatModifierPropertiesList2EXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_drmFormatModifierCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDrmFormatModifierPropertiesList2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drmFormatModifierCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrmFormatModifierPropertiesList2EXT),
                "::",
                stringify!(drmFormatModifierCount)
            )
        );
    }
    test_field_drmFormatModifierCount();
    fn test_field_pDrmFormatModifierProperties() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDrmFormatModifierPropertiesList2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDrmFormatModifierProperties) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrmFormatModifierPropertiesList2EXT),
                "::",
                stringify!(pDrmFormatModifierProperties)
            )
        );
    }
    test_field_pDrmFormatModifierProperties();
}
impl Default for VkDrmFormatModifierPropertiesList2EXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetImageDrmFormatModifierPropertiesEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pProperties: *mut VkImageDrmFormatModifierPropertiesEXT,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetImageDrmFormatModifierPropertiesEXT(
        device: VkDevice,
        image: VkImage,
        pProperties: *mut VkImageDrmFormatModifierPropertiesEXT,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkValidationCacheEXT_T {
    _unused: [u8; 0],
}
pub type VkValidationCacheEXT = *mut VkValidationCacheEXT_T;
pub const VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT: VkValidationCacheHeaderVersionEXT = 1;
pub const VK_VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT: VkValidationCacheHeaderVersionEXT =
    2147483647;
pub type VkValidationCacheHeaderVersionEXT = ::std::os::raw::c_int;
pub type VkValidationCacheCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkValidationCacheCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkValidationCacheCreateFlagsEXT,
    pub initialDataSize: usize,
    pub pInitialData: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkValidationCacheCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkValidationCacheCreateInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkValidationCacheCreateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkValidationCacheCreateInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkValidationCacheCreateInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkValidationCacheCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkValidationCacheCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkValidationCacheCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkValidationCacheCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkValidationCacheCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkValidationCacheCreateInfoEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_initialDataSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkValidationCacheCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).initialDataSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkValidationCacheCreateInfoEXT),
                "::",
                stringify!(initialDataSize)
            )
        );
    }
    test_field_initialDataSize();
    fn test_field_pInitialData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkValidationCacheCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pInitialData) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkValidationCacheCreateInfoEXT),
                "::",
                stringify!(pInitialData)
            )
        );
    }
    test_field_pInitialData();
}
impl Default for VkValidationCacheCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkShaderModuleValidationCacheCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub validationCache: VkValidationCacheEXT,
}
#[test]
fn bindgen_test_layout_VkShaderModuleValidationCacheCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkShaderModuleValidationCacheCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkShaderModuleValidationCacheCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkShaderModuleValidationCacheCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkShaderModuleValidationCacheCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkShaderModuleValidationCacheCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderModuleValidationCacheCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkShaderModuleValidationCacheCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderModuleValidationCacheCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_validationCache() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkShaderModuleValidationCacheCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).validationCache) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderModuleValidationCacheCreateInfoEXT),
                "::",
                stringify!(validationCache)
            )
        );
    }
    test_field_validationCache();
}
impl Default for VkShaderModuleValidationCacheCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCreateValidationCacheEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkValidationCacheCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pValidationCache: *mut VkValidationCacheEXT,
    ) -> VkResult,
>;
pub type PFN_vkDestroyValidationCacheEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        validationCache: VkValidationCacheEXT,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkMergeValidationCachesEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        dstCache: VkValidationCacheEXT,
        srcCacheCount: u32,
        pSrcCaches: *const VkValidationCacheEXT,
    ) -> VkResult,
>;
pub type PFN_vkGetValidationCacheDataEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        validationCache: VkValidationCacheEXT,
        pDataSize: *mut usize,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkCreateValidationCacheEXT(
        device: VkDevice,
        pCreateInfo: *const VkValidationCacheCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pValidationCache: *mut VkValidationCacheEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyValidationCacheEXT(
        device: VkDevice,
        validationCache: VkValidationCacheEXT,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkMergeValidationCachesEXT(
        device: VkDevice,
        dstCache: VkValidationCacheEXT,
        srcCacheCount: u32,
        pSrcCaches: *const VkValidationCacheEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetValidationCacheDataEXT(
        device: VkDevice,
        validationCache: VkValidationCacheEXT,
        pDataSize: *mut usize,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
pub use self::VkDescriptorBindingFlagBits as VkDescriptorBindingFlagBitsEXT;
pub type VkDescriptorBindingFlagsEXT = VkDescriptorBindingFlags;
pub type VkDescriptorSetLayoutBindingFlagsCreateInfoEXT =
    VkDescriptorSetLayoutBindingFlagsCreateInfo;
pub type VkPhysicalDeviceDescriptorIndexingFeaturesEXT = VkPhysicalDeviceDescriptorIndexingFeatures;
pub type VkPhysicalDeviceDescriptorIndexingPropertiesEXT =
    VkPhysicalDeviceDescriptorIndexingProperties;
pub type VkDescriptorSetVariableDescriptorCountAllocateInfoEXT =
    VkDescriptorSetVariableDescriptorCountAllocateInfo;
pub type VkDescriptorSetVariableDescriptorCountLayoutSupportEXT =
    VkDescriptorSetVariableDescriptorCountLayoutSupport;
pub const VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV: VkShadingRatePaletteEntryNV = 0;
pub const VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV: VkShadingRatePaletteEntryNV =
    1;
pub const VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV: VkShadingRatePaletteEntryNV = 2;
pub const VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV: VkShadingRatePaletteEntryNV = 3;
pub const VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV: VkShadingRatePaletteEntryNV = 4;
pub const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV: VkShadingRatePaletteEntryNV = 5;
pub const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV:
    VkShadingRatePaletteEntryNV = 6;
pub const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV:
    VkShadingRatePaletteEntryNV = 7;
pub const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV:
    VkShadingRatePaletteEntryNV = 8;
pub const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV:
    VkShadingRatePaletteEntryNV = 9;
pub const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV:
    VkShadingRatePaletteEntryNV = 10;
pub const VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV:
    VkShadingRatePaletteEntryNV = 11;
pub const VK_SHADING_RATE_PALETTE_ENTRY_MAX_ENUM_NV: VkShadingRatePaletteEntryNV = 2147483647;
pub type VkShadingRatePaletteEntryNV = ::std::os::raw::c_int;
pub const VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV: VkCoarseSampleOrderTypeNV = 0;
pub const VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV: VkCoarseSampleOrderTypeNV = 1;
pub const VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV: VkCoarseSampleOrderTypeNV = 2;
pub const VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV: VkCoarseSampleOrderTypeNV = 3;
pub const VK_COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV: VkCoarseSampleOrderTypeNV = 2147483647;
pub type VkCoarseSampleOrderTypeNV = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkShadingRatePaletteNV {
    pub shadingRatePaletteEntryCount: u32,
    pub pShadingRatePaletteEntries: *const VkShadingRatePaletteEntryNV,
}
#[test]
fn bindgen_test_layout_VkShadingRatePaletteNV() {
    assert_eq!(
        ::std::mem::size_of::<VkShadingRatePaletteNV>(),
        16usize,
        concat!("Size of: ", stringify!(VkShadingRatePaletteNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkShadingRatePaletteNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkShadingRatePaletteNV))
    );
    fn test_field_shadingRatePaletteEntryCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShadingRatePaletteNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shadingRatePaletteEntryCount) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShadingRatePaletteNV),
                "::",
                stringify!(shadingRatePaletteEntryCount)
            )
        );
    }
    test_field_shadingRatePaletteEntryCount();
    fn test_field_pShadingRatePaletteEntries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShadingRatePaletteNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pShadingRatePaletteEntries) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShadingRatePaletteNV),
                "::",
                stringify!(pShadingRatePaletteEntries)
            )
        );
    }
    test_field_pShadingRatePaletteEntries();
}
impl Default for VkShadingRatePaletteNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineViewportShadingRateImageStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub shadingRateImageEnable: VkBool32,
    pub viewportCount: u32,
    pub pShadingRatePalettes: *const VkShadingRatePaletteNV,
}
#[test]
fn bindgen_test_layout_VkPipelineViewportShadingRateImageStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineViewportShadingRateImageStateCreateInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineViewportShadingRateImageStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineViewportShadingRateImageStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineViewportShadingRateImageStateCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportShadingRateImageStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportShadingRateImageStateCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportShadingRateImageStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportShadingRateImageStateCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shadingRateImageEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportShadingRateImageStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shadingRateImageEnable) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportShadingRateImageStateCreateInfoNV),
                "::",
                stringify!(shadingRateImageEnable)
            )
        );
    }
    test_field_shadingRateImageEnable();
    fn test_field_viewportCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportShadingRateImageStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewportCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportShadingRateImageStateCreateInfoNV),
                "::",
                stringify!(viewportCount)
            )
        );
    }
    test_field_viewportCount();
    fn test_field_pShadingRatePalettes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportShadingRateImageStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pShadingRatePalettes) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportShadingRateImageStateCreateInfoNV),
                "::",
                stringify!(pShadingRatePalettes)
            )
        );
    }
    test_field_pShadingRatePalettes();
}
impl Default for VkPipelineViewportShadingRateImageStateCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShadingRateImageFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shadingRateImage: VkBool32,
    pub shadingRateCoarseSampleOrder: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShadingRateImageFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShadingRateImageFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShadingRateImageFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShadingRateImageFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShadingRateImageFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShadingRateImageFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShadingRateImageFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShadingRateImageFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShadingRateImageFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shadingRateImage() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShadingRateImageFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shadingRateImage) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShadingRateImageFeaturesNV),
                "::",
                stringify!(shadingRateImage)
            )
        );
    }
    test_field_shadingRateImage();
    fn test_field_shadingRateCoarseSampleOrder() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShadingRateImageFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shadingRateCoarseSampleOrder) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShadingRateImageFeaturesNV),
                "::",
                stringify!(shadingRateCoarseSampleOrder)
            )
        );
    }
    test_field_shadingRateCoarseSampleOrder();
}
impl Default for VkPhysicalDeviceShadingRateImageFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShadingRateImagePropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shadingRateTexelSize: VkExtent2D,
    pub shadingRatePaletteSize: u32,
    pub shadingRateMaxCoarseSamples: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShadingRateImagePropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShadingRateImagePropertiesNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShadingRateImagePropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShadingRateImagePropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShadingRateImagePropertiesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShadingRateImagePropertiesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShadingRateImagePropertiesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShadingRateImagePropertiesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShadingRateImagePropertiesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shadingRateTexelSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShadingRateImagePropertiesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shadingRateTexelSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShadingRateImagePropertiesNV),
                "::",
                stringify!(shadingRateTexelSize)
            )
        );
    }
    test_field_shadingRateTexelSize();
    fn test_field_shadingRatePaletteSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShadingRateImagePropertiesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shadingRatePaletteSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShadingRateImagePropertiesNV),
                "::",
                stringify!(shadingRatePaletteSize)
            )
        );
    }
    test_field_shadingRatePaletteSize();
    fn test_field_shadingRateMaxCoarseSamples() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShadingRateImagePropertiesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shadingRateMaxCoarseSamples) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShadingRateImagePropertiesNV),
                "::",
                stringify!(shadingRateMaxCoarseSamples)
            )
        );
    }
    test_field_shadingRateMaxCoarseSamples();
}
impl Default for VkPhysicalDeviceShadingRateImagePropertiesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkCoarseSampleLocationNV {
    pub pixelX: u32,
    pub pixelY: u32,
    pub sample: u32,
}
#[test]
fn bindgen_test_layout_VkCoarseSampleLocationNV() {
    assert_eq!(
        ::std::mem::size_of::<VkCoarseSampleLocationNV>(),
        12usize,
        concat!("Size of: ", stringify!(VkCoarseSampleLocationNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCoarseSampleLocationNV>(),
        4usize,
        concat!("Alignment of ", stringify!(VkCoarseSampleLocationNV))
    );
    fn test_field_pixelX() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCoarseSampleLocationNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixelX) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCoarseSampleLocationNV),
                "::",
                stringify!(pixelX)
            )
        );
    }
    test_field_pixelX();
    fn test_field_pixelY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCoarseSampleLocationNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pixelY) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCoarseSampleLocationNV),
                "::",
                stringify!(pixelY)
            )
        );
    }
    test_field_pixelY();
    fn test_field_sample() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCoarseSampleLocationNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sample) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCoarseSampleLocationNV),
                "::",
                stringify!(sample)
            )
        );
    }
    test_field_sample();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCoarseSampleOrderCustomNV {
    pub shadingRate: VkShadingRatePaletteEntryNV,
    pub sampleCount: u32,
    pub sampleLocationCount: u32,
    pub pSampleLocations: *const VkCoarseSampleLocationNV,
}
#[test]
fn bindgen_test_layout_VkCoarseSampleOrderCustomNV() {
    assert_eq!(
        ::std::mem::size_of::<VkCoarseSampleOrderCustomNV>(),
        24usize,
        concat!("Size of: ", stringify!(VkCoarseSampleOrderCustomNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCoarseSampleOrderCustomNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCoarseSampleOrderCustomNV))
    );
    fn test_field_shadingRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCoarseSampleOrderCustomNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shadingRate) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCoarseSampleOrderCustomNV),
                "::",
                stringify!(shadingRate)
            )
        );
    }
    test_field_shadingRate();
    fn test_field_sampleCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCoarseSampleOrderCustomNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleCount) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCoarseSampleOrderCustomNV),
                "::",
                stringify!(sampleCount)
            )
        );
    }
    test_field_sampleCount();
    fn test_field_sampleLocationCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCoarseSampleOrderCustomNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleLocationCount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCoarseSampleOrderCustomNV),
                "::",
                stringify!(sampleLocationCount)
            )
        );
    }
    test_field_sampleLocationCount();
    fn test_field_pSampleLocations() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCoarseSampleOrderCustomNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSampleLocations) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCoarseSampleOrderCustomNV),
                "::",
                stringify!(pSampleLocations)
            )
        );
    }
    test_field_pSampleLocations();
}
impl Default for VkCoarseSampleOrderCustomNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub sampleOrderType: VkCoarseSampleOrderTypeNV,
    pub customSampleOrderCount: u32,
    pub pCustomSampleOrders: *const VkCoarseSampleOrderCustomNV,
}
#[test]
fn bindgen_test_layout_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportCoarseSampleOrderStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportCoarseSampleOrderStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_sampleOrderType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportCoarseSampleOrderStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampleOrderType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV),
                "::",
                stringify!(sampleOrderType)
            )
        );
    }
    test_field_sampleOrderType();
    fn test_field_customSampleOrderCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportCoarseSampleOrderStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).customSampleOrderCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV),
                "::",
                stringify!(customSampleOrderCount)
            )
        );
    }
    test_field_customSampleOrderCount();
    fn test_field_pCustomSampleOrders() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportCoarseSampleOrderStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCustomSampleOrders) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportCoarseSampleOrderStateCreateInfoNV),
                "::",
                stringify!(pCustomSampleOrders)
            )
        );
    }
    test_field_pCustomSampleOrders();
}
impl Default for VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdBindShadingRateImageNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        imageView: VkImageView,
        imageLayout: VkImageLayout,
    ),
>;
pub type PFN_vkCmdSetViewportShadingRatePaletteNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstViewport: u32,
        viewportCount: u32,
        pShadingRatePalettes: *const VkShadingRatePaletteNV,
    ),
>;
pub type PFN_vkCmdSetCoarseSampleOrderNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        sampleOrderType: VkCoarseSampleOrderTypeNV,
        customSampleOrderCount: u32,
        pCustomSampleOrders: *const VkCoarseSampleOrderCustomNV,
    ),
>;
extern "C" {
    pub fn vkCmdBindShadingRateImageNV(
        commandBuffer: VkCommandBuffer,
        imageView: VkImageView,
        imageLayout: VkImageLayout,
    );
}
extern "C" {
    pub fn vkCmdSetViewportShadingRatePaletteNV(
        commandBuffer: VkCommandBuffer,
        firstViewport: u32,
        viewportCount: u32,
        pShadingRatePalettes: *const VkShadingRatePaletteNV,
    );
}
extern "C" {
    pub fn vkCmdSetCoarseSampleOrderNV(
        commandBuffer: VkCommandBuffer,
        sampleOrderType: VkCoarseSampleOrderTypeNV,
        customSampleOrderCount: u32,
        pCustomSampleOrders: *const VkCoarseSampleOrderCustomNV,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAccelerationStructureNV_T {
    _unused: [u8; 0],
}
pub type VkAccelerationStructureNV = *mut VkAccelerationStructureNV_T;
pub const VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR: VkRayTracingShaderGroupTypeKHR = 0;
pub const VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR: VkRayTracingShaderGroupTypeKHR =
    1;
pub const VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR:
    VkRayTracingShaderGroupTypeKHR = 2;
pub const VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV: VkRayTracingShaderGroupTypeKHR = 0;
pub const VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV: VkRayTracingShaderGroupTypeKHR =
    1;
pub const VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV: VkRayTracingShaderGroupTypeKHR =
    2;
pub const VK_RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_KHR: VkRayTracingShaderGroupTypeKHR =
    2147483647;
pub type VkRayTracingShaderGroupTypeKHR = ::std::os::raw::c_int;
pub use self::VkRayTracingShaderGroupTypeKHR as VkRayTracingShaderGroupTypeNV;
pub const VK_GEOMETRY_TYPE_TRIANGLES_KHR: VkGeometryTypeKHR = 0;
pub const VK_GEOMETRY_TYPE_AABBS_KHR: VkGeometryTypeKHR = 1;
pub const VK_GEOMETRY_TYPE_INSTANCES_KHR: VkGeometryTypeKHR = 2;
pub const VK_GEOMETRY_TYPE_TRIANGLES_NV: VkGeometryTypeKHR = 0;
pub const VK_GEOMETRY_TYPE_AABBS_NV: VkGeometryTypeKHR = 1;
pub const VK_GEOMETRY_TYPE_MAX_ENUM_KHR: VkGeometryTypeKHR = 2147483647;
pub type VkGeometryTypeKHR = ::std::os::raw::c_int;
pub use self::VkGeometryTypeKHR as VkGeometryTypeNV;
pub const VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR: VkAccelerationStructureTypeKHR = 0;
pub const VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR: VkAccelerationStructureTypeKHR = 1;
pub const VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR: VkAccelerationStructureTypeKHR = 2;
pub const VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV: VkAccelerationStructureTypeKHR = 0;
pub const VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV: VkAccelerationStructureTypeKHR = 1;
pub const VK_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_KHR: VkAccelerationStructureTypeKHR = 2147483647;
pub type VkAccelerationStructureTypeKHR = ::std::os::raw::c_int;
pub use self::VkAccelerationStructureTypeKHR as VkAccelerationStructureTypeNV;
pub const VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR: VkCopyAccelerationStructureModeKHR = 0;
pub const VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR: VkCopyAccelerationStructureModeKHR = 1;
pub const VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR: VkCopyAccelerationStructureModeKHR = 2;
pub const VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR: VkCopyAccelerationStructureModeKHR =
    3;
pub const VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV: VkCopyAccelerationStructureModeKHR = 0;
pub const VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV: VkCopyAccelerationStructureModeKHR = 1;
pub const VK_COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR: VkCopyAccelerationStructureModeKHR =
    2147483647;
pub type VkCopyAccelerationStructureModeKHR = ::std::os::raw::c_int;
pub use self::VkCopyAccelerationStructureModeKHR as VkCopyAccelerationStructureModeNV;
pub const VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV:
    VkAccelerationStructureMemoryRequirementsTypeNV = 0;
pub const VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV:
    VkAccelerationStructureMemoryRequirementsTypeNV = 1;
pub const VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV:
    VkAccelerationStructureMemoryRequirementsTypeNV = 2;
pub const VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV:
    VkAccelerationStructureMemoryRequirementsTypeNV = 2147483647;
pub type VkAccelerationStructureMemoryRequirementsTypeNV = ::std::os::raw::c_int;
pub const VK_GEOMETRY_OPAQUE_BIT_KHR: VkGeometryFlagBitsKHR = 1;
pub const VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR: VkGeometryFlagBitsKHR = 2;
pub const VK_GEOMETRY_OPAQUE_BIT_NV: VkGeometryFlagBitsKHR = 1;
pub const VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV: VkGeometryFlagBitsKHR = 2;
pub const VK_GEOMETRY_FLAG_BITS_MAX_ENUM_KHR: VkGeometryFlagBitsKHR = 2147483647;
pub type VkGeometryFlagBitsKHR = ::std::os::raw::c_int;
pub type VkGeometryFlagsKHR = VkFlags;
pub type VkGeometryFlagsNV = VkGeometryFlagsKHR;
pub use self::VkGeometryFlagBitsKHR as VkGeometryFlagBitsNV;
pub const VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR: VkGeometryInstanceFlagBitsKHR =
    1;
pub const VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR: VkGeometryInstanceFlagBitsKHR = 2;
pub const VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR: VkGeometryInstanceFlagBitsKHR = 4;
pub const VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR: VkGeometryInstanceFlagBitsKHR = 8;
pub const VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT: VkGeometryInstanceFlagBitsKHR =
    16;
pub const VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT: VkGeometryInstanceFlagBitsKHR = 32;
pub const VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR:
    VkGeometryInstanceFlagBitsKHR = 2;
pub const VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV: VkGeometryInstanceFlagBitsKHR = 1;
pub const VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV:
    VkGeometryInstanceFlagBitsKHR = 2;
pub const VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV: VkGeometryInstanceFlagBitsKHR = 4;
pub const VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV: VkGeometryInstanceFlagBitsKHR = 8;
pub const VK_GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_KHR: VkGeometryInstanceFlagBitsKHR = 2147483647;
pub type VkGeometryInstanceFlagBitsKHR = ::std::os::raw::c_int;
pub type VkGeometryInstanceFlagsKHR = VkFlags;
pub type VkGeometryInstanceFlagsNV = VkGeometryInstanceFlagsKHR;
pub use self::VkGeometryInstanceFlagBitsKHR as VkGeometryInstanceFlagBitsNV;
pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR:
    VkBuildAccelerationStructureFlagBitsKHR = 1;
pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR:
    VkBuildAccelerationStructureFlagBitsKHR = 2;
pub const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR:
    VkBuildAccelerationStructureFlagBitsKHR = 4;
pub const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR:
    VkBuildAccelerationStructureFlagBitsKHR = 8;
pub const VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR:
    VkBuildAccelerationStructureFlagBitsKHR = 16;
pub const VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV: VkBuildAccelerationStructureFlagBitsKHR =
    32;
pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT:
    VkBuildAccelerationStructureFlagBitsKHR = 64;
pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT:
    VkBuildAccelerationStructureFlagBitsKHR = 128;
pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT:
    VkBuildAccelerationStructureFlagBitsKHR = 256;
pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV:
    VkBuildAccelerationStructureFlagBitsKHR = 1;
pub const VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV:
    VkBuildAccelerationStructureFlagBitsKHR = 2;
pub const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV:
    VkBuildAccelerationStructureFlagBitsKHR = 4;
pub const VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV:
    VkBuildAccelerationStructureFlagBitsKHR = 8;
pub const VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV:
    VkBuildAccelerationStructureFlagBitsKHR = 16;
pub const VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_KHR:
    VkBuildAccelerationStructureFlagBitsKHR = 2147483647;
pub type VkBuildAccelerationStructureFlagBitsKHR = ::std::os::raw::c_int;
pub type VkBuildAccelerationStructureFlagsKHR = VkFlags;
pub type VkBuildAccelerationStructureFlagsNV = VkBuildAccelerationStructureFlagsKHR;
pub use self::VkBuildAccelerationStructureFlagBitsKHR as VkBuildAccelerationStructureFlagBitsNV;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRayTracingShaderGroupCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub type_: VkRayTracingShaderGroupTypeKHR,
    pub generalShader: u32,
    pub closestHitShader: u32,
    pub anyHitShader: u32,
    pub intersectionShader: u32,
}
#[test]
fn bindgen_test_layout_VkRayTracingShaderGroupCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkRayTracingShaderGroupCreateInfoNV>(),
        40usize,
        concat!("Size of: ", stringify!(VkRayTracingShaderGroupCreateInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRayTracingShaderGroupCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRayTracingShaderGroupCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingShaderGroupCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingShaderGroupCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingShaderGroupCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingShaderGroupCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingShaderGroupCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingShaderGroupCreateInfoNV),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_generalShader() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingShaderGroupCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).generalShader) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingShaderGroupCreateInfoNV),
                "::",
                stringify!(generalShader)
            )
        );
    }
    test_field_generalShader();
    fn test_field_closestHitShader() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingShaderGroupCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).closestHitShader) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingShaderGroupCreateInfoNV),
                "::",
                stringify!(closestHitShader)
            )
        );
    }
    test_field_closestHitShader();
    fn test_field_anyHitShader() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingShaderGroupCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).anyHitShader) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingShaderGroupCreateInfoNV),
                "::",
                stringify!(anyHitShader)
            )
        );
    }
    test_field_anyHitShader();
    fn test_field_intersectionShader() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingShaderGroupCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).intersectionShader) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingShaderGroupCreateInfoNV),
                "::",
                stringify!(intersectionShader)
            )
        );
    }
    test_field_intersectionShader();
}
impl Default for VkRayTracingShaderGroupCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRayTracingPipelineCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCreateFlags,
    pub stageCount: u32,
    pub pStages: *const VkPipelineShaderStageCreateInfo,
    pub groupCount: u32,
    pub pGroups: *const VkRayTracingShaderGroupCreateInfoNV,
    pub maxRecursionDepth: u32,
    pub layout: VkPipelineLayout,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: i32,
}
#[test]
fn bindgen_test_layout_VkRayTracingPipelineCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkRayTracingPipelineCreateInfoNV>(),
        80usize,
        concat!("Size of: ", stringify!(VkRayTracingPipelineCreateInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRayTracingPipelineCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRayTracingPipelineCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoNV),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_stageCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stageCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoNV),
                "::",
                stringify!(stageCount)
            )
        );
    }
    test_field_stageCount();
    fn test_field_pStages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pStages) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoNV),
                "::",
                stringify!(pStages)
            )
        );
    }
    test_field_pStages();
    fn test_field_groupCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).groupCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoNV),
                "::",
                stringify!(groupCount)
            )
        );
    }
    test_field_groupCount();
    fn test_field_pGroups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pGroups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoNV),
                "::",
                stringify!(pGroups)
            )
        );
    }
    test_field_pGroups();
    fn test_field_maxRecursionDepth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxRecursionDepth) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoNV),
                "::",
                stringify!(maxRecursionDepth)
            )
        );
    }
    test_field_maxRecursionDepth();
    fn test_field_layout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layout) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoNV),
                "::",
                stringify!(layout)
            )
        );
    }
    test_field_layout();
    fn test_field_basePipelineHandle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).basePipelineHandle) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoNV),
                "::",
                stringify!(basePipelineHandle)
            )
        );
    }
    test_field_basePipelineHandle();
    fn test_field_basePipelineIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).basePipelineIndex) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoNV),
                "::",
                stringify!(basePipelineIndex)
            )
        );
    }
    test_field_basePipelineIndex();
}
impl Default for VkRayTracingPipelineCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkGeometryTrianglesNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub vertexData: VkBuffer,
    pub vertexOffset: VkDeviceSize,
    pub vertexCount: u32,
    pub vertexStride: VkDeviceSize,
    pub vertexFormat: VkFormat,
    pub indexData: VkBuffer,
    pub indexOffset: VkDeviceSize,
    pub indexCount: u32,
    pub indexType: VkIndexType,
    pub transformData: VkBuffer,
    pub transformOffset: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkGeometryTrianglesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkGeometryTrianglesNV>(),
        96usize,
        concat!("Size of: ", stringify!(VkGeometryTrianglesNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkGeometryTrianglesNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkGeometryTrianglesNV))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryTrianglesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryTrianglesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryTrianglesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryTrianglesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_vertexData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryTrianglesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexData) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryTrianglesNV),
                "::",
                stringify!(vertexData)
            )
        );
    }
    test_field_vertexData();
    fn test_field_vertexOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryTrianglesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexOffset) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryTrianglesNV),
                "::",
                stringify!(vertexOffset)
            )
        );
    }
    test_field_vertexOffset();
    fn test_field_vertexCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryTrianglesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryTrianglesNV),
                "::",
                stringify!(vertexCount)
            )
        );
    }
    test_field_vertexCount();
    fn test_field_vertexStride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryTrianglesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexStride) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryTrianglesNV),
                "::",
                stringify!(vertexStride)
            )
        );
    }
    test_field_vertexStride();
    fn test_field_vertexFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryTrianglesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexFormat) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryTrianglesNV),
                "::",
                stringify!(vertexFormat)
            )
        );
    }
    test_field_vertexFormat();
    fn test_field_indexData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryTrianglesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indexData) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryTrianglesNV),
                "::",
                stringify!(indexData)
            )
        );
    }
    test_field_indexData();
    fn test_field_indexOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryTrianglesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indexOffset) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryTrianglesNV),
                "::",
                stringify!(indexOffset)
            )
        );
    }
    test_field_indexOffset();
    fn test_field_indexCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryTrianglesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indexCount) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryTrianglesNV),
                "::",
                stringify!(indexCount)
            )
        );
    }
    test_field_indexCount();
    fn test_field_indexType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryTrianglesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indexType) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryTrianglesNV),
                "::",
                stringify!(indexType)
            )
        );
    }
    test_field_indexType();
    fn test_field_transformData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryTrianglesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformData) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryTrianglesNV),
                "::",
                stringify!(transformData)
            )
        );
    }
    test_field_transformData();
    fn test_field_transformOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryTrianglesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformOffset) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryTrianglesNV),
                "::",
                stringify!(transformOffset)
            )
        );
    }
    test_field_transformOffset();
}
impl Default for VkGeometryTrianglesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkGeometryAABBNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub aabbData: VkBuffer,
    pub numAABBs: u32,
    pub stride: u32,
    pub offset: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkGeometryAABBNV() {
    assert_eq!(
        ::std::mem::size_of::<VkGeometryAABBNV>(),
        40usize,
        concat!("Size of: ", stringify!(VkGeometryAABBNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkGeometryAABBNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkGeometryAABBNV))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryAABBNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryAABBNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryAABBNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryAABBNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_aabbData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryAABBNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aabbData) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryAABBNV),
                "::",
                stringify!(aabbData)
            )
        );
    }
    test_field_aabbData();
    fn test_field_numAABBs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryAABBNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numAABBs) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryAABBNV),
                "::",
                stringify!(numAABBs)
            )
        );
    }
    test_field_numAABBs();
    fn test_field_stride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryAABBNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryAABBNV),
                "::",
                stringify!(stride)
            )
        );
    }
    test_field_stride();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryAABBNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryAABBNV),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
}
impl Default for VkGeometryAABBNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkGeometryDataNV {
    pub triangles: VkGeometryTrianglesNV,
    pub aabbs: VkGeometryAABBNV,
}
#[test]
fn bindgen_test_layout_VkGeometryDataNV() {
    assert_eq!(
        ::std::mem::size_of::<VkGeometryDataNV>(),
        136usize,
        concat!("Size of: ", stringify!(VkGeometryDataNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkGeometryDataNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkGeometryDataNV))
    );
    fn test_field_triangles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).triangles) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryDataNV),
                "::",
                stringify!(triangles)
            )
        );
    }
    test_field_triangles();
    fn test_field_aabbs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aabbs) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryDataNV),
                "::",
                stringify!(aabbs)
            )
        );
    }
    test_field_aabbs();
}
impl Default for VkGeometryDataNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkGeometryNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub geometryType: VkGeometryTypeKHR,
    pub geometry: VkGeometryDataNV,
    pub flags: VkGeometryFlagsKHR,
}
#[test]
fn bindgen_test_layout_VkGeometryNV() {
    assert_eq!(
        ::std::mem::size_of::<VkGeometryNV>(),
        168usize,
        concat!("Size of: ", stringify!(VkGeometryNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkGeometryNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkGeometryNV))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_geometryType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).geometryType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryNV),
                "::",
                stringify!(geometryType)
            )
        );
    }
    test_field_geometryType();
    fn test_field_geometry() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).geometry) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryNV),
                "::",
                stringify!(geometry)
            )
        );
    }
    test_field_geometry();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeometryNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeometryNV),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for VkGeometryNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAccelerationStructureInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub type_: VkAccelerationStructureTypeNV,
    pub flags: VkBuildAccelerationStructureFlagsNV,
    pub instanceCount: u32,
    pub geometryCount: u32,
    pub pGeometries: *const VkGeometryNV,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureInfoNV>(),
        40usize,
        concat!("Size of: ", stringify!(VkAccelerationStructureInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureInfoNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAccelerationStructureInfoNV))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAccelerationStructureInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAccelerationStructureInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAccelerationStructureInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureInfoNV),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAccelerationStructureInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureInfoNV),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_instanceCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAccelerationStructureInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).instanceCount) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureInfoNV),
                "::",
                stringify!(instanceCount)
            )
        );
    }
    test_field_instanceCount();
    fn test_field_geometryCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAccelerationStructureInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).geometryCount) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureInfoNV),
                "::",
                stringify!(geometryCount)
            )
        );
    }
    test_field_geometryCount();
    fn test_field_pGeometries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAccelerationStructureInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pGeometries) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureInfoNV),
                "::",
                stringify!(pGeometries)
            )
        );
    }
    test_field_pGeometries();
}
impl Default for VkAccelerationStructureInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAccelerationStructureCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub compactedSize: VkDeviceSize,
    pub info: VkAccelerationStructureInfoNV,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureCreateInfoNV>(),
        64usize,
        concat!("Size of: ", stringify!(VkAccelerationStructureCreateInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_compactedSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compactedSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureCreateInfoNV),
                "::",
                stringify!(compactedSize)
            )
        );
    }
    test_field_compactedSize();
    fn test_field_info() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureCreateInfoNV),
                "::",
                stringify!(info)
            )
        );
    }
    test_field_info();
}
impl Default for VkAccelerationStructureCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindAccelerationStructureMemoryInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub accelerationStructure: VkAccelerationStructureNV,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub deviceIndexCount: u32,
    pub pDeviceIndices: *const u32,
}
#[test]
fn bindgen_test_layout_VkBindAccelerationStructureMemoryInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkBindAccelerationStructureMemoryInfoNV>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(VkBindAccelerationStructureMemoryInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindAccelerationStructureMemoryInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkBindAccelerationStructureMemoryInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBindAccelerationStructureMemoryInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindAccelerationStructureMemoryInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBindAccelerationStructureMemoryInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindAccelerationStructureMemoryInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_accelerationStructure() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBindAccelerationStructureMemoryInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructure) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindAccelerationStructureMemoryInfoNV),
                "::",
                stringify!(accelerationStructure)
            )
        );
    }
    test_field_accelerationStructure();
    fn test_field_memory() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBindAccelerationStructureMemoryInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindAccelerationStructureMemoryInfoNV),
                "::",
                stringify!(memory)
            )
        );
    }
    test_field_memory();
    fn test_field_memoryOffset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBindAccelerationStructureMemoryInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryOffset) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindAccelerationStructureMemoryInfoNV),
                "::",
                stringify!(memoryOffset)
            )
        );
    }
    test_field_memoryOffset();
    fn test_field_deviceIndexCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBindAccelerationStructureMemoryInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceIndexCount) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindAccelerationStructureMemoryInfoNV),
                "::",
                stringify!(deviceIndexCount)
            )
        );
    }
    test_field_deviceIndexCount();
    fn test_field_pDeviceIndices() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBindAccelerationStructureMemoryInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDeviceIndices) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindAccelerationStructureMemoryInfoNV),
                "::",
                stringify!(pDeviceIndices)
            )
        );
    }
    test_field_pDeviceIndices();
}
impl Default for VkBindAccelerationStructureMemoryInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkWriteDescriptorSetAccelerationStructureNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub accelerationStructureCount: u32,
    pub pAccelerationStructures: *const VkAccelerationStructureNV,
}
#[test]
fn bindgen_test_layout_VkWriteDescriptorSetAccelerationStructureNV() {
    assert_eq!(
        ::std::mem::size_of::<VkWriteDescriptorSetAccelerationStructureNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkWriteDescriptorSetAccelerationStructureNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkWriteDescriptorSetAccelerationStructureNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkWriteDescriptorSetAccelerationStructureNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkWriteDescriptorSetAccelerationStructureNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSetAccelerationStructureNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkWriteDescriptorSetAccelerationStructureNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSetAccelerationStructureNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_accelerationStructureCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkWriteDescriptorSetAccelerationStructureNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructureCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSetAccelerationStructureNV),
                "::",
                stringify!(accelerationStructureCount)
            )
        );
    }
    test_field_accelerationStructureCount();
    fn test_field_pAccelerationStructures() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkWriteDescriptorSetAccelerationStructureNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pAccelerationStructures) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSetAccelerationStructureNV),
                "::",
                stringify!(pAccelerationStructures)
            )
        );
    }
    test_field_pAccelerationStructures();
}
impl Default for VkWriteDescriptorSetAccelerationStructureNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAccelerationStructureMemoryRequirementsInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub type_: VkAccelerationStructureMemoryRequirementsTypeNV,
    pub accelerationStructure: VkAccelerationStructureNV,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureMemoryRequirementsInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureMemoryRequirementsInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureMemoryRequirementsInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureMemoryRequirementsInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureMemoryRequirementsInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureMemoryRequirementsInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMemoryRequirementsInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureMemoryRequirementsInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMemoryRequirementsInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureMemoryRequirementsInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMemoryRequirementsInfoNV),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_accelerationStructure() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureMemoryRequirementsInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructure) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMemoryRequirementsInfoNV),
                "::",
                stringify!(accelerationStructure)
            )
        );
    }
    test_field_accelerationStructure();
}
impl Default for VkAccelerationStructureMemoryRequirementsInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceRayTracingPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderGroupHandleSize: u32,
    pub maxRecursionDepth: u32,
    pub maxShaderGroupStride: u32,
    pub shaderGroupBaseAlignment: u32,
    pub maxGeometryCount: u64,
    pub maxInstanceCount: u64,
    pub maxTriangleCount: u64,
    pub maxDescriptorSetAccelerationStructures: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceRayTracingPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceRayTracingPropertiesNV>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceRayTracingPropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceRayTracingPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceRayTracingPropertiesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRayTracingPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRayTracingPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderGroupHandleSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRayTracingPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderGroupHandleSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
                "::",
                stringify!(shaderGroupHandleSize)
            )
        );
    }
    test_field_shaderGroupHandleSize();
    fn test_field_maxRecursionDepth() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRayTracingPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxRecursionDepth) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
                "::",
                stringify!(maxRecursionDepth)
            )
        );
    }
    test_field_maxRecursionDepth();
    fn test_field_maxShaderGroupStride() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRayTracingPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxShaderGroupStride) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
                "::",
                stringify!(maxShaderGroupStride)
            )
        );
    }
    test_field_maxShaderGroupStride();
    fn test_field_shaderGroupBaseAlignment() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRayTracingPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderGroupBaseAlignment) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
                "::",
                stringify!(shaderGroupBaseAlignment)
            )
        );
    }
    test_field_shaderGroupBaseAlignment();
    fn test_field_maxGeometryCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRayTracingPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxGeometryCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
                "::",
                stringify!(maxGeometryCount)
            )
        );
    }
    test_field_maxGeometryCount();
    fn test_field_maxInstanceCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRayTracingPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxInstanceCount) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
                "::",
                stringify!(maxInstanceCount)
            )
        );
    }
    test_field_maxInstanceCount();
    fn test_field_maxTriangleCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRayTracingPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTriangleCount) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
                "::",
                stringify!(maxTriangleCount)
            )
        );
    }
    test_field_maxTriangleCount();
    fn test_field_maxDescriptorSetAccelerationStructures() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRayTracingPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetAccelerationStructures) as usize
                    - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPropertiesNV),
                "::",
                stringify!(maxDescriptorSetAccelerationStructures)
            )
        );
    }
    test_field_maxDescriptorSetAccelerationStructures();
}
impl Default for VkPhysicalDeviceRayTracingPropertiesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkTransformMatrixKHR {
    pub matrix: [[f32; 4usize]; 3usize],
}
#[test]
fn bindgen_test_layout_VkTransformMatrixKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkTransformMatrixKHR>(),
        48usize,
        concat!("Size of: ", stringify!(VkTransformMatrixKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkTransformMatrixKHR>(),
        4usize,
        concat!("Alignment of ", stringify!(VkTransformMatrixKHR))
    );
    fn test_field_matrix() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTransformMatrixKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).matrix) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTransformMatrixKHR),
                "::",
                stringify!(matrix)
            )
        );
    }
    test_field_matrix();
}
pub type VkTransformMatrixNV = VkTransformMatrixKHR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkAabbPositionsKHR {
    pub minX: f32,
    pub minY: f32,
    pub minZ: f32,
    pub maxX: f32,
    pub maxY: f32,
    pub maxZ: f32,
}
#[test]
fn bindgen_test_layout_VkAabbPositionsKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAabbPositionsKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkAabbPositionsKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAabbPositionsKHR>(),
        4usize,
        concat!("Alignment of ", stringify!(VkAabbPositionsKHR))
    );
    fn test_field_minX() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAabbPositionsKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minX) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAabbPositionsKHR),
                "::",
                stringify!(minX)
            )
        );
    }
    test_field_minX();
    fn test_field_minY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAabbPositionsKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minY) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAabbPositionsKHR),
                "::",
                stringify!(minY)
            )
        );
    }
    test_field_minY();
    fn test_field_minZ() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAabbPositionsKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minZ) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAabbPositionsKHR),
                "::",
                stringify!(minZ)
            )
        );
    }
    test_field_minZ();
    fn test_field_maxX() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAabbPositionsKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxX) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAabbPositionsKHR),
                "::",
                stringify!(maxX)
            )
        );
    }
    test_field_maxX();
    fn test_field_maxY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAabbPositionsKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxY) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAabbPositionsKHR),
                "::",
                stringify!(maxY)
            )
        );
    }
    test_field_maxY();
    fn test_field_maxZ() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAabbPositionsKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxZ) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAabbPositionsKHR),
                "::",
                stringify!(maxZ)
            )
        );
    }
    test_field_maxZ();
}
pub type VkAabbPositionsNV = VkAabbPositionsKHR;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkAccelerationStructureInstanceKHR {
    pub transform: VkTransformMatrixKHR,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub accelerationStructureReference: u64,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureInstanceKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureInstanceKHR>(),
        64usize,
        concat!("Size of: ", stringify!(VkAccelerationStructureInstanceKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureInstanceKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureInstanceKHR)
        )
    );
    fn test_field_transform() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureInstanceKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transform) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureInstanceKHR),
                "::",
                stringify!(transform)
            )
        );
    }
    test_field_transform();
    fn test_field_accelerationStructureReference() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureInstanceKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructureReference) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureInstanceKHR),
                "::",
                stringify!(accelerationStructureReference)
            )
        );
    }
    test_field_accelerationStructureReference();
}
impl VkAccelerationStructureInstanceKHR {
    #[inline]
    pub fn instanceCustomIndex(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_instanceCustomIndex(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn instanceShaderBindingTableRecordOffset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_instanceShaderBindingTableRecordOffset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> VkGeometryInstanceFlagsKHR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: VkGeometryInstanceFlagsKHR) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        instanceCustomIndex: u32,
        mask: u32,
        instanceShaderBindingTableRecordOffset: u32,
        flags: VkGeometryInstanceFlagsKHR,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let instanceCustomIndex: u32 = unsafe { ::std::mem::transmute(instanceCustomIndex) };
            instanceCustomIndex as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let mask: u32 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let instanceShaderBindingTableRecordOffset: u32 =
                unsafe { ::std::mem::transmute(instanceShaderBindingTableRecordOffset) };
            instanceShaderBindingTableRecordOffset as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VkAccelerationStructureInstanceNV = VkAccelerationStructureInstanceKHR;
pub type PFN_vkCreateAccelerationStructureNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkAccelerationStructureCreateInfoNV,
        pAllocator: *const VkAllocationCallbacks,
        pAccelerationStructure: *mut VkAccelerationStructureNV,
    ) -> VkResult,
>;
pub type PFN_vkDestroyAccelerationStructureNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        accelerationStructure: VkAccelerationStructureNV,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkGetAccelerationStructureMemoryRequirementsNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkAccelerationStructureMemoryRequirementsInfoNV,
        pMemoryRequirements: *mut VkMemoryRequirements2KHR,
    ),
>;
pub type PFN_vkBindAccelerationStructureMemoryNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindAccelerationStructureMemoryInfoNV,
    ) -> VkResult,
>;
pub type PFN_vkCmdBuildAccelerationStructureNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pInfo: *const VkAccelerationStructureInfoNV,
        instanceData: VkBuffer,
        instanceOffset: VkDeviceSize,
        update: VkBool32,
        dst: VkAccelerationStructureNV,
        src: VkAccelerationStructureNV,
        scratch: VkBuffer,
        scratchOffset: VkDeviceSize,
    ),
>;
pub type PFN_vkCmdCopyAccelerationStructureNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        dst: VkAccelerationStructureNV,
        src: VkAccelerationStructureNV,
        mode: VkCopyAccelerationStructureModeKHR,
    ),
>;
pub type PFN_vkCmdTraceRaysNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        raygenShaderBindingTableBuffer: VkBuffer,
        raygenShaderBindingOffset: VkDeviceSize,
        missShaderBindingTableBuffer: VkBuffer,
        missShaderBindingOffset: VkDeviceSize,
        missShaderBindingStride: VkDeviceSize,
        hitShaderBindingTableBuffer: VkBuffer,
        hitShaderBindingOffset: VkDeviceSize,
        hitShaderBindingStride: VkDeviceSize,
        callableShaderBindingTableBuffer: VkBuffer,
        callableShaderBindingOffset: VkDeviceSize,
        callableShaderBindingStride: VkDeviceSize,
        width: u32,
        height: u32,
        depth: u32,
    ),
>;
pub type PFN_vkCreateRayTracingPipelinesNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        createInfoCount: u32,
        pCreateInfos: *const VkRayTracingPipelineCreateInfoNV,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult,
>;
pub type PFN_vkGetRayTracingShaderGroupHandlesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipeline: VkPipeline,
        firstGroup: u32,
        groupCount: u32,
        dataSize: usize,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkGetRayTracingShaderGroupHandlesNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipeline: VkPipeline,
        firstGroup: u32,
        groupCount: u32,
        dataSize: usize,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkGetAccelerationStructureHandleNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        accelerationStructure: VkAccelerationStructureNV,
        dataSize: usize,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkCmdWriteAccelerationStructuresPropertiesNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        accelerationStructureCount: u32,
        pAccelerationStructures: *const VkAccelerationStructureNV,
        queryType: VkQueryType,
        queryPool: VkQueryPool,
        firstQuery: u32,
    ),
>;
pub type PFN_vkCompileDeferredNV = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, pipeline: VkPipeline, shader: u32) -> VkResult,
>;
extern "C" {
    pub fn vkCreateAccelerationStructureNV(
        device: VkDevice,
        pCreateInfo: *const VkAccelerationStructureCreateInfoNV,
        pAllocator: *const VkAllocationCallbacks,
        pAccelerationStructure: *mut VkAccelerationStructureNV,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyAccelerationStructureNV(
        device: VkDevice,
        accelerationStructure: VkAccelerationStructureNV,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkGetAccelerationStructureMemoryRequirementsNV(
        device: VkDevice,
        pInfo: *const VkAccelerationStructureMemoryRequirementsInfoNV,
        pMemoryRequirements: *mut VkMemoryRequirements2KHR,
    );
}
extern "C" {
    pub fn vkBindAccelerationStructureMemoryNV(
        device: VkDevice,
        bindInfoCount: u32,
        pBindInfos: *const VkBindAccelerationStructureMemoryInfoNV,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdBuildAccelerationStructureNV(
        commandBuffer: VkCommandBuffer,
        pInfo: *const VkAccelerationStructureInfoNV,
        instanceData: VkBuffer,
        instanceOffset: VkDeviceSize,
        update: VkBool32,
        dst: VkAccelerationStructureNV,
        src: VkAccelerationStructureNV,
        scratch: VkBuffer,
        scratchOffset: VkDeviceSize,
    );
}
extern "C" {
    pub fn vkCmdCopyAccelerationStructureNV(
        commandBuffer: VkCommandBuffer,
        dst: VkAccelerationStructureNV,
        src: VkAccelerationStructureNV,
        mode: VkCopyAccelerationStructureModeKHR,
    );
}
extern "C" {
    pub fn vkCmdTraceRaysNV(
        commandBuffer: VkCommandBuffer,
        raygenShaderBindingTableBuffer: VkBuffer,
        raygenShaderBindingOffset: VkDeviceSize,
        missShaderBindingTableBuffer: VkBuffer,
        missShaderBindingOffset: VkDeviceSize,
        missShaderBindingStride: VkDeviceSize,
        hitShaderBindingTableBuffer: VkBuffer,
        hitShaderBindingOffset: VkDeviceSize,
        hitShaderBindingStride: VkDeviceSize,
        callableShaderBindingTableBuffer: VkBuffer,
        callableShaderBindingOffset: VkDeviceSize,
        callableShaderBindingStride: VkDeviceSize,
        width: u32,
        height: u32,
        depth: u32,
    );
}
extern "C" {
    pub fn vkCreateRayTracingPipelinesNV(
        device: VkDevice,
        pipelineCache: VkPipelineCache,
        createInfoCount: u32,
        pCreateInfos: *const VkRayTracingPipelineCreateInfoNV,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetRayTracingShaderGroupHandlesKHR(
        device: VkDevice,
        pipeline: VkPipeline,
        firstGroup: u32,
        groupCount: u32,
        dataSize: usize,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetRayTracingShaderGroupHandlesNV(
        device: VkDevice,
        pipeline: VkPipeline,
        firstGroup: u32,
        groupCount: u32,
        dataSize: usize,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetAccelerationStructureHandleNV(
        device: VkDevice,
        accelerationStructure: VkAccelerationStructureNV,
        dataSize: usize,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdWriteAccelerationStructuresPropertiesNV(
        commandBuffer: VkCommandBuffer,
        accelerationStructureCount: u32,
        pAccelerationStructures: *const VkAccelerationStructureNV,
        queryType: VkQueryType,
        queryPool: VkQueryPool,
        firstQuery: u32,
    );
}
extern "C" {
    pub fn vkCompileDeferredNV(device: VkDevice, pipeline: VkPipeline, shader: u32) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub representativeFragmentTest: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_representativeFragmentTest() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).representativeFragmentTest) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV),
                "::",
                stringify!(representativeFragmentTest)
            )
        );
    }
    test_field_representativeFragmentTest();
}
impl Default for VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub representativeFragmentTestEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPipelineRepresentativeFragmentTestStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRepresentativeFragmentTestStateCreateInfoNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineRepresentativeFragmentTestStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRepresentativeFragmentTestStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineRepresentativeFragmentTestStateCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRepresentativeFragmentTestStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRepresentativeFragmentTestStateCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRepresentativeFragmentTestStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRepresentativeFragmentTestStateCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_representativeFragmentTestEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRepresentativeFragmentTestStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).representativeFragmentTestEnable) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRepresentativeFragmentTestStateCreateInfoNV),
                "::",
                stringify!(representativeFragmentTestEnable)
            )
        );
    }
    test_field_representativeFragmentTestEnable();
}
impl Default for VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceImageViewImageFormatInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub imageViewType: VkImageViewType,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceImageViewImageFormatInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceImageViewImageFormatInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceImageViewImageFormatInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceImageViewImageFormatInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceImageViewImageFormatInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImageViewImageFormatInfoEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageViewImageFormatInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImageViewImageFormatInfoEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageViewImageFormatInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_imageViewType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImageViewImageFormatInfoEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageViewType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageViewImageFormatInfoEXT),
                "::",
                stringify!(imageViewType)
            )
        );
    }
    test_field_imageViewType();
}
impl Default for VkPhysicalDeviceImageViewImageFormatInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFilterCubicImageViewImageFormatPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub filterCubic: VkBool32,
    pub filterCubicMinmax: VkBool32,
}
#[test]
fn bindgen_test_layout_VkFilterCubicImageViewImageFormatPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkFilterCubicImageViewImageFormatPropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkFilterCubicImageViewImageFormatPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkFilterCubicImageViewImageFormatPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkFilterCubicImageViewImageFormatPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkFilterCubicImageViewImageFormatPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFilterCubicImageViewImageFormatPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkFilterCubicImageViewImageFormatPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFilterCubicImageViewImageFormatPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_filterCubic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkFilterCubicImageViewImageFormatPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filterCubic) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFilterCubicImageViewImageFormatPropertiesEXT),
                "::",
                stringify!(filterCubic)
            )
        );
    }
    test_field_filterCubic();
    fn test_field_filterCubicMinmax() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkFilterCubicImageViewImageFormatPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filterCubicMinmax) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFilterCubicImageViewImageFormatPropertiesEXT),
                "::",
                stringify!(filterCubicMinmax)
            )
        );
    }
    test_field_filterCubicMinmax();
}
impl Default for VkFilterCubicImageViewImageFormatPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub use self::VkQueueGlobalPriorityKHR as VkQueueGlobalPriorityEXT;
pub type VkDeviceQueueGlobalPriorityCreateInfoEXT = VkDeviceQueueGlobalPriorityCreateInfoKHR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImportMemoryHostPointerInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleType: VkExternalMemoryHandleTypeFlagBits,
    pub pHostPointer: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkImportMemoryHostPointerInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkImportMemoryHostPointerInfoEXT>(),
        32usize,
        concat!("Size of: ", stringify!(VkImportMemoryHostPointerInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImportMemoryHostPointerInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkImportMemoryHostPointerInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportMemoryHostPointerInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportMemoryHostPointerInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportMemoryHostPointerInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportMemoryHostPointerInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_handleType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportMemoryHostPointerInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportMemoryHostPointerInfoEXT),
                "::",
                stringify!(handleType)
            )
        );
    }
    test_field_handleType();
    fn test_field_pHostPointer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImportMemoryHostPointerInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pHostPointer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImportMemoryHostPointerInfoEXT),
                "::",
                stringify!(pHostPointer)
            )
        );
    }
    test_field_pHostPointer();
}
impl Default for VkImportMemoryHostPointerInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryHostPointerPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryTypeBits: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryHostPointerPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryHostPointerPropertiesEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkMemoryHostPointerPropertiesEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryHostPointerPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkMemoryHostPointerPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryHostPointerPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryHostPointerPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryHostPointerPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryHostPointerPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_memoryTypeBits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryHostPointerPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryTypeBits) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryHostPointerPropertiesEXT),
                "::",
                stringify!(memoryTypeBits)
            )
        );
    }
    test_field_memoryTypeBits();
}
impl Default for VkMemoryHostPointerPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub minImportedHostPointerAlignment: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExternalMemoryHostPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceExternalMemoryHostPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExternalMemoryHostPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExternalMemoryHostPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalMemoryHostPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExternalMemoryHostPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalMemoryHostPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_minImportedHostPointerAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExternalMemoryHostPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minImportedHostPointerAlignment) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalMemoryHostPropertiesEXT),
                "::",
                stringify!(minImportedHostPointerAlignment)
            )
        );
    }
    test_field_minImportedHostPointerAlignment();
}
impl Default for VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetMemoryHostPointerPropertiesEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        handleType: VkExternalMemoryHandleTypeFlagBits,
        pHostPointer: *const ::std::os::raw::c_void,
        pMemoryHostPointerProperties: *mut VkMemoryHostPointerPropertiesEXT,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetMemoryHostPointerPropertiesEXT(
        device: VkDevice,
        handleType: VkExternalMemoryHandleTypeFlagBits,
        pHostPointer: *const ::std::os::raw::c_void,
        pMemoryHostPointerProperties: *mut VkMemoryHostPointerPropertiesEXT,
    ) -> VkResult;
}
pub type PFN_vkCmdWriteBufferMarkerAMD = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pipelineStage: VkPipelineStageFlagBits,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        marker: u32,
    ),
>;
extern "C" {
    pub fn vkCmdWriteBufferMarkerAMD(
        commandBuffer: VkCommandBuffer,
        pipelineStage: VkPipelineStageFlagBits,
        dstBuffer: VkBuffer,
        dstOffset: VkDeviceSize,
        marker: u32,
    );
}
pub const VK_PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD:
    VkPipelineCompilerControlFlagBitsAMD = 2147483647;
pub type VkPipelineCompilerControlFlagBitsAMD = ::std::os::raw::c_int;
pub type VkPipelineCompilerControlFlagsAMD = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCompilerControlCreateInfoAMD {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub compilerControlFlags: VkPipelineCompilerControlFlagsAMD,
}
#[test]
fn bindgen_test_layout_VkPipelineCompilerControlCreateInfoAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineCompilerControlCreateInfoAMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineCompilerControlCreateInfoAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineCompilerControlCreateInfoAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineCompilerControlCreateInfoAMD)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCompilerControlCreateInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCompilerControlCreateInfoAMD),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCompilerControlCreateInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCompilerControlCreateInfoAMD),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_compilerControlFlags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCompilerControlCreateInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compilerControlFlags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCompilerControlCreateInfoAMD),
                "::",
                stringify!(compilerControlFlags)
            )
        );
    }
    test_field_compilerControlFlags();
}
impl Default for VkPipelineCompilerControlCreateInfoAMD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_TIME_DOMAIN_DEVICE_EXT: VkTimeDomainEXT = 0;
pub const VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT: VkTimeDomainEXT = 1;
pub const VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT: VkTimeDomainEXT = 2;
pub const VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT: VkTimeDomainEXT = 3;
pub const VK_TIME_DOMAIN_MAX_ENUM_EXT: VkTimeDomainEXT = 2147483647;
pub type VkTimeDomainEXT = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCalibratedTimestampInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub timeDomain: VkTimeDomainEXT,
}
#[test]
fn bindgen_test_layout_VkCalibratedTimestampInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkCalibratedTimestampInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkCalibratedTimestampInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCalibratedTimestampInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCalibratedTimestampInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCalibratedTimestampInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCalibratedTimestampInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCalibratedTimestampInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCalibratedTimestampInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_timeDomain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCalibratedTimestampInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timeDomain) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCalibratedTimestampInfoEXT),
                "::",
                stringify!(timeDomain)
            )
        );
    }
    test_field_timeDomain();
}
impl Default for VkCalibratedTimestampInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pTimeDomainCount: *mut u32,
        pTimeDomains: *mut VkTimeDomainEXT,
    ) -> VkResult,
>;
pub type PFN_vkGetCalibratedTimestampsEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        timestampCount: u32,
        pTimestampInfos: *const VkCalibratedTimestampInfoEXT,
        pTimestamps: *mut u64,
        pMaxDeviation: *mut u64,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(
        physicalDevice: VkPhysicalDevice,
        pTimeDomainCount: *mut u32,
        pTimeDomains: *mut VkTimeDomainEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetCalibratedTimestampsEXT(
        device: VkDevice,
        timestampCount: u32,
        pTimestampInfos: *const VkCalibratedTimestampInfoEXT,
        pTimestamps: *mut u64,
        pMaxDeviation: *mut u64,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderCorePropertiesAMD {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderEngineCount: u32,
    pub shaderArraysPerEngineCount: u32,
    pub computeUnitsPerShaderArray: u32,
    pub simdPerComputeUnit: u32,
    pub wavefrontsPerSimd: u32,
    pub wavefrontSize: u32,
    pub sgprsPerSimd: u32,
    pub minSgprAllocation: u32,
    pub maxSgprAllocation: u32,
    pub sgprAllocationGranularity: u32,
    pub vgprsPerSimd: u32,
    pub minVgprAllocation: u32,
    pub maxVgprAllocation: u32,
    pub vgprAllocationGranularity: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderCorePropertiesAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderCorePropertiesAMD>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderCorePropertiesAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderCorePropertiesAMD)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCorePropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCorePropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderEngineCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCorePropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderEngineCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
                "::",
                stringify!(shaderEngineCount)
            )
        );
    }
    test_field_shaderEngineCount();
    fn test_field_shaderArraysPerEngineCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCorePropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderArraysPerEngineCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
                "::",
                stringify!(shaderArraysPerEngineCount)
            )
        );
    }
    test_field_shaderArraysPerEngineCount();
    fn test_field_computeUnitsPerShaderArray() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCorePropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).computeUnitsPerShaderArray) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
                "::",
                stringify!(computeUnitsPerShaderArray)
            )
        );
    }
    test_field_computeUnitsPerShaderArray();
    fn test_field_simdPerComputeUnit() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCorePropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).simdPerComputeUnit) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
                "::",
                stringify!(simdPerComputeUnit)
            )
        );
    }
    test_field_simdPerComputeUnit();
    fn test_field_wavefrontsPerSimd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCorePropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wavefrontsPerSimd) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
                "::",
                stringify!(wavefrontsPerSimd)
            )
        );
    }
    test_field_wavefrontsPerSimd();
    fn test_field_wavefrontSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCorePropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wavefrontSize) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
                "::",
                stringify!(wavefrontSize)
            )
        );
    }
    test_field_wavefrontSize();
    fn test_field_sgprsPerSimd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCorePropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sgprsPerSimd) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
                "::",
                stringify!(sgprsPerSimd)
            )
        );
    }
    test_field_sgprsPerSimd();
    fn test_field_minSgprAllocation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCorePropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minSgprAllocation) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
                "::",
                stringify!(minSgprAllocation)
            )
        );
    }
    test_field_minSgprAllocation();
    fn test_field_maxSgprAllocation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCorePropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSgprAllocation) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
                "::",
                stringify!(maxSgprAllocation)
            )
        );
    }
    test_field_maxSgprAllocation();
    fn test_field_sgprAllocationGranularity() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCorePropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sgprAllocationGranularity) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
                "::",
                stringify!(sgprAllocationGranularity)
            )
        );
    }
    test_field_sgprAllocationGranularity();
    fn test_field_vgprsPerSimd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCorePropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vgprsPerSimd) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
                "::",
                stringify!(vgprsPerSimd)
            )
        );
    }
    test_field_vgprsPerSimd();
    fn test_field_minVgprAllocation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCorePropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minVgprAllocation) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
                "::",
                stringify!(minVgprAllocation)
            )
        );
    }
    test_field_minVgprAllocation();
    fn test_field_maxVgprAllocation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCorePropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxVgprAllocation) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
                "::",
                stringify!(maxVgprAllocation)
            )
        );
    }
    test_field_maxVgprAllocation();
    fn test_field_vgprAllocationGranularity() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCorePropertiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vgprAllocationGranularity) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCorePropertiesAMD),
                "::",
                stringify!(vgprAllocationGranularity)
            )
        );
    }
    test_field_vgprAllocationGranularity();
}
impl Default for VkPhysicalDeviceShaderCorePropertiesAMD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD: VkMemoryOverallocationBehaviorAMD = 0;
pub const VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD: VkMemoryOverallocationBehaviorAMD = 1;
pub const VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD: VkMemoryOverallocationBehaviorAMD = 2;
pub const VK_MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD: VkMemoryOverallocationBehaviorAMD =
    2147483647;
pub type VkMemoryOverallocationBehaviorAMD = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceMemoryOverallocationCreateInfoAMD {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub overallocationBehavior: VkMemoryOverallocationBehaviorAMD,
}
#[test]
fn bindgen_test_layout_VkDeviceMemoryOverallocationCreateInfoAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceMemoryOverallocationCreateInfoAMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDeviceMemoryOverallocationCreateInfoAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceMemoryOverallocationCreateInfoAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceMemoryOverallocationCreateInfoAMD)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceMemoryOverallocationCreateInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceMemoryOverallocationCreateInfoAMD),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceMemoryOverallocationCreateInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceMemoryOverallocationCreateInfoAMD),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_overallocationBehavior() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceMemoryOverallocationCreateInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overallocationBehavior) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceMemoryOverallocationCreateInfoAMD),
                "::",
                stringify!(overallocationBehavior)
            )
        );
    }
    test_field_overallocationBehavior();
}
impl Default for VkDeviceMemoryOverallocationCreateInfoAMD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxVertexAttribDivisor: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxVertexAttribDivisor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxVertexAttribDivisor) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT),
                "::",
                stringify!(maxVertexAttribDivisor)
            )
        );
    }
    test_field_maxVertexAttribDivisor();
}
impl Default for VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkVertexInputBindingDivisorDescriptionEXT {
    pub binding: u32,
    pub divisor: u32,
}
#[test]
fn bindgen_test_layout_VkVertexInputBindingDivisorDescriptionEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkVertexInputBindingDivisorDescriptionEXT>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(VkVertexInputBindingDivisorDescriptionEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkVertexInputBindingDivisorDescriptionEXT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkVertexInputBindingDivisorDescriptionEXT)
        )
    );
    fn test_field_binding() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkVertexInputBindingDivisorDescriptionEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binding) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputBindingDivisorDescriptionEXT),
                "::",
                stringify!(binding)
            )
        );
    }
    test_field_binding();
    fn test_field_divisor() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkVertexInputBindingDivisorDescriptionEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).divisor) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputBindingDivisorDescriptionEXT),
                "::",
                stringify!(divisor)
            )
        );
    }
    test_field_divisor();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineVertexInputDivisorStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub vertexBindingDivisorCount: u32,
    pub pVertexBindingDivisors: *const VkVertexInputBindingDivisorDescriptionEXT,
}
#[test]
fn bindgen_test_layout_VkPipelineVertexInputDivisorStateCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineVertexInputDivisorStateCreateInfoEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineVertexInputDivisorStateCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineVertexInputDivisorStateCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineVertexInputDivisorStateCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineVertexInputDivisorStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineVertexInputDivisorStateCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineVertexInputDivisorStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineVertexInputDivisorStateCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_vertexBindingDivisorCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineVertexInputDivisorStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexBindingDivisorCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineVertexInputDivisorStateCreateInfoEXT),
                "::",
                stringify!(vertexBindingDivisorCount)
            )
        );
    }
    test_field_vertexBindingDivisorCount();
    fn test_field_pVertexBindingDivisors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineVertexInputDivisorStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pVertexBindingDivisors) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineVertexInputDivisorStateCreateInfoEXT),
                "::",
                stringify!(pVertexBindingDivisors)
            )
        );
    }
    test_field_pVertexBindingDivisors();
}
impl Default for VkPipelineVertexInputDivisorStateCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub vertexAttributeInstanceRateDivisor: VkBool32,
    pub vertexAttributeInstanceRateZeroDivisor: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_vertexAttributeInstanceRateDivisor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexAttributeInstanceRateDivisor) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT),
                "::",
                stringify!(vertexAttributeInstanceRateDivisor)
            )
        );
    }
    test_field_vertexAttributeInstanceRateDivisor();
    fn test_field_vertexAttributeInstanceRateZeroDivisor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexAttributeInstanceRateZeroDivisor) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT),
                "::",
                stringify!(vertexAttributeInstanceRateZeroDivisor)
            )
        );
    }
    test_field_vertexAttributeInstanceRateZeroDivisor();
}
impl Default for VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub use self::VkPipelineCreationFeedbackFlagBits as VkPipelineCreationFeedbackFlagBitsEXT;
pub type VkPipelineCreationFeedbackFlagsEXT = VkPipelineCreationFeedbackFlags;
pub type VkPipelineCreationFeedbackCreateInfoEXT = VkPipelineCreationFeedbackCreateInfo;
pub type VkPipelineCreationFeedbackEXT = VkPipelineCreationFeedback;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceComputeShaderDerivativesFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub computeDerivativeGroupQuads: VkBool32,
    pub computeDerivativeGroupLinear: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceComputeShaderDerivativesFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceComputeShaderDerivativesFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_computeDerivativeGroupQuads() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceComputeShaderDerivativesFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).computeDerivativeGroupQuads) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV),
                "::",
                stringify!(computeDerivativeGroupQuads)
            )
        );
    }
    test_field_computeDerivativeGroupQuads();
    fn test_field_computeDerivativeGroupLinear() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceComputeShaderDerivativesFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).computeDerivativeGroupLinear) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV),
                "::",
                stringify!(computeDerivativeGroupLinear)
            )
        );
    }
    test_field_computeDerivativeGroupLinear();
}
impl Default for VkPhysicalDeviceComputeShaderDerivativesFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMeshShaderFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub taskShader: VkBool32,
    pub meshShader: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMeshShaderFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMeshShaderFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMeshShaderFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMeshShaderFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMeshShaderFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_taskShader() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).taskShader) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderFeaturesNV),
                "::",
                stringify!(taskShader)
            )
        );
    }
    test_field_taskShader();
    fn test_field_meshShader() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).meshShader) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderFeaturesNV),
                "::",
                stringify!(meshShader)
            )
        );
    }
    test_field_meshShader();
}
impl Default for VkPhysicalDeviceMeshShaderFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMeshShaderPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxDrawMeshTasksCount: u32,
    pub maxTaskWorkGroupInvocations: u32,
    pub maxTaskWorkGroupSize: [u32; 3usize],
    pub maxTaskTotalMemorySize: u32,
    pub maxTaskOutputCount: u32,
    pub maxMeshWorkGroupInvocations: u32,
    pub maxMeshWorkGroupSize: [u32; 3usize],
    pub maxMeshTotalMemorySize: u32,
    pub maxMeshOutputVertices: u32,
    pub maxMeshOutputPrimitives: u32,
    pub maxMeshMultiviewViewCount: u32,
    pub meshOutputPerVertexGranularity: u32,
    pub meshOutputPerPrimitiveGranularity: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMeshShaderPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMeshShaderPropertiesNV>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMeshShaderPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxDrawMeshTasksCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDrawMeshTasksCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
                "::",
                stringify!(maxDrawMeshTasksCount)
            )
        );
    }
    test_field_maxDrawMeshTasksCount();
    fn test_field_maxTaskWorkGroupInvocations() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTaskWorkGroupInvocations) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
                "::",
                stringify!(maxTaskWorkGroupInvocations)
            )
        );
    }
    test_field_maxTaskWorkGroupInvocations();
    fn test_field_maxTaskWorkGroupSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTaskWorkGroupSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
                "::",
                stringify!(maxTaskWorkGroupSize)
            )
        );
    }
    test_field_maxTaskWorkGroupSize();
    fn test_field_maxTaskTotalMemorySize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTaskTotalMemorySize) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
                "::",
                stringify!(maxTaskTotalMemorySize)
            )
        );
    }
    test_field_maxTaskTotalMemorySize();
    fn test_field_maxTaskOutputCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTaskOutputCount) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
                "::",
                stringify!(maxTaskOutputCount)
            )
        );
    }
    test_field_maxTaskOutputCount();
    fn test_field_maxMeshWorkGroupInvocations() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshWorkGroupInvocations) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
                "::",
                stringify!(maxMeshWorkGroupInvocations)
            )
        );
    }
    test_field_maxMeshWorkGroupInvocations();
    fn test_field_maxMeshWorkGroupSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshWorkGroupSize) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
                "::",
                stringify!(maxMeshWorkGroupSize)
            )
        );
    }
    test_field_maxMeshWorkGroupSize();
    fn test_field_maxMeshTotalMemorySize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshTotalMemorySize) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
                "::",
                stringify!(maxMeshTotalMemorySize)
            )
        );
    }
    test_field_maxMeshTotalMemorySize();
    fn test_field_maxMeshOutputVertices() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshOutputVertices) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
                "::",
                stringify!(maxMeshOutputVertices)
            )
        );
    }
    test_field_maxMeshOutputVertices();
    fn test_field_maxMeshOutputPrimitives() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshOutputPrimitives) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
                "::",
                stringify!(maxMeshOutputPrimitives)
            )
        );
    }
    test_field_maxMeshOutputPrimitives();
    fn test_field_maxMeshMultiviewViewCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshMultiviewViewCount) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
                "::",
                stringify!(maxMeshMultiviewViewCount)
            )
        );
    }
    test_field_maxMeshMultiviewViewCount();
    fn test_field_meshOutputPerVertexGranularity() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).meshOutputPerVertexGranularity) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
                "::",
                stringify!(meshOutputPerVertexGranularity)
            )
        );
    }
    test_field_meshOutputPerVertexGranularity();
    fn test_field_meshOutputPerPrimitiveGranularity() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).meshOutputPerPrimitiveGranularity) as usize
                    - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesNV),
                "::",
                stringify!(meshOutputPerPrimitiveGranularity)
            )
        );
    }
    test_field_meshOutputPerPrimitiveGranularity();
}
impl Default for VkPhysicalDeviceMeshShaderPropertiesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkDrawMeshTasksIndirectCommandNV {
    pub taskCount: u32,
    pub firstTask: u32,
}
#[test]
fn bindgen_test_layout_VkDrawMeshTasksIndirectCommandNV() {
    assert_eq!(
        ::std::mem::size_of::<VkDrawMeshTasksIndirectCommandNV>(),
        8usize,
        concat!("Size of: ", stringify!(VkDrawMeshTasksIndirectCommandNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDrawMeshTasksIndirectCommandNV>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkDrawMeshTasksIndirectCommandNV)
        )
    );
    fn test_field_taskCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrawMeshTasksIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).taskCount) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrawMeshTasksIndirectCommandNV),
                "::",
                stringify!(taskCount)
            )
        );
    }
    test_field_taskCount();
    fn test_field_firstTask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrawMeshTasksIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstTask) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrawMeshTasksIndirectCommandNV),
                "::",
                stringify!(firstTask)
            )
        );
    }
    test_field_firstTask();
}
pub type PFN_vkCmdDrawMeshTasksNV = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, taskCount: u32, firstTask: u32),
>;
pub type PFN_vkCmdDrawMeshTasksIndirectNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        drawCount: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCmdDrawMeshTasksIndirectCountNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    ),
>;
extern "C" {
    pub fn vkCmdDrawMeshTasksNV(commandBuffer: VkCommandBuffer, taskCount: u32, firstTask: u32);
}
extern "C" {
    pub fn vkCmdDrawMeshTasksIndirectNV(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        drawCount: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawMeshTasksIndirectCountNV(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    );
}
pub type VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV =
    VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderImageFootprintFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub imageFootprint: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderImageFootprintFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderImageFootprintFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderImageFootprintFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderImageFootprintFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderImageFootprintFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderImageFootprintFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderImageFootprintFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderImageFootprintFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderImageFootprintFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_imageFootprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderImageFootprintFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageFootprint) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderImageFootprintFeaturesNV),
                "::",
                stringify!(imageFootprint)
            )
        );
    }
    test_field_imageFootprint();
}
impl Default for VkPhysicalDeviceShaderImageFootprintFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineViewportExclusiveScissorStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub exclusiveScissorCount: u32,
    pub pExclusiveScissors: *const VkRect2D,
}
#[test]
fn bindgen_test_layout_VkPipelineViewportExclusiveScissorStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineViewportExclusiveScissorStateCreateInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineViewportExclusiveScissorStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineViewportExclusiveScissorStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineViewportExclusiveScissorStateCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportExclusiveScissorStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportExclusiveScissorStateCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportExclusiveScissorStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportExclusiveScissorStateCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_exclusiveScissorCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportExclusiveScissorStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).exclusiveScissorCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportExclusiveScissorStateCreateInfoNV),
                "::",
                stringify!(exclusiveScissorCount)
            )
        );
    }
    test_field_exclusiveScissorCount();
    fn test_field_pExclusiveScissors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportExclusiveScissorStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pExclusiveScissors) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportExclusiveScissorStateCreateInfoNV),
                "::",
                stringify!(pExclusiveScissors)
            )
        );
    }
    test_field_pExclusiveScissors();
}
impl Default for VkPipelineViewportExclusiveScissorStateCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExclusiveScissorFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub exclusiveScissor: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExclusiveScissorFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExclusiveScissorFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceExclusiveScissorFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExclusiveScissorFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExclusiveScissorFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExclusiveScissorFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExclusiveScissorFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExclusiveScissorFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExclusiveScissorFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_exclusiveScissor() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExclusiveScissorFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).exclusiveScissor) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExclusiveScissorFeaturesNV),
                "::",
                stringify!(exclusiveScissor)
            )
        );
    }
    test_field_exclusiveScissor();
}
impl Default for VkPhysicalDeviceExclusiveScissorFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdSetExclusiveScissorNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstExclusiveScissor: u32,
        exclusiveScissorCount: u32,
        pExclusiveScissors: *const VkRect2D,
    ),
>;
extern "C" {
    pub fn vkCmdSetExclusiveScissorNV(
        commandBuffer: VkCommandBuffer,
        firstExclusiveScissor: u32,
        exclusiveScissorCount: u32,
        pExclusiveScissors: *const VkRect2D,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueueFamilyCheckpointPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub checkpointExecutionStageMask: VkPipelineStageFlags,
}
#[test]
fn bindgen_test_layout_VkQueueFamilyCheckpointPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkQueueFamilyCheckpointPropertiesNV>(),
        24usize,
        concat!("Size of: ", stringify!(VkQueueFamilyCheckpointPropertiesNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkQueueFamilyCheckpointPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkQueueFamilyCheckpointPropertiesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueueFamilyCheckpointPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyCheckpointPropertiesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueueFamilyCheckpointPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyCheckpointPropertiesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_checkpointExecutionStageMask() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueueFamilyCheckpointPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).checkpointExecutionStageMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueueFamilyCheckpointPropertiesNV),
                "::",
                stringify!(checkpointExecutionStageMask)
            )
        );
    }
    test_field_checkpointExecutionStageMask();
}
impl Default for VkQueueFamilyCheckpointPropertiesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCheckpointDataNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub stage: VkPipelineStageFlagBits,
    pub pCheckpointMarker: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkCheckpointDataNV() {
    assert_eq!(
        ::std::mem::size_of::<VkCheckpointDataNV>(),
        32usize,
        concat!("Size of: ", stringify!(VkCheckpointDataNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCheckpointDataNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCheckpointDataNV))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCheckpointDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCheckpointDataNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCheckpointDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCheckpointDataNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_stage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCheckpointDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stage) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCheckpointDataNV),
                "::",
                stringify!(stage)
            )
        );
    }
    test_field_stage();
    fn test_field_pCheckpointMarker() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCheckpointDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCheckpointMarker) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCheckpointDataNV),
                "::",
                stringify!(pCheckpointMarker)
            )
        );
    }
    test_field_pCheckpointMarker();
}
impl Default for VkCheckpointDataNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdSetCheckpointNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pCheckpointMarker: *const ::std::os::raw::c_void,
    ),
>;
pub type PFN_vkGetQueueCheckpointDataNV = ::std::option::Option<
    unsafe extern "C" fn(
        queue: VkQueue,
        pCheckpointDataCount: *mut u32,
        pCheckpointData: *mut VkCheckpointDataNV,
    ),
>;
extern "C" {
    pub fn vkCmdSetCheckpointNV(
        commandBuffer: VkCommandBuffer,
        pCheckpointMarker: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn vkGetQueueCheckpointDataNV(
        queue: VkQueue,
        pCheckpointDataCount: *mut u32,
        pCheckpointData: *mut VkCheckpointDataNV,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderIntegerFunctions2: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderIntegerFunctions2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderIntegerFunctions2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL),
                "::",
                stringify!(shaderIntegerFunctions2)
            )
        );
    }
    test_field_shaderIntegerFunctions2();
}
impl Default for VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPerformanceConfigurationINTEL_T {
    _unused: [u8; 0],
}
pub type VkPerformanceConfigurationINTEL = *mut VkPerformanceConfigurationINTEL_T;
pub const VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL:
    VkPerformanceConfigurationTypeINTEL = 0;
pub const VK_PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL: VkPerformanceConfigurationTypeINTEL =
    2147483647;
pub type VkPerformanceConfigurationTypeINTEL = ::std::os::raw::c_int;
pub const VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL: VkQueryPoolSamplingModeINTEL = 0;
pub const VK_QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL: VkQueryPoolSamplingModeINTEL = 2147483647;
pub type VkQueryPoolSamplingModeINTEL = ::std::os::raw::c_int;
pub const VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL: VkPerformanceOverrideTypeINTEL = 0;
pub const VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL: VkPerformanceOverrideTypeINTEL = 1;
pub const VK_PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL: VkPerformanceOverrideTypeINTEL = 2147483647;
pub type VkPerformanceOverrideTypeINTEL = ::std::os::raw::c_int;
pub const VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL:
    VkPerformanceParameterTypeINTEL = 0;
pub const VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL:
    VkPerformanceParameterTypeINTEL = 1;
pub const VK_PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL: VkPerformanceParameterTypeINTEL =
    2147483647;
pub type VkPerformanceParameterTypeINTEL = ::std::os::raw::c_int;
pub const VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL: VkPerformanceValueTypeINTEL = 0;
pub const VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL: VkPerformanceValueTypeINTEL = 1;
pub const VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL: VkPerformanceValueTypeINTEL = 2;
pub const VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL: VkPerformanceValueTypeINTEL = 3;
pub const VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL: VkPerformanceValueTypeINTEL = 4;
pub const VK_PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL: VkPerformanceValueTypeINTEL = 2147483647;
pub type VkPerformanceValueTypeINTEL = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkPerformanceValueDataINTEL {
    pub value32: u32,
    pub value64: u64,
    pub valueFloat: f32,
    pub valueBool: VkBool32,
    pub valueString: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VkPerformanceValueDataINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceValueDataINTEL>(),
        8usize,
        concat!("Size of: ", stringify!(VkPerformanceValueDataINTEL))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceValueDataINTEL>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPerformanceValueDataINTEL))
    );
    fn test_field_value32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceValueDataINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceValueDataINTEL),
                "::",
                stringify!(value32)
            )
        );
    }
    test_field_value32();
    fn test_field_value64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceValueDataINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value64) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceValueDataINTEL),
                "::",
                stringify!(value64)
            )
        );
    }
    test_field_value64();
    fn test_field_valueFloat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceValueDataINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).valueFloat) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceValueDataINTEL),
                "::",
                stringify!(valueFloat)
            )
        );
    }
    test_field_valueFloat();
    fn test_field_valueBool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceValueDataINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).valueBool) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceValueDataINTEL),
                "::",
                stringify!(valueBool)
            )
        );
    }
    test_field_valueBool();
    fn test_field_valueString() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceValueDataINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).valueString) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceValueDataINTEL),
                "::",
                stringify!(valueString)
            )
        );
    }
    test_field_valueString();
}
impl Default for VkPerformanceValueDataINTEL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkPerformanceValueINTEL {
    pub type_: VkPerformanceValueTypeINTEL,
    pub data: VkPerformanceValueDataINTEL,
}
#[test]
fn bindgen_test_layout_VkPerformanceValueINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceValueINTEL>(),
        16usize,
        concat!("Size of: ", stringify!(VkPerformanceValueINTEL))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceValueINTEL>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPerformanceValueINTEL))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceValueINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceValueINTEL),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceValueINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceValueINTEL),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
impl Default for VkPerformanceValueINTEL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkInitializePerformanceApiInfoINTEL {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pUserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkInitializePerformanceApiInfoINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkInitializePerformanceApiInfoINTEL>(),
        24usize,
        concat!("Size of: ", stringify!(VkInitializePerformanceApiInfoINTEL))
    );
    assert_eq!(
        ::std::mem::align_of::<VkInitializePerformanceApiInfoINTEL>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkInitializePerformanceApiInfoINTEL)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkInitializePerformanceApiInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkInitializePerformanceApiInfoINTEL),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkInitializePerformanceApiInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkInitializePerformanceApiInfoINTEL),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pUserData() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkInitializePerformanceApiInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkInitializePerformanceApiInfoINTEL),
                "::",
                stringify!(pUserData)
            )
        );
    }
    test_field_pUserData();
}
impl Default for VkInitializePerformanceApiInfoINTEL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueryPoolPerformanceQueryCreateInfoINTEL {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub performanceCountersSampling: VkQueryPoolSamplingModeINTEL,
}
#[test]
fn bindgen_test_layout_VkQueryPoolPerformanceQueryCreateInfoINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkQueryPoolPerformanceQueryCreateInfoINTEL>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkQueryPoolPerformanceQueryCreateInfoINTEL)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkQueryPoolPerformanceQueryCreateInfoINTEL>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkQueryPoolPerformanceQueryCreateInfoINTEL)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueryPoolPerformanceQueryCreateInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueryPoolPerformanceQueryCreateInfoINTEL),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueryPoolPerformanceQueryCreateInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueryPoolPerformanceQueryCreateInfoINTEL),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_performanceCountersSampling() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkQueryPoolPerformanceQueryCreateInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).performanceCountersSampling) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkQueryPoolPerformanceQueryCreateInfoINTEL),
                "::",
                stringify!(performanceCountersSampling)
            )
        );
    }
    test_field_performanceCountersSampling();
}
impl Default for VkQueryPoolPerformanceQueryCreateInfoINTEL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkQueryPoolCreateInfoINTEL = VkQueryPoolPerformanceQueryCreateInfoINTEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPerformanceMarkerInfoINTEL {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub marker: u64,
}
#[test]
fn bindgen_test_layout_VkPerformanceMarkerInfoINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceMarkerInfoINTEL>(),
        24usize,
        concat!("Size of: ", stringify!(VkPerformanceMarkerInfoINTEL))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceMarkerInfoINTEL>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPerformanceMarkerInfoINTEL))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceMarkerInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceMarkerInfoINTEL),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceMarkerInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceMarkerInfoINTEL),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_marker() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceMarkerInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).marker) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceMarkerInfoINTEL),
                "::",
                stringify!(marker)
            )
        );
    }
    test_field_marker();
}
impl Default for VkPerformanceMarkerInfoINTEL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPerformanceStreamMarkerInfoINTEL {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub marker: u32,
}
#[test]
fn bindgen_test_layout_VkPerformanceStreamMarkerInfoINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceStreamMarkerInfoINTEL>(),
        24usize,
        concat!("Size of: ", stringify!(VkPerformanceStreamMarkerInfoINTEL))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceStreamMarkerInfoINTEL>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPerformanceStreamMarkerInfoINTEL)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPerformanceStreamMarkerInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceStreamMarkerInfoINTEL),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPerformanceStreamMarkerInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceStreamMarkerInfoINTEL),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_marker() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPerformanceStreamMarkerInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).marker) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceStreamMarkerInfoINTEL),
                "::",
                stringify!(marker)
            )
        );
    }
    test_field_marker();
}
impl Default for VkPerformanceStreamMarkerInfoINTEL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPerformanceOverrideInfoINTEL {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub type_: VkPerformanceOverrideTypeINTEL,
    pub enable: VkBool32,
    pub parameter: u64,
}
#[test]
fn bindgen_test_layout_VkPerformanceOverrideInfoINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceOverrideInfoINTEL>(),
        32usize,
        concat!("Size of: ", stringify!(VkPerformanceOverrideInfoINTEL))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceOverrideInfoINTEL>(),
        8usize,
        concat!("Alignment of ", stringify!(VkPerformanceOverrideInfoINTEL))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceOverrideInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceOverrideInfoINTEL),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceOverrideInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceOverrideInfoINTEL),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceOverrideInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceOverrideInfoINTEL),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_enable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceOverrideInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceOverrideInfoINTEL),
                "::",
                stringify!(enable)
            )
        );
    }
    test_field_enable();
    fn test_field_parameter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPerformanceOverrideInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parameter) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceOverrideInfoINTEL),
                "::",
                stringify!(parameter)
            )
        );
    }
    test_field_parameter();
}
impl Default for VkPerformanceOverrideInfoINTEL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPerformanceConfigurationAcquireInfoINTEL {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub type_: VkPerformanceConfigurationTypeINTEL,
}
#[test]
fn bindgen_test_layout_VkPerformanceConfigurationAcquireInfoINTEL() {
    assert_eq!(
        ::std::mem::size_of::<VkPerformanceConfigurationAcquireInfoINTEL>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPerformanceConfigurationAcquireInfoINTEL)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPerformanceConfigurationAcquireInfoINTEL>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPerformanceConfigurationAcquireInfoINTEL)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPerformanceConfigurationAcquireInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceConfigurationAcquireInfoINTEL),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPerformanceConfigurationAcquireInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceConfigurationAcquireInfoINTEL),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPerformanceConfigurationAcquireInfoINTEL>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPerformanceConfigurationAcquireInfoINTEL),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
}
impl Default for VkPerformanceConfigurationAcquireInfoINTEL {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkInitializePerformanceApiINTEL = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInitializeInfo: *const VkInitializePerformanceApiInfoINTEL,
    ) -> VkResult,
>;
pub type PFN_vkUninitializePerformanceApiINTEL =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice)>;
pub type PFN_vkCmdSetPerformanceMarkerINTEL = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pMarkerInfo: *const VkPerformanceMarkerInfoINTEL,
    ) -> VkResult,
>;
pub type PFN_vkCmdSetPerformanceStreamMarkerINTEL = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pMarkerInfo: *const VkPerformanceStreamMarkerInfoINTEL,
    ) -> VkResult,
>;
pub type PFN_vkCmdSetPerformanceOverrideINTEL = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pOverrideInfo: *const VkPerformanceOverrideInfoINTEL,
    ) -> VkResult,
>;
pub type PFN_vkAcquirePerformanceConfigurationINTEL = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pAcquireInfo: *const VkPerformanceConfigurationAcquireInfoINTEL,
        pConfiguration: *mut VkPerformanceConfigurationINTEL,
    ) -> VkResult,
>;
pub type PFN_vkReleasePerformanceConfigurationINTEL = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        configuration: VkPerformanceConfigurationINTEL,
    ) -> VkResult,
>;
pub type PFN_vkQueueSetPerformanceConfigurationINTEL = ::std::option::Option<
    unsafe extern "C" fn(
        queue: VkQueue,
        configuration: VkPerformanceConfigurationINTEL,
    ) -> VkResult,
>;
pub type PFN_vkGetPerformanceParameterINTEL = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        parameter: VkPerformanceParameterTypeINTEL,
        pValue: *mut VkPerformanceValueINTEL,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkInitializePerformanceApiINTEL(
        device: VkDevice,
        pInitializeInfo: *const VkInitializePerformanceApiInfoINTEL,
    ) -> VkResult;
}
extern "C" {
    pub fn vkUninitializePerformanceApiINTEL(device: VkDevice);
}
extern "C" {
    pub fn vkCmdSetPerformanceMarkerINTEL(
        commandBuffer: VkCommandBuffer,
        pMarkerInfo: *const VkPerformanceMarkerInfoINTEL,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdSetPerformanceStreamMarkerINTEL(
        commandBuffer: VkCommandBuffer,
        pMarkerInfo: *const VkPerformanceStreamMarkerInfoINTEL,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdSetPerformanceOverrideINTEL(
        commandBuffer: VkCommandBuffer,
        pOverrideInfo: *const VkPerformanceOverrideInfoINTEL,
    ) -> VkResult;
}
extern "C" {
    pub fn vkAcquirePerformanceConfigurationINTEL(
        device: VkDevice,
        pAcquireInfo: *const VkPerformanceConfigurationAcquireInfoINTEL,
        pConfiguration: *mut VkPerformanceConfigurationINTEL,
    ) -> VkResult;
}
extern "C" {
    pub fn vkReleasePerformanceConfigurationINTEL(
        device: VkDevice,
        configuration: VkPerformanceConfigurationINTEL,
    ) -> VkResult;
}
extern "C" {
    pub fn vkQueueSetPerformanceConfigurationINTEL(
        queue: VkQueue,
        configuration: VkPerformanceConfigurationINTEL,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPerformanceParameterINTEL(
        device: VkDevice,
        parameter: VkPerformanceParameterTypeINTEL,
        pValue: *mut VkPerformanceValueINTEL,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePCIBusInfoPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub pciDomain: u32,
    pub pciBus: u32,
    pub pciDevice: u32,
    pub pciFunction: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePCIBusInfoPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePCIBusInfoPropertiesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePCIBusInfoPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePCIBusInfoPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePCIBusInfoPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePCIBusInfoPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePCIBusInfoPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePCIBusInfoPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePCIBusInfoPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pciDomain() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePCIBusInfoPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciDomain) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePCIBusInfoPropertiesEXT),
                "::",
                stringify!(pciDomain)
            )
        );
    }
    test_field_pciDomain();
    fn test_field_pciBus() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePCIBusInfoPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciBus) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePCIBusInfoPropertiesEXT),
                "::",
                stringify!(pciBus)
            )
        );
    }
    test_field_pciBus();
    fn test_field_pciDevice() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePCIBusInfoPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciDevice) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePCIBusInfoPropertiesEXT),
                "::",
                stringify!(pciDevice)
            )
        );
    }
    test_field_pciDevice();
    fn test_field_pciFunction() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePCIBusInfoPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pciFunction) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePCIBusInfoPropertiesEXT),
                "::",
                stringify!(pciFunction)
            )
        );
    }
    test_field_pciFunction();
}
impl Default for VkPhysicalDevicePCIBusInfoPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayNativeHdrSurfaceCapabilitiesAMD {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub localDimmingSupport: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDisplayNativeHdrSurfaceCapabilitiesAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkDisplayNativeHdrSurfaceCapabilitiesAMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDisplayNativeHdrSurfaceCapabilitiesAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDisplayNativeHdrSurfaceCapabilitiesAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDisplayNativeHdrSurfaceCapabilitiesAMD)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDisplayNativeHdrSurfaceCapabilitiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayNativeHdrSurfaceCapabilitiesAMD),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDisplayNativeHdrSurfaceCapabilitiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayNativeHdrSurfaceCapabilitiesAMD),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_localDimmingSupport() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDisplayNativeHdrSurfaceCapabilitiesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).localDimmingSupport) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDisplayNativeHdrSurfaceCapabilitiesAMD),
                "::",
                stringify!(localDimmingSupport)
            )
        );
    }
    test_field_localDimmingSupport();
}
impl Default for VkDisplayNativeHdrSurfaceCapabilitiesAMD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSwapchainDisplayNativeHdrCreateInfoAMD {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub localDimmingEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkSwapchainDisplayNativeHdrCreateInfoAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkSwapchainDisplayNativeHdrCreateInfoAMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkSwapchainDisplayNativeHdrCreateInfoAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkSwapchainDisplayNativeHdrCreateInfoAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSwapchainDisplayNativeHdrCreateInfoAMD)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSwapchainDisplayNativeHdrCreateInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainDisplayNativeHdrCreateInfoAMD),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSwapchainDisplayNativeHdrCreateInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainDisplayNativeHdrCreateInfoAMD),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_localDimmingEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSwapchainDisplayNativeHdrCreateInfoAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).localDimmingEnable) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainDisplayNativeHdrCreateInfoAMD),
                "::",
                stringify!(localDimmingEnable)
            )
        );
    }
    test_field_localDimmingEnable();
}
impl Default for VkSwapchainDisplayNativeHdrCreateInfoAMD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkSetLocalDimmingAMD = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, swapChain: VkSwapchainKHR, localDimmingEnable: VkBool32),
>;
extern "C" {
    pub fn vkSetLocalDimmingAMD(
        device: VkDevice,
        swapChain: VkSwapchainKHR,
        localDimmingEnable: VkBool32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub fragmentDensityMap: VkBool32,
    pub fragmentDensityMapDynamic: VkBool32,
    pub fragmentDensityMapNonSubsampledImages: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentDensityMapFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentDensityMapFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentDensityMapFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceFragmentDensityMapFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMapFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceFragmentDensityMapFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMapFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_fragmentDensityMap() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceFragmentDensityMapFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentDensityMap) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMapFeaturesEXT),
                "::",
                stringify!(fragmentDensityMap)
            )
        );
    }
    test_field_fragmentDensityMap();
    fn test_field_fragmentDensityMapDynamic() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceFragmentDensityMapFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentDensityMapDynamic) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMapFeaturesEXT),
                "::",
                stringify!(fragmentDensityMapDynamic)
            )
        );
    }
    test_field_fragmentDensityMapDynamic();
    fn test_field_fragmentDensityMapNonSubsampledImages() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceFragmentDensityMapFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentDensityMapNonSubsampledImages) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMapFeaturesEXT),
                "::",
                stringify!(fragmentDensityMapNonSubsampledImages)
            )
        );
    }
    test_field_fragmentDensityMapNonSubsampledImages();
}
impl Default for VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub minFragmentDensityTexelSize: VkExtent2D,
    pub maxFragmentDensityTexelSize: VkExtent2D,
    pub fragmentDensityInvocations: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentDensityMapPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentDensityMapPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentDensityMapPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMapPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMapPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMapPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMapPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_minFragmentDensityTexelSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMapPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minFragmentDensityTexelSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMapPropertiesEXT),
                "::",
                stringify!(minFragmentDensityTexelSize)
            )
        );
    }
    test_field_minFragmentDensityTexelSize();
    fn test_field_maxFragmentDensityTexelSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMapPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFragmentDensityTexelSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMapPropertiesEXT),
                "::",
                stringify!(maxFragmentDensityTexelSize)
            )
        );
    }
    test_field_maxFragmentDensityTexelSize();
    fn test_field_fragmentDensityInvocations() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMapPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentDensityInvocations) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMapPropertiesEXT),
                "::",
                stringify!(fragmentDensityInvocations)
            )
        );
    }
    test_field_fragmentDensityInvocations();
}
impl Default for VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassFragmentDensityMapCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub fragmentDensityMapAttachment: VkAttachmentReference,
}
#[test]
fn bindgen_test_layout_VkRenderPassFragmentDensityMapCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassFragmentDensityMapCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkRenderPassFragmentDensityMapCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassFragmentDensityMapCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRenderPassFragmentDensityMapCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassFragmentDensityMapCreateInfoEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassFragmentDensityMapCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassFragmentDensityMapCreateInfoEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassFragmentDensityMapCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_fragmentDensityMapAttachment() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassFragmentDensityMapCreateInfoEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentDensityMapAttachment) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassFragmentDensityMapCreateInfoEXT),
                "::",
                stringify!(fragmentDensityMapAttachment)
            )
        );
    }
    test_field_fragmentDensityMapAttachment();
}
impl Default for VkRenderPassFragmentDensityMapCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = VkPhysicalDeviceScalarBlockLayoutFeatures;
pub type VkPhysicalDeviceSubgroupSizeControlFeaturesEXT =
    VkPhysicalDeviceSubgroupSizeControlFeatures;
pub type VkPhysicalDeviceSubgroupSizeControlPropertiesEXT =
    VkPhysicalDeviceSubgroupSizeControlProperties;
pub type VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT =
    VkPipelineShaderStageRequiredSubgroupSizeCreateInfo;
pub const VK_SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD: VkShaderCorePropertiesFlagBitsAMD =
    2147483647;
pub type VkShaderCorePropertiesFlagBitsAMD = ::std::os::raw::c_int;
pub type VkShaderCorePropertiesFlagsAMD = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderCoreProperties2AMD {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderCoreFeatures: VkShaderCorePropertiesFlagsAMD,
    pub activeComputeUnitCount: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderCoreProperties2AMD() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderCoreProperties2AMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderCoreProperties2AMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderCoreProperties2AMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderCoreProperties2AMD)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCoreProperties2AMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCoreProperties2AMD),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCoreProperties2AMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCoreProperties2AMD),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderCoreFeatures() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCoreProperties2AMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderCoreFeatures) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCoreProperties2AMD),
                "::",
                stringify!(shaderCoreFeatures)
            )
        );
    }
    test_field_shaderCoreFeatures();
    fn test_field_activeComputeUnitCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderCoreProperties2AMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).activeComputeUnitCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCoreProperties2AMD),
                "::",
                stringify!(activeComputeUnitCount)
            )
        );
    }
    test_field_activeComputeUnitCount();
}
impl Default for VkPhysicalDeviceShaderCoreProperties2AMD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceCoherentMemoryFeaturesAMD {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub deviceCoherentMemory: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceCoherentMemoryFeaturesAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceCoherentMemoryFeaturesAMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceCoherentMemoryFeaturesAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceCoherentMemoryFeaturesAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceCoherentMemoryFeaturesAMD)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCoherentMemoryFeaturesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCoherentMemoryFeaturesAMD),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCoherentMemoryFeaturesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCoherentMemoryFeaturesAMD),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_deviceCoherentMemory() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCoherentMemoryFeaturesAMD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceCoherentMemory) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCoherentMemoryFeaturesAMD),
                "::",
                stringify!(deviceCoherentMemory)
            )
        );
    }
    test_field_deviceCoherentMemory();
}
impl Default for VkPhysicalDeviceCoherentMemoryFeaturesAMD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderImageInt64Atomics: VkBool32,
    pub sparseImageInt64Atomics: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderImageInt64Atomics() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderImageInt64Atomics) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT),
                "::",
                stringify!(shaderImageInt64Atomics)
            )
        );
    }
    test_field_shaderImageInt64Atomics();
    fn test_field_sparseImageInt64Atomics() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseImageInt64Atomics) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT),
                "::",
                stringify!(sparseImageInt64Atomics)
            )
        );
    }
    test_field_sparseImageInt64Atomics();
}
impl Default for VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMemoryBudgetPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub heapBudget: [VkDeviceSize; 16usize],
    pub heapUsage: [VkDeviceSize; 16usize],
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMemoryBudgetPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMemoryBudgetPropertiesEXT>(),
        272usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMemoryBudgetPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMemoryBudgetPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMemoryBudgetPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMemoryBudgetPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryBudgetPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMemoryBudgetPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryBudgetPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_heapBudget() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMemoryBudgetPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).heapBudget) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryBudgetPropertiesEXT),
                "::",
                stringify!(heapBudget)
            )
        );
    }
    test_field_heapBudget();
    fn test_field_heapUsage() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMemoryBudgetPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).heapUsage) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryBudgetPropertiesEXT),
                "::",
                stringify!(heapUsage)
            )
        );
    }
    test_field_heapUsage();
}
impl Default for VkPhysicalDeviceMemoryBudgetPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMemoryPriorityFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryPriority: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMemoryPriorityFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMemoryPriorityFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMemoryPriorityFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMemoryPriorityFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMemoryPriorityFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMemoryPriorityFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryPriorityFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMemoryPriorityFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryPriorityFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_memoryPriority() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMemoryPriorityFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryPriority) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryPriorityFeaturesEXT),
                "::",
                stringify!(memoryPriority)
            )
        );
    }
    test_field_memoryPriority();
}
impl Default for VkPhysicalDeviceMemoryPriorityFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryPriorityAllocateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub priority: f32,
}
#[test]
fn bindgen_test_layout_VkMemoryPriorityAllocateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryPriorityAllocateInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkMemoryPriorityAllocateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryPriorityAllocateInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryPriorityAllocateInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryPriorityAllocateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryPriorityAllocateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryPriorityAllocateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryPriorityAllocateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_priority() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryPriorityAllocateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryPriorityAllocateInfoEXT),
                "::",
                stringify!(priority)
            )
        );
    }
    test_field_priority();
}
impl Default for VkMemoryPriorityAllocateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub dedicatedAllocationImageAliasing: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_dedicatedAllocationImageAliasing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dedicatedAllocationImageAliasing) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV),
                "::",
                stringify!(dedicatedAllocationImageAliasing)
            )
        );
    }
    test_field_dedicatedAllocationImageAliasing();
}
impl Default for VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceBufferDeviceAddressFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub bufferDeviceAddress: VkBool32,
    pub bufferDeviceAddressCaptureReplay: VkBool32,
    pub bufferDeviceAddressMultiDevice: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceBufferDeviceAddressFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceBufferDeviceAddressFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_bufferDeviceAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceBufferDeviceAddressFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferDeviceAddress) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT),
                "::",
                stringify!(bufferDeviceAddress)
            )
        );
    }
    test_field_bufferDeviceAddress();
    fn test_field_bufferDeviceAddressCaptureReplay() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceBufferDeviceAddressFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferDeviceAddressCaptureReplay) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT),
                "::",
                stringify!(bufferDeviceAddressCaptureReplay)
            )
        );
    }
    test_field_bufferDeviceAddressCaptureReplay();
    fn test_field_bufferDeviceAddressMultiDevice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceBufferDeviceAddressFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferDeviceAddressMultiDevice) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT),
                "::",
                stringify!(bufferDeviceAddressMultiDevice)
            )
        );
    }
    test_field_bufferDeviceAddressMultiDevice();
}
impl Default for VkPhysicalDeviceBufferDeviceAddressFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPhysicalDeviceBufferAddressFeaturesEXT = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT;
pub type VkBufferDeviceAddressInfoEXT = VkBufferDeviceAddressInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferDeviceAddressCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub deviceAddress: VkDeviceAddress,
}
#[test]
fn bindgen_test_layout_VkBufferDeviceAddressCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferDeviceAddressCreateInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkBufferDeviceAddressCreateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferDeviceAddressCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkBufferDeviceAddressCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBufferDeviceAddressCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferDeviceAddressCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBufferDeviceAddressCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferDeviceAddressCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_deviceAddress() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBufferDeviceAddressCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceAddress) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferDeviceAddressCreateInfoEXT),
                "::",
                stringify!(deviceAddress)
            )
        );
    }
    test_field_deviceAddress();
}
impl Default for VkBufferDeviceAddressCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetBufferDeviceAddressEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkBufferDeviceAddressInfo,
    ) -> VkDeviceAddress,
>;
extern "C" {
    pub fn vkGetBufferDeviceAddressEXT(
        device: VkDevice,
        pInfo: *const VkBufferDeviceAddressInfo,
    ) -> VkDeviceAddress;
}
pub use self::VkToolPurposeFlagBits as VkToolPurposeFlagBitsEXT;
pub type VkToolPurposeFlagsEXT = VkToolPurposeFlags;
pub type VkPhysicalDeviceToolPropertiesEXT = VkPhysicalDeviceToolProperties;
pub type PFN_vkGetPhysicalDeviceToolPropertiesEXT = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pToolCount: *mut u32,
        pToolProperties: *mut VkPhysicalDeviceToolProperties,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPhysicalDeviceToolPropertiesEXT(
        physicalDevice: VkPhysicalDevice,
        pToolCount: *mut u32,
        pToolProperties: *mut VkPhysicalDeviceToolProperties,
    ) -> VkResult;
}
pub type VkImageStencilUsageCreateInfoEXT = VkImageStencilUsageCreateInfo;
pub const VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT: VkValidationFeatureEnableEXT = 0;
pub const VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT:
    VkValidationFeatureEnableEXT = 1;
pub const VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT: VkValidationFeatureEnableEXT = 2;
pub const VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT: VkValidationFeatureEnableEXT = 3;
pub const VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT:
    VkValidationFeatureEnableEXT = 4;
pub const VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT: VkValidationFeatureEnableEXT = 2147483647;
pub type VkValidationFeatureEnableEXT = ::std::os::raw::c_int;
pub const VK_VALIDATION_FEATURE_DISABLE_ALL_EXT: VkValidationFeatureDisableEXT = 0;
pub const VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT: VkValidationFeatureDisableEXT = 1;
pub const VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT: VkValidationFeatureDisableEXT = 2;
pub const VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT: VkValidationFeatureDisableEXT = 3;
pub const VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT: VkValidationFeatureDisableEXT = 4;
pub const VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT: VkValidationFeatureDisableEXT = 5;
pub const VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT: VkValidationFeatureDisableEXT = 6;
pub const VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT: VkValidationFeatureDisableEXT =
    7;
pub const VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT: VkValidationFeatureDisableEXT = 2147483647;
pub type VkValidationFeatureDisableEXT = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkValidationFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub enabledValidationFeatureCount: u32,
    pub pEnabledValidationFeatures: *const VkValidationFeatureEnableEXT,
    pub disabledValidationFeatureCount: u32,
    pub pDisabledValidationFeatures: *const VkValidationFeatureDisableEXT,
}
#[test]
fn bindgen_test_layout_VkValidationFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkValidationFeaturesEXT>(),
        48usize,
        concat!("Size of: ", stringify!(VkValidationFeaturesEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkValidationFeaturesEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkValidationFeaturesEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkValidationFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkValidationFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkValidationFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkValidationFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_enabledValidationFeatureCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkValidationFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enabledValidationFeatureCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkValidationFeaturesEXT),
                "::",
                stringify!(enabledValidationFeatureCount)
            )
        );
    }
    test_field_enabledValidationFeatureCount();
    fn test_field_pEnabledValidationFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkValidationFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pEnabledValidationFeatures) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkValidationFeaturesEXT),
                "::",
                stringify!(pEnabledValidationFeatures)
            )
        );
    }
    test_field_pEnabledValidationFeatures();
    fn test_field_disabledValidationFeatureCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkValidationFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).disabledValidationFeatureCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkValidationFeaturesEXT),
                "::",
                stringify!(disabledValidationFeatureCount)
            )
        );
    }
    test_field_disabledValidationFeatureCount();
    fn test_field_pDisabledValidationFeatures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkValidationFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDisabledValidationFeatures) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkValidationFeaturesEXT),
                "::",
                stringify!(pDisabledValidationFeatures)
            )
        );
    }
    test_field_pDisabledValidationFeatures();
}
impl Default for VkValidationFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_COMPONENT_TYPE_FLOAT16_NV: VkComponentTypeNV = 0;
pub const VK_COMPONENT_TYPE_FLOAT32_NV: VkComponentTypeNV = 1;
pub const VK_COMPONENT_TYPE_FLOAT64_NV: VkComponentTypeNV = 2;
pub const VK_COMPONENT_TYPE_SINT8_NV: VkComponentTypeNV = 3;
pub const VK_COMPONENT_TYPE_SINT16_NV: VkComponentTypeNV = 4;
pub const VK_COMPONENT_TYPE_SINT32_NV: VkComponentTypeNV = 5;
pub const VK_COMPONENT_TYPE_SINT64_NV: VkComponentTypeNV = 6;
pub const VK_COMPONENT_TYPE_UINT8_NV: VkComponentTypeNV = 7;
pub const VK_COMPONENT_TYPE_UINT16_NV: VkComponentTypeNV = 8;
pub const VK_COMPONENT_TYPE_UINT32_NV: VkComponentTypeNV = 9;
pub const VK_COMPONENT_TYPE_UINT64_NV: VkComponentTypeNV = 10;
pub const VK_COMPONENT_TYPE_MAX_ENUM_NV: VkComponentTypeNV = 2147483647;
pub type VkComponentTypeNV = ::std::os::raw::c_int;
pub const VK_SCOPE_DEVICE_NV: VkScopeNV = 1;
pub const VK_SCOPE_WORKGROUP_NV: VkScopeNV = 2;
pub const VK_SCOPE_SUBGROUP_NV: VkScopeNV = 3;
pub const VK_SCOPE_QUEUE_FAMILY_NV: VkScopeNV = 5;
pub const VK_SCOPE_MAX_ENUM_NV: VkScopeNV = 2147483647;
pub type VkScopeNV = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCooperativeMatrixPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub MSize: u32,
    pub NSize: u32,
    pub KSize: u32,
    pub AType: VkComponentTypeNV,
    pub BType: VkComponentTypeNV,
    pub CType: VkComponentTypeNV,
    pub DType: VkComponentTypeNV,
    pub scope: VkScopeNV,
}
#[test]
fn bindgen_test_layout_VkCooperativeMatrixPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkCooperativeMatrixPropertiesNV>(),
        48usize,
        concat!("Size of: ", stringify!(VkCooperativeMatrixPropertiesNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCooperativeMatrixPropertiesNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCooperativeMatrixPropertiesNV))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCooperativeMatrixPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCooperativeMatrixPropertiesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCooperativeMatrixPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCooperativeMatrixPropertiesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_MSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCooperativeMatrixPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).MSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCooperativeMatrixPropertiesNV),
                "::",
                stringify!(MSize)
            )
        );
    }
    test_field_MSize();
    fn test_field_NSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCooperativeMatrixPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).NSize) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCooperativeMatrixPropertiesNV),
                "::",
                stringify!(NSize)
            )
        );
    }
    test_field_NSize();
    fn test_field_KSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCooperativeMatrixPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).KSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCooperativeMatrixPropertiesNV),
                "::",
                stringify!(KSize)
            )
        );
    }
    test_field_KSize();
    fn test_field_AType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCooperativeMatrixPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).AType) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCooperativeMatrixPropertiesNV),
                "::",
                stringify!(AType)
            )
        );
    }
    test_field_AType();
    fn test_field_BType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCooperativeMatrixPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).BType) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCooperativeMatrixPropertiesNV),
                "::",
                stringify!(BType)
            )
        );
    }
    test_field_BType();
    fn test_field_CType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCooperativeMatrixPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).CType) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCooperativeMatrixPropertiesNV),
                "::",
                stringify!(CType)
            )
        );
    }
    test_field_CType();
    fn test_field_DType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCooperativeMatrixPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).DType) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCooperativeMatrixPropertiesNV),
                "::",
                stringify!(DType)
            )
        );
    }
    test_field_DType();
    fn test_field_scope() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCooperativeMatrixPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scope) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCooperativeMatrixPropertiesNV),
                "::",
                stringify!(scope)
            )
        );
    }
    test_field_scope();
}
impl Default for VkCooperativeMatrixPropertiesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceCooperativeMatrixFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub cooperativeMatrix: VkBool32,
    pub cooperativeMatrixRobustBufferAccess: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceCooperativeMatrixFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceCooperativeMatrixFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceCooperativeMatrixFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceCooperativeMatrixFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceCooperativeMatrixFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCooperativeMatrixFeaturesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCooperativeMatrixFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCooperativeMatrixFeaturesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCooperativeMatrixFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_cooperativeMatrix() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCooperativeMatrixFeaturesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cooperativeMatrix) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCooperativeMatrixFeaturesNV),
                "::",
                stringify!(cooperativeMatrix)
            )
        );
    }
    test_field_cooperativeMatrix();
    fn test_field_cooperativeMatrixRobustBufferAccess() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCooperativeMatrixFeaturesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cooperativeMatrixRobustBufferAccess) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCooperativeMatrixFeaturesNV),
                "::",
                stringify!(cooperativeMatrixRobustBufferAccess)
            )
        );
    }
    test_field_cooperativeMatrixRobustBufferAccess();
}
impl Default for VkPhysicalDeviceCooperativeMatrixFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceCooperativeMatrixPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub cooperativeMatrixSupportedStages: VkShaderStageFlags,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceCooperativeMatrixPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceCooperativeMatrixPropertiesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceCooperativeMatrixPropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceCooperativeMatrixPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceCooperativeMatrixPropertiesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceCooperativeMatrixPropertiesNV > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCooperativeMatrixPropertiesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceCooperativeMatrixPropertiesNV > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCooperativeMatrixPropertiesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_cooperativeMatrixSupportedStages() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceCooperativeMatrixPropertiesNV > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cooperativeMatrixSupportedStages) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCooperativeMatrixPropertiesNV),
                "::",
                stringify!(cooperativeMatrixSupportedStages)
            )
        );
    }
    test_field_cooperativeMatrixSupportedStages();
}
impl Default for VkPhysicalDeviceCooperativeMatrixPropertiesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkCooperativeMatrixPropertiesNV,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(
        physicalDevice: VkPhysicalDevice,
        pPropertyCount: *mut u32,
        pProperties: *mut VkCooperativeMatrixPropertiesNV,
    ) -> VkResult;
}
pub const VK_COVERAGE_REDUCTION_MODE_MERGE_NV: VkCoverageReductionModeNV = 0;
pub const VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV: VkCoverageReductionModeNV = 1;
pub const VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV: VkCoverageReductionModeNV = 2147483647;
pub type VkCoverageReductionModeNV = ::std::os::raw::c_int;
pub type VkPipelineCoverageReductionStateCreateFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceCoverageReductionModeFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub coverageReductionMode: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceCoverageReductionModeFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceCoverageReductionModeFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceCoverageReductionModeFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceCoverageReductionModeFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceCoverageReductionModeFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceCoverageReductionModeFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCoverageReductionModeFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceCoverageReductionModeFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCoverageReductionModeFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_coverageReductionMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceCoverageReductionModeFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).coverageReductionMode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCoverageReductionModeFeaturesNV),
                "::",
                stringify!(coverageReductionMode)
            )
        );
    }
    test_field_coverageReductionMode();
}
impl Default for VkPhysicalDeviceCoverageReductionModeFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCoverageReductionStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCoverageReductionStateCreateFlagsNV,
    pub coverageReductionMode: VkCoverageReductionModeNV,
}
#[test]
fn bindgen_test_layout_VkPipelineCoverageReductionStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineCoverageReductionStateCreateInfoNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineCoverageReductionStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineCoverageReductionStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineCoverageReductionStateCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCoverageReductionStateCreateInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCoverageReductionStateCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCoverageReductionStateCreateInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCoverageReductionStateCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCoverageReductionStateCreateInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCoverageReductionStateCreateInfoNV),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_coverageReductionMode() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPipelineCoverageReductionStateCreateInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).coverageReductionMode) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineCoverageReductionStateCreateInfoNV),
                "::",
                stringify!(coverageReductionMode)
            )
        );
    }
    test_field_coverageReductionMode();
}
impl Default for VkPipelineCoverageReductionStateCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFramebufferMixedSamplesCombinationNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub coverageReductionMode: VkCoverageReductionModeNV,
    pub rasterizationSamples: VkSampleCountFlagBits,
    pub depthStencilSamples: VkSampleCountFlags,
    pub colorSamples: VkSampleCountFlags,
}
#[test]
fn bindgen_test_layout_VkFramebufferMixedSamplesCombinationNV() {
    assert_eq!(
        ::std::mem::size_of::<VkFramebufferMixedSamplesCombinationNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkFramebufferMixedSamplesCombinationNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkFramebufferMixedSamplesCombinationNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkFramebufferMixedSamplesCombinationNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkFramebufferMixedSamplesCombinationNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferMixedSamplesCombinationNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkFramebufferMixedSamplesCombinationNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferMixedSamplesCombinationNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_coverageReductionMode() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkFramebufferMixedSamplesCombinationNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).coverageReductionMode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferMixedSamplesCombinationNV),
                "::",
                stringify!(coverageReductionMode)
            )
        );
    }
    test_field_coverageReductionMode();
    fn test_field_rasterizationSamples() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkFramebufferMixedSamplesCombinationNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rasterizationSamples) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferMixedSamplesCombinationNV),
                "::",
                stringify!(rasterizationSamples)
            )
        );
    }
    test_field_rasterizationSamples();
    fn test_field_depthStencilSamples() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkFramebufferMixedSamplesCombinationNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthStencilSamples) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferMixedSamplesCombinationNV),
                "::",
                stringify!(depthStencilSamples)
            )
        );
    }
    test_field_depthStencilSamples();
    fn test_field_colorSamples() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkFramebufferMixedSamplesCombinationNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorSamples) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkFramebufferMixedSamplesCombinationNV),
                "::",
                stringify!(colorSamples)
            )
        );
    }
    test_field_colorSamples();
}
impl Default for VkFramebufferMixedSamplesCombinationNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV =
    ::std::option::Option<
        unsafe extern "C" fn(
            physicalDevice: VkPhysicalDevice,
            pCombinationCount: *mut u32,
            pCombinations: *mut VkFramebufferMixedSamplesCombinationNV,
        ) -> VkResult,
    >;
extern "C" {
    pub fn vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
        physicalDevice: VkPhysicalDevice,
        pCombinationCount: *mut u32,
        pCombinations: *mut VkFramebufferMixedSamplesCombinationNV,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub fragmentShaderSampleInterlock: VkBool32,
    pub fragmentShaderPixelInterlock: VkBool32,
    pub fragmentShaderShadingRateInterlock: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_fragmentShaderSampleInterlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentShaderSampleInterlock) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT),
                "::",
                stringify!(fragmentShaderSampleInterlock)
            )
        );
    }
    test_field_fragmentShaderSampleInterlock();
    fn test_field_fragmentShaderPixelInterlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentShaderPixelInterlock) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT),
                "::",
                stringify!(fragmentShaderPixelInterlock)
            )
        );
    }
    test_field_fragmentShaderPixelInterlock();
    fn test_field_fragmentShaderShadingRateInterlock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentShaderShadingRateInterlock) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT),
                "::",
                stringify!(fragmentShaderShadingRateInterlock)
            )
        );
    }
    test_field_fragmentShaderShadingRateInterlock();
}
impl Default for VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub ycbcrImageArrays: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_ycbcrImageArrays() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ycbcrImageArrays) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT),
                "::",
                stringify!(ycbcrImageArrays)
            )
        );
    }
    test_field_ycbcrImageArrays();
}
impl Default for VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT: VkProvokingVertexModeEXT = 0;
pub const VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT: VkProvokingVertexModeEXT = 1;
pub const VK_PROVOKING_VERTEX_MODE_MAX_ENUM_EXT: VkProvokingVertexModeEXT = 2147483647;
pub type VkProvokingVertexModeEXT = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceProvokingVertexFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub provokingVertexLast: VkBool32,
    pub transformFeedbackPreservesProvokingVertex: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceProvokingVertexFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceProvokingVertexFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceProvokingVertexFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceProvokingVertexFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceProvokingVertexFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceProvokingVertexFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProvokingVertexFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceProvokingVertexFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProvokingVertexFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_provokingVertexLast() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceProvokingVertexFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).provokingVertexLast) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProvokingVertexFeaturesEXT),
                "::",
                stringify!(provokingVertexLast)
            )
        );
    }
    test_field_provokingVertexLast();
    fn test_field_transformFeedbackPreservesProvokingVertex() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceProvokingVertexFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformFeedbackPreservesProvokingVertex) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProvokingVertexFeaturesEXT),
                "::",
                stringify!(transformFeedbackPreservesProvokingVertex)
            )
        );
    }
    test_field_transformFeedbackPreservesProvokingVertex();
}
impl Default for VkPhysicalDeviceProvokingVertexFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceProvokingVertexPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub provokingVertexModePerPipeline: VkBool32,
    pub transformFeedbackPreservesTriangleFanProvokingVertex: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceProvokingVertexPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceProvokingVertexPropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceProvokingVertexPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceProvokingVertexPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceProvokingVertexPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceProvokingVertexPropertiesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProvokingVertexPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceProvokingVertexPropertiesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProvokingVertexPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_provokingVertexModePerPipeline() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceProvokingVertexPropertiesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).provokingVertexModePerPipeline) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProvokingVertexPropertiesEXT),
                "::",
                stringify!(provokingVertexModePerPipeline)
            )
        );
    }
    test_field_provokingVertexModePerPipeline();
    fn test_field_transformFeedbackPreservesTriangleFanProvokingVertex() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceProvokingVertexPropertiesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformFeedbackPreservesTriangleFanProvokingVertex)
                    as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceProvokingVertexPropertiesEXT),
                "::",
                stringify!(transformFeedbackPreservesTriangleFanProvokingVertex)
            )
        );
    }
    test_field_transformFeedbackPreservesTriangleFanProvokingVertex();
}
impl Default for VkPhysicalDeviceProvokingVertexPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRasterizationProvokingVertexStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub provokingVertexMode: VkProvokingVertexModeEXT,
}
#[test]
fn bindgen_test_layout_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRasterizationProvokingVertexStateCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRasterizationProvokingVertexStateCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationProvokingVertexStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationProvokingVertexStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_provokingVertexMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineRasterizationProvokingVertexStateCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).provokingVertexMode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT),
                "::",
                stringify!(provokingVertexMode)
            )
        );
    }
    test_field_provokingVertexMode();
}
impl Default for VkPipelineRasterizationProvokingVertexStateCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkHeadlessSurfaceCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkHeadlessSurfaceCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkHeadlessSurfaceCreateFlagsEXT,
}
#[test]
fn bindgen_test_layout_VkHeadlessSurfaceCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkHeadlessSurfaceCreateInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkHeadlessSurfaceCreateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkHeadlessSurfaceCreateInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkHeadlessSurfaceCreateInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkHeadlessSurfaceCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkHeadlessSurfaceCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkHeadlessSurfaceCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkHeadlessSurfaceCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkHeadlessSurfaceCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkHeadlessSurfaceCreateInfoEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for VkHeadlessSurfaceCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCreateHeadlessSurfaceEXT = ::std::option::Option<
    unsafe extern "C" fn(
        instance: VkInstance,
        pCreateInfo: *const VkHeadlessSurfaceCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pSurface: *mut VkSurfaceKHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkCreateHeadlessSurfaceEXT(
        instance: VkInstance,
        pCreateInfo: *const VkHeadlessSurfaceCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pSurface: *mut VkSurfaceKHR,
    ) -> VkResult;
}
pub const VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT: VkLineRasterizationModeEXT = 0;
pub const VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT: VkLineRasterizationModeEXT = 1;
pub const VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT: VkLineRasterizationModeEXT = 2;
pub const VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT: VkLineRasterizationModeEXT = 3;
pub const VK_LINE_RASTERIZATION_MODE_MAX_ENUM_EXT: VkLineRasterizationModeEXT = 2147483647;
pub type VkLineRasterizationModeEXT = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceLineRasterizationFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub rectangularLines: VkBool32,
    pub bresenhamLines: VkBool32,
    pub smoothLines: VkBool32,
    pub stippledRectangularLines: VkBool32,
    pub stippledBresenhamLines: VkBool32,
    pub stippledSmoothLines: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceLineRasterizationFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceLineRasterizationFeaturesEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceLineRasterizationFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceLineRasterizationFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceLineRasterizationFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_rectangularLines() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceLineRasterizationFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rectangularLines) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT),
                "::",
                stringify!(rectangularLines)
            )
        );
    }
    test_field_rectangularLines();
    fn test_field_bresenhamLines() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceLineRasterizationFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bresenhamLines) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT),
                "::",
                stringify!(bresenhamLines)
            )
        );
    }
    test_field_bresenhamLines();
    fn test_field_smoothLines() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceLineRasterizationFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).smoothLines) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT),
                "::",
                stringify!(smoothLines)
            )
        );
    }
    test_field_smoothLines();
    fn test_field_stippledRectangularLines() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceLineRasterizationFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stippledRectangularLines) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT),
                "::",
                stringify!(stippledRectangularLines)
            )
        );
    }
    test_field_stippledRectangularLines();
    fn test_field_stippledBresenhamLines() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceLineRasterizationFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stippledBresenhamLines) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT),
                "::",
                stringify!(stippledBresenhamLines)
            )
        );
    }
    test_field_stippledBresenhamLines();
    fn test_field_stippledSmoothLines() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceLineRasterizationFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stippledSmoothLines) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLineRasterizationFeaturesEXT),
                "::",
                stringify!(stippledSmoothLines)
            )
        );
    }
    test_field_stippledSmoothLines();
}
impl Default for VkPhysicalDeviceLineRasterizationFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceLineRasterizationPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub lineSubPixelPrecisionBits: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceLineRasterizationPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceLineRasterizationPropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceLineRasterizationPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceLineRasterizationPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceLineRasterizationPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceLineRasterizationPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLineRasterizationPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceLineRasterizationPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLineRasterizationPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_lineSubPixelPrecisionBits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceLineRasterizationPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lineSubPixelPrecisionBits) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLineRasterizationPropertiesEXT),
                "::",
                stringify!(lineSubPixelPrecisionBits)
            )
        );
    }
    test_field_lineSubPixelPrecisionBits();
}
impl Default for VkPhysicalDeviceLineRasterizationPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineRasterizationLineStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub lineRasterizationMode: VkLineRasterizationModeEXT,
    pub stippledLineEnable: VkBool32,
    pub lineStippleFactor: u32,
    pub lineStipplePattern: u16,
}
#[test]
fn bindgen_test_layout_VkPipelineRasterizationLineStateCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineRasterizationLineStateCreateInfoEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineRasterizationLineStateCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineRasterizationLineStateCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineRasterizationLineStateCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineRasterizationLineStateCreateInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationLineStateCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineRasterizationLineStateCreateInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationLineStateCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_lineRasterizationMode() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineRasterizationLineStateCreateInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lineRasterizationMode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationLineStateCreateInfoEXT),
                "::",
                stringify!(lineRasterizationMode)
            )
        );
    }
    test_field_lineRasterizationMode();
    fn test_field_stippledLineEnable() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineRasterizationLineStateCreateInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stippledLineEnable) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationLineStateCreateInfoEXT),
                "::",
                stringify!(stippledLineEnable)
            )
        );
    }
    test_field_stippledLineEnable();
    fn test_field_lineStippleFactor() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineRasterizationLineStateCreateInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lineStippleFactor) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationLineStateCreateInfoEXT),
                "::",
                stringify!(lineStippleFactor)
            )
        );
    }
    test_field_lineStippleFactor();
    fn test_field_lineStipplePattern() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPipelineRasterizationLineStateCreateInfoEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lineStipplePattern) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineRasterizationLineStateCreateInfoEXT),
                "::",
                stringify!(lineStipplePattern)
            )
        );
    }
    test_field_lineStipplePattern();
}
impl Default for VkPipelineRasterizationLineStateCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdSetLineStippleEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        lineStippleFactor: u32,
        lineStipplePattern: u16,
    ),
>;
extern "C" {
    pub fn vkCmdSetLineStippleEXT(
        commandBuffer: VkCommandBuffer,
        lineStippleFactor: u32,
        lineStipplePattern: u16,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderAtomicFloatFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderBufferFloat32Atomics: VkBool32,
    pub shaderBufferFloat32AtomicAdd: VkBool32,
    pub shaderBufferFloat64Atomics: VkBool32,
    pub shaderBufferFloat64AtomicAdd: VkBool32,
    pub shaderSharedFloat32Atomics: VkBool32,
    pub shaderSharedFloat32AtomicAdd: VkBool32,
    pub shaderSharedFloat64Atomics: VkBool32,
    pub shaderSharedFloat64AtomicAdd: VkBool32,
    pub shaderImageFloat32Atomics: VkBool32,
    pub shaderImageFloat32AtomicAdd: VkBool32,
    pub sparseImageFloat32Atomics: VkBool32,
    pub sparseImageFloat32AtomicAdd: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderBufferFloat32Atomics() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderBufferFloat32Atomics) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT),
                "::",
                stringify!(shaderBufferFloat32Atomics)
            )
        );
    }
    test_field_shaderBufferFloat32Atomics();
    fn test_field_shaderBufferFloat32AtomicAdd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderBufferFloat32AtomicAdd) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT),
                "::",
                stringify!(shaderBufferFloat32AtomicAdd)
            )
        );
    }
    test_field_shaderBufferFloat32AtomicAdd();
    fn test_field_shaderBufferFloat64Atomics() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderBufferFloat64Atomics) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT),
                "::",
                stringify!(shaderBufferFloat64Atomics)
            )
        );
    }
    test_field_shaderBufferFloat64Atomics();
    fn test_field_shaderBufferFloat64AtomicAdd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderBufferFloat64AtomicAdd) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT),
                "::",
                stringify!(shaderBufferFloat64AtomicAdd)
            )
        );
    }
    test_field_shaderBufferFloat64AtomicAdd();
    fn test_field_shaderSharedFloat32Atomics() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSharedFloat32Atomics) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT),
                "::",
                stringify!(shaderSharedFloat32Atomics)
            )
        );
    }
    test_field_shaderSharedFloat32Atomics();
    fn test_field_shaderSharedFloat32AtomicAdd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSharedFloat32AtomicAdd) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT),
                "::",
                stringify!(shaderSharedFloat32AtomicAdd)
            )
        );
    }
    test_field_shaderSharedFloat32AtomicAdd();
    fn test_field_shaderSharedFloat64Atomics() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSharedFloat64Atomics) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT),
                "::",
                stringify!(shaderSharedFloat64Atomics)
            )
        );
    }
    test_field_shaderSharedFloat64Atomics();
    fn test_field_shaderSharedFloat64AtomicAdd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSharedFloat64AtomicAdd) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT),
                "::",
                stringify!(shaderSharedFloat64AtomicAdd)
            )
        );
    }
    test_field_shaderSharedFloat64AtomicAdd();
    fn test_field_shaderImageFloat32Atomics() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderImageFloat32Atomics) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT),
                "::",
                stringify!(shaderImageFloat32Atomics)
            )
        );
    }
    test_field_shaderImageFloat32Atomics();
    fn test_field_shaderImageFloat32AtomicAdd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderImageFloat32AtomicAdd) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT),
                "::",
                stringify!(shaderImageFloat32AtomicAdd)
            )
        );
    }
    test_field_shaderImageFloat32AtomicAdd();
    fn test_field_sparseImageFloat32Atomics() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseImageFloat32Atomics) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT),
                "::",
                stringify!(sparseImageFloat32Atomics)
            )
        );
    }
    test_field_sparseImageFloat32Atomics();
    fn test_field_sparseImageFloat32AtomicAdd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseImageFloat32AtomicAdd) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT),
                "::",
                stringify!(sparseImageFloat32AtomicAdd)
            )
        );
    }
    test_field_sparseImageFloat32AtomicAdd();
}
impl Default for VkPhysicalDeviceShaderAtomicFloatFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPhysicalDeviceHostQueryResetFeaturesEXT = VkPhysicalDeviceHostQueryResetFeatures;
pub type PFN_vkResetQueryPoolEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
    ),
>;
extern "C" {
    pub fn vkResetQueryPoolEXT(
        device: VkDevice,
        queryPool: VkQueryPool,
        firstQuery: u32,
        queryCount: u32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceIndexTypeUint8FeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub indexTypeUint8: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceIndexTypeUint8FeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceIndexTypeUint8FeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceIndexTypeUint8FeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceIndexTypeUint8FeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceIndexTypeUint8FeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceIndexTypeUint8FeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceIndexTypeUint8FeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceIndexTypeUint8FeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceIndexTypeUint8FeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_indexTypeUint8() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceIndexTypeUint8FeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indexTypeUint8) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceIndexTypeUint8FeaturesEXT),
                "::",
                stringify!(indexTypeUint8)
            )
        );
    }
    test_field_indexTypeUint8();
}
impl Default for VkPhysicalDeviceIndexTypeUint8FeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExtendedDynamicStateFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub extendedDynamicState: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicStateFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicStateFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_extendedDynamicState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicStateFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT),
                "::",
                stringify!(extendedDynamicState)
            )
        );
    }
    test_field_extendedDynamicState();
}
impl Default for VkPhysicalDeviceExtendedDynamicStateFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdSetCullModeEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags),
>;
pub type PFN_vkCmdSetFrontFaceEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, frontFace: VkFrontFace),
>;
pub type PFN_vkCmdSetPrimitiveTopologyEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, primitiveTopology: VkPrimitiveTopology),
>;
pub type PFN_vkCmdSetViewportWithCountEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        viewportCount: u32,
        pViewports: *const VkViewport,
    ),
>;
pub type PFN_vkCmdSetScissorWithCountEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        scissorCount: u32,
        pScissors: *const VkRect2D,
    ),
>;
pub type PFN_vkCmdBindVertexBuffers2EXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstBinding: u32,
        bindingCount: u32,
        pBuffers: *const VkBuffer,
        pOffsets: *const VkDeviceSize,
        pSizes: *const VkDeviceSize,
        pStrides: *const VkDeviceSize,
    ),
>;
pub type PFN_vkCmdSetDepthTestEnableEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32),
>;
pub type PFN_vkCmdSetDepthWriteEnableEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32),
>;
pub type PFN_vkCmdSetDepthCompareOpEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp),
>;
pub type PFN_vkCmdSetDepthBoundsTestEnableEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, depthBoundsTestEnable: VkBool32),
>;
pub type PFN_vkCmdSetStencilTestEnableEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, stencilTestEnable: VkBool32),
>;
pub type PFN_vkCmdSetStencilOpEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        failOp: VkStencilOp,
        passOp: VkStencilOp,
        depthFailOp: VkStencilOp,
        compareOp: VkCompareOp,
    ),
>;
extern "C" {
    pub fn vkCmdSetCullModeEXT(commandBuffer: VkCommandBuffer, cullMode: VkCullModeFlags);
}
extern "C" {
    pub fn vkCmdSetFrontFaceEXT(commandBuffer: VkCommandBuffer, frontFace: VkFrontFace);
}
extern "C" {
    pub fn vkCmdSetPrimitiveTopologyEXT(
        commandBuffer: VkCommandBuffer,
        primitiveTopology: VkPrimitiveTopology,
    );
}
extern "C" {
    pub fn vkCmdSetViewportWithCountEXT(
        commandBuffer: VkCommandBuffer,
        viewportCount: u32,
        pViewports: *const VkViewport,
    );
}
extern "C" {
    pub fn vkCmdSetScissorWithCountEXT(
        commandBuffer: VkCommandBuffer,
        scissorCount: u32,
        pScissors: *const VkRect2D,
    );
}
extern "C" {
    pub fn vkCmdBindVertexBuffers2EXT(
        commandBuffer: VkCommandBuffer,
        firstBinding: u32,
        bindingCount: u32,
        pBuffers: *const VkBuffer,
        pOffsets: *const VkDeviceSize,
        pSizes: *const VkDeviceSize,
        pStrides: *const VkDeviceSize,
    );
}
extern "C" {
    pub fn vkCmdSetDepthTestEnableEXT(commandBuffer: VkCommandBuffer, depthTestEnable: VkBool32);
}
extern "C" {
    pub fn vkCmdSetDepthWriteEnableEXT(commandBuffer: VkCommandBuffer, depthWriteEnable: VkBool32);
}
extern "C" {
    pub fn vkCmdSetDepthCompareOpEXT(commandBuffer: VkCommandBuffer, depthCompareOp: VkCompareOp);
}
extern "C" {
    pub fn vkCmdSetDepthBoundsTestEnableEXT(
        commandBuffer: VkCommandBuffer,
        depthBoundsTestEnable: VkBool32,
    );
}
extern "C" {
    pub fn vkCmdSetStencilTestEnableEXT(
        commandBuffer: VkCommandBuffer,
        stencilTestEnable: VkBool32,
    );
}
extern "C" {
    pub fn vkCmdSetStencilOpEXT(
        commandBuffer: VkCommandBuffer,
        faceMask: VkStencilFaceFlags,
        failOp: VkStencilOp,
        passOp: VkStencilOp,
        depthFailOp: VkStencilOp,
        compareOp: VkCompareOp,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderBufferFloat16Atomics: VkBool32,
    pub shaderBufferFloat16AtomicAdd: VkBool32,
    pub shaderBufferFloat16AtomicMinMax: VkBool32,
    pub shaderBufferFloat32AtomicMinMax: VkBool32,
    pub shaderBufferFloat64AtomicMinMax: VkBool32,
    pub shaderSharedFloat16Atomics: VkBool32,
    pub shaderSharedFloat16AtomicAdd: VkBool32,
    pub shaderSharedFloat16AtomicMinMax: VkBool32,
    pub shaderSharedFloat32AtomicMinMax: VkBool32,
    pub shaderSharedFloat64AtomicMinMax: VkBool32,
    pub shaderImageFloat32AtomicMinMax: VkBool32,
    pub sparseImageFloat32AtomicMinMax: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderBufferFloat16Atomics() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderBufferFloat16Atomics) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT),
                "::",
                stringify!(shaderBufferFloat16Atomics)
            )
        );
    }
    test_field_shaderBufferFloat16Atomics();
    fn test_field_shaderBufferFloat16AtomicAdd() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderBufferFloat16AtomicAdd) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT),
                "::",
                stringify!(shaderBufferFloat16AtomicAdd)
            )
        );
    }
    test_field_shaderBufferFloat16AtomicAdd();
    fn test_field_shaderBufferFloat16AtomicMinMax() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderBufferFloat16AtomicMinMax) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT),
                "::",
                stringify!(shaderBufferFloat16AtomicMinMax)
            )
        );
    }
    test_field_shaderBufferFloat16AtomicMinMax();
    fn test_field_shaderBufferFloat32AtomicMinMax() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderBufferFloat32AtomicMinMax) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT),
                "::",
                stringify!(shaderBufferFloat32AtomicMinMax)
            )
        );
    }
    test_field_shaderBufferFloat32AtomicMinMax();
    fn test_field_shaderBufferFloat64AtomicMinMax() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderBufferFloat64AtomicMinMax) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT),
                "::",
                stringify!(shaderBufferFloat64AtomicMinMax)
            )
        );
    }
    test_field_shaderBufferFloat64AtomicMinMax();
    fn test_field_shaderSharedFloat16Atomics() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSharedFloat16Atomics) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT),
                "::",
                stringify!(shaderSharedFloat16Atomics)
            )
        );
    }
    test_field_shaderSharedFloat16Atomics();
    fn test_field_shaderSharedFloat16AtomicAdd() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSharedFloat16AtomicAdd) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT),
                "::",
                stringify!(shaderSharedFloat16AtomicAdd)
            )
        );
    }
    test_field_shaderSharedFloat16AtomicAdd();
    fn test_field_shaderSharedFloat16AtomicMinMax() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSharedFloat16AtomicMinMax) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT),
                "::",
                stringify!(shaderSharedFloat16AtomicMinMax)
            )
        );
    }
    test_field_shaderSharedFloat16AtomicMinMax();
    fn test_field_shaderSharedFloat32AtomicMinMax() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSharedFloat32AtomicMinMax) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT),
                "::",
                stringify!(shaderSharedFloat32AtomicMinMax)
            )
        );
    }
    test_field_shaderSharedFloat32AtomicMinMax();
    fn test_field_shaderSharedFloat64AtomicMinMax() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderSharedFloat64AtomicMinMax) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT),
                "::",
                stringify!(shaderSharedFloat64AtomicMinMax)
            )
        );
    }
    test_field_shaderSharedFloat64AtomicMinMax();
    fn test_field_shaderImageFloat32AtomicMinMax() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderImageFloat32AtomicMinMax) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT),
                "::",
                stringify!(shaderImageFloat32AtomicMinMax)
            )
        );
    }
    test_field_shaderImageFloat32AtomicMinMax();
    fn test_field_sparseImageFloat32AtomicMinMax() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sparseImageFloat32AtomicMinMax) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT),
                "::",
                stringify!(sparseImageFloat32AtomicMinMax)
            )
        );
    }
    test_field_sparseImageFloat32AtomicMinMax();
}
impl Default for VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT =
    VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkIndirectCommandsLayoutNV_T {
    _unused: [u8; 0],
}
pub type VkIndirectCommandsLayoutNV = *mut VkIndirectCommandsLayoutNV_T;
pub const VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV: VkIndirectCommandsTokenTypeNV = 0;
pub const VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV: VkIndirectCommandsTokenTypeNV = 1;
pub const VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV: VkIndirectCommandsTokenTypeNV = 2;
pub const VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV: VkIndirectCommandsTokenTypeNV = 3;
pub const VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV: VkIndirectCommandsTokenTypeNV = 4;
pub const VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV: VkIndirectCommandsTokenTypeNV = 5;
pub const VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV: VkIndirectCommandsTokenTypeNV = 6;
pub const VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV: VkIndirectCommandsTokenTypeNV = 7;
pub const VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV: VkIndirectCommandsTokenTypeNV =
    1000328000;
pub const VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NV: VkIndirectCommandsTokenTypeNV = 2147483647;
pub type VkIndirectCommandsTokenTypeNV = ::std::os::raw::c_int;
pub const VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV: VkIndirectStateFlagBitsNV = 1;
pub const VK_INDIRECT_STATE_FLAG_BITS_MAX_ENUM_NV: VkIndirectStateFlagBitsNV = 2147483647;
pub type VkIndirectStateFlagBitsNV = ::std::os::raw::c_int;
pub type VkIndirectStateFlagsNV = VkFlags;
pub const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV:
    VkIndirectCommandsLayoutUsageFlagBitsNV = 1;
pub const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV:
    VkIndirectCommandsLayoutUsageFlagBitsNV = 2;
pub const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV:
    VkIndirectCommandsLayoutUsageFlagBitsNV = 4;
pub const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NV:
    VkIndirectCommandsLayoutUsageFlagBitsNV = 2147483647;
pub type VkIndirectCommandsLayoutUsageFlagBitsNV = ::std::os::raw::c_int;
pub type VkIndirectCommandsLayoutUsageFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxGraphicsShaderGroupCount: u32,
    pub maxIndirectSequenceCount: u32,
    pub maxIndirectCommandsTokenCount: u32,
    pub maxIndirectCommandsStreamCount: u32,
    pub maxIndirectCommandsTokenOffset: u32,
    pub maxIndirectCommandsStreamStride: u32,
    pub minSequencesCountBufferOffsetAlignment: u32,
    pub minSequencesIndexBufferOffsetAlignment: u32,
    pub minIndirectCommandsBufferOffsetAlignment: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxGraphicsShaderGroupCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxGraphicsShaderGroupCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV),
                "::",
                stringify!(maxGraphicsShaderGroupCount)
            )
        );
    }
    test_field_maxGraphicsShaderGroupCount();
    fn test_field_maxIndirectSequenceCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxIndirectSequenceCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV),
                "::",
                stringify!(maxIndirectSequenceCount)
            )
        );
    }
    test_field_maxIndirectSequenceCount();
    fn test_field_maxIndirectCommandsTokenCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxIndirectCommandsTokenCount) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV),
                "::",
                stringify!(maxIndirectCommandsTokenCount)
            )
        );
    }
    test_field_maxIndirectCommandsTokenCount();
    fn test_field_maxIndirectCommandsStreamCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxIndirectCommandsStreamCount) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV),
                "::",
                stringify!(maxIndirectCommandsStreamCount)
            )
        );
    }
    test_field_maxIndirectCommandsStreamCount();
    fn test_field_maxIndirectCommandsTokenOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxIndirectCommandsTokenOffset) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV),
                "::",
                stringify!(maxIndirectCommandsTokenOffset)
            )
        );
    }
    test_field_maxIndirectCommandsTokenOffset();
    fn test_field_maxIndirectCommandsStreamStride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxIndirectCommandsStreamStride) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV),
                "::",
                stringify!(maxIndirectCommandsStreamStride)
            )
        );
    }
    test_field_maxIndirectCommandsStreamStride();
    fn test_field_minSequencesCountBufferOffsetAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minSequencesCountBufferOffsetAlignment) as usize
                    - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV),
                "::",
                stringify!(minSequencesCountBufferOffsetAlignment)
            )
        );
    }
    test_field_minSequencesCountBufferOffsetAlignment();
    fn test_field_minSequencesIndexBufferOffsetAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minSequencesIndexBufferOffsetAlignment) as usize
                    - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV),
                "::",
                stringify!(minSequencesIndexBufferOffsetAlignment)
            )
        );
    }
    test_field_minSequencesIndexBufferOffsetAlignment();
    fn test_field_minIndirectCommandsBufferOffsetAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minIndirectCommandsBufferOffsetAlignment) as usize
                    - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV),
                "::",
                stringify!(minIndirectCommandsBufferOffsetAlignment)
            )
        );
    }
    test_field_minIndirectCommandsBufferOffsetAlignment();
}
impl Default for VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub deviceGeneratedCommands: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_deviceGeneratedCommands() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceGeneratedCommands) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV),
                "::",
                stringify!(deviceGeneratedCommands)
            )
        );
    }
    test_field_deviceGeneratedCommands();
}
impl Default for VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkGraphicsShaderGroupCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub stageCount: u32,
    pub pStages: *const VkPipelineShaderStageCreateInfo,
    pub pVertexInputState: *const VkPipelineVertexInputStateCreateInfo,
    pub pTessellationState: *const VkPipelineTessellationStateCreateInfo,
}
#[test]
fn bindgen_test_layout_VkGraphicsShaderGroupCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkGraphicsShaderGroupCreateInfoNV>(),
        48usize,
        concat!("Size of: ", stringify!(VkGraphicsShaderGroupCreateInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkGraphicsShaderGroupCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkGraphicsShaderGroupCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsShaderGroupCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsShaderGroupCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsShaderGroupCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsShaderGroupCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_stageCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsShaderGroupCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stageCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsShaderGroupCreateInfoNV),
                "::",
                stringify!(stageCount)
            )
        );
    }
    test_field_stageCount();
    fn test_field_pStages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsShaderGroupCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pStages) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsShaderGroupCreateInfoNV),
                "::",
                stringify!(pStages)
            )
        );
    }
    test_field_pStages();
    fn test_field_pVertexInputState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsShaderGroupCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pVertexInputState) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsShaderGroupCreateInfoNV),
                "::",
                stringify!(pVertexInputState)
            )
        );
    }
    test_field_pVertexInputState();
    fn test_field_pTessellationState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGraphicsShaderGroupCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pTessellationState) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsShaderGroupCreateInfoNV),
                "::",
                stringify!(pTessellationState)
            )
        );
    }
    test_field_pTessellationState();
}
impl Default for VkGraphicsShaderGroupCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkGraphicsPipelineShaderGroupsCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub groupCount: u32,
    pub pGroups: *const VkGraphicsShaderGroupCreateInfoNV,
    pub pipelineCount: u32,
    pub pPipelines: *const VkPipeline,
}
#[test]
fn bindgen_test_layout_VkGraphicsPipelineShaderGroupsCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkGraphicsPipelineShaderGroupsCreateInfoNV>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkGraphicsPipelineShaderGroupsCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkGraphicsPipelineShaderGroupsCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkGraphicsPipelineShaderGroupsCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkGraphicsPipelineShaderGroupsCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineShaderGroupsCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkGraphicsPipelineShaderGroupsCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineShaderGroupsCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_groupCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkGraphicsPipelineShaderGroupsCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).groupCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineShaderGroupsCreateInfoNV),
                "::",
                stringify!(groupCount)
            )
        );
    }
    test_field_groupCount();
    fn test_field_pGroups() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkGraphicsPipelineShaderGroupsCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pGroups) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineShaderGroupsCreateInfoNV),
                "::",
                stringify!(pGroups)
            )
        );
    }
    test_field_pGroups();
    fn test_field_pipelineCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkGraphicsPipelineShaderGroupsCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineShaderGroupsCreateInfoNV),
                "::",
                stringify!(pipelineCount)
            )
        );
    }
    test_field_pipelineCount();
    fn test_field_pPipelines() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkGraphicsPipelineShaderGroupsCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pPipelines) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineShaderGroupsCreateInfoNV),
                "::",
                stringify!(pPipelines)
            )
        );
    }
    test_field_pPipelines();
}
impl Default for VkGraphicsPipelineShaderGroupsCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkBindShaderGroupIndirectCommandNV {
    pub groupIndex: u32,
}
#[test]
fn bindgen_test_layout_VkBindShaderGroupIndirectCommandNV() {
    assert_eq!(
        ::std::mem::size_of::<VkBindShaderGroupIndirectCommandNV>(),
        4usize,
        concat!("Size of: ", stringify!(VkBindShaderGroupIndirectCommandNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindShaderGroupIndirectCommandNV>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkBindShaderGroupIndirectCommandNV)
        )
    );
    fn test_field_groupIndex() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBindShaderGroupIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).groupIndex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindShaderGroupIndirectCommandNV),
                "::",
                stringify!(groupIndex)
            )
        );
    }
    test_field_groupIndex();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBindIndexBufferIndirectCommandNV {
    pub bufferAddress: VkDeviceAddress,
    pub size: u32,
    pub indexType: VkIndexType,
}
#[test]
fn bindgen_test_layout_VkBindIndexBufferIndirectCommandNV() {
    assert_eq!(
        ::std::mem::size_of::<VkBindIndexBufferIndirectCommandNV>(),
        16usize,
        concat!("Size of: ", stringify!(VkBindIndexBufferIndirectCommandNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindIndexBufferIndirectCommandNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkBindIndexBufferIndirectCommandNV)
        )
    );
    fn test_field_bufferAddress() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBindIndexBufferIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferAddress) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindIndexBufferIndirectCommandNV),
                "::",
                stringify!(bufferAddress)
            )
        );
    }
    test_field_bufferAddress();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBindIndexBufferIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindIndexBufferIndirectCommandNV),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_indexType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBindIndexBufferIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indexType) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindIndexBufferIndirectCommandNV),
                "::",
                stringify!(indexType)
            )
        );
    }
    test_field_indexType();
}
impl Default for VkBindIndexBufferIndirectCommandNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkBindVertexBufferIndirectCommandNV {
    pub bufferAddress: VkDeviceAddress,
    pub size: u32,
    pub stride: u32,
}
#[test]
fn bindgen_test_layout_VkBindVertexBufferIndirectCommandNV() {
    assert_eq!(
        ::std::mem::size_of::<VkBindVertexBufferIndirectCommandNV>(),
        16usize,
        concat!("Size of: ", stringify!(VkBindVertexBufferIndirectCommandNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkBindVertexBufferIndirectCommandNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkBindVertexBufferIndirectCommandNV)
        )
    );
    fn test_field_bufferAddress() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBindVertexBufferIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferAddress) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindVertexBufferIndirectCommandNV),
                "::",
                stringify!(bufferAddress)
            )
        );
    }
    test_field_bufferAddress();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBindVertexBufferIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindVertexBufferIndirectCommandNV),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_stride() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBindVertexBufferIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBindVertexBufferIndirectCommandNV),
                "::",
                stringify!(stride)
            )
        );
    }
    test_field_stride();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkSetStateFlagsIndirectCommandNV {
    pub data: u32,
}
#[test]
fn bindgen_test_layout_VkSetStateFlagsIndirectCommandNV() {
    assert_eq!(
        ::std::mem::size_of::<VkSetStateFlagsIndirectCommandNV>(),
        4usize,
        concat!("Size of: ", stringify!(VkSetStateFlagsIndirectCommandNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSetStateFlagsIndirectCommandNV>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkSetStateFlagsIndirectCommandNV)
        )
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSetStateFlagsIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSetStateFlagsIndirectCommandNV),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkIndirectCommandsStreamNV {
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkIndirectCommandsStreamNV() {
    assert_eq!(
        ::std::mem::size_of::<VkIndirectCommandsStreamNV>(),
        16usize,
        concat!("Size of: ", stringify!(VkIndirectCommandsStreamNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkIndirectCommandsStreamNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkIndirectCommandsStreamNV))
    );
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsStreamNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsStreamNV),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsStreamNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsStreamNV),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
}
impl Default for VkIndirectCommandsStreamNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkIndirectCommandsLayoutTokenNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub tokenType: VkIndirectCommandsTokenTypeNV,
    pub stream: u32,
    pub offset: u32,
    pub vertexBindingUnit: u32,
    pub vertexDynamicStride: VkBool32,
    pub pushconstantPipelineLayout: VkPipelineLayout,
    pub pushconstantShaderStageFlags: VkShaderStageFlags,
    pub pushconstantOffset: u32,
    pub pushconstantSize: u32,
    pub indirectStateFlags: VkIndirectStateFlagsNV,
    pub indexTypeCount: u32,
    pub pIndexTypes: *const VkIndexType,
    pub pIndexTypeValues: *const u32,
}
#[test]
fn bindgen_test_layout_VkIndirectCommandsLayoutTokenNV() {
    assert_eq!(
        ::std::mem::size_of::<VkIndirectCommandsLayoutTokenNV>(),
        88usize,
        concat!("Size of: ", stringify!(VkIndirectCommandsLayoutTokenNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkIndirectCommandsLayoutTokenNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkIndirectCommandsLayoutTokenNV))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutTokenNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutTokenNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutTokenNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutTokenNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_tokenType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutTokenNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tokenType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutTokenNV),
                "::",
                stringify!(tokenType)
            )
        );
    }
    test_field_tokenType();
    fn test_field_stream() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutTokenNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stream) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutTokenNV),
                "::",
                stringify!(stream)
            )
        );
    }
    test_field_stream();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutTokenNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutTokenNV),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_vertexBindingUnit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutTokenNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexBindingUnit) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutTokenNV),
                "::",
                stringify!(vertexBindingUnit)
            )
        );
    }
    test_field_vertexBindingUnit();
    fn test_field_vertexDynamicStride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutTokenNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexDynamicStride) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutTokenNV),
                "::",
                stringify!(vertexDynamicStride)
            )
        );
    }
    test_field_vertexDynamicStride();
    fn test_field_pushconstantPipelineLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutTokenNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pushconstantPipelineLayout) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutTokenNV),
                "::",
                stringify!(pushconstantPipelineLayout)
            )
        );
    }
    test_field_pushconstantPipelineLayout();
    fn test_field_pushconstantShaderStageFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutTokenNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pushconstantShaderStageFlags) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutTokenNV),
                "::",
                stringify!(pushconstantShaderStageFlags)
            )
        );
    }
    test_field_pushconstantShaderStageFlags();
    fn test_field_pushconstantOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutTokenNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pushconstantOffset) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutTokenNV),
                "::",
                stringify!(pushconstantOffset)
            )
        );
    }
    test_field_pushconstantOffset();
    fn test_field_pushconstantSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutTokenNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pushconstantSize) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutTokenNV),
                "::",
                stringify!(pushconstantSize)
            )
        );
    }
    test_field_pushconstantSize();
    fn test_field_indirectStateFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutTokenNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indirectStateFlags) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutTokenNV),
                "::",
                stringify!(indirectStateFlags)
            )
        );
    }
    test_field_indirectStateFlags();
    fn test_field_indexTypeCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutTokenNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indexTypeCount) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutTokenNV),
                "::",
                stringify!(indexTypeCount)
            )
        );
    }
    test_field_indexTypeCount();
    fn test_field_pIndexTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutTokenNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pIndexTypes) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutTokenNV),
                "::",
                stringify!(pIndexTypes)
            )
        );
    }
    test_field_pIndexTypes();
    fn test_field_pIndexTypeValues() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutTokenNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pIndexTypeValues) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutTokenNV),
                "::",
                stringify!(pIndexTypeValues)
            )
        );
    }
    test_field_pIndexTypeValues();
}
impl Default for VkIndirectCommandsLayoutTokenNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkIndirectCommandsLayoutCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkIndirectCommandsLayoutUsageFlagsNV,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub tokenCount: u32,
    pub pTokens: *const VkIndirectCommandsLayoutTokenNV,
    pub streamCount: u32,
    pub pStreamStrides: *const u32,
}
#[test]
fn bindgen_test_layout_VkIndirectCommandsLayoutCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkIndirectCommandsLayoutCreateInfoNV>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(VkIndirectCommandsLayoutCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkIndirectCommandsLayoutCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkIndirectCommandsLayoutCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutCreateInfoNV),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_pipelineBindPoint() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineBindPoint) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutCreateInfoNV),
                "::",
                stringify!(pipelineBindPoint)
            )
        );
    }
    test_field_pipelineBindPoint();
    fn test_field_tokenCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tokenCount) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutCreateInfoNV),
                "::",
                stringify!(tokenCount)
            )
        );
    }
    test_field_tokenCount();
    fn test_field_pTokens() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pTokens) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutCreateInfoNV),
                "::",
                stringify!(pTokens)
            )
        );
    }
    test_field_pTokens();
    fn test_field_streamCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).streamCount) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutCreateInfoNV),
                "::",
                stringify!(streamCount)
            )
        );
    }
    test_field_streamCount();
    fn test_field_pStreamStrides() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkIndirectCommandsLayoutCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pStreamStrides) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkIndirectCommandsLayoutCreateInfoNV),
                "::",
                stringify!(pStreamStrides)
            )
        );
    }
    test_field_pStreamStrides();
}
impl Default for VkIndirectCommandsLayoutCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkGeneratedCommandsInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub pipeline: VkPipeline,
    pub indirectCommandsLayout: VkIndirectCommandsLayoutNV,
    pub streamCount: u32,
    pub pStreams: *const VkIndirectCommandsStreamNV,
    pub sequencesCount: u32,
    pub preprocessBuffer: VkBuffer,
    pub preprocessOffset: VkDeviceSize,
    pub preprocessSize: VkDeviceSize,
    pub sequencesCountBuffer: VkBuffer,
    pub sequencesCountOffset: VkDeviceSize,
    pub sequencesIndexBuffer: VkBuffer,
    pub sequencesIndexOffset: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkGeneratedCommandsInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkGeneratedCommandsInfoNV>(),
        120usize,
        concat!("Size of: ", stringify!(VkGeneratedCommandsInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkGeneratedCommandsInfoNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkGeneratedCommandsInfoNV))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeneratedCommandsInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeneratedCommandsInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pipelineBindPoint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeneratedCommandsInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineBindPoint) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsInfoNV),
                "::",
                stringify!(pipelineBindPoint)
            )
        );
    }
    test_field_pipelineBindPoint();
    fn test_field_pipeline() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeneratedCommandsInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipeline) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsInfoNV),
                "::",
                stringify!(pipeline)
            )
        );
    }
    test_field_pipeline();
    fn test_field_indirectCommandsLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeneratedCommandsInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indirectCommandsLayout) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsInfoNV),
                "::",
                stringify!(indirectCommandsLayout)
            )
        );
    }
    test_field_indirectCommandsLayout();
    fn test_field_streamCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeneratedCommandsInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).streamCount) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsInfoNV),
                "::",
                stringify!(streamCount)
            )
        );
    }
    test_field_streamCount();
    fn test_field_pStreams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeneratedCommandsInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pStreams) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsInfoNV),
                "::",
                stringify!(pStreams)
            )
        );
    }
    test_field_pStreams();
    fn test_field_sequencesCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeneratedCommandsInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sequencesCount) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsInfoNV),
                "::",
                stringify!(sequencesCount)
            )
        );
    }
    test_field_sequencesCount();
    fn test_field_preprocessBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeneratedCommandsInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).preprocessBuffer) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsInfoNV),
                "::",
                stringify!(preprocessBuffer)
            )
        );
    }
    test_field_preprocessBuffer();
    fn test_field_preprocessOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeneratedCommandsInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).preprocessOffset) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsInfoNV),
                "::",
                stringify!(preprocessOffset)
            )
        );
    }
    test_field_preprocessOffset();
    fn test_field_preprocessSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeneratedCommandsInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).preprocessSize) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsInfoNV),
                "::",
                stringify!(preprocessSize)
            )
        );
    }
    test_field_preprocessSize();
    fn test_field_sequencesCountBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeneratedCommandsInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sequencesCountBuffer) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsInfoNV),
                "::",
                stringify!(sequencesCountBuffer)
            )
        );
    }
    test_field_sequencesCountBuffer();
    fn test_field_sequencesCountOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeneratedCommandsInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sequencesCountOffset) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsInfoNV),
                "::",
                stringify!(sequencesCountOffset)
            )
        );
    }
    test_field_sequencesCountOffset();
    fn test_field_sequencesIndexBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeneratedCommandsInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sequencesIndexBuffer) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsInfoNV),
                "::",
                stringify!(sequencesIndexBuffer)
            )
        );
    }
    test_field_sequencesIndexBuffer();
    fn test_field_sequencesIndexOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkGeneratedCommandsInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sequencesIndexOffset) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsInfoNV),
                "::",
                stringify!(sequencesIndexOffset)
            )
        );
    }
    test_field_sequencesIndexOffset();
}
impl Default for VkGeneratedCommandsInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkGeneratedCommandsMemoryRequirementsInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub pipeline: VkPipeline,
    pub indirectCommandsLayout: VkIndirectCommandsLayoutNV,
    pub maxSequencesCount: u32,
}
#[test]
fn bindgen_test_layout_VkGeneratedCommandsMemoryRequirementsInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkGeneratedCommandsMemoryRequirementsInfoNV>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkGeneratedCommandsMemoryRequirementsInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkGeneratedCommandsMemoryRequirementsInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkGeneratedCommandsMemoryRequirementsInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkGeneratedCommandsMemoryRequirementsInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsMemoryRequirementsInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkGeneratedCommandsMemoryRequirementsInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsMemoryRequirementsInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pipelineBindPoint() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkGeneratedCommandsMemoryRequirementsInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineBindPoint) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsMemoryRequirementsInfoNV),
                "::",
                stringify!(pipelineBindPoint)
            )
        );
    }
    test_field_pipelineBindPoint();
    fn test_field_pipeline() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkGeneratedCommandsMemoryRequirementsInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipeline) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsMemoryRequirementsInfoNV),
                "::",
                stringify!(pipeline)
            )
        );
    }
    test_field_pipeline();
    fn test_field_indirectCommandsLayout() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkGeneratedCommandsMemoryRequirementsInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indirectCommandsLayout) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsMemoryRequirementsInfoNV),
                "::",
                stringify!(indirectCommandsLayout)
            )
        );
    }
    test_field_indirectCommandsLayout();
    fn test_field_maxSequencesCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkGeneratedCommandsMemoryRequirementsInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSequencesCount) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGeneratedCommandsMemoryRequirementsInfoNV),
                "::",
                stringify!(maxSequencesCount)
            )
        );
    }
    test_field_maxSequencesCount();
}
impl Default for VkGeneratedCommandsMemoryRequirementsInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetGeneratedCommandsMemoryRequirementsNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoNV,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    ),
>;
pub type PFN_vkCmdPreprocessGeneratedCommandsNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoNV,
    ),
>;
pub type PFN_vkCmdExecuteGeneratedCommandsNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        isPreprocessed: VkBool32,
        pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoNV,
    ),
>;
pub type PFN_vkCmdBindPipelineShaderGroupNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        pipeline: VkPipeline,
        groupIndex: u32,
    ),
>;
pub type PFN_vkCreateIndirectCommandsLayoutNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkIndirectCommandsLayoutCreateInfoNV,
        pAllocator: *const VkAllocationCallbacks,
        pIndirectCommandsLayout: *mut VkIndirectCommandsLayoutNV,
    ) -> VkResult,
>;
pub type PFN_vkDestroyIndirectCommandsLayoutNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        indirectCommandsLayout: VkIndirectCommandsLayoutNV,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
extern "C" {
    pub fn vkGetGeneratedCommandsMemoryRequirementsNV(
        device: VkDevice,
        pInfo: *const VkGeneratedCommandsMemoryRequirementsInfoNV,
        pMemoryRequirements: *mut VkMemoryRequirements2,
    );
}
extern "C" {
    pub fn vkCmdPreprocessGeneratedCommandsNV(
        commandBuffer: VkCommandBuffer,
        pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoNV,
    );
}
extern "C" {
    pub fn vkCmdExecuteGeneratedCommandsNV(
        commandBuffer: VkCommandBuffer,
        isPreprocessed: VkBool32,
        pGeneratedCommandsInfo: *const VkGeneratedCommandsInfoNV,
    );
}
extern "C" {
    pub fn vkCmdBindPipelineShaderGroupNV(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        pipeline: VkPipeline,
        groupIndex: u32,
    );
}
extern "C" {
    pub fn vkCreateIndirectCommandsLayoutNV(
        device: VkDevice,
        pCreateInfo: *const VkIndirectCommandsLayoutCreateInfoNV,
        pAllocator: *const VkAllocationCallbacks,
        pIndirectCommandsLayout: *mut VkIndirectCommandsLayoutNV,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyIndirectCommandsLayoutNV(
        device: VkDevice,
        indirectCommandsLayout: VkIndirectCommandsLayoutNV,
        pAllocator: *const VkAllocationCallbacks,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceInheritedViewportScissorFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub inheritedViewportScissor2D: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceInheritedViewportScissorFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceInheritedViewportScissorFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceInheritedViewportScissorFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceInheritedViewportScissorFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceInheritedViewportScissorFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceInheritedViewportScissorFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInheritedViewportScissorFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceInheritedViewportScissorFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInheritedViewportScissorFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_inheritedViewportScissor2D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceInheritedViewportScissorFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inheritedViewportScissor2D) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInheritedViewportScissorFeaturesNV),
                "::",
                stringify!(inheritedViewportScissor2D)
            )
        );
    }
    test_field_inheritedViewportScissor2D();
}
impl Default for VkPhysicalDeviceInheritedViewportScissorFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBufferInheritanceViewportScissorInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub viewportScissor2D: VkBool32,
    pub viewportDepthCount: u32,
    pub pViewportDepths: *const VkViewport,
}
#[test]
fn bindgen_test_layout_VkCommandBufferInheritanceViewportScissorInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkCommandBufferInheritanceViewportScissorInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkCommandBufferInheritanceViewportScissorInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkCommandBufferInheritanceViewportScissorInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkCommandBufferInheritanceViewportScissorInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkCommandBufferInheritanceViewportScissorInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceViewportScissorInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkCommandBufferInheritanceViewportScissorInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceViewportScissorInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_viewportScissor2D() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkCommandBufferInheritanceViewportScissorInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewportScissor2D) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceViewportScissorInfoNV),
                "::",
                stringify!(viewportScissor2D)
            )
        );
    }
    test_field_viewportScissor2D();
    fn test_field_viewportDepthCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkCommandBufferInheritanceViewportScissorInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viewportDepthCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceViewportScissorInfoNV),
                "::",
                stringify!(viewportDepthCount)
            )
        );
    }
    test_field_viewportDepthCount();
    fn test_field_pViewportDepths() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkCommandBufferInheritanceViewportScissorInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pViewportDepths) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceViewportScissorInfoNV),
                "::",
                stringify!(pViewportDepths)
            )
        );
    }
    test_field_pViewportDepths();
}
impl Default for VkCommandBufferInheritanceViewportScissorInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub texelBufferAlignment: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_texelBufferAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).texelBufferAlignment) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT),
                "::",
                stringify!(texelBufferAlignment)
            )
        );
    }
    test_field_texelBufferAlignment();
}
impl Default for VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT =
    VkPhysicalDeviceTexelBufferAlignmentProperties;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassTransformBeginInfoQCOM {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub transform: VkSurfaceTransformFlagBitsKHR,
}
#[test]
fn bindgen_test_layout_VkRenderPassTransformBeginInfoQCOM() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassTransformBeginInfoQCOM>(),
        24usize,
        concat!("Size of: ", stringify!(VkRenderPassTransformBeginInfoQCOM))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassTransformBeginInfoQCOM>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRenderPassTransformBeginInfoQCOM)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassTransformBeginInfoQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassTransformBeginInfoQCOM),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassTransformBeginInfoQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassTransformBeginInfoQCOM),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_transform() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassTransformBeginInfoQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transform) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassTransformBeginInfoQCOM),
                "::",
                stringify!(transform)
            )
        );
    }
    test_field_transform();
}
impl Default for VkRenderPassTransformBeginInfoQCOM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBufferInheritanceRenderPassTransformInfoQCOM {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub transform: VkSurfaceTransformFlagBitsKHR,
    pub renderArea: VkRect2D,
}
#[test]
fn bindgen_test_layout_VkCommandBufferInheritanceRenderPassTransformInfoQCOM() {
    assert_eq!(
        ::std::mem::size_of::<VkCommandBufferInheritanceRenderPassTransformInfoQCOM>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkCommandBufferInheritanceRenderPassTransformInfoQCOM)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkCommandBufferInheritanceRenderPassTransformInfoQCOM>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkCommandBufferInheritanceRenderPassTransformInfoQCOM)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkCommandBufferInheritanceRenderPassTransformInfoQCOM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceRenderPassTransformInfoQCOM),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkCommandBufferInheritanceRenderPassTransformInfoQCOM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceRenderPassTransformInfoQCOM),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_transform() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkCommandBufferInheritanceRenderPassTransformInfoQCOM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transform) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceRenderPassTransformInfoQCOM),
                "::",
                stringify!(transform)
            )
        );
    }
    test_field_transform();
    fn test_field_renderArea() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkCommandBufferInheritanceRenderPassTransformInfoQCOM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).renderArea) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCommandBufferInheritanceRenderPassTransformInfoQCOM),
                "::",
                stringify!(renderArea)
            )
        );
    }
    test_field_renderArea();
}
impl Default for VkCommandBufferInheritanceRenderPassTransformInfoQCOM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT: VkDeviceMemoryReportEventTypeEXT = 0;
pub const VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT: VkDeviceMemoryReportEventTypeEXT = 1;
pub const VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT: VkDeviceMemoryReportEventTypeEXT = 2;
pub const VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT: VkDeviceMemoryReportEventTypeEXT = 3;
pub const VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT:
    VkDeviceMemoryReportEventTypeEXT = 4;
pub const VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_MAX_ENUM_EXT: VkDeviceMemoryReportEventTypeEXT =
    2147483647;
pub type VkDeviceMemoryReportEventTypeEXT = ::std::os::raw::c_int;
pub type VkDeviceMemoryReportFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDeviceMemoryReportFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub deviceMemoryReport: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDeviceMemoryReportFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDeviceMemoryReportFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_deviceMemoryReport() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDeviceMemoryReportFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceMemoryReport) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT),
                "::",
                stringify!(deviceMemoryReport)
            )
        );
    }
    test_field_deviceMemoryReport();
}
impl Default for VkPhysicalDeviceDeviceMemoryReportFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceMemoryReportCallbackDataEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub flags: VkDeviceMemoryReportFlagsEXT,
    pub type_: VkDeviceMemoryReportEventTypeEXT,
    pub memoryObjectId: u64,
    pub size: VkDeviceSize,
    pub objectType: VkObjectType,
    pub objectHandle: u64,
    pub heapIndex: u32,
}
#[test]
fn bindgen_test_layout_VkDeviceMemoryReportCallbackDataEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceMemoryReportCallbackDataEXT>(),
        64usize,
        concat!("Size of: ", stringify!(VkDeviceMemoryReportCallbackDataEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceMemoryReportCallbackDataEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceMemoryReportCallbackDataEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceMemoryReportCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceMemoryReportCallbackDataEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceMemoryReportCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceMemoryReportCallbackDataEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceMemoryReportCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceMemoryReportCallbackDataEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceMemoryReportCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceMemoryReportCallbackDataEXT),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_memoryObjectId() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceMemoryReportCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryObjectId) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceMemoryReportCallbackDataEXT),
                "::",
                stringify!(memoryObjectId)
            )
        );
    }
    test_field_memoryObjectId();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceMemoryReportCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceMemoryReportCallbackDataEXT),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_objectType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceMemoryReportCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objectType) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceMemoryReportCallbackDataEXT),
                "::",
                stringify!(objectType)
            )
        );
    }
    test_field_objectType();
    fn test_field_objectHandle() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceMemoryReportCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objectHandle) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceMemoryReportCallbackDataEXT),
                "::",
                stringify!(objectHandle)
            )
        );
    }
    test_field_objectHandle();
    fn test_field_heapIndex() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceMemoryReportCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).heapIndex) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceMemoryReportCallbackDataEXT),
                "::",
                stringify!(heapIndex)
            )
        );
    }
    test_field_heapIndex();
}
impl Default for VkDeviceMemoryReportCallbackDataEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkDeviceMemoryReportCallbackEXT = ::std::option::Option<
    unsafe extern "C" fn(
        pCallbackData: *const VkDeviceMemoryReportCallbackDataEXT,
        pUserData: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceDeviceMemoryReportCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDeviceMemoryReportFlagsEXT,
    pub pfnUserCallback: PFN_vkDeviceMemoryReportCallbackEXT,
    pub pUserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkDeviceDeviceMemoryReportCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceDeviceMemoryReportCreateInfoEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkDeviceDeviceMemoryReportCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceDeviceMemoryReportCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceDeviceMemoryReportCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceDeviceMemoryReportCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceDeviceMemoryReportCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceDeviceMemoryReportCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceDeviceMemoryReportCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceDeviceMemoryReportCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceDeviceMemoryReportCreateInfoEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_pfnUserCallback() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceDeviceMemoryReportCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pfnUserCallback) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceDeviceMemoryReportCreateInfoEXT),
                "::",
                stringify!(pfnUserCallback)
            )
        );
    }
    test_field_pfnUserCallback();
    fn test_field_pUserData() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceDeviceMemoryReportCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pUserData) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceDeviceMemoryReportCreateInfoEXT),
                "::",
                stringify!(pUserData)
            )
        );
    }
    test_field_pUserData();
}
impl Default for VkDeviceDeviceMemoryReportCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkAcquireDrmDisplayEXT = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        drmFd: i32,
        display: VkDisplayKHR,
    ) -> VkResult,
>;
pub type PFN_vkGetDrmDisplayEXT = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        drmFd: i32,
        connectorId: u32,
        display: *mut VkDisplayKHR,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkAcquireDrmDisplayEXT(
        physicalDevice: VkPhysicalDevice,
        drmFd: i32,
        display: VkDisplayKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDrmDisplayEXT(
        physicalDevice: VkPhysicalDevice,
        drmFd: i32,
        connectorId: u32,
        display: *mut VkDisplayKHR,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceRobustness2FeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub robustBufferAccess2: VkBool32,
    pub robustImageAccess2: VkBool32,
    pub nullDescriptor: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceRobustness2FeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceRobustness2FeaturesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceRobustness2FeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceRobustness2FeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceRobustness2FeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRobustness2FeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRobustness2FeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRobustness2FeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRobustness2FeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_robustBufferAccess2() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRobustness2FeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).robustBufferAccess2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRobustness2FeaturesEXT),
                "::",
                stringify!(robustBufferAccess2)
            )
        );
    }
    test_field_robustBufferAccess2();
    fn test_field_robustImageAccess2() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRobustness2FeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).robustImageAccess2) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRobustness2FeaturesEXT),
                "::",
                stringify!(robustImageAccess2)
            )
        );
    }
    test_field_robustImageAccess2();
    fn test_field_nullDescriptor() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRobustness2FeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nullDescriptor) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRobustness2FeaturesEXT),
                "::",
                stringify!(nullDescriptor)
            )
        );
    }
    test_field_nullDescriptor();
}
impl Default for VkPhysicalDeviceRobustness2FeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceRobustness2PropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub robustStorageBufferAccessSizeAlignment: VkDeviceSize,
    pub robustUniformBufferAccessSizeAlignment: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceRobustness2PropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceRobustness2PropertiesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceRobustness2PropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceRobustness2PropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceRobustness2PropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRobustness2PropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRobustness2PropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRobustness2PropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRobustness2PropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_robustStorageBufferAccessSizeAlignment() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRobustness2PropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).robustStorageBufferAccessSizeAlignment) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRobustness2PropertiesEXT),
                "::",
                stringify!(robustStorageBufferAccessSizeAlignment)
            )
        );
    }
    test_field_robustStorageBufferAccessSizeAlignment();
    fn test_field_robustUniformBufferAccessSizeAlignment() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRobustness2PropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).robustUniformBufferAccessSizeAlignment) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRobustness2PropertiesEXT),
                "::",
                stringify!(robustUniformBufferAccessSizeAlignment)
            )
        );
    }
    test_field_robustUniformBufferAccessSizeAlignment();
}
impl Default for VkPhysicalDeviceRobustness2PropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSamplerCustomBorderColorCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub customBorderColor: VkClearColorValue,
    pub format: VkFormat,
}
#[test]
fn bindgen_test_layout_VkSamplerCustomBorderColorCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkSamplerCustomBorderColorCreateInfoEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkSamplerCustomBorderColorCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkSamplerCustomBorderColorCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSamplerCustomBorderColorCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerCustomBorderColorCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCustomBorderColorCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerCustomBorderColorCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCustomBorderColorCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_customBorderColor() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerCustomBorderColorCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).customBorderColor) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCustomBorderColorCreateInfoEXT),
                "::",
                stringify!(customBorderColor)
            )
        );
    }
    test_field_customBorderColor();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerCustomBorderColorCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCustomBorderColorCreateInfoEXT),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
}
impl Default for VkSamplerCustomBorderColorCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceCustomBorderColorPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxCustomBorderColorSamplers: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceCustomBorderColorPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceCustomBorderColorPropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceCustomBorderColorPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceCustomBorderColorPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceCustomBorderColorPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceCustomBorderColorPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCustomBorderColorPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceCustomBorderColorPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCustomBorderColorPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxCustomBorderColorSamplers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceCustomBorderColorPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxCustomBorderColorSamplers) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCustomBorderColorPropertiesEXT),
                "::",
                stringify!(maxCustomBorderColorSamplers)
            )
        );
    }
    test_field_maxCustomBorderColorSamplers();
}
impl Default for VkPhysicalDeviceCustomBorderColorPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceCustomBorderColorFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub customBorderColors: VkBool32,
    pub customBorderColorWithoutFormat: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceCustomBorderColorFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceCustomBorderColorFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceCustomBorderColorFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceCustomBorderColorFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceCustomBorderColorFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCustomBorderColorFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCustomBorderColorFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCustomBorderColorFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCustomBorderColorFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_customBorderColors() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCustomBorderColorFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).customBorderColors) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCustomBorderColorFeaturesEXT),
                "::",
                stringify!(customBorderColors)
            )
        );
    }
    test_field_customBorderColors();
    fn test_field_customBorderColorWithoutFormat() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCustomBorderColorFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).customBorderColorWithoutFormat) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCustomBorderColorFeaturesEXT),
                "::",
                stringify!(customBorderColorWithoutFormat)
            )
        );
    }
    test_field_customBorderColorWithoutFormat();
}
impl Default for VkPhysicalDeviceCustomBorderColorFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePresentBarrierFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub presentBarrier: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePresentBarrierFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePresentBarrierFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePresentBarrierFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePresentBarrierFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePresentBarrierFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePresentBarrierFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePresentBarrierFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePresentBarrierFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePresentBarrierFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_presentBarrier() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevicePresentBarrierFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).presentBarrier) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePresentBarrierFeaturesNV),
                "::",
                stringify!(presentBarrier)
            )
        );
    }
    test_field_presentBarrier();
}
impl Default for VkPhysicalDevicePresentBarrierFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSurfaceCapabilitiesPresentBarrierNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub presentBarrierSupported: VkBool32,
}
#[test]
fn bindgen_test_layout_VkSurfaceCapabilitiesPresentBarrierNV() {
    assert_eq!(
        ::std::mem::size_of::<VkSurfaceCapabilitiesPresentBarrierNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkSurfaceCapabilitiesPresentBarrierNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkSurfaceCapabilitiesPresentBarrierNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSurfaceCapabilitiesPresentBarrierNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSurfaceCapabilitiesPresentBarrierNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilitiesPresentBarrierNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSurfaceCapabilitiesPresentBarrierNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilitiesPresentBarrierNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_presentBarrierSupported() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSurfaceCapabilitiesPresentBarrierNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).presentBarrierSupported) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSurfaceCapabilitiesPresentBarrierNV),
                "::",
                stringify!(presentBarrierSupported)
            )
        );
    }
    test_field_presentBarrierSupported();
}
impl Default for VkSurfaceCapabilitiesPresentBarrierNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSwapchainPresentBarrierCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub presentBarrierEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkSwapchainPresentBarrierCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkSwapchainPresentBarrierCreateInfoNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkSwapchainPresentBarrierCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkSwapchainPresentBarrierCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSwapchainPresentBarrierCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSwapchainPresentBarrierCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainPresentBarrierCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSwapchainPresentBarrierCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainPresentBarrierCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_presentBarrierEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSwapchainPresentBarrierCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).presentBarrierEnable) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSwapchainPresentBarrierCreateInfoNV),
                "::",
                stringify!(presentBarrierEnable)
            )
        );
    }
    test_field_presentBarrierEnable();
}
impl Default for VkSwapchainPresentBarrierCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPrivateDataSlotEXT = VkPrivateDataSlot;
pub type VkPrivateDataSlotCreateFlagsEXT = VkPrivateDataSlotCreateFlags;
pub type VkPhysicalDevicePrivateDataFeaturesEXT = VkPhysicalDevicePrivateDataFeatures;
pub type VkDevicePrivateDataCreateInfoEXT = VkDevicePrivateDataCreateInfo;
pub type VkPrivateDataSlotCreateInfoEXT = VkPrivateDataSlotCreateInfo;
pub type PFN_vkCreatePrivateDataSlotEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkPrivateDataSlotCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPrivateDataSlot: *mut VkPrivateDataSlot,
    ) -> VkResult,
>;
pub type PFN_vkDestroyPrivateDataSlotEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        privateDataSlot: VkPrivateDataSlot,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkSetPrivateDataEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        objectType: VkObjectType,
        objectHandle: u64,
        privateDataSlot: VkPrivateDataSlot,
        data: u64,
    ) -> VkResult,
>;
pub type PFN_vkGetPrivateDataEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        objectType: VkObjectType,
        objectHandle: u64,
        privateDataSlot: VkPrivateDataSlot,
        pData: *mut u64,
    ),
>;
extern "C" {
    pub fn vkCreatePrivateDataSlotEXT(
        device: VkDevice,
        pCreateInfo: *const VkPrivateDataSlotCreateInfo,
        pAllocator: *const VkAllocationCallbacks,
        pPrivateDataSlot: *mut VkPrivateDataSlot,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyPrivateDataSlotEXT(
        device: VkDevice,
        privateDataSlot: VkPrivateDataSlot,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkSetPrivateDataEXT(
        device: VkDevice,
        objectType: VkObjectType,
        objectHandle: u64,
        privateDataSlot: VkPrivateDataSlot,
        data: u64,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetPrivateDataEXT(
        device: VkDevice,
        objectType: VkObjectType,
        objectHandle: u64,
        privateDataSlot: VkPrivateDataSlot,
        pData: *mut u64,
    );
}
pub type VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT =
    VkPhysicalDevicePipelineCreationCacheControlFeatures;
pub const VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV:
    VkDeviceDiagnosticsConfigFlagBitsNV = 1;
pub const VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV:
    VkDeviceDiagnosticsConfigFlagBitsNV = 2;
pub const VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV:
    VkDeviceDiagnosticsConfigFlagBitsNV = 4;
pub const VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV:
    VkDeviceDiagnosticsConfigFlagBitsNV = 8;
pub const VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_MAX_ENUM_NV: VkDeviceDiagnosticsConfigFlagBitsNV =
    2147483647;
pub type VkDeviceDiagnosticsConfigFlagBitsNV = ::std::os::raw::c_int;
pub type VkDeviceDiagnosticsConfigFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDiagnosticsConfigFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub diagnosticsConfig: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDiagnosticsConfigFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDiagnosticsConfigFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDiagnosticsConfigFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDiagnosticsConfigFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDiagnosticsConfigFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDiagnosticsConfigFeaturesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDiagnosticsConfigFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDiagnosticsConfigFeaturesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDiagnosticsConfigFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_diagnosticsConfig() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDiagnosticsConfigFeaturesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).diagnosticsConfig) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDiagnosticsConfigFeaturesNV),
                "::",
                stringify!(diagnosticsConfig)
            )
        );
    }
    test_field_diagnosticsConfig();
}
impl Default for VkPhysicalDeviceDiagnosticsConfigFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceDiagnosticsConfigCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDeviceDiagnosticsConfigFlagsNV,
}
#[test]
fn bindgen_test_layout_VkDeviceDiagnosticsConfigCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceDiagnosticsConfigCreateInfoNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDeviceDiagnosticsConfigCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceDiagnosticsConfigCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceDiagnosticsConfigCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceDiagnosticsConfigCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceDiagnosticsConfigCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceDiagnosticsConfigCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceDiagnosticsConfigCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceDiagnosticsConfigCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceDiagnosticsConfigCreateInfoNV),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for VkDeviceDiagnosticsConfigCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAccelerationStructureKHR_T {
    _unused: [u8; 0],
}
pub type VkAccelerationStructureKHR = *mut VkAccelerationStructureKHR_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDescriptorBufferPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub combinedImageSamplerDescriptorSingleArray: VkBool32,
    pub bufferlessPushDescriptors: VkBool32,
    pub allowSamplerImageViewPostSubmitCreation: VkBool32,
    pub descriptorBufferOffsetAlignment: VkDeviceSize,
    pub maxDescriptorBufferBindings: u32,
    pub maxResourceDescriptorBufferBindings: u32,
    pub maxSamplerDescriptorBufferBindings: u32,
    pub maxEmbeddedImmutableSamplerBindings: u32,
    pub maxEmbeddedImmutableSamplers: u32,
    pub bufferCaptureReplayDescriptorDataSize: usize,
    pub imageCaptureReplayDescriptorDataSize: usize,
    pub imageViewCaptureReplayDescriptorDataSize: usize,
    pub samplerCaptureReplayDescriptorDataSize: usize,
    pub accelerationStructureCaptureReplayDescriptorDataSize: usize,
    pub samplerDescriptorSize: usize,
    pub combinedImageSamplerDescriptorSize: usize,
    pub sampledImageDescriptorSize: usize,
    pub storageImageDescriptorSize: usize,
    pub uniformTexelBufferDescriptorSize: usize,
    pub robustUniformTexelBufferDescriptorSize: usize,
    pub storageTexelBufferDescriptorSize: usize,
    pub robustStorageTexelBufferDescriptorSize: usize,
    pub uniformBufferDescriptorSize: usize,
    pub robustUniformBufferDescriptorSize: usize,
    pub storageBufferDescriptorSize: usize,
    pub robustStorageBufferDescriptorSize: usize,
    pub inputAttachmentDescriptorSize: usize,
    pub accelerationStructureDescriptorSize: usize,
    pub maxSamplerDescriptorBufferRange: VkDeviceSize,
    pub maxResourceDescriptorBufferRange: VkDeviceSize,
    pub samplerDescriptorBufferAddressSpaceSize: VkDeviceSize,
    pub resourceDescriptorBufferAddressSpaceSize: VkDeviceSize,
    pub descriptorBufferAddressSpaceSize: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDescriptorBufferPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDescriptorBufferPropertiesEXT>(),
        256usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDescriptorBufferPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_combinedImageSamplerDescriptorSingleArray() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).combinedImageSamplerDescriptorSingleArray) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(combinedImageSamplerDescriptorSingleArray)
            )
        );
    }
    test_field_combinedImageSamplerDescriptorSingleArray();
    fn test_field_bufferlessPushDescriptors() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferlessPushDescriptors) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(bufferlessPushDescriptors)
            )
        );
    }
    test_field_bufferlessPushDescriptors();
    fn test_field_allowSamplerImageViewPostSubmitCreation() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).allowSamplerImageViewPostSubmitCreation) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(allowSamplerImageViewPostSubmitCreation)
            )
        );
    }
    test_field_allowSamplerImageViewPostSubmitCreation();
    fn test_field_descriptorBufferOffsetAlignment() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBufferOffsetAlignment) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(descriptorBufferOffsetAlignment)
            )
        );
    }
    test_field_descriptorBufferOffsetAlignment();
    fn test_field_maxDescriptorBufferBindings() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorBufferBindings) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(maxDescriptorBufferBindings)
            )
        );
    }
    test_field_maxDescriptorBufferBindings();
    fn test_field_maxResourceDescriptorBufferBindings() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxResourceDescriptorBufferBindings) as usize
                    - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(maxResourceDescriptorBufferBindings)
            )
        );
    }
    test_field_maxResourceDescriptorBufferBindings();
    fn test_field_maxSamplerDescriptorBufferBindings() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSamplerDescriptorBufferBindings) as usize
                    - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(maxSamplerDescriptorBufferBindings)
            )
        );
    }
    test_field_maxSamplerDescriptorBufferBindings();
    fn test_field_maxEmbeddedImmutableSamplerBindings() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxEmbeddedImmutableSamplerBindings) as usize
                    - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(maxEmbeddedImmutableSamplerBindings)
            )
        );
    }
    test_field_maxEmbeddedImmutableSamplerBindings();
    fn test_field_maxEmbeddedImmutableSamplers() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxEmbeddedImmutableSamplers) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(maxEmbeddedImmutableSamplers)
            )
        );
    }
    test_field_maxEmbeddedImmutableSamplers();
    fn test_field_bufferCaptureReplayDescriptorDataSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferCaptureReplayDescriptorDataSize) as usize
                    - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(bufferCaptureReplayDescriptorDataSize)
            )
        );
    }
    test_field_bufferCaptureReplayDescriptorDataSize();
    fn test_field_imageCaptureReplayDescriptorDataSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageCaptureReplayDescriptorDataSize) as usize
                    - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(imageCaptureReplayDescriptorDataSize)
            )
        );
    }
    test_field_imageCaptureReplayDescriptorDataSize();
    fn test_field_imageViewCaptureReplayDescriptorDataSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageViewCaptureReplayDescriptorDataSize) as usize
                    - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(imageViewCaptureReplayDescriptorDataSize)
            )
        );
    }
    test_field_imageViewCaptureReplayDescriptorDataSize();
    fn test_field_samplerCaptureReplayDescriptorDataSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samplerCaptureReplayDescriptorDataSize) as usize
                    - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(samplerCaptureReplayDescriptorDataSize)
            )
        );
    }
    test_field_samplerCaptureReplayDescriptorDataSize();
    fn test_field_accelerationStructureCaptureReplayDescriptorDataSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructureCaptureReplayDescriptorDataSize)
                    as usize
                    - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(accelerationStructureCaptureReplayDescriptorDataSize)
            )
        );
    }
    test_field_accelerationStructureCaptureReplayDescriptorDataSize();
    fn test_field_samplerDescriptorSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samplerDescriptorSize) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(samplerDescriptorSize)
            )
        );
    }
    test_field_samplerDescriptorSize();
    fn test_field_combinedImageSamplerDescriptorSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).combinedImageSamplerDescriptorSize) as usize
                    - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(combinedImageSamplerDescriptorSize)
            )
        );
    }
    test_field_combinedImageSamplerDescriptorSize();
    fn test_field_sampledImageDescriptorSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampledImageDescriptorSize) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(sampledImageDescriptorSize)
            )
        );
    }
    test_field_sampledImageDescriptorSize();
    fn test_field_storageImageDescriptorSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storageImageDescriptorSize) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(storageImageDescriptorSize)
            )
        );
    }
    test_field_storageImageDescriptorSize();
    fn test_field_uniformTexelBufferDescriptorSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uniformTexelBufferDescriptorSize) as usize
                    - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(uniformTexelBufferDescriptorSize)
            )
        );
    }
    test_field_uniformTexelBufferDescriptorSize();
    fn test_field_robustUniformTexelBufferDescriptorSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).robustUniformTexelBufferDescriptorSize) as usize
                    - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(robustUniformTexelBufferDescriptorSize)
            )
        );
    }
    test_field_robustUniformTexelBufferDescriptorSize();
    fn test_field_storageTexelBufferDescriptorSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storageTexelBufferDescriptorSize) as usize
                    - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(storageTexelBufferDescriptorSize)
            )
        );
    }
    test_field_storageTexelBufferDescriptorSize();
    fn test_field_robustStorageTexelBufferDescriptorSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).robustStorageTexelBufferDescriptorSize) as usize
                    - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(robustStorageTexelBufferDescriptorSize)
            )
        );
    }
    test_field_robustStorageTexelBufferDescriptorSize();
    fn test_field_uniformBufferDescriptorSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uniformBufferDescriptorSize) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(uniformBufferDescriptorSize)
            )
        );
    }
    test_field_uniformBufferDescriptorSize();
    fn test_field_robustUniformBufferDescriptorSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).robustUniformBufferDescriptorSize) as usize
                    - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(robustUniformBufferDescriptorSize)
            )
        );
    }
    test_field_robustUniformBufferDescriptorSize();
    fn test_field_storageBufferDescriptorSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storageBufferDescriptorSize) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(storageBufferDescriptorSize)
            )
        );
    }
    test_field_storageBufferDescriptorSize();
    fn test_field_robustStorageBufferDescriptorSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).robustStorageBufferDescriptorSize) as usize
                    - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(robustStorageBufferDescriptorSize)
            )
        );
    }
    test_field_robustStorageBufferDescriptorSize();
    fn test_field_inputAttachmentDescriptorSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inputAttachmentDescriptorSize) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(inputAttachmentDescriptorSize)
            )
        );
    }
    test_field_inputAttachmentDescriptorSize();
    fn test_field_accelerationStructureDescriptorSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructureDescriptorSize) as usize
                    - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(accelerationStructureDescriptorSize)
            )
        );
    }
    test_field_accelerationStructureDescriptorSize();
    fn test_field_maxSamplerDescriptorBufferRange() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSamplerDescriptorBufferRange) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(maxSamplerDescriptorBufferRange)
            )
        );
    }
    test_field_maxSamplerDescriptorBufferRange();
    fn test_field_maxResourceDescriptorBufferRange() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxResourceDescriptorBufferRange) as usize
                    - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(maxResourceDescriptorBufferRange)
            )
        );
    }
    test_field_maxResourceDescriptorBufferRange();
    fn test_field_samplerDescriptorBufferAddressSpaceSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).samplerDescriptorBufferAddressSpaceSize) as usize
                    - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(samplerDescriptorBufferAddressSpaceSize)
            )
        );
    }
    test_field_samplerDescriptorBufferAddressSpaceSize();
    fn test_field_resourceDescriptorBufferAddressSpaceSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resourceDescriptorBufferAddressSpaceSize) as usize
                    - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(resourceDescriptorBufferAddressSpaceSize)
            )
        );
    }
    test_field_resourceDescriptorBufferAddressSpaceSize();
    fn test_field_descriptorBufferAddressSpaceSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceDescriptorBufferPropertiesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBufferAddressSpaceSize) as usize
                    - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferPropertiesEXT),
                "::",
                stringify!(descriptorBufferAddressSpaceSize)
            )
        );
    }
    test_field_descriptorBufferAddressSpaceSize();
}
impl Default for VkPhysicalDeviceDescriptorBufferPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub combinedImageSamplerDensityMapDescriptorSize: usize,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_combinedImageSamplerDensityMapDescriptorSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).combinedImageSamplerDensityMapDescriptorSize) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT),
                "::",
                stringify!(combinedImageSamplerDensityMapDescriptorSize)
            )
        );
    }
    test_field_combinedImageSamplerDensityMapDescriptorSize();
}
impl Default for VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDescriptorBufferFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub descriptorBuffer: VkBool32,
    pub descriptorBufferCaptureReplay: VkBool32,
    pub descriptorBufferImageLayoutIgnored: VkBool32,
    pub descriptorBufferPushDescriptors: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDescriptorBufferFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDescriptorBufferFeaturesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDescriptorBufferFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDescriptorBufferFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDescriptorBufferFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorBufferFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorBufferFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_descriptorBuffer() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorBufferFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBuffer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferFeaturesEXT),
                "::",
                stringify!(descriptorBuffer)
            )
        );
    }
    test_field_descriptorBuffer();
    fn test_field_descriptorBufferCaptureReplay() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorBufferFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBufferCaptureReplay) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferFeaturesEXT),
                "::",
                stringify!(descriptorBufferCaptureReplay)
            )
        );
    }
    test_field_descriptorBufferCaptureReplay();
    fn test_field_descriptorBufferImageLayoutIgnored() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorBufferFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBufferImageLayoutIgnored) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferFeaturesEXT),
                "::",
                stringify!(descriptorBufferImageLayoutIgnored)
            )
        );
    }
    test_field_descriptorBufferImageLayoutIgnored();
    fn test_field_descriptorBufferPushDescriptors() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDescriptorBufferFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBufferPushDescriptors) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorBufferFeaturesEXT),
                "::",
                stringify!(descriptorBufferPushDescriptors)
            )
        );
    }
    test_field_descriptorBufferPushDescriptors();
}
impl Default for VkPhysicalDeviceDescriptorBufferFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorAddressInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub address: VkDeviceAddress,
    pub range: VkDeviceSize,
    pub format: VkFormat,
}
#[test]
fn bindgen_test_layout_VkDescriptorAddressInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorAddressInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkDescriptorAddressInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorAddressInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorAddressInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorAddressInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorAddressInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorAddressInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorAddressInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorAddressInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorAddressInfoEXT),
                "::",
                stringify!(address)
            )
        );
    }
    test_field_address();
    fn test_field_range() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorAddressInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorAddressInfoEXT),
                "::",
                stringify!(range)
            )
        );
    }
    test_field_range();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorAddressInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorAddressInfoEXT),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
}
impl Default for VkDescriptorAddressInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorBufferBindingInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub address: VkDeviceAddress,
    pub usage: VkBufferUsageFlags,
}
#[test]
fn bindgen_test_layout_VkDescriptorBufferBindingInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorBufferBindingInfoEXT>(),
        32usize,
        concat!("Size of: ", stringify!(VkDescriptorBufferBindingInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorBufferBindingInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDescriptorBufferBindingInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorBufferBindingInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorBufferBindingInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorBufferBindingInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorBufferBindingInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorBufferBindingInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorBufferBindingInfoEXT),
                "::",
                stringify!(address)
            )
        );
    }
    test_field_address();
    fn test_field_usage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorBufferBindingInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorBufferBindingInfoEXT),
                "::",
                stringify!(usage)
            )
        );
    }
    test_field_usage();
}
impl Default for VkDescriptorBufferBindingInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorBufferBindingPushDescriptorBufferHandleEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub buffer: VkBuffer,
}
#[test]
fn bindgen_test_layout_VkDescriptorBufferBindingPushDescriptorBufferHandleEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorBufferBindingPushDescriptorBufferHandleEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorBufferBindingPushDescriptorBufferHandleEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkDescriptorBufferBindingPushDescriptorBufferHandleEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkDescriptorBufferBindingPushDescriptorBufferHandleEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkDescriptorBufferBindingPushDescriptorBufferHandleEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorBufferBindingPushDescriptorBufferHandleEXT),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
}
impl Default for VkDescriptorBufferBindingPushDescriptorBufferHandleEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkDescriptorDataEXT {
    pub pSampler: *const VkSampler,
    pub pCombinedImageSampler: *const VkDescriptorImageInfo,
    pub pInputAttachmentImage: *const VkDescriptorImageInfo,
    pub pSampledImage: *const VkDescriptorImageInfo,
    pub pStorageImage: *const VkDescriptorImageInfo,
    pub pUniformTexelBuffer: *const VkDescriptorAddressInfoEXT,
    pub pStorageTexelBuffer: *const VkDescriptorAddressInfoEXT,
    pub pUniformBuffer: *const VkDescriptorAddressInfoEXT,
    pub pStorageBuffer: *const VkDescriptorAddressInfoEXT,
    pub accelerationStructure: VkDeviceAddress,
}
#[test]
fn bindgen_test_layout_VkDescriptorDataEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorDataEXT>(),
        8usize,
        concat!("Size of: ", stringify!(VkDescriptorDataEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorDataEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorDataEXT))
    );
    fn test_field_pSampler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSampler) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorDataEXT),
                "::",
                stringify!(pSampler)
            )
        );
    }
    test_field_pSampler();
    fn test_field_pCombinedImageSampler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pCombinedImageSampler) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorDataEXT),
                "::",
                stringify!(pCombinedImageSampler)
            )
        );
    }
    test_field_pCombinedImageSampler();
    fn test_field_pInputAttachmentImage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pInputAttachmentImage) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorDataEXT),
                "::",
                stringify!(pInputAttachmentImage)
            )
        );
    }
    test_field_pInputAttachmentImage();
    fn test_field_pSampledImage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSampledImage) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorDataEXT),
                "::",
                stringify!(pSampledImage)
            )
        );
    }
    test_field_pSampledImage();
    fn test_field_pStorageImage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pStorageImage) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorDataEXT),
                "::",
                stringify!(pStorageImage)
            )
        );
    }
    test_field_pStorageImage();
    fn test_field_pUniformTexelBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pUniformTexelBuffer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorDataEXT),
                "::",
                stringify!(pUniformTexelBuffer)
            )
        );
    }
    test_field_pUniformTexelBuffer();
    fn test_field_pStorageTexelBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pStorageTexelBuffer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorDataEXT),
                "::",
                stringify!(pStorageTexelBuffer)
            )
        );
    }
    test_field_pStorageTexelBuffer();
    fn test_field_pUniformBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pUniformBuffer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorDataEXT),
                "::",
                stringify!(pUniformBuffer)
            )
        );
    }
    test_field_pUniformBuffer();
    fn test_field_pStorageBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pStorageBuffer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorDataEXT),
                "::",
                stringify!(pStorageBuffer)
            )
        );
    }
    test_field_pStorageBuffer();
    fn test_field_accelerationStructure() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructure) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorDataEXT),
                "::",
                stringify!(accelerationStructure)
            )
        );
    }
    test_field_accelerationStructure();
}
impl Default for VkDescriptorDataEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkDescriptorGetInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub type_: VkDescriptorType,
    pub data: VkDescriptorDataEXT,
}
#[test]
fn bindgen_test_layout_VkDescriptorGetInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorGetInfoEXT>(),
        32usize,
        concat!("Size of: ", stringify!(VkDescriptorGetInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorGetInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDescriptorGetInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorGetInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorGetInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorGetInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorGetInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorGetInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorGetInfoEXT),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDescriptorGetInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorGetInfoEXT),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
impl Default for VkDescriptorGetInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferCaptureDescriptorDataInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub buffer: VkBuffer,
}
#[test]
fn bindgen_test_layout_VkBufferCaptureDescriptorDataInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkBufferCaptureDescriptorDataInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkBufferCaptureDescriptorDataInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkBufferCaptureDescriptorDataInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkBufferCaptureDescriptorDataInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBufferCaptureDescriptorDataInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCaptureDescriptorDataInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBufferCaptureDescriptorDataInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCaptureDescriptorDataInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkBufferCaptureDescriptorDataInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkBufferCaptureDescriptorDataInfoEXT),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
}
impl Default for VkBufferCaptureDescriptorDataInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageCaptureDescriptorDataInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
}
#[test]
fn bindgen_test_layout_VkImageCaptureDescriptorDataInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkImageCaptureDescriptorDataInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkImageCaptureDescriptorDataInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageCaptureDescriptorDataInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkImageCaptureDescriptorDataInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageCaptureDescriptorDataInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCaptureDescriptorDataInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageCaptureDescriptorDataInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCaptureDescriptorDataInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_image() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageCaptureDescriptorDataInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCaptureDescriptorDataInfoEXT),
                "::",
                stringify!(image)
            )
        );
    }
    test_field_image();
}
impl Default for VkImageCaptureDescriptorDataInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageViewCaptureDescriptorDataInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub imageView: VkImageView,
}
#[test]
fn bindgen_test_layout_VkImageViewCaptureDescriptorDataInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkImageViewCaptureDescriptorDataInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkImageViewCaptureDescriptorDataInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageViewCaptureDescriptorDataInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkImageViewCaptureDescriptorDataInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageViewCaptureDescriptorDataInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewCaptureDescriptorDataInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageViewCaptureDescriptorDataInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewCaptureDescriptorDataInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_imageView() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageViewCaptureDescriptorDataInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageView) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewCaptureDescriptorDataInfoEXT),
                "::",
                stringify!(imageView)
            )
        );
    }
    test_field_imageView();
}
impl Default for VkImageViewCaptureDescriptorDataInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSamplerCaptureDescriptorDataInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub sampler: VkSampler,
}
#[test]
fn bindgen_test_layout_VkSamplerCaptureDescriptorDataInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkSamplerCaptureDescriptorDataInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkSamplerCaptureDescriptorDataInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkSamplerCaptureDescriptorDataInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSamplerCaptureDescriptorDataInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerCaptureDescriptorDataInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCaptureDescriptorDataInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerCaptureDescriptorDataInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCaptureDescriptorDataInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_sampler() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSamplerCaptureDescriptorDataInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampler) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerCaptureDescriptorDataInfoEXT),
                "::",
                stringify!(sampler)
            )
        );
    }
    test_field_sampler();
}
impl Default for VkSamplerCaptureDescriptorDataInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkOpaqueCaptureDescriptorDataCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub opaqueCaptureDescriptorData: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkOpaqueCaptureDescriptorDataCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkOpaqueCaptureDescriptorDataCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkOpaqueCaptureDescriptorDataCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkOpaqueCaptureDescriptorDataCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkOpaqueCaptureDescriptorDataCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkOpaqueCaptureDescriptorDataCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpaqueCaptureDescriptorDataCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkOpaqueCaptureDescriptorDataCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpaqueCaptureDescriptorDataCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_opaqueCaptureDescriptorData() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkOpaqueCaptureDescriptorDataCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opaqueCaptureDescriptorData) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpaqueCaptureDescriptorDataCreateInfoEXT),
                "::",
                stringify!(opaqueCaptureDescriptorData)
            )
        );
    }
    test_field_opaqueCaptureDescriptorData();
}
impl Default for VkOpaqueCaptureDescriptorDataCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAccelerationStructureCaptureDescriptorDataInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub accelerationStructure: VkAccelerationStructureKHR,
    pub accelerationStructureNV: VkAccelerationStructureNV,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureCaptureDescriptorDataInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureCaptureDescriptorDataInfoEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureCaptureDescriptorDataInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureCaptureDescriptorDataInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureCaptureDescriptorDataInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureCaptureDescriptorDataInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureCaptureDescriptorDataInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureCaptureDescriptorDataInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureCaptureDescriptorDataInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_accelerationStructure() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureCaptureDescriptorDataInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructure) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureCaptureDescriptorDataInfoEXT),
                "::",
                stringify!(accelerationStructure)
            )
        );
    }
    test_field_accelerationStructure();
    fn test_field_accelerationStructureNV() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureCaptureDescriptorDataInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructureNV) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureCaptureDescriptorDataInfoEXT),
                "::",
                stringify!(accelerationStructureNV)
            )
        );
    }
    test_field_accelerationStructureNV();
}
impl Default for VkAccelerationStructureCaptureDescriptorDataInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetDescriptorSetLayoutSizeEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        layout: VkDescriptorSetLayout,
        pLayoutSizeInBytes: *mut VkDeviceSize,
    ),
>;
pub type PFN_vkGetDescriptorSetLayoutBindingOffsetEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        layout: VkDescriptorSetLayout,
        binding: u32,
        pOffset: *mut VkDeviceSize,
    ),
>;
pub type PFN_vkGetDescriptorEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pDescriptorInfo: *const VkDescriptorGetInfoEXT,
        dataSize: usize,
        pDescriptor: *mut ::std::os::raw::c_void,
    ),
>;
pub type PFN_vkCmdBindDescriptorBuffersEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        bufferCount: u32,
        pBindingInfos: *const VkDescriptorBufferBindingInfoEXT,
    ),
>;
pub type PFN_vkCmdSetDescriptorBufferOffsetsEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        layout: VkPipelineLayout,
        firstSet: u32,
        setCount: u32,
        pBufferIndices: *const u32,
        pOffsets: *const VkDeviceSize,
    ),
>;
pub type PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        layout: VkPipelineLayout,
        set: u32,
    ),
>;
pub type PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkBufferCaptureDescriptorDataInfoEXT,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkGetImageOpaqueCaptureDescriptorDataEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkImageCaptureDescriptorDataInfoEXT,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkImageViewCaptureDescriptorDataInfoEXT,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkSamplerCaptureDescriptorDataInfoEXT,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkAccelerationStructureCaptureDescriptorDataInfoEXT,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetDescriptorSetLayoutSizeEXT(
        device: VkDevice,
        layout: VkDescriptorSetLayout,
        pLayoutSizeInBytes: *mut VkDeviceSize,
    );
}
extern "C" {
    pub fn vkGetDescriptorSetLayoutBindingOffsetEXT(
        device: VkDevice,
        layout: VkDescriptorSetLayout,
        binding: u32,
        pOffset: *mut VkDeviceSize,
    );
}
extern "C" {
    pub fn vkGetDescriptorEXT(
        device: VkDevice,
        pDescriptorInfo: *const VkDescriptorGetInfoEXT,
        dataSize: usize,
        pDescriptor: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn vkCmdBindDescriptorBuffersEXT(
        commandBuffer: VkCommandBuffer,
        bufferCount: u32,
        pBindingInfos: *const VkDescriptorBufferBindingInfoEXT,
    );
}
extern "C" {
    pub fn vkCmdSetDescriptorBufferOffsetsEXT(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        layout: VkPipelineLayout,
        firstSet: u32,
        setCount: u32,
        pBufferIndices: *const u32,
        pOffsets: *const VkDeviceSize,
    );
}
extern "C" {
    pub fn vkCmdBindDescriptorBufferEmbeddedSamplersEXT(
        commandBuffer: VkCommandBuffer,
        pipelineBindPoint: VkPipelineBindPoint,
        layout: VkPipelineLayout,
        set: u32,
    );
}
extern "C" {
    pub fn vkGetBufferOpaqueCaptureDescriptorDataEXT(
        device: VkDevice,
        pInfo: *const VkBufferCaptureDescriptorDataInfoEXT,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetImageOpaqueCaptureDescriptorDataEXT(
        device: VkDevice,
        pInfo: *const VkImageCaptureDescriptorDataInfoEXT,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetImageViewOpaqueCaptureDescriptorDataEXT(
        device: VkDevice,
        pInfo: *const VkImageViewCaptureDescriptorDataInfoEXT,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetSamplerOpaqueCaptureDescriptorDataEXT(
        device: VkDevice,
        pInfo: *const VkSamplerCaptureDescriptorDataInfoEXT,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT(
        device: VkDevice,
        pInfo: *const VkAccelerationStructureCaptureDescriptorDataInfoEXT,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
pub const VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT:
    VkGraphicsPipelineLibraryFlagBitsEXT = 1;
pub const VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT:
    VkGraphicsPipelineLibraryFlagBitsEXT = 2;
pub const VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT:
    VkGraphicsPipelineLibraryFlagBitsEXT = 4;
pub const VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT:
    VkGraphicsPipelineLibraryFlagBitsEXT = 8;
pub const VK_GRAPHICS_PIPELINE_LIBRARY_FLAG_BITS_MAX_ENUM_EXT:
    VkGraphicsPipelineLibraryFlagBitsEXT = 2147483647;
pub type VkGraphicsPipelineLibraryFlagBitsEXT = ::std::os::raw::c_int;
pub type VkGraphicsPipelineLibraryFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub graphicsPipelineLibrary: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_graphicsPipelineLibrary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).graphicsPipelineLibrary) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT),
                "::",
                stringify!(graphicsPipelineLibrary)
            )
        );
    }
    test_field_graphicsPipelineLibrary();
}
impl Default for VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub graphicsPipelineLibraryFastLinking: VkBool32,
    pub graphicsPipelineLibraryIndependentInterpolationDecoration: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_graphicsPipelineLibraryFastLinking() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).graphicsPipelineLibraryFastLinking) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT),
                "::",
                stringify!(graphicsPipelineLibraryFastLinking)
            )
        );
    }
    test_field_graphicsPipelineLibraryFastLinking();
    fn test_field_graphicsPipelineLibraryIndependentInterpolationDecoration() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).graphicsPipelineLibraryIndependentInterpolationDecoration
                ) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT),
                "::",
                stringify!(graphicsPipelineLibraryIndependentInterpolationDecoration)
            )
        );
    }
    test_field_graphicsPipelineLibraryIndependentInterpolationDecoration();
}
impl Default for VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkGraphicsPipelineLibraryCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub flags: VkGraphicsPipelineLibraryFlagsEXT,
}
#[test]
fn bindgen_test_layout_VkGraphicsPipelineLibraryCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkGraphicsPipelineLibraryCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkGraphicsPipelineLibraryCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkGraphicsPipelineLibraryCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkGraphicsPipelineLibraryCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkGraphicsPipelineLibraryCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineLibraryCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkGraphicsPipelineLibraryCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineLibraryCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkGraphicsPipelineLibraryCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkGraphicsPipelineLibraryCreateInfoEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for VkGraphicsPipelineLibraryCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderEarlyAndLateFragmentTests: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderEarlyAndLateFragmentTests() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderEarlyAndLateFragmentTests) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD),
                "::",
                stringify!(shaderEarlyAndLateFragmentTests)
            )
        );
    }
    test_field_shaderEarlyAndLateFragmentTests();
}
impl Default for VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV: VkFragmentShadingRateTypeNV = 0;
pub const VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV: VkFragmentShadingRateTypeNV = 1;
pub const VK_FRAGMENT_SHADING_RATE_TYPE_MAX_ENUM_NV: VkFragmentShadingRateTypeNV = 2147483647;
pub type VkFragmentShadingRateTypeNV = ::std::os::raw::c_int;
pub const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV: VkFragmentShadingRateNV = 0;
pub const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV: VkFragmentShadingRateNV = 1;
pub const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV: VkFragmentShadingRateNV = 4;
pub const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV: VkFragmentShadingRateNV = 5;
pub const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV: VkFragmentShadingRateNV = 6;
pub const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV: VkFragmentShadingRateNV = 9;
pub const VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV: VkFragmentShadingRateNV = 10;
pub const VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV: VkFragmentShadingRateNV = 11;
pub const VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV: VkFragmentShadingRateNV = 12;
pub const VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV: VkFragmentShadingRateNV = 13;
pub const VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV: VkFragmentShadingRateNV = 14;
pub const VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV: VkFragmentShadingRateNV = 15;
pub const VK_FRAGMENT_SHADING_RATE_MAX_ENUM_NV: VkFragmentShadingRateNV = 2147483647;
pub type VkFragmentShadingRateNV = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub fragmentShadingRateEnums: VkBool32,
    pub supersampleFragmentShadingRates: VkBool32,
    pub noInvocationFragmentShadingRates: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_fragmentShadingRateEnums() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentShadingRateEnums) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV),
                "::",
                stringify!(fragmentShadingRateEnums)
            )
        );
    }
    test_field_fragmentShadingRateEnums();
    fn test_field_supersampleFragmentShadingRates() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supersampleFragmentShadingRates) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV),
                "::",
                stringify!(supersampleFragmentShadingRates)
            )
        );
    }
    test_field_supersampleFragmentShadingRates();
    fn test_field_noInvocationFragmentShadingRates() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).noInvocationFragmentShadingRates) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV),
                "::",
                stringify!(noInvocationFragmentShadingRates)
            )
        );
    }
    test_field_noInvocationFragmentShadingRates();
}
impl Default for VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxFragmentShadingRateInvocationCount: VkSampleCountFlagBits,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxFragmentShadingRateInvocationCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxFragmentShadingRateInvocationCount) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV),
                "::",
                stringify!(maxFragmentShadingRateInvocationCount)
            )
        );
    }
    test_field_maxFragmentShadingRateInvocationCount();
}
impl Default for VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineFragmentShadingRateEnumStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub shadingRateType: VkFragmentShadingRateTypeNV,
    pub shadingRate: VkFragmentShadingRateNV,
    pub combinerOps: [VkFragmentShadingRateCombinerOpKHR; 2usize],
}
#[test]
fn bindgen_test_layout_VkPipelineFragmentShadingRateEnumStateCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineFragmentShadingRateEnumStateCreateInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineFragmentShadingRateEnumStateCreateInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineFragmentShadingRateEnumStateCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineFragmentShadingRateEnumStateCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineFragmentShadingRateEnumStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineFragmentShadingRateEnumStateCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineFragmentShadingRateEnumStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineFragmentShadingRateEnumStateCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shadingRateType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineFragmentShadingRateEnumStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shadingRateType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineFragmentShadingRateEnumStateCreateInfoNV),
                "::",
                stringify!(shadingRateType)
            )
        );
    }
    test_field_shadingRateType();
    fn test_field_shadingRate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineFragmentShadingRateEnumStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shadingRate) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineFragmentShadingRateEnumStateCreateInfoNV),
                "::",
                stringify!(shadingRate)
            )
        );
    }
    test_field_shadingRate();
    fn test_field_combinerOps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineFragmentShadingRateEnumStateCreateInfoNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).combinerOps) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineFragmentShadingRateEnumStateCreateInfoNV),
                "::",
                stringify!(combinerOps)
            )
        );
    }
    test_field_combinerOps();
}
impl Default for VkPipelineFragmentShadingRateEnumStateCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdSetFragmentShadingRateEnumNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        shadingRate: VkFragmentShadingRateNV,
        combinerOps: *const VkFragmentShadingRateCombinerOpKHR,
    ),
>;
extern "C" {
    pub fn vkCmdSetFragmentShadingRateEnumNV(
        commandBuffer: VkCommandBuffer,
        shadingRate: VkFragmentShadingRateNV,
        combinerOps: *const VkFragmentShadingRateCombinerOpKHR,
    );
}
pub const VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV:
    VkAccelerationStructureMotionInstanceTypeNV = 0;
pub const VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV:
    VkAccelerationStructureMotionInstanceTypeNV = 1;
pub const VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV:
    VkAccelerationStructureMotionInstanceTypeNV = 2;
pub const VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MAX_ENUM_NV:
    VkAccelerationStructureMotionInstanceTypeNV = 2147483647;
pub type VkAccelerationStructureMotionInstanceTypeNV = ::std::os::raw::c_int;
pub type VkAccelerationStructureMotionInfoFlagsNV = VkFlags;
pub type VkAccelerationStructureMotionInstanceFlagsNV = VkFlags;
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkDeviceOrHostAddressConstKHR {
    pub deviceAddress: VkDeviceAddress,
    pub hostAddress: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkDeviceOrHostAddressConstKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceOrHostAddressConstKHR>(),
        8usize,
        concat!("Size of: ", stringify!(VkDeviceOrHostAddressConstKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceOrHostAddressConstKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceOrHostAddressConstKHR))
    );
    fn test_field_deviceAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceOrHostAddressConstKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceAddress) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceOrHostAddressConstKHR),
                "::",
                stringify!(deviceAddress)
            )
        );
    }
    test_field_deviceAddress();
    fn test_field_hostAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceOrHostAddressConstKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostAddress) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceOrHostAddressConstKHR),
                "::",
                stringify!(hostAddress)
            )
        );
    }
    test_field_hostAddress();
}
impl Default for VkDeviceOrHostAddressConstKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureGeometryMotionTrianglesDataNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub vertexData: VkDeviceOrHostAddressConstKHR,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureGeometryMotionTrianglesDataNV() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureGeometryMotionTrianglesDataNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureGeometryMotionTrianglesDataNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureGeometryMotionTrianglesDataNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureGeometryMotionTrianglesDataNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureGeometryMotionTrianglesDataNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryMotionTrianglesDataNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureGeometryMotionTrianglesDataNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryMotionTrianglesDataNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_vertexData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureGeometryMotionTrianglesDataNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexData) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryMotionTrianglesDataNV),
                "::",
                stringify!(vertexData)
            )
        );
    }
    test_field_vertexData();
}
impl Default for VkAccelerationStructureGeometryMotionTrianglesDataNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAccelerationStructureMotionInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub maxInstances: u32,
    pub flags: VkAccelerationStructureMotionInfoFlagsNV,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureMotionInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureMotionInfoNV>(),
        24usize,
        concat!("Size of: ", stringify!(VkAccelerationStructureMotionInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureMotionInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureMotionInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureMotionInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMotionInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureMotionInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMotionInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxInstances() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureMotionInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxInstances) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMotionInfoNV),
                "::",
                stringify!(maxInstances)
            )
        );
    }
    test_field_maxInstances();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureMotionInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMotionInfoNV),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for VkAccelerationStructureMotionInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkAccelerationStructureMatrixMotionInstanceNV {
    pub transformT0: VkTransformMatrixKHR,
    pub transformT1: VkTransformMatrixKHR,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub accelerationStructureReference: u64,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureMatrixMotionInstanceNV() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureMatrixMotionInstanceNV>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureMatrixMotionInstanceNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureMatrixMotionInstanceNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureMatrixMotionInstanceNV)
        )
    );
    fn test_field_transformT0() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkAccelerationStructureMatrixMotionInstanceNV > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformT0) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMatrixMotionInstanceNV),
                "::",
                stringify!(transformT0)
            )
        );
    }
    test_field_transformT0();
    fn test_field_transformT1() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkAccelerationStructureMatrixMotionInstanceNV > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformT1) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMatrixMotionInstanceNV),
                "::",
                stringify!(transformT1)
            )
        );
    }
    test_field_transformT1();
    fn test_field_accelerationStructureReference() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkAccelerationStructureMatrixMotionInstanceNV > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructureReference) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMatrixMotionInstanceNV),
                "::",
                stringify!(accelerationStructureReference)
            )
        );
    }
    test_field_accelerationStructureReference();
}
impl VkAccelerationStructureMatrixMotionInstanceNV {
    #[inline]
    pub fn instanceCustomIndex(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_instanceCustomIndex(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn instanceShaderBindingTableRecordOffset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_instanceShaderBindingTableRecordOffset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> VkGeometryInstanceFlagsKHR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: VkGeometryInstanceFlagsKHR) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        instanceCustomIndex: u32,
        mask: u32,
        instanceShaderBindingTableRecordOffset: u32,
        flags: VkGeometryInstanceFlagsKHR,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let instanceCustomIndex: u32 = unsafe { ::std::mem::transmute(instanceCustomIndex) };
            instanceCustomIndex as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let mask: u32 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let instanceShaderBindingTableRecordOffset: u32 =
                unsafe { ::std::mem::transmute(instanceShaderBindingTableRecordOffset) };
            instanceShaderBindingTableRecordOffset as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkSRTDataNV {
    pub sx: f32,
    pub a: f32,
    pub b: f32,
    pub pvx: f32,
    pub sy: f32,
    pub c: f32,
    pub pvy: f32,
    pub sz: f32,
    pub pvz: f32,
    pub qx: f32,
    pub qy: f32,
    pub qz: f32,
    pub qw: f32,
    pub tx: f32,
    pub ty: f32,
    pub tz: f32,
}
#[test]
fn bindgen_test_layout_VkSRTDataNV() {
    assert_eq!(
        ::std::mem::size_of::<VkSRTDataNV>(),
        64usize,
        concat!("Size of: ", stringify!(VkSRTDataNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSRTDataNV>(),
        4usize,
        concat!("Alignment of ", stringify!(VkSRTDataNV))
    );
    fn test_field_sx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSRTDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sx) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSRTDataNV),
                "::",
                stringify!(sx)
            )
        );
    }
    test_field_sx();
    fn test_field_a() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSRTDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSRTDataNV),
                "::",
                stringify!(a)
            )
        );
    }
    test_field_a();
    fn test_field_b() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSRTDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSRTDataNV),
                "::",
                stringify!(b)
            )
        );
    }
    test_field_b();
    fn test_field_pvx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSRTDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pvx) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSRTDataNV),
                "::",
                stringify!(pvx)
            )
        );
    }
    test_field_pvx();
    fn test_field_sy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSRTDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sy) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSRTDataNV),
                "::",
                stringify!(sy)
            )
        );
    }
    test_field_sy();
    fn test_field_c() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSRTDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSRTDataNV),
                "::",
                stringify!(c)
            )
        );
    }
    test_field_c();
    fn test_field_pvy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSRTDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pvy) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSRTDataNV),
                "::",
                stringify!(pvy)
            )
        );
    }
    test_field_pvy();
    fn test_field_sz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSRTDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sz) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSRTDataNV),
                "::",
                stringify!(sz)
            )
        );
    }
    test_field_sz();
    fn test_field_pvz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSRTDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pvz) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSRTDataNV),
                "::",
                stringify!(pvz)
            )
        );
    }
    test_field_pvz();
    fn test_field_qx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSRTDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qx) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSRTDataNV),
                "::",
                stringify!(qx)
            )
        );
    }
    test_field_qx();
    fn test_field_qy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSRTDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qy) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSRTDataNV),
                "::",
                stringify!(qy)
            )
        );
    }
    test_field_qy();
    fn test_field_qz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSRTDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qz) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSRTDataNV),
                "::",
                stringify!(qz)
            )
        );
    }
    test_field_qz();
    fn test_field_qw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSRTDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qw) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSRTDataNV),
                "::",
                stringify!(qw)
            )
        );
    }
    test_field_qw();
    fn test_field_tx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSRTDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tx) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSRTDataNV),
                "::",
                stringify!(tx)
            )
        );
    }
    test_field_tx();
    fn test_field_ty() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSRTDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ty) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSRTDataNV),
                "::",
                stringify!(ty)
            )
        );
    }
    test_field_ty();
    fn test_field_tz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSRTDataNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tz) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSRTDataNV),
                "::",
                stringify!(tz)
            )
        );
    }
    test_field_tz();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkAccelerationStructureSRTMotionInstanceNV {
    pub transformT0: VkSRTDataNV,
    pub transformT1: VkSRTDataNV,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub accelerationStructureReference: u64,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureSRTMotionInstanceNV() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureSRTMotionInstanceNV>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureSRTMotionInstanceNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureSRTMotionInstanceNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureSRTMotionInstanceNV)
        )
    );
    fn test_field_transformT0() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureSRTMotionInstanceNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformT0) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureSRTMotionInstanceNV),
                "::",
                stringify!(transformT0)
            )
        );
    }
    test_field_transformT0();
    fn test_field_transformT1() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureSRTMotionInstanceNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformT1) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureSRTMotionInstanceNV),
                "::",
                stringify!(transformT1)
            )
        );
    }
    test_field_transformT1();
    fn test_field_accelerationStructureReference() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureSRTMotionInstanceNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructureReference) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureSRTMotionInstanceNV),
                "::",
                stringify!(accelerationStructureReference)
            )
        );
    }
    test_field_accelerationStructureReference();
}
impl VkAccelerationStructureSRTMotionInstanceNV {
    #[inline]
    pub fn instanceCustomIndex(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_instanceCustomIndex(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn mask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn instanceShaderBindingTableRecordOffset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_instanceShaderBindingTableRecordOffset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> VkGeometryInstanceFlagsKHR {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: VkGeometryInstanceFlagsKHR) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        instanceCustomIndex: u32,
        mask: u32,
        instanceShaderBindingTableRecordOffset: u32,
        flags: VkGeometryInstanceFlagsKHR,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let instanceCustomIndex: u32 = unsafe { ::std::mem::transmute(instanceCustomIndex) };
            instanceCustomIndex as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let mask: u32 = unsafe { ::std::mem::transmute(mask) };
            mask as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let instanceShaderBindingTableRecordOffset: u32 =
                unsafe { ::std::mem::transmute(instanceShaderBindingTableRecordOffset) };
            instanceShaderBindingTableRecordOffset as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkAccelerationStructureMotionInstanceDataNV {
    pub staticInstance: VkAccelerationStructureInstanceKHR,
    pub matrixMotionInstance: VkAccelerationStructureMatrixMotionInstanceNV,
    pub srtMotionInstance: VkAccelerationStructureSRTMotionInstanceNV,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureMotionInstanceDataNV() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureMotionInstanceDataNV>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureMotionInstanceDataNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureMotionInstanceDataNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureMotionInstanceDataNV)
        )
    );
    fn test_field_staticInstance() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureMotionInstanceDataNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).staticInstance) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMotionInstanceDataNV),
                "::",
                stringify!(staticInstance)
            )
        );
    }
    test_field_staticInstance();
    fn test_field_matrixMotionInstance() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureMotionInstanceDataNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).matrixMotionInstance) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMotionInstanceDataNV),
                "::",
                stringify!(matrixMotionInstance)
            )
        );
    }
    test_field_matrixMotionInstance();
    fn test_field_srtMotionInstance() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureMotionInstanceDataNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srtMotionInstance) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMotionInstanceDataNV),
                "::",
                stringify!(srtMotionInstance)
            )
        );
    }
    test_field_srtMotionInstance();
}
impl Default for VkAccelerationStructureMotionInstanceDataNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureMotionInstanceNV {
    pub type_: VkAccelerationStructureMotionInstanceTypeNV,
    pub flags: VkAccelerationStructureMotionInstanceFlagsNV,
    pub data: VkAccelerationStructureMotionInstanceDataNV,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureMotionInstanceNV() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureMotionInstanceNV>(),
        152usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureMotionInstanceNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureMotionInstanceNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureMotionInstanceNV)
        )
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureMotionInstanceNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMotionInstanceNV),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureMotionInstanceNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMotionInstanceNV),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureMotionInstanceNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureMotionInstanceNV),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
impl Default for VkAccelerationStructureMotionInstanceNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceRayTracingMotionBlurFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub rayTracingMotionBlur: VkBool32,
    pub rayTracingMotionBlurPipelineTraceRaysIndirect: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceRayTracingMotionBlurFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceRayTracingMotionBlurFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingMotionBlurFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingMotionBlurFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_rayTracingMotionBlur() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingMotionBlurFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rayTracingMotionBlur) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV),
                "::",
                stringify!(rayTracingMotionBlur)
            )
        );
    }
    test_field_rayTracingMotionBlur();
    fn test_field_rayTracingMotionBlurPipelineTraceRaysIndirect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingMotionBlurFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rayTracingMotionBlurPipelineTraceRaysIndirect) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV),
                "::",
                stringify!(rayTracingMotionBlurPipelineTraceRaysIndirect)
            )
        );
    }
    test_field_rayTracingMotionBlurPipelineTraceRaysIndirect();
}
impl Default for VkPhysicalDeviceRayTracingMotionBlurFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub ycbcr2plane444Formats: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_ycbcr2plane444Formats() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ycbcr2plane444Formats) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT),
                "::",
                stringify!(ycbcr2plane444Formats)
            )
        );
    }
    test_field_ycbcr2plane444Formats();
}
impl Default for VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentDensityMap2FeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub fragmentDensityMapDeferred: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMap2FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMap2FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_fragmentDensityMapDeferred() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMap2FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentDensityMapDeferred) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT),
                "::",
                stringify!(fragmentDensityMapDeferred)
            )
        );
    }
    test_field_fragmentDensityMapDeferred();
}
impl Default for VkPhysicalDeviceFragmentDensityMap2FeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentDensityMap2PropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub subsampledLoads: VkBool32,
    pub subsampledCoarseReconstructionEarlyAccess: VkBool32,
    pub maxSubsampledArrayLayers: u32,
    pub maxDescriptorSetSubsampledSamplers: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMap2PropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMap2PropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_subsampledLoads() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMap2PropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subsampledLoads) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT),
                "::",
                stringify!(subsampledLoads)
            )
        );
    }
    test_field_subsampledLoads();
    fn test_field_subsampledCoarseReconstructionEarlyAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMap2PropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subsampledCoarseReconstructionEarlyAccess) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT),
                "::",
                stringify!(subsampledCoarseReconstructionEarlyAccess)
            )
        );
    }
    test_field_subsampledCoarseReconstructionEarlyAccess();
    fn test_field_maxSubsampledArrayLayers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMap2PropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSubsampledArrayLayers) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT),
                "::",
                stringify!(maxSubsampledArrayLayers)
            )
        );
    }
    test_field_maxSubsampledArrayLayers();
    fn test_field_maxDescriptorSetSubsampledSamplers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMap2PropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetSubsampledSamplers) as usize
                    - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT),
                "::",
                stringify!(maxDescriptorSetSubsampledSamplers)
            )
        );
    }
    test_field_maxDescriptorSetSubsampledSamplers();
}
impl Default for VkPhysicalDeviceFragmentDensityMap2PropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCopyCommandTransformInfoQCOM {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub transform: VkSurfaceTransformFlagBitsKHR,
}
#[test]
fn bindgen_test_layout_VkCopyCommandTransformInfoQCOM() {
    assert_eq!(
        ::std::mem::size_of::<VkCopyCommandTransformInfoQCOM>(),
        24usize,
        concat!("Size of: ", stringify!(VkCopyCommandTransformInfoQCOM))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCopyCommandTransformInfoQCOM>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCopyCommandTransformInfoQCOM))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyCommandTransformInfoQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyCommandTransformInfoQCOM),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyCommandTransformInfoQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyCommandTransformInfoQCOM),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_transform() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyCommandTransformInfoQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transform) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyCommandTransformInfoQCOM),
                "::",
                stringify!(transform)
            )
        );
    }
    test_field_transform();
}
impl Default for VkCopyCommandTransformInfoQCOM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPhysicalDeviceImageRobustnessFeaturesEXT = VkPhysicalDeviceImageRobustnessFeatures;
pub const VK_IMAGE_COMPRESSION_DEFAULT_EXT: VkImageCompressionFlagBitsEXT = 0;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT: VkImageCompressionFlagBitsEXT = 1;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT: VkImageCompressionFlagBitsEXT = 2;
pub const VK_IMAGE_COMPRESSION_DISABLED_EXT: VkImageCompressionFlagBitsEXT = 4;
pub const VK_IMAGE_COMPRESSION_FLAG_BITS_MAX_ENUM_EXT: VkImageCompressionFlagBitsEXT = 2147483647;
pub type VkImageCompressionFlagBitsEXT = ::std::os::raw::c_int;
pub type VkImageCompressionFlagsEXT = VkFlags;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT: VkImageCompressionFixedRateFlagBitsEXT = 0;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT = 1;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT = 2;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT = 4;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT = 8;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT = 16;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT = 32;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT = 64;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    128;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    256;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    512;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    1024;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    2048;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    4096;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    8192;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    16384;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    32768;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    65536;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    131072;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    262144;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    524288;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    1048576;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    2097152;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    4194304;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT: VkImageCompressionFixedRateFlagBitsEXT =
    8388608;
pub const VK_IMAGE_COMPRESSION_FIXED_RATE_FLAG_BITS_MAX_ENUM_EXT:
    VkImageCompressionFixedRateFlagBitsEXT = 2147483647;
pub type VkImageCompressionFixedRateFlagBitsEXT = ::std::os::raw::c_int;
pub type VkImageCompressionFixedRateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceImageCompressionControlFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub imageCompressionControl: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceImageCompressionControlFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceImageCompressionControlFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceImageCompressionControlFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceImageCompressionControlFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceImageCompressionControlFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceImageCompressionControlFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageCompressionControlFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceImageCompressionControlFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageCompressionControlFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_imageCompressionControl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceImageCompressionControlFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageCompressionControl) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageCompressionControlFeaturesEXT),
                "::",
                stringify!(imageCompressionControl)
            )
        );
    }
    test_field_imageCompressionControl();
}
impl Default for VkPhysicalDeviceImageCompressionControlFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageCompressionControlEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkImageCompressionFlagsEXT,
    pub compressionControlPlaneCount: u32,
    pub pFixedRateFlags: *mut VkImageCompressionFixedRateFlagsEXT,
}
#[test]
fn bindgen_test_layout_VkImageCompressionControlEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkImageCompressionControlEXT>(),
        32usize,
        concat!("Size of: ", stringify!(VkImageCompressionControlEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageCompressionControlEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageCompressionControlEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCompressionControlEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCompressionControlEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCompressionControlEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCompressionControlEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCompressionControlEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCompressionControlEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_compressionControlPlaneCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCompressionControlEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compressionControlPlaneCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCompressionControlEXT),
                "::",
                stringify!(compressionControlPlaneCount)
            )
        );
    }
    test_field_compressionControlPlaneCount();
    fn test_field_pFixedRateFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCompressionControlEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pFixedRateFlags) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCompressionControlEXT),
                "::",
                stringify!(pFixedRateFlags)
            )
        );
    }
    test_field_pFixedRateFlags();
}
impl Default for VkImageCompressionControlEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubresourceLayout2EXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub subresourceLayout: VkSubresourceLayout,
}
#[test]
fn bindgen_test_layout_VkSubresourceLayout2EXT() {
    assert_eq!(
        ::std::mem::size_of::<VkSubresourceLayout2EXT>(),
        56usize,
        concat!("Size of: ", stringify!(VkSubresourceLayout2EXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubresourceLayout2EXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkSubresourceLayout2EXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubresourceLayout2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubresourceLayout2EXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubresourceLayout2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubresourceLayout2EXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_subresourceLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkSubresourceLayout2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subresourceLayout) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubresourceLayout2EXT),
                "::",
                stringify!(subresourceLayout)
            )
        );
    }
    test_field_subresourceLayout();
}
impl Default for VkSubresourceLayout2EXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageSubresource2EXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub imageSubresource: VkImageSubresource,
}
#[test]
fn bindgen_test_layout_VkImageSubresource2EXT() {
    assert_eq!(
        ::std::mem::size_of::<VkImageSubresource2EXT>(),
        32usize,
        concat!("Size of: ", stringify!(VkImageSubresource2EXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageSubresource2EXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageSubresource2EXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSubresource2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSubresource2EXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSubresource2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSubresource2EXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_imageSubresource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageSubresource2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageSubresource) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageSubresource2EXT),
                "::",
                stringify!(imageSubresource)
            )
        );
    }
    test_field_imageSubresource();
}
impl Default for VkImageSubresource2EXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageCompressionPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub imageCompressionFlags: VkImageCompressionFlagsEXT,
    pub imageCompressionFixedRateFlags: VkImageCompressionFixedRateFlagsEXT,
}
#[test]
fn bindgen_test_layout_VkImageCompressionPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkImageCompressionPropertiesEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkImageCompressionPropertiesEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageCompressionPropertiesEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageCompressionPropertiesEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCompressionPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCompressionPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCompressionPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCompressionPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_imageCompressionFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCompressionPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageCompressionFlags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCompressionPropertiesEXT),
                "::",
                stringify!(imageCompressionFlags)
            )
        );
    }
    test_field_imageCompressionFlags();
    fn test_field_imageCompressionFixedRateFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageCompressionPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageCompressionFixedRateFlags) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageCompressionPropertiesEXT),
                "::",
                stringify!(imageCompressionFixedRateFlags)
            )
        );
    }
    test_field_imageCompressionFixedRateFlags();
}
impl Default for VkImageCompressionPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetImageSubresourceLayout2EXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        image: VkImage,
        pSubresource: *const VkImageSubresource2EXT,
        pLayout: *mut VkSubresourceLayout2EXT,
    ),
>;
extern "C" {
    pub fn vkGetImageSubresourceLayout2EXT(
        device: VkDevice,
        image: VkImage,
        pSubresource: *const VkImageSubresource2EXT,
        pLayout: *mut VkSubresourceLayout2EXT,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub attachmentFeedbackLoopLayout: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_attachmentFeedbackLoopLayout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attachmentFeedbackLoopLayout) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT),
                "::",
                stringify!(attachmentFeedbackLoopLayout)
            )
        );
    }
    test_field_attachmentFeedbackLoopLayout();
}
impl Default for VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevice4444FormatsFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub formatA4R4G4B4: VkBool32,
    pub formatA4B4G4R4: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevice4444FormatsFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevice4444FormatsFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevice4444FormatsFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevice4444FormatsFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevice4444FormatsFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevice4444FormatsFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevice4444FormatsFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevice4444FormatsFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevice4444FormatsFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_formatA4R4G4B4() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevice4444FormatsFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).formatA4R4G4B4) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevice4444FormatsFeaturesEXT),
                "::",
                stringify!(formatA4R4G4B4)
            )
        );
    }
    test_field_formatA4R4G4B4();
    fn test_field_formatA4B4G4R4() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDevice4444FormatsFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).formatA4B4G4R4) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevice4444FormatsFeaturesEXT),
                "::",
                stringify!(formatA4B4G4R4)
            )
        );
    }
    test_field_formatA4B4G4R4();
}
impl Default for VkPhysicalDevice4444FormatsFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT: VkDeviceFaultAddressTypeEXT = 0;
pub const VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT: VkDeviceFaultAddressTypeEXT = 1;
pub const VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT: VkDeviceFaultAddressTypeEXT = 2;
pub const VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT: VkDeviceFaultAddressTypeEXT = 3;
pub const VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT:
    VkDeviceFaultAddressTypeEXT = 4;
pub const VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT:
    VkDeviceFaultAddressTypeEXT = 5;
pub const VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT: VkDeviceFaultAddressTypeEXT =
    6;
pub const VK_DEVICE_FAULT_ADDRESS_TYPE_MAX_ENUM_EXT: VkDeviceFaultAddressTypeEXT = 2147483647;
pub type VkDeviceFaultAddressTypeEXT = ::std::os::raw::c_int;
pub const VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT:
    VkDeviceFaultVendorBinaryHeaderVersionEXT = 1;
pub const VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_MAX_ENUM_EXT:
    VkDeviceFaultVendorBinaryHeaderVersionEXT = 2147483647;
pub type VkDeviceFaultVendorBinaryHeaderVersionEXT = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFaultFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub deviceFault: VkBool32,
    pub deviceFaultVendorBinary: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFaultFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFaultFeaturesEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceFaultFeaturesEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFaultFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFaultFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFaultFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFaultFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFaultFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFaultFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_deviceFault() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFaultFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceFault) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFaultFeaturesEXT),
                "::",
                stringify!(deviceFault)
            )
        );
    }
    test_field_deviceFault();
    fn test_field_deviceFaultVendorBinary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceFaultFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceFaultVendorBinary) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFaultFeaturesEXT),
                "::",
                stringify!(deviceFaultVendorBinary)
            )
        );
    }
    test_field_deviceFaultVendorBinary();
}
impl Default for VkPhysicalDeviceFaultFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceFaultCountsEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub addressInfoCount: u32,
    pub vendorInfoCount: u32,
    pub vendorBinarySize: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkDeviceFaultCountsEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceFaultCountsEXT>(),
        32usize,
        concat!("Size of: ", stringify!(VkDeviceFaultCountsEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceFaultCountsEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceFaultCountsEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultCountsEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultCountsEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultCountsEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultCountsEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_addressInfoCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultCountsEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).addressInfoCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultCountsEXT),
                "::",
                stringify!(addressInfoCount)
            )
        );
    }
    test_field_addressInfoCount();
    fn test_field_vendorInfoCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultCountsEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vendorInfoCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultCountsEXT),
                "::",
                stringify!(vendorInfoCount)
            )
        );
    }
    test_field_vendorInfoCount();
    fn test_field_vendorBinarySize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultCountsEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vendorBinarySize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultCountsEXT),
                "::",
                stringify!(vendorBinarySize)
            )
        );
    }
    test_field_vendorBinarySize();
}
impl Default for VkDeviceFaultCountsEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceFaultAddressInfoEXT {
    pub addressType: VkDeviceFaultAddressTypeEXT,
    pub reportedAddress: VkDeviceAddress,
    pub addressPrecision: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkDeviceFaultAddressInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceFaultAddressInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkDeviceFaultAddressInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceFaultAddressInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceFaultAddressInfoEXT))
    );
    fn test_field_addressType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultAddressInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).addressType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultAddressInfoEXT),
                "::",
                stringify!(addressType)
            )
        );
    }
    test_field_addressType();
    fn test_field_reportedAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultAddressInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reportedAddress) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultAddressInfoEXT),
                "::",
                stringify!(reportedAddress)
            )
        );
    }
    test_field_reportedAddress();
    fn test_field_addressPrecision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultAddressInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).addressPrecision) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultAddressInfoEXT),
                "::",
                stringify!(addressPrecision)
            )
        );
    }
    test_field_addressPrecision();
}
impl Default for VkDeviceFaultAddressInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceFaultVendorInfoEXT {
    pub description: [::std::os::raw::c_char; 256usize],
    pub vendorFaultCode: u64,
    pub vendorFaultData: u64,
}
#[test]
fn bindgen_test_layout_VkDeviceFaultVendorInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceFaultVendorInfoEXT>(),
        272usize,
        concat!("Size of: ", stringify!(VkDeviceFaultVendorInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceFaultVendorInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceFaultVendorInfoEXT))
    );
    fn test_field_description() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultVendorInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultVendorInfoEXT),
                "::",
                stringify!(description)
            )
        );
    }
    test_field_description();
    fn test_field_vendorFaultCode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultVendorInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vendorFaultCode) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultVendorInfoEXT),
                "::",
                stringify!(vendorFaultCode)
            )
        );
    }
    test_field_vendorFaultCode();
    fn test_field_vendorFaultData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultVendorInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vendorFaultData) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultVendorInfoEXT),
                "::",
                stringify!(vendorFaultData)
            )
        );
    }
    test_field_vendorFaultData();
}
impl Default for VkDeviceFaultVendorInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceFaultInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub description: [::std::os::raw::c_char; 256usize],
    pub pAddressInfos: *mut VkDeviceFaultAddressInfoEXT,
    pub pVendorInfos: *mut VkDeviceFaultVendorInfoEXT,
    pub pVendorBinaryData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkDeviceFaultInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceFaultInfoEXT>(),
        296usize,
        concat!("Size of: ", stringify!(VkDeviceFaultInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceFaultInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceFaultInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_description() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultInfoEXT),
                "::",
                stringify!(description)
            )
        );
    }
    test_field_description();
    fn test_field_pAddressInfos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pAddressInfos) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultInfoEXT),
                "::",
                stringify!(pAddressInfos)
            )
        );
    }
    test_field_pAddressInfos();
    fn test_field_pVendorInfos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pVendorInfos) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultInfoEXT),
                "::",
                stringify!(pVendorInfos)
            )
        );
    }
    test_field_pVendorInfos();
    fn test_field_pVendorBinaryData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceFaultInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pVendorBinaryData) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultInfoEXT),
                "::",
                stringify!(pVendorBinaryData)
            )
        );
    }
    test_field_pVendorBinaryData();
}
impl Default for VkDeviceFaultInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceFaultVendorBinaryHeaderVersionOneEXT {
    pub headerSize: u32,
    pub headerVersion: VkDeviceFaultVendorBinaryHeaderVersionEXT,
    pub vendorID: u32,
    pub deviceID: u32,
    pub driverVersion: u32,
    pub pipelineCacheUUID: [u8; 16usize],
    pub applicationNameOffset: u32,
    pub applicationVersion: u32,
    pub engineNameOffset: u32,
}
#[test]
fn bindgen_test_layout_VkDeviceFaultVendorBinaryHeaderVersionOneEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceFaultVendorBinaryHeaderVersionOneEXT>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkDeviceFaultVendorBinaryHeaderVersionOneEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceFaultVendorBinaryHeaderVersionOneEXT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceFaultVendorBinaryHeaderVersionOneEXT)
        )
    );
    fn test_field_headerSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceFaultVendorBinaryHeaderVersionOneEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).headerSize) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultVendorBinaryHeaderVersionOneEXT),
                "::",
                stringify!(headerSize)
            )
        );
    }
    test_field_headerSize();
    fn test_field_headerVersion() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceFaultVendorBinaryHeaderVersionOneEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).headerVersion) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultVendorBinaryHeaderVersionOneEXT),
                "::",
                stringify!(headerVersion)
            )
        );
    }
    test_field_headerVersion();
    fn test_field_vendorID() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceFaultVendorBinaryHeaderVersionOneEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vendorID) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultVendorBinaryHeaderVersionOneEXT),
                "::",
                stringify!(vendorID)
            )
        );
    }
    test_field_vendorID();
    fn test_field_deviceID() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceFaultVendorBinaryHeaderVersionOneEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceID) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultVendorBinaryHeaderVersionOneEXT),
                "::",
                stringify!(deviceID)
            )
        );
    }
    test_field_deviceID();
    fn test_field_driverVersion() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceFaultVendorBinaryHeaderVersionOneEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).driverVersion) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultVendorBinaryHeaderVersionOneEXT),
                "::",
                stringify!(driverVersion)
            )
        );
    }
    test_field_driverVersion();
    fn test_field_pipelineCacheUUID() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceFaultVendorBinaryHeaderVersionOneEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineCacheUUID) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultVendorBinaryHeaderVersionOneEXT),
                "::",
                stringify!(pipelineCacheUUID)
            )
        );
    }
    test_field_pipelineCacheUUID();
    fn test_field_applicationNameOffset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceFaultVendorBinaryHeaderVersionOneEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).applicationNameOffset) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultVendorBinaryHeaderVersionOneEXT),
                "::",
                stringify!(applicationNameOffset)
            )
        );
    }
    test_field_applicationNameOffset();
    fn test_field_applicationVersion() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceFaultVendorBinaryHeaderVersionOneEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).applicationVersion) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultVendorBinaryHeaderVersionOneEXT),
                "::",
                stringify!(applicationVersion)
            )
        );
    }
    test_field_applicationVersion();
    fn test_field_engineNameOffset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceFaultVendorBinaryHeaderVersionOneEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).engineNameOffset) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceFaultVendorBinaryHeaderVersionOneEXT),
                "::",
                stringify!(engineNameOffset)
            )
        );
    }
    test_field_engineNameOffset();
}
impl Default for VkDeviceFaultVendorBinaryHeaderVersionOneEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetDeviceFaultInfoEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pFaultCounts: *mut VkDeviceFaultCountsEXT,
        pFaultInfo: *mut VkDeviceFaultInfoEXT,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetDeviceFaultInfoEXT(
        device: VkDevice,
        pFaultCounts: *mut VkDeviceFaultCountsEXT,
        pFaultInfo: *mut VkDeviceFaultInfoEXT,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub rasterizationOrderColorAttachmentAccess: VkBool32,
    pub rasterizationOrderDepthAttachmentAccess: VkBool32,
    pub rasterizationOrderStencilAttachmentAccess: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_rasterizationOrderColorAttachmentAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rasterizationOrderColorAttachmentAccess) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT),
                "::",
                stringify!(rasterizationOrderColorAttachmentAccess)
            )
        );
    }
    test_field_rasterizationOrderColorAttachmentAccess();
    fn test_field_rasterizationOrderDepthAttachmentAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rasterizationOrderDepthAttachmentAccess) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT),
                "::",
                stringify!(rasterizationOrderDepthAttachmentAccess)
            )
        );
    }
    test_field_rasterizationOrderDepthAttachmentAccess();
    fn test_field_rasterizationOrderStencilAttachmentAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rasterizationOrderStencilAttachmentAccess) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT),
                "::",
                stringify!(rasterizationOrderStencilAttachmentAccess)
            )
        );
    }
    test_field_rasterizationOrderStencilAttachmentAccess();
}
impl Default for VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM =
    VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub formatRgba10x6WithoutYCbCrSampler: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_formatRgba10x6WithoutYCbCrSampler() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).formatRgba10x6WithoutYCbCrSampler) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT),
                "::",
                stringify!(formatRgba10x6WithoutYCbCrSampler)
            )
        );
    }
    test_field_formatRgba10x6WithoutYCbCrSampler();
}
impl Default for VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub mutableDescriptorType: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_mutableDescriptorType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mutableDescriptorType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT),
                "::",
                stringify!(mutableDescriptorType)
            )
        );
    }
    test_field_mutableDescriptorType();
}
impl Default for VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE =
    VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMutableDescriptorTypeListEXT {
    pub descriptorTypeCount: u32,
    pub pDescriptorTypes: *const VkDescriptorType,
}
#[test]
fn bindgen_test_layout_VkMutableDescriptorTypeListEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMutableDescriptorTypeListEXT>(),
        16usize,
        concat!("Size of: ", stringify!(VkMutableDescriptorTypeListEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMutableDescriptorTypeListEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMutableDescriptorTypeListEXT))
    );
    fn test_field_descriptorTypeCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMutableDescriptorTypeListEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorTypeCount) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMutableDescriptorTypeListEXT),
                "::",
                stringify!(descriptorTypeCount)
            )
        );
    }
    test_field_descriptorTypeCount();
    fn test_field_pDescriptorTypes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMutableDescriptorTypeListEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDescriptorTypes) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMutableDescriptorTypeListEXT),
                "::",
                stringify!(pDescriptorTypes)
            )
        );
    }
    test_field_pDescriptorTypes();
}
impl Default for VkMutableDescriptorTypeListEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkMutableDescriptorTypeListVALVE = VkMutableDescriptorTypeListEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMutableDescriptorTypeCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub mutableDescriptorTypeListCount: u32,
    pub pMutableDescriptorTypeLists: *const VkMutableDescriptorTypeListEXT,
}
#[test]
fn bindgen_test_layout_VkMutableDescriptorTypeCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMutableDescriptorTypeCreateInfoEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkMutableDescriptorTypeCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkMutableDescriptorTypeCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkMutableDescriptorTypeCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkMutableDescriptorTypeCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMutableDescriptorTypeCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkMutableDescriptorTypeCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMutableDescriptorTypeCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_mutableDescriptorTypeListCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkMutableDescriptorTypeCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mutableDescriptorTypeListCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMutableDescriptorTypeCreateInfoEXT),
                "::",
                stringify!(mutableDescriptorTypeListCount)
            )
        );
    }
    test_field_mutableDescriptorTypeListCount();
    fn test_field_pMutableDescriptorTypeLists() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkMutableDescriptorTypeCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pMutableDescriptorTypeLists) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMutableDescriptorTypeCreateInfoEXT),
                "::",
                stringify!(pMutableDescriptorTypeLists)
            )
        );
    }
    test_field_pMutableDescriptorTypeLists();
}
impl Default for VkMutableDescriptorTypeCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkMutableDescriptorTypeCreateInfoVALVE = VkMutableDescriptorTypeCreateInfoEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub vertexInputDynamicState: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_vertexInputDynamicState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexInputDynamicState) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT),
                "::",
                stringify!(vertexInputDynamicState)
            )
        );
    }
    test_field_vertexInputDynamicState();
}
impl Default for VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkVertexInputBindingDescription2EXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub binding: u32,
    pub stride: u32,
    pub inputRate: VkVertexInputRate,
    pub divisor: u32,
}
#[test]
fn bindgen_test_layout_VkVertexInputBindingDescription2EXT() {
    assert_eq!(
        ::std::mem::size_of::<VkVertexInputBindingDescription2EXT>(),
        32usize,
        concat!("Size of: ", stringify!(VkVertexInputBindingDescription2EXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkVertexInputBindingDescription2EXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkVertexInputBindingDescription2EXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkVertexInputBindingDescription2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputBindingDescription2EXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkVertexInputBindingDescription2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputBindingDescription2EXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_binding() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkVertexInputBindingDescription2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binding) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputBindingDescription2EXT),
                "::",
                stringify!(binding)
            )
        );
    }
    test_field_binding();
    fn test_field_stride() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkVertexInputBindingDescription2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputBindingDescription2EXT),
                "::",
                stringify!(stride)
            )
        );
    }
    test_field_stride();
    fn test_field_inputRate() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkVertexInputBindingDescription2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inputRate) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputBindingDescription2EXT),
                "::",
                stringify!(inputRate)
            )
        );
    }
    test_field_inputRate();
    fn test_field_divisor() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkVertexInputBindingDescription2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).divisor) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputBindingDescription2EXT),
                "::",
                stringify!(divisor)
            )
        );
    }
    test_field_divisor();
}
impl Default for VkVertexInputBindingDescription2EXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkVertexInputAttributeDescription2EXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub location: u32,
    pub binding: u32,
    pub format: VkFormat,
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_VkVertexInputAttributeDescription2EXT() {
    assert_eq!(
        ::std::mem::size_of::<VkVertexInputAttributeDescription2EXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkVertexInputAttributeDescription2EXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkVertexInputAttributeDescription2EXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkVertexInputAttributeDescription2EXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkVertexInputAttributeDescription2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputAttributeDescription2EXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkVertexInputAttributeDescription2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputAttributeDescription2EXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_location() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkVertexInputAttributeDescription2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputAttributeDescription2EXT),
                "::",
                stringify!(location)
            )
        );
    }
    test_field_location();
    fn test_field_binding() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkVertexInputAttributeDescription2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binding) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputAttributeDescription2EXT),
                "::",
                stringify!(binding)
            )
        );
    }
    test_field_binding();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkVertexInputAttributeDescription2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputAttributeDescription2EXT),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkVertexInputAttributeDescription2EXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkVertexInputAttributeDescription2EXT),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
}
impl Default for VkVertexInputAttributeDescription2EXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdSetVertexInputEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        vertexBindingDescriptionCount: u32,
        pVertexBindingDescriptions: *const VkVertexInputBindingDescription2EXT,
        vertexAttributeDescriptionCount: u32,
        pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription2EXT,
    ),
>;
extern "C" {
    pub fn vkCmdSetVertexInputEXT(
        commandBuffer: VkCommandBuffer,
        vertexBindingDescriptionCount: u32,
        pVertexBindingDescriptions: *const VkVertexInputBindingDescription2EXT,
        vertexAttributeDescriptionCount: u32,
        pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription2EXT,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDrmPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub hasPrimary: VkBool32,
    pub hasRender: VkBool32,
    pub primaryMajor: i64,
    pub primaryMinor: i64,
    pub renderMajor: i64,
    pub renderMinor: i64,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDrmPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDrmPropertiesEXT>(),
        56usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceDrmPropertiesEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDrmPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDrmPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceDrmPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDrmPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceDrmPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDrmPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_hasPrimary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceDrmPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hasPrimary) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDrmPropertiesEXT),
                "::",
                stringify!(hasPrimary)
            )
        );
    }
    test_field_hasPrimary();
    fn test_field_hasRender() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceDrmPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hasRender) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDrmPropertiesEXT),
                "::",
                stringify!(hasRender)
            )
        );
    }
    test_field_hasRender();
    fn test_field_primaryMajor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceDrmPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).primaryMajor) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDrmPropertiesEXT),
                "::",
                stringify!(primaryMajor)
            )
        );
    }
    test_field_primaryMajor();
    fn test_field_primaryMinor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceDrmPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).primaryMinor) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDrmPropertiesEXT),
                "::",
                stringify!(primaryMinor)
            )
        );
    }
    test_field_primaryMinor();
    fn test_field_renderMajor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceDrmPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).renderMajor) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDrmPropertiesEXT),
                "::",
                stringify!(renderMajor)
            )
        );
    }
    test_field_renderMajor();
    fn test_field_renderMinor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPhysicalDeviceDrmPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).renderMinor) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDrmPropertiesEXT),
                "::",
                stringify!(renderMinor)
            )
        );
    }
    test_field_renderMinor();
}
impl Default for VkPhysicalDeviceDrmPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT: VkDeviceAddressBindingTypeEXT = 0;
pub const VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT: VkDeviceAddressBindingTypeEXT = 1;
pub const VK_DEVICE_ADDRESS_BINDING_TYPE_MAX_ENUM_EXT: VkDeviceAddressBindingTypeEXT = 2147483647;
pub type VkDeviceAddressBindingTypeEXT = ::std::os::raw::c_int;
pub const VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT: VkDeviceAddressBindingFlagBitsEXT = 1;
pub const VK_DEVICE_ADDRESS_BINDING_FLAG_BITS_MAX_ENUM_EXT: VkDeviceAddressBindingFlagBitsEXT =
    2147483647;
pub type VkDeviceAddressBindingFlagBitsEXT = ::std::os::raw::c_int;
pub type VkDeviceAddressBindingFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceAddressBindingReportFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub reportAddressBinding: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceAddressBindingReportFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceAddressBindingReportFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceAddressBindingReportFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceAddressBindingReportFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceAddressBindingReportFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAddressBindingReportFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAddressBindingReportFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAddressBindingReportFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAddressBindingReportFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_reportAddressBinding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAddressBindingReportFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reportAddressBinding) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAddressBindingReportFeaturesEXT),
                "::",
                stringify!(reportAddressBinding)
            )
        );
    }
    test_field_reportAddressBinding();
}
impl Default for VkPhysicalDeviceAddressBindingReportFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceAddressBindingCallbackDataEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub flags: VkDeviceAddressBindingFlagsEXT,
    pub baseAddress: VkDeviceAddress,
    pub size: VkDeviceSize,
    pub bindingType: VkDeviceAddressBindingTypeEXT,
}
#[test]
fn bindgen_test_layout_VkDeviceAddressBindingCallbackDataEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceAddressBindingCallbackDataEXT>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkDeviceAddressBindingCallbackDataEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceAddressBindingCallbackDataEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDeviceAddressBindingCallbackDataEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceAddressBindingCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceAddressBindingCallbackDataEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceAddressBindingCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceAddressBindingCallbackDataEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceAddressBindingCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceAddressBindingCallbackDataEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_baseAddress() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceAddressBindingCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).baseAddress) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceAddressBindingCallbackDataEXT),
                "::",
                stringify!(baseAddress)
            )
        );
    }
    test_field_baseAddress();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceAddressBindingCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceAddressBindingCallbackDataEXT),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_bindingType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDeviceAddressBindingCallbackDataEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bindingType) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceAddressBindingCallbackDataEXT),
                "::",
                stringify!(bindingType)
            )
        );
    }
    test_field_bindingType();
}
impl Default for VkDeviceAddressBindingCallbackDataEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDepthClipControlFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub depthClipControl: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDepthClipControlFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDepthClipControlFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDepthClipControlFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDepthClipControlFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDepthClipControlFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDepthClipControlFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDepthClipControlFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDepthClipControlFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDepthClipControlFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_depthClipControl() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDepthClipControlFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthClipControl) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDepthClipControlFeaturesEXT),
                "::",
                stringify!(depthClipControl)
            )
        );
    }
    test_field_depthClipControl();
}
impl Default for VkPhysicalDeviceDepthClipControlFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineViewportDepthClipControlCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub negativeOneToOne: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPipelineViewportDepthClipControlCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineViewportDepthClipControlCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineViewportDepthClipControlCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineViewportDepthClipControlCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineViewportDepthClipControlCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportDepthClipControlCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportDepthClipControlCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportDepthClipControlCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportDepthClipControlCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_negativeOneToOne() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineViewportDepthClipControlCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).negativeOneToOne) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineViewportDepthClipControlCreateInfoEXT),
                "::",
                stringify!(negativeOneToOne)
            )
        );
    }
    test_field_negativeOneToOne();
}
impl Default for VkPipelineViewportDepthClipControlCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub primitiveTopologyListRestart: VkBool32,
    pub primitiveTopologyPatchListRestart: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_primitiveTopologyListRestart() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).primitiveTopologyListRestart) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT),
                "::",
                stringify!(primitiveTopologyListRestart)
            )
        );
    }
    test_field_primitiveTopologyListRestart();
    fn test_field_primitiveTopologyPatchListRestart() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).primitiveTopologyPatchListRestart) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT),
                "::",
                stringify!(primitiveTopologyPatchListRestart)
            )
        );
    }
    test_field_primitiveTopologyPatchListRestart();
}
impl Default for VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassShadingPipelineCreateInfoHUAWEI {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub renderPass: VkRenderPass,
    pub subpass: u32,
}
#[test]
fn bindgen_test_layout_VkSubpassShadingPipelineCreateInfoHUAWEI() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassShadingPipelineCreateInfoHUAWEI>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkSubpassShadingPipelineCreateInfoHUAWEI)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassShadingPipelineCreateInfoHUAWEI>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSubpassShadingPipelineCreateInfoHUAWEI)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSubpassShadingPipelineCreateInfoHUAWEI>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassShadingPipelineCreateInfoHUAWEI),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSubpassShadingPipelineCreateInfoHUAWEI>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassShadingPipelineCreateInfoHUAWEI),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_renderPass() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSubpassShadingPipelineCreateInfoHUAWEI>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).renderPass) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassShadingPipelineCreateInfoHUAWEI),
                "::",
                stringify!(renderPass)
            )
        );
    }
    test_field_renderPass();
    fn test_field_subpass() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSubpassShadingPipelineCreateInfoHUAWEI>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subpass) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassShadingPipelineCreateInfoHUAWEI),
                "::",
                stringify!(subpass)
            )
        );
    }
    test_field_subpass();
}
impl Default for VkSubpassShadingPipelineCreateInfoHUAWEI {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSubpassShadingFeaturesHUAWEI {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub subpassShading: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSubpassShadingFeaturesHUAWEI() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSubpassShadingFeaturesHUAWEI>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSubpassShadingFeaturesHUAWEI>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSubpassShadingFeaturesHUAWEI>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSubpassShadingFeaturesHUAWEI>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_subpassShading() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceSubpassShadingFeaturesHUAWEI>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subpassShading) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI),
                "::",
                stringify!(subpassShading)
            )
        );
    }
    test_field_subpassShading();
}
impl Default for VkPhysicalDeviceSubpassShadingFeaturesHUAWEI {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSubpassShadingPropertiesHUAWEI {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxSubpassShadingWorkgroupSizeAspectRatio: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSubpassShadingPropertiesHUAWEI() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSubpassShadingPropertiesHUAWEI>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSubpassShadingPropertiesHUAWEI>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceSubpassShadingPropertiesHUAWEI,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceSubpassShadingPropertiesHUAWEI,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxSubpassShadingWorkgroupSizeAspectRatio() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceSubpassShadingPropertiesHUAWEI,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxSubpassShadingWorkgroupSizeAspectRatio) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI),
                "::",
                stringify!(maxSubpassShadingWorkgroupSizeAspectRatio)
            )
        );
    }
    test_field_maxSubpassShadingWorkgroupSizeAspectRatio();
}
impl Default for VkPhysicalDeviceSubpassShadingPropertiesHUAWEI {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        renderpass: VkRenderPass,
        pMaxWorkgroupSize: *mut VkExtent2D,
    ) -> VkResult,
>;
pub type PFN_vkCmdSubpassShadingHUAWEI =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer)>;
extern "C" {
    pub fn vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(
        device: VkDevice,
        renderpass: VkRenderPass,
        pMaxWorkgroupSize: *mut VkExtent2D,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdSubpassShadingHUAWEI(commandBuffer: VkCommandBuffer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceInvocationMaskFeaturesHUAWEI {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub invocationMask: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceInvocationMaskFeaturesHUAWEI>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceInvocationMaskFeaturesHUAWEI>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceInvocationMaskFeaturesHUAWEI>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceInvocationMaskFeaturesHUAWEI>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_invocationMask() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceInvocationMaskFeaturesHUAWEI>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).invocationMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI),
                "::",
                stringify!(invocationMask)
            )
        );
    }
    test_field_invocationMask();
}
impl Default for VkPhysicalDeviceInvocationMaskFeaturesHUAWEI {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdBindInvocationMaskHUAWEI = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        imageView: VkImageView,
        imageLayout: VkImageLayout,
    ),
>;
extern "C" {
    pub fn vkCmdBindInvocationMaskHUAWEI(
        commandBuffer: VkCommandBuffer,
        imageView: VkImageView,
        imageLayout: VkImageLayout,
    );
}
pub type VkRemoteAddressNV = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMemoryGetRemoteAddressInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub memory: VkDeviceMemory,
    pub handleType: VkExternalMemoryHandleTypeFlagBits,
}
#[test]
fn bindgen_test_layout_VkMemoryGetRemoteAddressInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkMemoryGetRemoteAddressInfoNV>(),
        32usize,
        concat!("Size of: ", stringify!(VkMemoryGetRemoteAddressInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMemoryGetRemoteAddressInfoNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMemoryGetRemoteAddressInfoNV))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryGetRemoteAddressInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryGetRemoteAddressInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryGetRemoteAddressInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryGetRemoteAddressInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_memory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryGetRemoteAddressInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryGetRemoteAddressInfoNV),
                "::",
                stringify!(memory)
            )
        );
    }
    test_field_memory();
    fn test_field_handleType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMemoryGetRemoteAddressInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).handleType) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMemoryGetRemoteAddressInfoNV),
                "::",
                stringify!(handleType)
            )
        );
    }
    test_field_handleType();
}
impl Default for VkMemoryGetRemoteAddressInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExternalMemoryRDMAFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub externalMemoryRDMA: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExternalMemoryRDMAFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExternalMemoryRDMAFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalMemoryRDMAFeaturesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalMemoryRDMAFeaturesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_externalMemoryRDMA() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceExternalMemoryRDMAFeaturesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).externalMemoryRDMA) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV),
                "::",
                stringify!(externalMemoryRDMA)
            )
        );
    }
    test_field_externalMemoryRDMA();
}
impl Default for VkPhysicalDeviceExternalMemoryRDMAFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetMemoryRemoteAddressNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pMemoryGetRemoteAddressInfo: *const VkMemoryGetRemoteAddressInfoNV,
        pAddress: *mut VkRemoteAddressNV,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetMemoryRemoteAddressNV(
        device: VkDevice,
        pMemoryGetRemoteAddressInfo: *const VkMemoryGetRemoteAddressInfoNV,
        pAddress: *mut VkRemoteAddressNV,
    ) -> VkResult;
}
pub type VkPipelineInfoEXT = VkPipelineInfoKHR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelinePropertiesIdentifierEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub pipelineIdentifier: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_VkPipelinePropertiesIdentifierEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelinePropertiesIdentifierEXT>(),
        32usize,
        concat!("Size of: ", stringify!(VkPipelinePropertiesIdentifierEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelinePropertiesIdentifierEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelinePropertiesIdentifierEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelinePropertiesIdentifierEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelinePropertiesIdentifierEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelinePropertiesIdentifierEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelinePropertiesIdentifierEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pipelineIdentifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelinePropertiesIdentifierEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineIdentifier) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelinePropertiesIdentifierEXT),
                "::",
                stringify!(pipelineIdentifier)
            )
        );
    }
    test_field_pipelineIdentifier();
}
impl Default for VkPipelinePropertiesIdentifierEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePipelinePropertiesFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub pipelinePropertiesIdentifier: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePipelinePropertiesFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePipelinePropertiesFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePipelinePropertiesFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePipelinePropertiesFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePipelinePropertiesFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDevicePipelinePropertiesFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelinePropertiesFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDevicePipelinePropertiesFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelinePropertiesFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pipelinePropertiesIdentifier() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDevicePipelinePropertiesFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelinePropertiesIdentifier) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelinePropertiesFeaturesEXT),
                "::",
                stringify!(pipelinePropertiesIdentifier)
            )
        );
    }
    test_field_pipelinePropertiesIdentifier();
}
impl Default for VkPhysicalDevicePipelinePropertiesFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetPipelinePropertiesEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pPipelineInfo: *const VkPipelineInfoEXT,
        pPipelineProperties: *mut VkBaseOutStructure,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetPipelinePropertiesEXT(
        device: VkDevice,
        pPipelineInfo: *const VkPipelineInfoEXT,
        pPipelineProperties: *mut VkBaseOutStructure,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub multisampledRenderToSingleSampled: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_multisampledRenderToSingleSampled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multisampledRenderToSingleSampled) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT),
                "::",
                stringify!(multisampledRenderToSingleSampled)
            )
        );
    }
    test_field_multisampledRenderToSingleSampled();
}
impl Default for VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassResolvePerformanceQueryEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub optimal: VkBool32,
}
#[test]
fn bindgen_test_layout_VkSubpassResolvePerformanceQueryEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassResolvePerformanceQueryEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkSubpassResolvePerformanceQueryEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassResolvePerformanceQueryEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSubpassResolvePerformanceQueryEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSubpassResolvePerformanceQueryEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassResolvePerformanceQueryEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSubpassResolvePerformanceQueryEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassResolvePerformanceQueryEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_optimal() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSubpassResolvePerformanceQueryEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).optimal) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassResolvePerformanceQueryEXT),
                "::",
                stringify!(optimal)
            )
        );
    }
    test_field_optimal();
}
impl Default for VkSubpassResolvePerformanceQueryEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMultisampledRenderToSingleSampledInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub multisampledRenderToSingleSampledEnable: VkBool32,
    pub rasterizationSamples: VkSampleCountFlagBits,
}
#[test]
fn bindgen_test_layout_VkMultisampledRenderToSingleSampledInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMultisampledRenderToSingleSampledInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkMultisampledRenderToSingleSampledInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkMultisampledRenderToSingleSampledInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkMultisampledRenderToSingleSampledInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkMultisampledRenderToSingleSampledInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMultisampledRenderToSingleSampledInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkMultisampledRenderToSingleSampledInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMultisampledRenderToSingleSampledInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_multisampledRenderToSingleSampledEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkMultisampledRenderToSingleSampledInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multisampledRenderToSingleSampledEnable) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMultisampledRenderToSingleSampledInfoEXT),
                "::",
                stringify!(multisampledRenderToSingleSampledEnable)
            )
        );
    }
    test_field_multisampledRenderToSingleSampledEnable();
    fn test_field_rasterizationSamples() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkMultisampledRenderToSingleSampledInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rasterizationSamples) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMultisampledRenderToSingleSampledInfoEXT),
                "::",
                stringify!(rasterizationSamples)
            )
        );
    }
    test_field_rasterizationSamples();
}
impl Default for VkMultisampledRenderToSingleSampledInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExtendedDynamicState2FeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub extendedDynamicState2: VkBool32,
    pub extendedDynamicState2LogicOp: VkBool32,
    pub extendedDynamicState2PatchControlPoints: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState2FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState2FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_extendedDynamicState2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState2FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT),
                "::",
                stringify!(extendedDynamicState2)
            )
        );
    }
    test_field_extendedDynamicState2();
    fn test_field_extendedDynamicState2LogicOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState2FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState2LogicOp) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT),
                "::",
                stringify!(extendedDynamicState2LogicOp)
            )
        );
    }
    test_field_extendedDynamicState2LogicOp();
    fn test_field_extendedDynamicState2PatchControlPoints() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState2FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState2PatchControlPoints) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT),
                "::",
                stringify!(extendedDynamicState2PatchControlPoints)
            )
        );
    }
    test_field_extendedDynamicState2PatchControlPoints();
}
impl Default for VkPhysicalDeviceExtendedDynamicState2FeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdSetPatchControlPointsEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, patchControlPoints: u32),
>;
pub type PFN_vkCmdSetRasterizerDiscardEnableEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, rasterizerDiscardEnable: VkBool32),
>;
pub type PFN_vkCmdSetDepthBiasEnableEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32),
>;
pub type PFN_vkCmdSetLogicOpEXT =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer, logicOp: VkLogicOp)>;
pub type PFN_vkCmdSetPrimitiveRestartEnableEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, primitiveRestartEnable: VkBool32),
>;
extern "C" {
    pub fn vkCmdSetPatchControlPointsEXT(commandBuffer: VkCommandBuffer, patchControlPoints: u32);
}
extern "C" {
    pub fn vkCmdSetRasterizerDiscardEnableEXT(
        commandBuffer: VkCommandBuffer,
        rasterizerDiscardEnable: VkBool32,
    );
}
extern "C" {
    pub fn vkCmdSetDepthBiasEnableEXT(commandBuffer: VkCommandBuffer, depthBiasEnable: VkBool32);
}
extern "C" {
    pub fn vkCmdSetLogicOpEXT(commandBuffer: VkCommandBuffer, logicOp: VkLogicOp);
}
extern "C" {
    pub fn vkCmdSetPrimitiveRestartEnableEXT(
        commandBuffer: VkCommandBuffer,
        primitiveRestartEnable: VkBool32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceColorWriteEnableFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub colorWriteEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceColorWriteEnableFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceColorWriteEnableFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceColorWriteEnableFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceColorWriteEnableFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceColorWriteEnableFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceColorWriteEnableFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceColorWriteEnableFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceColorWriteEnableFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceColorWriteEnableFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_colorWriteEnable() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceColorWriteEnableFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorWriteEnable) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceColorWriteEnableFeaturesEXT),
                "::",
                stringify!(colorWriteEnable)
            )
        );
    }
    test_field_colorWriteEnable();
}
impl Default for VkPhysicalDeviceColorWriteEnableFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineColorWriteCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub attachmentCount: u32,
    pub pColorWriteEnables: *const VkBool32,
}
#[test]
fn bindgen_test_layout_VkPipelineColorWriteCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineColorWriteCreateInfoEXT>(),
        32usize,
        concat!("Size of: ", stringify!(VkPipelineColorWriteCreateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineColorWriteCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineColorWriteCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineColorWriteCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorWriteCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineColorWriteCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorWriteCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_attachmentCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineColorWriteCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attachmentCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorWriteCreateInfoEXT),
                "::",
                stringify!(attachmentCount)
            )
        );
    }
    test_field_attachmentCount();
    fn test_field_pColorWriteEnables() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkPipelineColorWriteCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pColorWriteEnables) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineColorWriteCreateInfoEXT),
                "::",
                stringify!(pColorWriteEnables)
            )
        );
    }
    test_field_pColorWriteEnables();
}
impl Default for VkPipelineColorWriteCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdSetColorWriteEnableEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        attachmentCount: u32,
        pColorWriteEnables: *const VkBool32,
    ),
>;
extern "C" {
    pub fn vkCmdSetColorWriteEnableEXT(
        commandBuffer: VkCommandBuffer,
        attachmentCount: u32,
        pColorWriteEnables: *const VkBool32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub primitivesGeneratedQuery: VkBool32,
    pub primitivesGeneratedQueryWithRasterizerDiscard: VkBool32,
    pub primitivesGeneratedQueryWithNonZeroStreams: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_primitivesGeneratedQuery() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).primitivesGeneratedQuery) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT),
                "::",
                stringify!(primitivesGeneratedQuery)
            )
        );
    }
    test_field_primitivesGeneratedQuery();
    fn test_field_primitivesGeneratedQueryWithRasterizerDiscard() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).primitivesGeneratedQueryWithRasterizerDiscard) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT),
                "::",
                stringify!(primitivesGeneratedQueryWithRasterizerDiscard)
            )
        );
    }
    test_field_primitivesGeneratedQueryWithRasterizerDiscard();
    fn test_field_primitivesGeneratedQueryWithNonZeroStreams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).primitivesGeneratedQueryWithNonZeroStreams) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT),
                "::",
                stringify!(primitivesGeneratedQueryWithNonZeroStreams)
            )
        );
    }
    test_field_primitivesGeneratedQueryWithNonZeroStreams();
}
impl Default for VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT =
    VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR;
pub type VkQueueFamilyGlobalPriorityPropertiesEXT = VkQueueFamilyGlobalPriorityPropertiesKHR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceImageViewMinLodFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub minLod: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceImageViewMinLodFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceImageViewMinLodFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceImageViewMinLodFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceImageViewMinLodFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceImageViewMinLodFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImageViewMinLodFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageViewMinLodFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImageViewMinLodFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageViewMinLodFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_minLod() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImageViewMinLodFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minLod) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageViewMinLodFeaturesEXT),
                "::",
                stringify!(minLod)
            )
        );
    }
    test_field_minLod();
}
impl Default for VkPhysicalDeviceImageViewMinLodFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageViewMinLodCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub minLod: f32,
}
#[test]
fn bindgen_test_layout_VkImageViewMinLodCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkImageViewMinLodCreateInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkImageViewMinLodCreateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageViewMinLodCreateInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkImageViewMinLodCreateInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewMinLodCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewMinLodCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewMinLodCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewMinLodCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_minLod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkImageViewMinLodCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minLod) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewMinLodCreateInfoEXT),
                "::",
                stringify!(minLod)
            )
        );
    }
    test_field_minLod();
}
impl Default for VkImageViewMinLodCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMultiDrawFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub multiDraw: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMultiDrawFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMultiDrawFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMultiDrawFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMultiDrawFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMultiDrawFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMultiDrawFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiDrawFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMultiDrawFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiDrawFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_multiDraw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMultiDrawFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiDraw) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiDrawFeaturesEXT),
                "::",
                stringify!(multiDraw)
            )
        );
    }
    test_field_multiDraw();
}
impl Default for VkPhysicalDeviceMultiDrawFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMultiDrawPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxMultiDrawCount: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMultiDrawPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMultiDrawPropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMultiDrawPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMultiDrawPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMultiDrawPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMultiDrawPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiDrawPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMultiDrawPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiDrawPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxMultiDrawCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMultiDrawPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMultiDrawCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiDrawPropertiesEXT),
                "::",
                stringify!(maxMultiDrawCount)
            )
        );
    }
    test_field_maxMultiDrawCount();
}
impl Default for VkPhysicalDeviceMultiDrawPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkMultiDrawInfoEXT {
    pub firstVertex: u32,
    pub vertexCount: u32,
}
#[test]
fn bindgen_test_layout_VkMultiDrawInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMultiDrawInfoEXT>(),
        8usize,
        concat!("Size of: ", stringify!(VkMultiDrawInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMultiDrawInfoEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(VkMultiDrawInfoEXT))
    );
    fn test_field_firstVertex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMultiDrawInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstVertex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMultiDrawInfoEXT),
                "::",
                stringify!(firstVertex)
            )
        );
    }
    test_field_firstVertex();
    fn test_field_vertexCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMultiDrawInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexCount) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMultiDrawInfoEXT),
                "::",
                stringify!(vertexCount)
            )
        );
    }
    test_field_vertexCount();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkMultiDrawIndexedInfoEXT {
    pub firstIndex: u32,
    pub indexCount: u32,
    pub vertexOffset: i32,
}
#[test]
fn bindgen_test_layout_VkMultiDrawIndexedInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMultiDrawIndexedInfoEXT>(),
        12usize,
        concat!("Size of: ", stringify!(VkMultiDrawIndexedInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMultiDrawIndexedInfoEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(VkMultiDrawIndexedInfoEXT))
    );
    fn test_field_firstIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMultiDrawIndexedInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstIndex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMultiDrawIndexedInfoEXT),
                "::",
                stringify!(firstIndex)
            )
        );
    }
    test_field_firstIndex();
    fn test_field_indexCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMultiDrawIndexedInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indexCount) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMultiDrawIndexedInfoEXT),
                "::",
                stringify!(indexCount)
            )
        );
    }
    test_field_indexCount();
    fn test_field_vertexOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMultiDrawIndexedInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexOffset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMultiDrawIndexedInfoEXT),
                "::",
                stringify!(vertexOffset)
            )
        );
    }
    test_field_vertexOffset();
}
pub type PFN_vkCmdDrawMultiEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        drawCount: u32,
        pVertexInfo: *const VkMultiDrawInfoEXT,
        instanceCount: u32,
        firstInstance: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCmdDrawMultiIndexedEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        drawCount: u32,
        pIndexInfo: *const VkMultiDrawIndexedInfoEXT,
        instanceCount: u32,
        firstInstance: u32,
        stride: u32,
        pVertexOffset: *const i32,
    ),
>;
extern "C" {
    pub fn vkCmdDrawMultiEXT(
        commandBuffer: VkCommandBuffer,
        drawCount: u32,
        pVertexInfo: *const VkMultiDrawInfoEXT,
        instanceCount: u32,
        firstInstance: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawMultiIndexedEXT(
        commandBuffer: VkCommandBuffer,
        drawCount: u32,
        pIndexInfo: *const VkMultiDrawIndexedInfoEXT,
        instanceCount: u32,
        firstInstance: u32,
        stride: u32,
        pVertexOffset: *const i32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceImage2DViewOf3DFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub image2DViewOf3D: VkBool32,
    pub sampler2DViewOf3D: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_image2DViewOf3D() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image2DViewOf3D) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT),
                "::",
                stringify!(image2DViewOf3D)
            )
        );
    }
    test_field_image2DViewOf3D();
    fn test_field_sampler2DViewOf3D() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sampler2DViewOf3D) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT),
                "::",
                stringify!(sampler2DViewOf3D)
            )
        );
    }
    test_field_sampler2DViewOf3D();
}
impl Default for VkPhysicalDeviceImage2DViewOf3DFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMicromapEXT_T {
    _unused: [u8; 0],
}
pub type VkMicromapEXT = *mut VkMicromapEXT_T;
pub const VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT: VkMicromapTypeEXT = 0;
pub const VK_MICROMAP_TYPE_MAX_ENUM_EXT: VkMicromapTypeEXT = 2147483647;
pub type VkMicromapTypeEXT = ::std::os::raw::c_int;
pub const VK_BUILD_MICROMAP_MODE_BUILD_EXT: VkBuildMicromapModeEXT = 0;
pub const VK_BUILD_MICROMAP_MODE_MAX_ENUM_EXT: VkBuildMicromapModeEXT = 2147483647;
pub type VkBuildMicromapModeEXT = ::std::os::raw::c_int;
pub const VK_COPY_MICROMAP_MODE_CLONE_EXT: VkCopyMicromapModeEXT = 0;
pub const VK_COPY_MICROMAP_MODE_SERIALIZE_EXT: VkCopyMicromapModeEXT = 1;
pub const VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT: VkCopyMicromapModeEXT = 2;
pub const VK_COPY_MICROMAP_MODE_COMPACT_EXT: VkCopyMicromapModeEXT = 3;
pub const VK_COPY_MICROMAP_MODE_MAX_ENUM_EXT: VkCopyMicromapModeEXT = 2147483647;
pub type VkCopyMicromapModeEXT = ::std::os::raw::c_int;
pub const VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT: VkOpacityMicromapFormatEXT = 1;
pub const VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT: VkOpacityMicromapFormatEXT = 2;
pub const VK_OPACITY_MICROMAP_FORMAT_MAX_ENUM_EXT: VkOpacityMicromapFormatEXT = 2147483647;
pub type VkOpacityMicromapFormatEXT = ::std::os::raw::c_int;
pub const VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT:
    VkOpacityMicromapSpecialIndexEXT = -1;
pub const VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT: VkOpacityMicromapSpecialIndexEXT = -2;
pub const VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT:
    VkOpacityMicromapSpecialIndexEXT = -3;
pub const VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT:
    VkOpacityMicromapSpecialIndexEXT = -4;
pub const VK_OPACITY_MICROMAP_SPECIAL_INDEX_MAX_ENUM_EXT: VkOpacityMicromapSpecialIndexEXT =
    2147483647;
pub type VkOpacityMicromapSpecialIndexEXT = ::std::os::raw::c_int;
pub const VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR:
    VkAccelerationStructureCompatibilityKHR = 0;
pub const VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR:
    VkAccelerationStructureCompatibilityKHR = 1;
pub const VK_ACCELERATION_STRUCTURE_COMPATIBILITY_MAX_ENUM_KHR:
    VkAccelerationStructureCompatibilityKHR = 2147483647;
pub type VkAccelerationStructureCompatibilityKHR = ::std::os::raw::c_int;
pub const VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR: VkAccelerationStructureBuildTypeKHR = 0;
pub const VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR: VkAccelerationStructureBuildTypeKHR = 1;
pub const VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR:
    VkAccelerationStructureBuildTypeKHR = 2;
pub const VK_ACCELERATION_STRUCTURE_BUILD_TYPE_MAX_ENUM_KHR: VkAccelerationStructureBuildTypeKHR =
    2147483647;
pub type VkAccelerationStructureBuildTypeKHR = ::std::os::raw::c_int;
pub const VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT: VkBuildMicromapFlagBitsEXT = 1;
pub const VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT: VkBuildMicromapFlagBitsEXT = 2;
pub const VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT: VkBuildMicromapFlagBitsEXT = 4;
pub const VK_BUILD_MICROMAP_FLAG_BITS_MAX_ENUM_EXT: VkBuildMicromapFlagBitsEXT = 2147483647;
pub type VkBuildMicromapFlagBitsEXT = ::std::os::raw::c_int;
pub type VkBuildMicromapFlagsEXT = VkFlags;
pub const VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT: VkMicromapCreateFlagBitsEXT = 1;
pub const VK_MICROMAP_CREATE_FLAG_BITS_MAX_ENUM_EXT: VkMicromapCreateFlagBitsEXT = 2147483647;
pub type VkMicromapCreateFlagBitsEXT = ::std::os::raw::c_int;
pub type VkMicromapCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkMicromapUsageEXT {
    pub count: u32,
    pub subdivisionLevel: u32,
    pub format: u32,
}
#[test]
fn bindgen_test_layout_VkMicromapUsageEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMicromapUsageEXT>(),
        12usize,
        concat!("Size of: ", stringify!(VkMicromapUsageEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMicromapUsageEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(VkMicromapUsageEXT))
    );
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapUsageEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapUsageEXT),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_subdivisionLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapUsageEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subdivisionLevel) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapUsageEXT),
                "::",
                stringify!(subdivisionLevel)
            )
        );
    }
    test_field_subdivisionLevel();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapUsageEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapUsageEXT),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkDeviceOrHostAddressKHR {
    pub deviceAddress: VkDeviceAddress,
    pub hostAddress: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkDeviceOrHostAddressKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkDeviceOrHostAddressKHR>(),
        8usize,
        concat!("Size of: ", stringify!(VkDeviceOrHostAddressKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDeviceOrHostAddressKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDeviceOrHostAddressKHR))
    );
    fn test_field_deviceAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceOrHostAddressKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceAddress) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceOrHostAddressKHR),
                "::",
                stringify!(deviceAddress)
            )
        );
    }
    test_field_deviceAddress();
    fn test_field_hostAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDeviceOrHostAddressKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostAddress) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDeviceOrHostAddressKHR),
                "::",
                stringify!(hostAddress)
            )
        );
    }
    test_field_hostAddress();
}
impl Default for VkDeviceOrHostAddressKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkMicromapBuildInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub type_: VkMicromapTypeEXT,
    pub flags: VkBuildMicromapFlagsEXT,
    pub mode: VkBuildMicromapModeEXT,
    pub dstMicromap: VkMicromapEXT,
    pub usageCountsCount: u32,
    pub pUsageCounts: *const VkMicromapUsageEXT,
    pub ppUsageCounts: *const *const VkMicromapUsageEXT,
    pub data: VkDeviceOrHostAddressConstKHR,
    pub scratchData: VkDeviceOrHostAddressKHR,
    pub triangleArray: VkDeviceOrHostAddressConstKHR,
    pub triangleArrayStride: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkMicromapBuildInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMicromapBuildInfoEXT>(),
        96usize,
        concat!("Size of: ", stringify!(VkMicromapBuildInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMicromapBuildInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMicromapBuildInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildInfoEXT),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildInfoEXT),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildInfoEXT),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_dstMicromap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstMicromap) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildInfoEXT),
                "::",
                stringify!(dstMicromap)
            )
        );
    }
    test_field_dstMicromap();
    fn test_field_usageCountsCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).usageCountsCount) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildInfoEXT),
                "::",
                stringify!(usageCountsCount)
            )
        );
    }
    test_field_usageCountsCount();
    fn test_field_pUsageCounts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pUsageCounts) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildInfoEXT),
                "::",
                stringify!(pUsageCounts)
            )
        );
    }
    test_field_pUsageCounts();
    fn test_field_ppUsageCounts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ppUsageCounts) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildInfoEXT),
                "::",
                stringify!(ppUsageCounts)
            )
        );
    }
    test_field_ppUsageCounts();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildInfoEXT),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_scratchData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scratchData) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildInfoEXT),
                "::",
                stringify!(scratchData)
            )
        );
    }
    test_field_scratchData();
    fn test_field_triangleArray() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).triangleArray) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildInfoEXT),
                "::",
                stringify!(triangleArray)
            )
        );
    }
    test_field_triangleArray();
    fn test_field_triangleArrayStride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).triangleArrayStride) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildInfoEXT),
                "::",
                stringify!(triangleArrayStride)
            )
        );
    }
    test_field_triangleArrayStride();
}
impl Default for VkMicromapBuildInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMicromapCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub createFlags: VkMicromapCreateFlagsEXT,
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
    pub type_: VkMicromapTypeEXT,
    pub deviceAddress: VkDeviceAddress,
}
#[test]
fn bindgen_test_layout_VkMicromapCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMicromapCreateInfoEXT>(),
        64usize,
        concat!("Size of: ", stringify!(VkMicromapCreateInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMicromapCreateInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMicromapCreateInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_createFlags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).createFlags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapCreateInfoEXT),
                "::",
                stringify!(createFlags)
            )
        );
    }
    test_field_createFlags();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapCreateInfoEXT),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapCreateInfoEXT),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapCreateInfoEXT),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapCreateInfoEXT),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_deviceAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceAddress) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapCreateInfoEXT),
                "::",
                stringify!(deviceAddress)
            )
        );
    }
    test_field_deviceAddress();
}
impl Default for VkMicromapCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceOpacityMicromapFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub micromap: VkBool32,
    pub micromapCaptureReplay: VkBool32,
    pub micromapHostCommands: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceOpacityMicromapFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceOpacityMicromapFeaturesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceOpacityMicromapFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceOpacityMicromapFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceOpacityMicromapFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpacityMicromapFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpacityMicromapFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpacityMicromapFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpacityMicromapFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_micromap() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpacityMicromapFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).micromap) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpacityMicromapFeaturesEXT),
                "::",
                stringify!(micromap)
            )
        );
    }
    test_field_micromap();
    fn test_field_micromapCaptureReplay() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpacityMicromapFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).micromapCaptureReplay) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpacityMicromapFeaturesEXT),
                "::",
                stringify!(micromapCaptureReplay)
            )
        );
    }
    test_field_micromapCaptureReplay();
    fn test_field_micromapHostCommands() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpacityMicromapFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).micromapHostCommands) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpacityMicromapFeaturesEXT),
                "::",
                stringify!(micromapHostCommands)
            )
        );
    }
    test_field_micromapHostCommands();
}
impl Default for VkPhysicalDeviceOpacityMicromapFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceOpacityMicromapPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxOpacity2StateSubdivisionLevel: u32,
    pub maxOpacity4StateSubdivisionLevel: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceOpacityMicromapPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceOpacityMicromapPropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceOpacityMicromapPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceOpacityMicromapPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceOpacityMicromapPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpacityMicromapPropertiesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpacityMicromapPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpacityMicromapPropertiesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpacityMicromapPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxOpacity2StateSubdivisionLevel() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpacityMicromapPropertiesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxOpacity2StateSubdivisionLevel) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpacityMicromapPropertiesEXT),
                "::",
                stringify!(maxOpacity2StateSubdivisionLevel)
            )
        );
    }
    test_field_maxOpacity2StateSubdivisionLevel();
    fn test_field_maxOpacity4StateSubdivisionLevel() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpacityMicromapPropertiesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxOpacity4StateSubdivisionLevel) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpacityMicromapPropertiesEXT),
                "::",
                stringify!(maxOpacity4StateSubdivisionLevel)
            )
        );
    }
    test_field_maxOpacity4StateSubdivisionLevel();
}
impl Default for VkPhysicalDeviceOpacityMicromapPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMicromapVersionInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pVersionData: *const u8,
}
#[test]
fn bindgen_test_layout_VkMicromapVersionInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMicromapVersionInfoEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkMicromapVersionInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMicromapVersionInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMicromapVersionInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapVersionInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapVersionInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapVersionInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapVersionInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pVersionData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapVersionInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pVersionData) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapVersionInfoEXT),
                "::",
                stringify!(pVersionData)
            )
        );
    }
    test_field_pVersionData();
}
impl Default for VkMicromapVersionInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyMicromapToMemoryInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub src: VkMicromapEXT,
    pub dst: VkDeviceOrHostAddressKHR,
    pub mode: VkCopyMicromapModeEXT,
}
#[test]
fn bindgen_test_layout_VkCopyMicromapToMemoryInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkCopyMicromapToMemoryInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkCopyMicromapToMemoryInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCopyMicromapToMemoryInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCopyMicromapToMemoryInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMicromapToMemoryInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMicromapToMemoryInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMicromapToMemoryInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMicromapToMemoryInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_src() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMicromapToMemoryInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMicromapToMemoryInfoEXT),
                "::",
                stringify!(src)
            )
        );
    }
    test_field_src();
    fn test_field_dst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMicromapToMemoryInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMicromapToMemoryInfoEXT),
                "::",
                stringify!(dst)
            )
        );
    }
    test_field_dst();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMicromapToMemoryInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMicromapToMemoryInfoEXT),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
}
impl Default for VkCopyMicromapToMemoryInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyMemoryToMicromapInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub src: VkDeviceOrHostAddressConstKHR,
    pub dst: VkMicromapEXT,
    pub mode: VkCopyMicromapModeEXT,
}
#[test]
fn bindgen_test_layout_VkCopyMemoryToMicromapInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkCopyMemoryToMicromapInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkCopyMemoryToMicromapInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCopyMemoryToMicromapInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCopyMemoryToMicromapInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMemoryToMicromapInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryToMicromapInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMemoryToMicromapInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryToMicromapInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_src() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMemoryToMicromapInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryToMicromapInfoEXT),
                "::",
                stringify!(src)
            )
        );
    }
    test_field_src();
    fn test_field_dst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMemoryToMicromapInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryToMicromapInfoEXT),
                "::",
                stringify!(dst)
            )
        );
    }
    test_field_dst();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMemoryToMicromapInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryToMicromapInfoEXT),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
}
impl Default for VkCopyMemoryToMicromapInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCopyMicromapInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub src: VkMicromapEXT,
    pub dst: VkMicromapEXT,
    pub mode: VkCopyMicromapModeEXT,
}
#[test]
fn bindgen_test_layout_VkCopyMicromapInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkCopyMicromapInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkCopyMicromapInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCopyMicromapInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCopyMicromapInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMicromapInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMicromapInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMicromapInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMicromapInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_src() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMicromapInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMicromapInfoEXT),
                "::",
                stringify!(src)
            )
        );
    }
    test_field_src();
    fn test_field_dst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMicromapInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMicromapInfoEXT),
                "::",
                stringify!(dst)
            )
        );
    }
    test_field_dst();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMicromapInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMicromapInfoEXT),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
}
impl Default for VkCopyMicromapInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkMicromapBuildSizesInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub micromapSize: VkDeviceSize,
    pub buildScratchSize: VkDeviceSize,
    pub discardable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkMicromapBuildSizesInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMicromapBuildSizesInfoEXT>(),
        40usize,
        concat!("Size of: ", stringify!(VkMicromapBuildSizesInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMicromapBuildSizesInfoEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkMicromapBuildSizesInfoEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildSizesInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildSizesInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildSizesInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildSizesInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_micromapSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildSizesInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).micromapSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildSizesInfoEXT),
                "::",
                stringify!(micromapSize)
            )
        );
    }
    test_field_micromapSize();
    fn test_field_buildScratchSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildSizesInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buildScratchSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildSizesInfoEXT),
                "::",
                stringify!(buildScratchSize)
            )
        );
    }
    test_field_buildScratchSize();
    fn test_field_discardable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapBuildSizesInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).discardable) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapBuildSizesInfoEXT),
                "::",
                stringify!(discardable)
            )
        );
    }
    test_field_discardable();
}
impl Default for VkMicromapBuildSizesInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureTrianglesOpacityMicromapEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub indexType: VkIndexType,
    pub indexBuffer: VkDeviceOrHostAddressConstKHR,
    pub indexStride: VkDeviceSize,
    pub baseTriangle: u32,
    pub usageCountsCount: u32,
    pub pUsageCounts: *const VkMicromapUsageEXT,
    pub ppUsageCounts: *const *const VkMicromapUsageEXT,
    pub micromap: VkMicromapEXT,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureTrianglesOpacityMicromapEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureTrianglesOpacityMicromapEXT>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureTrianglesOpacityMicromapEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureTrianglesOpacityMicromapEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureTrianglesOpacityMicromapEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureTrianglesOpacityMicromapEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureTrianglesOpacityMicromapEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureTrianglesOpacityMicromapEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureTrianglesOpacityMicromapEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_indexType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureTrianglesOpacityMicromapEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indexType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureTrianglesOpacityMicromapEXT),
                "::",
                stringify!(indexType)
            )
        );
    }
    test_field_indexType();
    fn test_field_indexBuffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureTrianglesOpacityMicromapEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indexBuffer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureTrianglesOpacityMicromapEXT),
                "::",
                stringify!(indexBuffer)
            )
        );
    }
    test_field_indexBuffer();
    fn test_field_indexStride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureTrianglesOpacityMicromapEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indexStride) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureTrianglesOpacityMicromapEXT),
                "::",
                stringify!(indexStride)
            )
        );
    }
    test_field_indexStride();
    fn test_field_baseTriangle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureTrianglesOpacityMicromapEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).baseTriangle) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureTrianglesOpacityMicromapEXT),
                "::",
                stringify!(baseTriangle)
            )
        );
    }
    test_field_baseTriangle();
    fn test_field_usageCountsCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureTrianglesOpacityMicromapEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).usageCountsCount) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureTrianglesOpacityMicromapEXT),
                "::",
                stringify!(usageCountsCount)
            )
        );
    }
    test_field_usageCountsCount();
    fn test_field_pUsageCounts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureTrianglesOpacityMicromapEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pUsageCounts) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureTrianglesOpacityMicromapEXT),
                "::",
                stringify!(pUsageCounts)
            )
        );
    }
    test_field_pUsageCounts();
    fn test_field_ppUsageCounts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureTrianglesOpacityMicromapEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ppUsageCounts) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureTrianglesOpacityMicromapEXT),
                "::",
                stringify!(ppUsageCounts)
            )
        );
    }
    test_field_ppUsageCounts();
    fn test_field_micromap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureTrianglesOpacityMicromapEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).micromap) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureTrianglesOpacityMicromapEXT),
                "::",
                stringify!(micromap)
            )
        );
    }
    test_field_micromap();
}
impl Default for VkAccelerationStructureTrianglesOpacityMicromapEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkMicromapTriangleEXT {
    pub dataOffset: u32,
    pub subdivisionLevel: u16,
    pub format: u16,
}
#[test]
fn bindgen_test_layout_VkMicromapTriangleEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkMicromapTriangleEXT>(),
        8usize,
        concat!("Size of: ", stringify!(VkMicromapTriangleEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkMicromapTriangleEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(VkMicromapTriangleEXT))
    );
    fn test_field_dataOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapTriangleEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataOffset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapTriangleEXT),
                "::",
                stringify!(dataOffset)
            )
        );
    }
    test_field_dataOffset();
    fn test_field_subdivisionLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapTriangleEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subdivisionLevel) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapTriangleEXT),
                "::",
                stringify!(subdivisionLevel)
            )
        );
    }
    test_field_subdivisionLevel();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkMicromapTriangleEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(VkMicromapTriangleEXT),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
}
pub type PFN_vkCreateMicromapEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkMicromapCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pMicromap: *mut VkMicromapEXT,
    ) -> VkResult,
>;
pub type PFN_vkDestroyMicromapEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        micromap: VkMicromapEXT,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCmdBuildMicromapsEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        infoCount: u32,
        pInfos: *const VkMicromapBuildInfoEXT,
    ),
>;
pub type PFN_vkBuildMicromapsEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        infoCount: u32,
        pInfos: *const VkMicromapBuildInfoEXT,
    ) -> VkResult,
>;
pub type PFN_vkCopyMicromapEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        pInfo: *const VkCopyMicromapInfoEXT,
    ) -> VkResult,
>;
pub type PFN_vkCopyMicromapToMemoryEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        pInfo: *const VkCopyMicromapToMemoryInfoEXT,
    ) -> VkResult,
>;
pub type PFN_vkCopyMemoryToMicromapEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        pInfo: *const VkCopyMemoryToMicromapInfoEXT,
    ) -> VkResult,
>;
pub type PFN_vkWriteMicromapsPropertiesEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        micromapCount: u32,
        pMicromaps: *const VkMicromapEXT,
        queryType: VkQueryType,
        dataSize: usize,
        pData: *mut ::std::os::raw::c_void,
        stride: usize,
    ) -> VkResult,
>;
pub type PFN_vkCmdCopyMicromapEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pInfo: *const VkCopyMicromapInfoEXT),
>;
pub type PFN_vkCmdCopyMicromapToMemoryEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pInfo: *const VkCopyMicromapToMemoryInfoEXT,
    ),
>;
pub type PFN_vkCmdCopyMemoryToMicromapEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pInfo: *const VkCopyMemoryToMicromapInfoEXT,
    ),
>;
pub type PFN_vkCmdWriteMicromapsPropertiesEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        micromapCount: u32,
        pMicromaps: *const VkMicromapEXT,
        queryType: VkQueryType,
        queryPool: VkQueryPool,
        firstQuery: u32,
    ),
>;
pub type PFN_vkGetDeviceMicromapCompatibilityEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pVersionInfo: *const VkMicromapVersionInfoEXT,
        pCompatibility: *mut VkAccelerationStructureCompatibilityKHR,
    ),
>;
pub type PFN_vkGetMicromapBuildSizesEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        buildType: VkAccelerationStructureBuildTypeKHR,
        pBuildInfo: *const VkMicromapBuildInfoEXT,
        pSizeInfo: *mut VkMicromapBuildSizesInfoEXT,
    ),
>;
extern "C" {
    pub fn vkCreateMicromapEXT(
        device: VkDevice,
        pCreateInfo: *const VkMicromapCreateInfoEXT,
        pAllocator: *const VkAllocationCallbacks,
        pMicromap: *mut VkMicromapEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyMicromapEXT(
        device: VkDevice,
        micromap: VkMicromapEXT,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCmdBuildMicromapsEXT(
        commandBuffer: VkCommandBuffer,
        infoCount: u32,
        pInfos: *const VkMicromapBuildInfoEXT,
    );
}
extern "C" {
    pub fn vkBuildMicromapsEXT(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        infoCount: u32,
        pInfos: *const VkMicromapBuildInfoEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCopyMicromapEXT(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        pInfo: *const VkCopyMicromapInfoEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCopyMicromapToMemoryEXT(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        pInfo: *const VkCopyMicromapToMemoryInfoEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCopyMemoryToMicromapEXT(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        pInfo: *const VkCopyMemoryToMicromapInfoEXT,
    ) -> VkResult;
}
extern "C" {
    pub fn vkWriteMicromapsPropertiesEXT(
        device: VkDevice,
        micromapCount: u32,
        pMicromaps: *const VkMicromapEXT,
        queryType: VkQueryType,
        dataSize: usize,
        pData: *mut ::std::os::raw::c_void,
        stride: usize,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdCopyMicromapEXT(
        commandBuffer: VkCommandBuffer,
        pInfo: *const VkCopyMicromapInfoEXT,
    );
}
extern "C" {
    pub fn vkCmdCopyMicromapToMemoryEXT(
        commandBuffer: VkCommandBuffer,
        pInfo: *const VkCopyMicromapToMemoryInfoEXT,
    );
}
extern "C" {
    pub fn vkCmdCopyMemoryToMicromapEXT(
        commandBuffer: VkCommandBuffer,
        pInfo: *const VkCopyMemoryToMicromapInfoEXT,
    );
}
extern "C" {
    pub fn vkCmdWriteMicromapsPropertiesEXT(
        commandBuffer: VkCommandBuffer,
        micromapCount: u32,
        pMicromaps: *const VkMicromapEXT,
        queryType: VkQueryType,
        queryPool: VkQueryPool,
        firstQuery: u32,
    );
}
extern "C" {
    pub fn vkGetDeviceMicromapCompatibilityEXT(
        device: VkDevice,
        pVersionInfo: *const VkMicromapVersionInfoEXT,
        pCompatibility: *mut VkAccelerationStructureCompatibilityKHR,
    );
}
extern "C" {
    pub fn vkGetMicromapBuildSizesEXT(
        device: VkDevice,
        buildType: VkAccelerationStructureBuildTypeKHR,
        pBuildInfo: *const VkMicromapBuildInfoEXT,
        pSizeInfo: *mut VkMicromapBuildSizesInfoEXT,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceBorderColorSwizzleFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub borderColorSwizzle: VkBool32,
    pub borderColorSwizzleFromImage: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceBorderColorSwizzleFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceBorderColorSwizzleFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceBorderColorSwizzleFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceBorderColorSwizzleFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_borderColorSwizzle() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceBorderColorSwizzleFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).borderColorSwizzle) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT),
                "::",
                stringify!(borderColorSwizzle)
            )
        );
    }
    test_field_borderColorSwizzle();
    fn test_field_borderColorSwizzleFromImage() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceBorderColorSwizzleFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).borderColorSwizzleFromImage) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT),
                "::",
                stringify!(borderColorSwizzleFromImage)
            )
        );
    }
    test_field_borderColorSwizzleFromImage();
}
impl Default for VkPhysicalDeviceBorderColorSwizzleFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSamplerBorderColorComponentMappingCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub components: VkComponentMapping,
    pub srgb: VkBool32,
}
#[test]
fn bindgen_test_layout_VkSamplerBorderColorComponentMappingCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkSamplerBorderColorComponentMappingCreateInfoEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkSamplerBorderColorComponentMappingCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkSamplerBorderColorComponentMappingCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSamplerBorderColorComponentMappingCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkSamplerBorderColorComponentMappingCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerBorderColorComponentMappingCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkSamplerBorderColorComponentMappingCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerBorderColorComponentMappingCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_components() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkSamplerBorderColorComponentMappingCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).components) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerBorderColorComponentMappingCreateInfoEXT),
                "::",
                stringify!(components)
            )
        );
    }
    test_field_components();
    fn test_field_srgb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkSamplerBorderColorComponentMappingCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srgb) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSamplerBorderColorComponentMappingCreateInfoEXT),
                "::",
                stringify!(srgb)
            )
        );
    }
    test_field_srgb();
}
impl Default for VkSamplerBorderColorComponentMappingCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub pageableDeviceLocalMemory: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pageableDeviceLocalMemory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pageableDeviceLocalMemory) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT),
                "::",
                stringify!(pageableDeviceLocalMemory)
            )
        );
    }
    test_field_pageableDeviceLocalMemory();
}
impl Default for VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkSetDeviceMemoryPriorityEXT = ::std::option::Option<
    unsafe extern "C" fn(device: VkDevice, memory: VkDeviceMemory, priority: f32),
>;
extern "C" {
    pub fn vkSetDeviceMemoryPriorityEXT(device: VkDevice, memory: VkDeviceMemory, priority: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub descriptorSetHostMapping: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_descriptorSetHostMapping() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorSetHostMapping) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE),
                "::",
                stringify!(descriptorSetHostMapping)
            )
        );
    }
    test_field_descriptorSetHostMapping();
}
impl Default for VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetBindingReferenceVALVE {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub descriptorSetLayout: VkDescriptorSetLayout,
    pub binding: u32,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetBindingReferenceVALVE() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorSetBindingReferenceVALVE>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkDescriptorSetBindingReferenceVALVE)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorSetBindingReferenceVALVE>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDescriptorSetBindingReferenceVALVE)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorSetBindingReferenceVALVE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetBindingReferenceVALVE),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorSetBindingReferenceVALVE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetBindingReferenceVALVE),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_descriptorSetLayout() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorSetBindingReferenceVALVE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorSetLayout) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetBindingReferenceVALVE),
                "::",
                stringify!(descriptorSetLayout)
            )
        );
    }
    test_field_descriptorSetLayout();
    fn test_field_binding() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorSetBindingReferenceVALVE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).binding) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetBindingReferenceVALVE),
                "::",
                stringify!(binding)
            )
        );
    }
    test_field_binding();
}
impl Default for VkDescriptorSetBindingReferenceVALVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetLayoutHostMappingInfoVALVE {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub descriptorOffset: usize,
    pub descriptorSize: u32,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetLayoutHostMappingInfoVALVE() {
    assert_eq!(
        ::std::mem::size_of::<VkDescriptorSetLayoutHostMappingInfoVALVE>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkDescriptorSetLayoutHostMappingInfoVALVE)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkDescriptorSetLayoutHostMappingInfoVALVE>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkDescriptorSetLayoutHostMappingInfoVALVE)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorSetLayoutHostMappingInfoVALVE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutHostMappingInfoVALVE),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorSetLayoutHostMappingInfoVALVE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutHostMappingInfoVALVE),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_descriptorOffset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorSetLayoutHostMappingInfoVALVE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorOffset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutHostMappingInfoVALVE),
                "::",
                stringify!(descriptorOffset)
            )
        );
    }
    test_field_descriptorOffset();
    fn test_field_descriptorSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkDescriptorSetLayoutHostMappingInfoVALVE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDescriptorSetLayoutHostMappingInfoVALVE),
                "::",
                stringify!(descriptorSize)
            )
        );
    }
    test_field_descriptorSize();
}
impl Default for VkDescriptorSetLayoutHostMappingInfoVALVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pBindingReference: *const VkDescriptorSetBindingReferenceVALVE,
        pHostMapping: *mut VkDescriptorSetLayoutHostMappingInfoVALVE,
    ),
>;
pub type PFN_vkGetDescriptorSetHostMappingVALVE = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        descriptorSet: VkDescriptorSet,
        ppData: *mut *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn vkGetDescriptorSetLayoutHostMappingInfoVALVE(
        device: VkDevice,
        pBindingReference: *const VkDescriptorSetBindingReferenceVALVE,
        pHostMapping: *mut VkDescriptorSetLayoutHostMappingInfoVALVE,
    );
}
extern "C" {
    pub fn vkGetDescriptorSetHostMappingVALVE(
        device: VkDevice,
        descriptorSet: VkDescriptorSet,
        ppData: *mut *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceDepthClampZeroOneFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub depthClampZeroOne: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDepthClampZeroOneFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceDepthClampZeroOneFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceDepthClampZeroOneFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDepthClampZeroOneFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDepthClampZeroOneFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_depthClampZeroOne() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceDepthClampZeroOneFeaturesEXT>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depthClampZeroOne) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT),
                "::",
                stringify!(depthClampZeroOne)
            )
        );
    }
    test_field_depthClampZeroOne();
}
impl Default for VkPhysicalDeviceDepthClampZeroOneFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub nonSeamlessCubeMap: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_nonSeamlessCubeMap() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nonSeamlessCubeMap) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT),
                "::",
                stringify!(nonSeamlessCubeMap)
            )
        );
    }
    test_field_nonSeamlessCubeMap();
}
impl Default for VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub fragmentDensityMapOffset: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_fragmentDensityMapOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentDensityMapOffset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM),
                "::",
                stringify!(fragmentDensityMapOffset)
            )
        );
    }
    test_field_fragmentDensityMapOffset();
}
impl Default for VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub fragmentDensityOffsetGranularity: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_fragmentDensityOffsetGranularity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentDensityOffsetGranularity) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM),
                "::",
                stringify!(fragmentDensityOffsetGranularity)
            )
        );
    }
    test_field_fragmentDensityOffsetGranularity();
}
impl Default for VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSubpassFragmentDensityMapOffsetEndInfoQCOM {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub fragmentDensityOffsetCount: u32,
    pub pFragmentDensityOffsets: *const VkOffset2D,
}
#[test]
fn bindgen_test_layout_VkSubpassFragmentDensityMapOffsetEndInfoQCOM() {
    assert_eq!(
        ::std::mem::size_of::<VkSubpassFragmentDensityMapOffsetEndInfoQCOM>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkSubpassFragmentDensityMapOffsetEndInfoQCOM)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkSubpassFragmentDensityMapOffsetEndInfoQCOM>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkSubpassFragmentDensityMapOffsetEndInfoQCOM)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSubpassFragmentDensityMapOffsetEndInfoQCOM>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassFragmentDensityMapOffsetEndInfoQCOM),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSubpassFragmentDensityMapOffsetEndInfoQCOM>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassFragmentDensityMapOffsetEndInfoQCOM),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_fragmentDensityOffsetCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSubpassFragmentDensityMapOffsetEndInfoQCOM>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragmentDensityOffsetCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassFragmentDensityMapOffsetEndInfoQCOM),
                "::",
                stringify!(fragmentDensityOffsetCount)
            )
        );
    }
    test_field_fragmentDensityOffsetCount();
    fn test_field_pFragmentDensityOffsets() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkSubpassFragmentDensityMapOffsetEndInfoQCOM>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pFragmentDensityOffsets) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkSubpassFragmentDensityMapOffsetEndInfoQCOM),
                "::",
                stringify!(pFragmentDensityOffsets)
            )
        );
    }
    test_field_pFragmentDensityOffsets();
}
impl Default for VkSubpassFragmentDensityMapOffsetEndInfoQCOM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkCopyMemoryIndirectCommandNV {
    pub srcAddress: VkDeviceAddress,
    pub dstAddress: VkDeviceAddress,
    pub size: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkCopyMemoryIndirectCommandNV() {
    assert_eq!(
        ::std::mem::size_of::<VkCopyMemoryIndirectCommandNV>(),
        24usize,
        concat!("Size of: ", stringify!(VkCopyMemoryIndirectCommandNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCopyMemoryIndirectCommandNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkCopyMemoryIndirectCommandNV))
    );
    fn test_field_srcAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMemoryIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcAddress) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryIndirectCommandNV),
                "::",
                stringify!(srcAddress)
            )
        );
    }
    test_field_srcAddress();
    fn test_field_dstAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMemoryIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstAddress) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryIndirectCommandNV),
                "::",
                stringify!(dstAddress)
            )
        );
    }
    test_field_dstAddress();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkCopyMemoryIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryIndirectCommandNV),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkCopyMemoryToImageIndirectCommandNV {
    pub srcAddress: VkDeviceAddress,
    pub bufferRowLength: u32,
    pub bufferImageHeight: u32,
    pub imageSubresource: VkImageSubresourceLayers,
    pub imageOffset: VkOffset3D,
    pub imageExtent: VkExtent3D,
}
#[test]
fn bindgen_test_layout_VkCopyMemoryToImageIndirectCommandNV() {
    assert_eq!(
        ::std::mem::size_of::<VkCopyMemoryToImageIndirectCommandNV>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(VkCopyMemoryToImageIndirectCommandNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkCopyMemoryToImageIndirectCommandNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkCopyMemoryToImageIndirectCommandNV)
        )
    );
    fn test_field_srcAddress() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyMemoryToImageIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcAddress) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryToImageIndirectCommandNV),
                "::",
                stringify!(srcAddress)
            )
        );
    }
    test_field_srcAddress();
    fn test_field_bufferRowLength() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyMemoryToImageIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferRowLength) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryToImageIndirectCommandNV),
                "::",
                stringify!(bufferRowLength)
            )
        );
    }
    test_field_bufferRowLength();
    fn test_field_bufferImageHeight() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyMemoryToImageIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bufferImageHeight) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryToImageIndirectCommandNV),
                "::",
                stringify!(bufferImageHeight)
            )
        );
    }
    test_field_bufferImageHeight();
    fn test_field_imageSubresource() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyMemoryToImageIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageSubresource) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryToImageIndirectCommandNV),
                "::",
                stringify!(imageSubresource)
            )
        );
    }
    test_field_imageSubresource();
    fn test_field_imageOffset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyMemoryToImageIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageOffset) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryToImageIndirectCommandNV),
                "::",
                stringify!(imageOffset)
            )
        );
    }
    test_field_imageOffset();
    fn test_field_imageExtent() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyMemoryToImageIndirectCommandNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageExtent) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryToImageIndirectCommandNV),
                "::",
                stringify!(imageExtent)
            )
        );
    }
    test_field_imageExtent();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceCopyMemoryIndirectFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub indirectCopy: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceCopyMemoryIndirectFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceCopyMemoryIndirectFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceCopyMemoryIndirectFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCopyMemoryIndirectFeaturesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCopyMemoryIndirectFeaturesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_indirectCopy() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceCopyMemoryIndirectFeaturesNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indirectCopy) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV),
                "::",
                stringify!(indirectCopy)
            )
        );
    }
    test_field_indirectCopy();
}
impl Default for VkPhysicalDeviceCopyMemoryIndirectFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceCopyMemoryIndirectPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub supportedQueues: VkQueueFlags,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceCopyMemoryIndirectPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceCopyMemoryIndirectPropertiesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceCopyMemoryIndirectPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceCopyMemoryIndirectPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceCopyMemoryIndirectPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_supportedQueues() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceCopyMemoryIndirectPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedQueues) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV),
                "::",
                stringify!(supportedQueues)
            )
        );
    }
    test_field_supportedQueues();
}
impl Default for VkPhysicalDeviceCopyMemoryIndirectPropertiesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdCopyMemoryIndirectNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        copyBufferAddress: VkDeviceAddress,
        copyCount: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCmdCopyMemoryToImageIndirectNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        copyBufferAddress: VkDeviceAddress,
        copyCount: u32,
        stride: u32,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        pImageSubresources: *const VkImageSubresourceLayers,
    ),
>;
extern "C" {
    pub fn vkCmdCopyMemoryIndirectNV(
        commandBuffer: VkCommandBuffer,
        copyBufferAddress: VkDeviceAddress,
        copyCount: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCmdCopyMemoryToImageIndirectNV(
        commandBuffer: VkCommandBuffer,
        copyBufferAddress: VkDeviceAddress,
        copyCount: u32,
        stride: u32,
        dstImage: VkImage,
        dstImageLayout: VkImageLayout,
        pImageSubresources: *const VkImageSubresourceLayers,
    );
}
pub type VkMemoryDecompressionMethodFlagBitsNV = VkFlags64;
pub const VK_MEMORY_DECOMPRESSION_METHOD_GDEFLATE_1_0_BIT_NV:
    VkMemoryDecompressionMethodFlagBitsNV = 1;
pub type VkMemoryDecompressionMethodFlagsNV = VkFlags64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkDecompressMemoryRegionNV {
    pub srcAddress: VkDeviceAddress,
    pub dstAddress: VkDeviceAddress,
    pub compressedSize: VkDeviceSize,
    pub decompressedSize: VkDeviceSize,
    pub decompressionMethod: VkMemoryDecompressionMethodFlagsNV,
}
#[test]
fn bindgen_test_layout_VkDecompressMemoryRegionNV() {
    assert_eq!(
        ::std::mem::size_of::<VkDecompressMemoryRegionNV>(),
        40usize,
        concat!("Size of: ", stringify!(VkDecompressMemoryRegionNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDecompressMemoryRegionNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDecompressMemoryRegionNV))
    );
    fn test_field_srcAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDecompressMemoryRegionNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcAddress) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDecompressMemoryRegionNV),
                "::",
                stringify!(srcAddress)
            )
        );
    }
    test_field_srcAddress();
    fn test_field_dstAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDecompressMemoryRegionNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstAddress) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDecompressMemoryRegionNV),
                "::",
                stringify!(dstAddress)
            )
        );
    }
    test_field_dstAddress();
    fn test_field_compressedSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDecompressMemoryRegionNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compressedSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDecompressMemoryRegionNV),
                "::",
                stringify!(compressedSize)
            )
        );
    }
    test_field_compressedSize();
    fn test_field_decompressedSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDecompressMemoryRegionNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).decompressedSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDecompressMemoryRegionNV),
                "::",
                stringify!(decompressedSize)
            )
        );
    }
    test_field_decompressedSize();
    fn test_field_decompressionMethod() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDecompressMemoryRegionNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).decompressionMethod) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDecompressMemoryRegionNV),
                "::",
                stringify!(decompressionMethod)
            )
        );
    }
    test_field_decompressionMethod();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMemoryDecompressionFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryDecompression: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMemoryDecompressionFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMemoryDecompressionFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMemoryDecompressionFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMemoryDecompressionFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMemoryDecompressionFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceMemoryDecompressionFeaturesNV > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryDecompressionFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceMemoryDecompressionFeaturesNV > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryDecompressionFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_memoryDecompression() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceMemoryDecompressionFeaturesNV > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memoryDecompression) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryDecompressionFeaturesNV),
                "::",
                stringify!(memoryDecompression)
            )
        );
    }
    test_field_memoryDecompression();
}
impl Default for VkPhysicalDeviceMemoryDecompressionFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMemoryDecompressionPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub decompressionMethods: VkMemoryDecompressionMethodFlagsNV,
    pub maxDecompressionIndirectCount: u64,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMemoryDecompressionPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMemoryDecompressionPropertiesNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMemoryDecompressionPropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMemoryDecompressionPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMemoryDecompressionPropertiesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceMemoryDecompressionPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryDecompressionPropertiesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceMemoryDecompressionPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryDecompressionPropertiesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_decompressionMethods() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceMemoryDecompressionPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).decompressionMethods) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryDecompressionPropertiesNV),
                "::",
                stringify!(decompressionMethods)
            )
        );
    }
    test_field_decompressionMethods();
    fn test_field_maxDecompressionIndirectCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceMemoryDecompressionPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDecompressionIndirectCount) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMemoryDecompressionPropertiesNV),
                "::",
                stringify!(maxDecompressionIndirectCount)
            )
        );
    }
    test_field_maxDecompressionIndirectCount();
}
impl Default for VkPhysicalDeviceMemoryDecompressionPropertiesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdDecompressMemoryNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        decompressRegionCount: u32,
        pDecompressMemoryRegions: *const VkDecompressMemoryRegionNV,
    ),
>;
pub type PFN_vkCmdDecompressMemoryIndirectCountNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        indirectCommandsAddress: VkDeviceAddress,
        indirectCommandsCountAddress: VkDeviceAddress,
        stride: u32,
    ),
>;
extern "C" {
    pub fn vkCmdDecompressMemoryNV(
        commandBuffer: VkCommandBuffer,
        decompressRegionCount: u32,
        pDecompressMemoryRegions: *const VkDecompressMemoryRegionNV,
    );
}
extern "C" {
    pub fn vkCmdDecompressMemoryIndirectCountNV(
        commandBuffer: VkCommandBuffer,
        indirectCommandsAddress: VkDeviceAddress,
        indirectCommandsCountAddress: VkDeviceAddress,
        stride: u32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceLinearColorAttachmentFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub linearColorAttachment: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceLinearColorAttachmentFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceLinearColorAttachmentFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceLinearColorAttachmentFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceLinearColorAttachmentFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceLinearColorAttachmentFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceLinearColorAttachmentFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLinearColorAttachmentFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceLinearColorAttachmentFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLinearColorAttachmentFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_linearColorAttachment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceLinearColorAttachmentFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).linearColorAttachment) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLinearColorAttachmentFeaturesNV),
                "::",
                stringify!(linearColorAttachment)
            )
        );
    }
    test_field_linearColorAttachment();
}
impl Default for VkPhysicalDeviceLinearColorAttachmentFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub imageCompressionControlSwapchain: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_imageCompressionControlSwapchain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageCompressionControlSwapchain) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT),
                "::",
                stringify!(imageCompressionControlSwapchain)
            )
        );
    }
    test_field_imageCompressionControlSwapchain();
}
impl Default for VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageViewSampleWeightCreateInfoQCOM {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub filterCenter: VkOffset2D,
    pub filterSize: VkExtent2D,
    pub numPhases: u32,
}
#[test]
fn bindgen_test_layout_VkImageViewSampleWeightCreateInfoQCOM() {
    assert_eq!(
        ::std::mem::size_of::<VkImageViewSampleWeightCreateInfoQCOM>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkImageViewSampleWeightCreateInfoQCOM)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkImageViewSampleWeightCreateInfoQCOM>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkImageViewSampleWeightCreateInfoQCOM)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageViewSampleWeightCreateInfoQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewSampleWeightCreateInfoQCOM),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageViewSampleWeightCreateInfoQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewSampleWeightCreateInfoQCOM),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_filterCenter() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageViewSampleWeightCreateInfoQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filterCenter) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewSampleWeightCreateInfoQCOM),
                "::",
                stringify!(filterCenter)
            )
        );
    }
    test_field_filterCenter();
    fn test_field_filterSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageViewSampleWeightCreateInfoQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filterSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewSampleWeightCreateInfoQCOM),
                "::",
                stringify!(filterSize)
            )
        );
    }
    test_field_filterSize();
    fn test_field_numPhases() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkImageViewSampleWeightCreateInfoQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numPhases) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkImageViewSampleWeightCreateInfoQCOM),
                "::",
                stringify!(numPhases)
            )
        );
    }
    test_field_numPhases();
}
impl Default for VkImageViewSampleWeightCreateInfoQCOM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceImageProcessingFeaturesQCOM {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub textureSampleWeighted: VkBool32,
    pub textureBoxFilter: VkBool32,
    pub textureBlockMatch: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceImageProcessingFeaturesQCOM() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceImageProcessingFeaturesQCOM>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceImageProcessingFeaturesQCOM)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceImageProcessingFeaturesQCOM>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceImageProcessingFeaturesQCOM)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImageProcessingFeaturesQCOM>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageProcessingFeaturesQCOM),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImageProcessingFeaturesQCOM>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageProcessingFeaturesQCOM),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_textureSampleWeighted() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImageProcessingFeaturesQCOM>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).textureSampleWeighted) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageProcessingFeaturesQCOM),
                "::",
                stringify!(textureSampleWeighted)
            )
        );
    }
    test_field_textureSampleWeighted();
    fn test_field_textureBoxFilter() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImageProcessingFeaturesQCOM>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).textureBoxFilter) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageProcessingFeaturesQCOM),
                "::",
                stringify!(textureBoxFilter)
            )
        );
    }
    test_field_textureBoxFilter();
    fn test_field_textureBlockMatch() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceImageProcessingFeaturesQCOM>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).textureBlockMatch) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageProcessingFeaturesQCOM),
                "::",
                stringify!(textureBlockMatch)
            )
        );
    }
    test_field_textureBlockMatch();
}
impl Default for VkPhysicalDeviceImageProcessingFeaturesQCOM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceImageProcessingPropertiesQCOM {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxWeightFilterPhases: u32,
    pub maxWeightFilterDimension: VkExtent2D,
    pub maxBlockMatchRegion: VkExtent2D,
    pub maxBoxFilterBlockSize: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceImageProcessingPropertiesQCOM() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceImageProcessingPropertiesQCOM>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceImageProcessingPropertiesQCOM)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceImageProcessingPropertiesQCOM>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceImageProcessingPropertiesQCOM)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceImageProcessingPropertiesQCOM > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageProcessingPropertiesQCOM),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceImageProcessingPropertiesQCOM > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageProcessingPropertiesQCOM),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxWeightFilterPhases() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceImageProcessingPropertiesQCOM > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxWeightFilterPhases) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageProcessingPropertiesQCOM),
                "::",
                stringify!(maxWeightFilterPhases)
            )
        );
    }
    test_field_maxWeightFilterPhases();
    fn test_field_maxWeightFilterDimension() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceImageProcessingPropertiesQCOM > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxWeightFilterDimension) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageProcessingPropertiesQCOM),
                "::",
                stringify!(maxWeightFilterDimension)
            )
        );
    }
    test_field_maxWeightFilterDimension();
    fn test_field_maxBlockMatchRegion() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceImageProcessingPropertiesQCOM > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxBlockMatchRegion) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageProcessingPropertiesQCOM),
                "::",
                stringify!(maxBlockMatchRegion)
            )
        );
    }
    test_field_maxBlockMatchRegion();
    fn test_field_maxBoxFilterBlockSize() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceImageProcessingPropertiesQCOM > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxBoxFilterBlockSize) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceImageProcessingPropertiesQCOM),
                "::",
                stringify!(maxBoxFilterBlockSize)
            )
        );
    }
    test_field_maxBoxFilterBlockSize();
}
impl Default for VkPhysicalDeviceImageProcessingPropertiesQCOM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExtendedDynamicState3FeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub extendedDynamicState3TessellationDomainOrigin: VkBool32,
    pub extendedDynamicState3DepthClampEnable: VkBool32,
    pub extendedDynamicState3PolygonMode: VkBool32,
    pub extendedDynamicState3RasterizationSamples: VkBool32,
    pub extendedDynamicState3SampleMask: VkBool32,
    pub extendedDynamicState3AlphaToCoverageEnable: VkBool32,
    pub extendedDynamicState3AlphaToOneEnable: VkBool32,
    pub extendedDynamicState3LogicOpEnable: VkBool32,
    pub extendedDynamicState3ColorBlendEnable: VkBool32,
    pub extendedDynamicState3ColorBlendEquation: VkBool32,
    pub extendedDynamicState3ColorWriteMask: VkBool32,
    pub extendedDynamicState3RasterizationStream: VkBool32,
    pub extendedDynamicState3ConservativeRasterizationMode: VkBool32,
    pub extendedDynamicState3ExtraPrimitiveOverestimationSize: VkBool32,
    pub extendedDynamicState3DepthClipEnable: VkBool32,
    pub extendedDynamicState3SampleLocationsEnable: VkBool32,
    pub extendedDynamicState3ColorBlendAdvanced: VkBool32,
    pub extendedDynamicState3ProvokingVertexMode: VkBool32,
    pub extendedDynamicState3LineRasterizationMode: VkBool32,
    pub extendedDynamicState3LineStippleEnable: VkBool32,
    pub extendedDynamicState3DepthClipNegativeOneToOne: VkBool32,
    pub extendedDynamicState3ViewportWScalingEnable: VkBool32,
    pub extendedDynamicState3ViewportSwizzle: VkBool32,
    pub extendedDynamicState3CoverageToColorEnable: VkBool32,
    pub extendedDynamicState3CoverageToColorLocation: VkBool32,
    pub extendedDynamicState3CoverageModulationMode: VkBool32,
    pub extendedDynamicState3CoverageModulationTableEnable: VkBool32,
    pub extendedDynamicState3CoverageModulationTable: VkBool32,
    pub extendedDynamicState3CoverageReductionMode: VkBool32,
    pub extendedDynamicState3RepresentativeFragmentTestEnable: VkBool32,
    pub extendedDynamicState3ShadingRateImageEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExtendedDynamicState3FeaturesEXT>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExtendedDynamicState3FeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_extendedDynamicState3TessellationDomainOrigin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3TessellationDomainOrigin) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3TessellationDomainOrigin)
            )
        );
    }
    test_field_extendedDynamicState3TessellationDomainOrigin();
    fn test_field_extendedDynamicState3DepthClampEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3DepthClampEnable) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3DepthClampEnable)
            )
        );
    }
    test_field_extendedDynamicState3DepthClampEnable();
    fn test_field_extendedDynamicState3PolygonMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3PolygonMode) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3PolygonMode)
            )
        );
    }
    test_field_extendedDynamicState3PolygonMode();
    fn test_field_extendedDynamicState3RasterizationSamples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3RasterizationSamples) as usize
                    - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3RasterizationSamples)
            )
        );
    }
    test_field_extendedDynamicState3RasterizationSamples();
    fn test_field_extendedDynamicState3SampleMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3SampleMask) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3SampleMask)
            )
        );
    }
    test_field_extendedDynamicState3SampleMask();
    fn test_field_extendedDynamicState3AlphaToCoverageEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3AlphaToCoverageEnable) as usize
                    - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3AlphaToCoverageEnable)
            )
        );
    }
    test_field_extendedDynamicState3AlphaToCoverageEnable();
    fn test_field_extendedDynamicState3AlphaToOneEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3AlphaToOneEnable) as usize
                    - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3AlphaToOneEnable)
            )
        );
    }
    test_field_extendedDynamicState3AlphaToOneEnable();
    fn test_field_extendedDynamicState3LogicOpEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3LogicOpEnable) as usize
                    - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3LogicOpEnable)
            )
        );
    }
    test_field_extendedDynamicState3LogicOpEnable();
    fn test_field_extendedDynamicState3ColorBlendEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3ColorBlendEnable) as usize
                    - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3ColorBlendEnable)
            )
        );
    }
    test_field_extendedDynamicState3ColorBlendEnable();
    fn test_field_extendedDynamicState3ColorBlendEquation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3ColorBlendEquation) as usize
                    - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3ColorBlendEquation)
            )
        );
    }
    test_field_extendedDynamicState3ColorBlendEquation();
    fn test_field_extendedDynamicState3ColorWriteMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3ColorWriteMask) as usize
                    - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3ColorWriteMask)
            )
        );
    }
    test_field_extendedDynamicState3ColorWriteMask();
    fn test_field_extendedDynamicState3RasterizationStream() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3RasterizationStream) as usize
                    - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3RasterizationStream)
            )
        );
    }
    test_field_extendedDynamicState3RasterizationStream();
    fn test_field_extendedDynamicState3ConservativeRasterizationMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3ConservativeRasterizationMode)
                    as usize
                    - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3ConservativeRasterizationMode)
            )
        );
    }
    test_field_extendedDynamicState3ConservativeRasterizationMode();
    fn test_field_extendedDynamicState3ExtraPrimitiveOverestimationSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3ExtraPrimitiveOverestimationSize)
                    as usize
                    - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3ExtraPrimitiveOverestimationSize)
            )
        );
    }
    test_field_extendedDynamicState3ExtraPrimitiveOverestimationSize();
    fn test_field_extendedDynamicState3DepthClipEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3DepthClipEnable) as usize
                    - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3DepthClipEnable)
            )
        );
    }
    test_field_extendedDynamicState3DepthClipEnable();
    fn test_field_extendedDynamicState3SampleLocationsEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3SampleLocationsEnable) as usize
                    - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3SampleLocationsEnable)
            )
        );
    }
    test_field_extendedDynamicState3SampleLocationsEnable();
    fn test_field_extendedDynamicState3ColorBlendAdvanced() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3ColorBlendAdvanced) as usize
                    - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3ColorBlendAdvanced)
            )
        );
    }
    test_field_extendedDynamicState3ColorBlendAdvanced();
    fn test_field_extendedDynamicState3ProvokingVertexMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3ProvokingVertexMode) as usize
                    - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3ProvokingVertexMode)
            )
        );
    }
    test_field_extendedDynamicState3ProvokingVertexMode();
    fn test_field_extendedDynamicState3LineRasterizationMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3LineRasterizationMode) as usize
                    - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3LineRasterizationMode)
            )
        );
    }
    test_field_extendedDynamicState3LineRasterizationMode();
    fn test_field_extendedDynamicState3LineStippleEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3LineStippleEnable) as usize
                    - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3LineStippleEnable)
            )
        );
    }
    test_field_extendedDynamicState3LineStippleEnable();
    fn test_field_extendedDynamicState3DepthClipNegativeOneToOne() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3DepthClipNegativeOneToOne) as usize
                    - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3DepthClipNegativeOneToOne)
            )
        );
    }
    test_field_extendedDynamicState3DepthClipNegativeOneToOne();
    fn test_field_extendedDynamicState3ViewportWScalingEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3ViewportWScalingEnable) as usize
                    - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3ViewportWScalingEnable)
            )
        );
    }
    test_field_extendedDynamicState3ViewportWScalingEnable();
    fn test_field_extendedDynamicState3ViewportSwizzle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3ViewportSwizzle) as usize
                    - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3ViewportSwizzle)
            )
        );
    }
    test_field_extendedDynamicState3ViewportSwizzle();
    fn test_field_extendedDynamicState3CoverageToColorEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3CoverageToColorEnable) as usize
                    - ptr as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3CoverageToColorEnable)
            )
        );
    }
    test_field_extendedDynamicState3CoverageToColorEnable();
    fn test_field_extendedDynamicState3CoverageToColorLocation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3CoverageToColorLocation) as usize
                    - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3CoverageToColorLocation)
            )
        );
    }
    test_field_extendedDynamicState3CoverageToColorLocation();
    fn test_field_extendedDynamicState3CoverageModulationMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3CoverageModulationMode) as usize
                    - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3CoverageModulationMode)
            )
        );
    }
    test_field_extendedDynamicState3CoverageModulationMode();
    fn test_field_extendedDynamicState3CoverageModulationTableEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3CoverageModulationTableEnable)
                    as usize
                    - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3CoverageModulationTableEnable)
            )
        );
    }
    test_field_extendedDynamicState3CoverageModulationTableEnable();
    fn test_field_extendedDynamicState3CoverageModulationTable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3CoverageModulationTable) as usize
                    - ptr as usize
            },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3CoverageModulationTable)
            )
        );
    }
    test_field_extendedDynamicState3CoverageModulationTable();
    fn test_field_extendedDynamicState3CoverageReductionMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3CoverageReductionMode) as usize
                    - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3CoverageReductionMode)
            )
        );
    }
    test_field_extendedDynamicState3CoverageReductionMode();
    fn test_field_extendedDynamicState3RepresentativeFragmentTestEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3RepresentativeFragmentTestEnable)
                    as usize
                    - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3RepresentativeFragmentTestEnable)
            )
        );
    }
    test_field_extendedDynamicState3RepresentativeFragmentTestEnable();
    fn test_field_extendedDynamicState3ShadingRateImageEnable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extendedDynamicState3ShadingRateImageEnable) as usize
                    - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT),
                "::",
                stringify!(extendedDynamicState3ShadingRateImageEnable)
            )
        );
    }
    test_field_extendedDynamicState3ShadingRateImageEnable();
}
impl Default for VkPhysicalDeviceExtendedDynamicState3FeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceExtendedDynamicState3PropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub dynamicPrimitiveTopologyUnrestricted: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceExtendedDynamicState3PropertiesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceExtendedDynamicState3PropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3PropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3PropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_dynamicPrimitiveTopologyUnrestricted() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceExtendedDynamicState3PropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dynamicPrimitiveTopologyUnrestricted) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT),
                "::",
                stringify!(dynamicPrimitiveTopologyUnrestricted)
            )
        );
    }
    test_field_dynamicPrimitiveTopologyUnrestricted();
}
impl Default for VkPhysicalDeviceExtendedDynamicState3PropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkColorBlendEquationEXT {
    pub srcColorBlendFactor: VkBlendFactor,
    pub dstColorBlendFactor: VkBlendFactor,
    pub colorBlendOp: VkBlendOp,
    pub srcAlphaBlendFactor: VkBlendFactor,
    pub dstAlphaBlendFactor: VkBlendFactor,
    pub alphaBlendOp: VkBlendOp,
}
#[test]
fn bindgen_test_layout_VkColorBlendEquationEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkColorBlendEquationEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkColorBlendEquationEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkColorBlendEquationEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(VkColorBlendEquationEXT))
    );
    fn test_field_srcColorBlendFactor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkColorBlendEquationEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcColorBlendFactor) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkColorBlendEquationEXT),
                "::",
                stringify!(srcColorBlendFactor)
            )
        );
    }
    test_field_srcColorBlendFactor();
    fn test_field_dstColorBlendFactor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkColorBlendEquationEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstColorBlendFactor) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkColorBlendEquationEXT),
                "::",
                stringify!(dstColorBlendFactor)
            )
        );
    }
    test_field_dstColorBlendFactor();
    fn test_field_colorBlendOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkColorBlendEquationEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).colorBlendOp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkColorBlendEquationEXT),
                "::",
                stringify!(colorBlendOp)
            )
        );
    }
    test_field_colorBlendOp();
    fn test_field_srcAlphaBlendFactor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkColorBlendEquationEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcAlphaBlendFactor) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkColorBlendEquationEXT),
                "::",
                stringify!(srcAlphaBlendFactor)
            )
        );
    }
    test_field_srcAlphaBlendFactor();
    fn test_field_dstAlphaBlendFactor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkColorBlendEquationEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstAlphaBlendFactor) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkColorBlendEquationEXT),
                "::",
                stringify!(dstAlphaBlendFactor)
            )
        );
    }
    test_field_dstAlphaBlendFactor();
    fn test_field_alphaBlendOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkColorBlendEquationEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alphaBlendOp) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkColorBlendEquationEXT),
                "::",
                stringify!(alphaBlendOp)
            )
        );
    }
    test_field_alphaBlendOp();
}
impl Default for VkColorBlendEquationEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkColorBlendAdvancedEXT {
    pub advancedBlendOp: VkBlendOp,
    pub srcPremultiplied: VkBool32,
    pub dstPremultiplied: VkBool32,
    pub blendOverlap: VkBlendOverlapEXT,
    pub clampResults: VkBool32,
}
#[test]
fn bindgen_test_layout_VkColorBlendAdvancedEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkColorBlendAdvancedEXT>(),
        20usize,
        concat!("Size of: ", stringify!(VkColorBlendAdvancedEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkColorBlendAdvancedEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(VkColorBlendAdvancedEXT))
    );
    fn test_field_advancedBlendOp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkColorBlendAdvancedEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).advancedBlendOp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkColorBlendAdvancedEXT),
                "::",
                stringify!(advancedBlendOp)
            )
        );
    }
    test_field_advancedBlendOp();
    fn test_field_srcPremultiplied() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkColorBlendAdvancedEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcPremultiplied) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkColorBlendAdvancedEXT),
                "::",
                stringify!(srcPremultiplied)
            )
        );
    }
    test_field_srcPremultiplied();
    fn test_field_dstPremultiplied() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkColorBlendAdvancedEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstPremultiplied) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkColorBlendAdvancedEXT),
                "::",
                stringify!(dstPremultiplied)
            )
        );
    }
    test_field_dstPremultiplied();
    fn test_field_blendOverlap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkColorBlendAdvancedEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blendOverlap) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkColorBlendAdvancedEXT),
                "::",
                stringify!(blendOverlap)
            )
        );
    }
    test_field_blendOverlap();
    fn test_field_clampResults() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkColorBlendAdvancedEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clampResults) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkColorBlendAdvancedEXT),
                "::",
                stringify!(clampResults)
            )
        );
    }
    test_field_clampResults();
}
impl Default for VkColorBlendAdvancedEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCmdSetTessellationDomainOriginEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, domainOrigin: VkTessellationDomainOrigin),
>;
pub type PFN_vkCmdSetDepthClampEnableEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, depthClampEnable: VkBool32),
>;
pub type PFN_vkCmdSetPolygonModeEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, polygonMode: VkPolygonMode),
>;
pub type PFN_vkCmdSetRasterizationSamplesEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        rasterizationSamples: VkSampleCountFlagBits,
    ),
>;
pub type PFN_vkCmdSetSampleMaskEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        samples: VkSampleCountFlagBits,
        pSampleMask: *const VkSampleMask,
    ),
>;
pub type PFN_vkCmdSetAlphaToCoverageEnableEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, alphaToCoverageEnable: VkBool32),
>;
pub type PFN_vkCmdSetAlphaToOneEnableEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, alphaToOneEnable: VkBool32),
>;
pub type PFN_vkCmdSetLogicOpEnableEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, logicOpEnable: VkBool32),
>;
pub type PFN_vkCmdSetColorBlendEnableEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstAttachment: u32,
        attachmentCount: u32,
        pColorBlendEnables: *const VkBool32,
    ),
>;
pub type PFN_vkCmdSetColorBlendEquationEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstAttachment: u32,
        attachmentCount: u32,
        pColorBlendEquations: *const VkColorBlendEquationEXT,
    ),
>;
pub type PFN_vkCmdSetColorWriteMaskEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstAttachment: u32,
        attachmentCount: u32,
        pColorWriteMasks: *const VkColorComponentFlags,
    ),
>;
pub type PFN_vkCmdSetRasterizationStreamEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, rasterizationStream: u32),
>;
pub type PFN_vkCmdSetConservativeRasterizationModeEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        conservativeRasterizationMode: VkConservativeRasterizationModeEXT,
    ),
>;
pub type PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, extraPrimitiveOverestimationSize: f32),
>;
pub type PFN_vkCmdSetDepthClipEnableEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, depthClipEnable: VkBool32),
>;
pub type PFN_vkCmdSetSampleLocationsEnableEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, sampleLocationsEnable: VkBool32),
>;
pub type PFN_vkCmdSetColorBlendAdvancedEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstAttachment: u32,
        attachmentCount: u32,
        pColorBlendAdvanced: *const VkColorBlendAdvancedEXT,
    ),
>;
pub type PFN_vkCmdSetProvokingVertexModeEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        provokingVertexMode: VkProvokingVertexModeEXT,
    ),
>;
pub type PFN_vkCmdSetLineRasterizationModeEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        lineRasterizationMode: VkLineRasterizationModeEXT,
    ),
>;
pub type PFN_vkCmdSetLineStippleEnableEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, stippledLineEnable: VkBool32),
>;
pub type PFN_vkCmdSetDepthClipNegativeOneToOneEXT = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, negativeOneToOne: VkBool32),
>;
pub type PFN_vkCmdSetViewportWScalingEnableNV = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, viewportWScalingEnable: VkBool32),
>;
pub type PFN_vkCmdSetViewportSwizzleNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        firstViewport: u32,
        viewportCount: u32,
        pViewportSwizzles: *const VkViewportSwizzleNV,
    ),
>;
pub type PFN_vkCmdSetCoverageToColorEnableNV = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, coverageToColorEnable: VkBool32),
>;
pub type PFN_vkCmdSetCoverageToColorLocationNV = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, coverageToColorLocation: u32),
>;
pub type PFN_vkCmdSetCoverageModulationModeNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        coverageModulationMode: VkCoverageModulationModeNV,
    ),
>;
pub type PFN_vkCmdSetCoverageModulationTableEnableNV = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, coverageModulationTableEnable: VkBool32),
>;
pub type PFN_vkCmdSetCoverageModulationTableNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        coverageModulationTableCount: u32,
        pCoverageModulationTable: *const f32,
    ),
>;
pub type PFN_vkCmdSetShadingRateImageEnableNV = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, shadingRateImageEnable: VkBool32),
>;
pub type PFN_vkCmdSetRepresentativeFragmentTestEnableNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        representativeFragmentTestEnable: VkBool32,
    ),
>;
pub type PFN_vkCmdSetCoverageReductionModeNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        coverageReductionMode: VkCoverageReductionModeNV,
    ),
>;
extern "C" {
    pub fn vkCmdSetTessellationDomainOriginEXT(
        commandBuffer: VkCommandBuffer,
        domainOrigin: VkTessellationDomainOrigin,
    );
}
extern "C" {
    pub fn vkCmdSetDepthClampEnableEXT(commandBuffer: VkCommandBuffer, depthClampEnable: VkBool32);
}
extern "C" {
    pub fn vkCmdSetPolygonModeEXT(commandBuffer: VkCommandBuffer, polygonMode: VkPolygonMode);
}
extern "C" {
    pub fn vkCmdSetRasterizationSamplesEXT(
        commandBuffer: VkCommandBuffer,
        rasterizationSamples: VkSampleCountFlagBits,
    );
}
extern "C" {
    pub fn vkCmdSetSampleMaskEXT(
        commandBuffer: VkCommandBuffer,
        samples: VkSampleCountFlagBits,
        pSampleMask: *const VkSampleMask,
    );
}
extern "C" {
    pub fn vkCmdSetAlphaToCoverageEnableEXT(
        commandBuffer: VkCommandBuffer,
        alphaToCoverageEnable: VkBool32,
    );
}
extern "C" {
    pub fn vkCmdSetAlphaToOneEnableEXT(commandBuffer: VkCommandBuffer, alphaToOneEnable: VkBool32);
}
extern "C" {
    pub fn vkCmdSetLogicOpEnableEXT(commandBuffer: VkCommandBuffer, logicOpEnable: VkBool32);
}
extern "C" {
    pub fn vkCmdSetColorBlendEnableEXT(
        commandBuffer: VkCommandBuffer,
        firstAttachment: u32,
        attachmentCount: u32,
        pColorBlendEnables: *const VkBool32,
    );
}
extern "C" {
    pub fn vkCmdSetColorBlendEquationEXT(
        commandBuffer: VkCommandBuffer,
        firstAttachment: u32,
        attachmentCount: u32,
        pColorBlendEquations: *const VkColorBlendEquationEXT,
    );
}
extern "C" {
    pub fn vkCmdSetColorWriteMaskEXT(
        commandBuffer: VkCommandBuffer,
        firstAttachment: u32,
        attachmentCount: u32,
        pColorWriteMasks: *const VkColorComponentFlags,
    );
}
extern "C" {
    pub fn vkCmdSetRasterizationStreamEXT(commandBuffer: VkCommandBuffer, rasterizationStream: u32);
}
extern "C" {
    pub fn vkCmdSetConservativeRasterizationModeEXT(
        commandBuffer: VkCommandBuffer,
        conservativeRasterizationMode: VkConservativeRasterizationModeEXT,
    );
}
extern "C" {
    pub fn vkCmdSetExtraPrimitiveOverestimationSizeEXT(
        commandBuffer: VkCommandBuffer,
        extraPrimitiveOverestimationSize: f32,
    );
}
extern "C" {
    pub fn vkCmdSetDepthClipEnableEXT(commandBuffer: VkCommandBuffer, depthClipEnable: VkBool32);
}
extern "C" {
    pub fn vkCmdSetSampleLocationsEnableEXT(
        commandBuffer: VkCommandBuffer,
        sampleLocationsEnable: VkBool32,
    );
}
extern "C" {
    pub fn vkCmdSetColorBlendAdvancedEXT(
        commandBuffer: VkCommandBuffer,
        firstAttachment: u32,
        attachmentCount: u32,
        pColorBlendAdvanced: *const VkColorBlendAdvancedEXT,
    );
}
extern "C" {
    pub fn vkCmdSetProvokingVertexModeEXT(
        commandBuffer: VkCommandBuffer,
        provokingVertexMode: VkProvokingVertexModeEXT,
    );
}
extern "C" {
    pub fn vkCmdSetLineRasterizationModeEXT(
        commandBuffer: VkCommandBuffer,
        lineRasterizationMode: VkLineRasterizationModeEXT,
    );
}
extern "C" {
    pub fn vkCmdSetLineStippleEnableEXT(
        commandBuffer: VkCommandBuffer,
        stippledLineEnable: VkBool32,
    );
}
extern "C" {
    pub fn vkCmdSetDepthClipNegativeOneToOneEXT(
        commandBuffer: VkCommandBuffer,
        negativeOneToOne: VkBool32,
    );
}
extern "C" {
    pub fn vkCmdSetViewportWScalingEnableNV(
        commandBuffer: VkCommandBuffer,
        viewportWScalingEnable: VkBool32,
    );
}
extern "C" {
    pub fn vkCmdSetViewportSwizzleNV(
        commandBuffer: VkCommandBuffer,
        firstViewport: u32,
        viewportCount: u32,
        pViewportSwizzles: *const VkViewportSwizzleNV,
    );
}
extern "C" {
    pub fn vkCmdSetCoverageToColorEnableNV(
        commandBuffer: VkCommandBuffer,
        coverageToColorEnable: VkBool32,
    );
}
extern "C" {
    pub fn vkCmdSetCoverageToColorLocationNV(
        commandBuffer: VkCommandBuffer,
        coverageToColorLocation: u32,
    );
}
extern "C" {
    pub fn vkCmdSetCoverageModulationModeNV(
        commandBuffer: VkCommandBuffer,
        coverageModulationMode: VkCoverageModulationModeNV,
    );
}
extern "C" {
    pub fn vkCmdSetCoverageModulationTableEnableNV(
        commandBuffer: VkCommandBuffer,
        coverageModulationTableEnable: VkBool32,
    );
}
extern "C" {
    pub fn vkCmdSetCoverageModulationTableNV(
        commandBuffer: VkCommandBuffer,
        coverageModulationTableCount: u32,
        pCoverageModulationTable: *const f32,
    );
}
extern "C" {
    pub fn vkCmdSetShadingRateImageEnableNV(
        commandBuffer: VkCommandBuffer,
        shadingRateImageEnable: VkBool32,
    );
}
extern "C" {
    pub fn vkCmdSetRepresentativeFragmentTestEnableNV(
        commandBuffer: VkCommandBuffer,
        representativeFragmentTestEnable: VkBool32,
    );
}
extern "C" {
    pub fn vkCmdSetCoverageReductionModeNV(
        commandBuffer: VkCommandBuffer,
        coverageReductionMode: VkCoverageReductionModeNV,
    );
}
pub const VK_SUBPASS_MERGE_STATUS_MERGED_EXT: VkSubpassMergeStatusEXT = 0;
pub const VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT: VkSubpassMergeStatusEXT = 1;
pub const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT: VkSubpassMergeStatusEXT = 2;
pub const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT: VkSubpassMergeStatusEXT = 3;
pub const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT: VkSubpassMergeStatusEXT = 4;
pub const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT: VkSubpassMergeStatusEXT = 5;
pub const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT: VkSubpassMergeStatusEXT = 6;
pub const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT:
    VkSubpassMergeStatusEXT = 7;
pub const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT: VkSubpassMergeStatusEXT = 8;
pub const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT: VkSubpassMergeStatusEXT = 9;
pub const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT: VkSubpassMergeStatusEXT = 10;
pub const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT: VkSubpassMergeStatusEXT =
    11;
pub const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT: VkSubpassMergeStatusEXT = 12;
pub const VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT: VkSubpassMergeStatusEXT = 13;
pub const VK_SUBPASS_MERGE_STATUS_MAX_ENUM_EXT: VkSubpassMergeStatusEXT = 2147483647;
pub type VkSubpassMergeStatusEXT = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub subpassMergeFeedback: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_subpassMergeFeedback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subpassMergeFeedback) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT),
                "::",
                stringify!(subpassMergeFeedback)
            )
        );
    }
    test_field_subpassMergeFeedback();
}
impl Default for VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassCreationControlEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub disallowMerging: VkBool32,
}
#[test]
fn bindgen_test_layout_VkRenderPassCreationControlEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassCreationControlEXT>(),
        24usize,
        concat!("Size of: ", stringify!(VkRenderPassCreationControlEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassCreationControlEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkRenderPassCreationControlEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreationControlEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreationControlEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreationControlEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreationControlEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_disallowMerging() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRenderPassCreationControlEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).disallowMerging) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreationControlEXT),
                "::",
                stringify!(disallowMerging)
            )
        );
    }
    test_field_disallowMerging();
}
impl Default for VkRenderPassCreationControlEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkRenderPassCreationFeedbackInfoEXT {
    pub postMergeSubpassCount: u32,
}
#[test]
fn bindgen_test_layout_VkRenderPassCreationFeedbackInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassCreationFeedbackInfoEXT>(),
        4usize,
        concat!("Size of: ", stringify!(VkRenderPassCreationFeedbackInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassCreationFeedbackInfoEXT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkRenderPassCreationFeedbackInfoEXT)
        )
    );
    fn test_field_postMergeSubpassCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassCreationFeedbackInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).postMergeSubpassCount) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreationFeedbackInfoEXT),
                "::",
                stringify!(postMergeSubpassCount)
            )
        );
    }
    test_field_postMergeSubpassCount();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassCreationFeedbackCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pRenderPassFeedback: *mut VkRenderPassCreationFeedbackInfoEXT,
}
#[test]
fn bindgen_test_layout_VkRenderPassCreationFeedbackCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassCreationFeedbackCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkRenderPassCreationFeedbackCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassCreationFeedbackCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRenderPassCreationFeedbackCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassCreationFeedbackCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreationFeedbackCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassCreationFeedbackCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreationFeedbackCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pRenderPassFeedback() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassCreationFeedbackCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pRenderPassFeedback) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassCreationFeedbackCreateInfoEXT),
                "::",
                stringify!(pRenderPassFeedback)
            )
        );
    }
    test_field_pRenderPassFeedback();
}
impl Default for VkRenderPassCreationFeedbackCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassSubpassFeedbackInfoEXT {
    pub subpassMergeStatus: VkSubpassMergeStatusEXT,
    pub description: [::std::os::raw::c_char; 256usize],
    pub postMergeIndex: u32,
}
#[test]
fn bindgen_test_layout_VkRenderPassSubpassFeedbackInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassSubpassFeedbackInfoEXT>(),
        264usize,
        concat!("Size of: ", stringify!(VkRenderPassSubpassFeedbackInfoEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassSubpassFeedbackInfoEXT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkRenderPassSubpassFeedbackInfoEXT)
        )
    );
    fn test_field_subpassMergeStatus() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassSubpassFeedbackInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subpassMergeStatus) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassSubpassFeedbackInfoEXT),
                "::",
                stringify!(subpassMergeStatus)
            )
        );
    }
    test_field_subpassMergeStatus();
    fn test_field_description() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassSubpassFeedbackInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassSubpassFeedbackInfoEXT),
                "::",
                stringify!(description)
            )
        );
    }
    test_field_description();
    fn test_field_postMergeIndex() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassSubpassFeedbackInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).postMergeIndex) as usize - ptr as usize
            },
            260usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassSubpassFeedbackInfoEXT),
                "::",
                stringify!(postMergeIndex)
            )
        );
    }
    test_field_postMergeIndex();
}
impl Default for VkRenderPassSubpassFeedbackInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPassSubpassFeedbackCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pSubpassFeedback: *mut VkRenderPassSubpassFeedbackInfoEXT,
}
#[test]
fn bindgen_test_layout_VkRenderPassSubpassFeedbackCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkRenderPassSubpassFeedbackCreateInfoEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkRenderPassSubpassFeedbackCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkRenderPassSubpassFeedbackCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRenderPassSubpassFeedbackCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassSubpassFeedbackCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassSubpassFeedbackCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassSubpassFeedbackCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassSubpassFeedbackCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pSubpassFeedback() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRenderPassSubpassFeedbackCreateInfoEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pSubpassFeedback) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRenderPassSubpassFeedbackCreateInfoEXT),
                "::",
                stringify!(pSubpassFeedback)
            )
        );
    }
    test_field_pSubpassFeedback();
}
impl Default for VkRenderPassSubpassFeedbackCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG: VkDirectDriverLoadingModeLUNARG = 0;
pub const VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG: VkDirectDriverLoadingModeLUNARG = 1;
pub const VK_DIRECT_DRIVER_LOADING_MODE_MAX_ENUM_LUNARG: VkDirectDriverLoadingModeLUNARG =
    2147483647;
pub type VkDirectDriverLoadingModeLUNARG = ::std::os::raw::c_int;
pub type VkDirectDriverLoadingFlagsLUNARG = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDirectDriverLoadingInfoLUNARG {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub flags: VkDirectDriverLoadingFlagsLUNARG,
    pub pfnGetInstanceProcAddr: PFN_vkGetInstanceProcAddr,
}
#[test]
fn bindgen_test_layout_VkDirectDriverLoadingInfoLUNARG() {
    assert_eq!(
        ::std::mem::size_of::<VkDirectDriverLoadingInfoLUNARG>(),
        32usize,
        concat!("Size of: ", stringify!(VkDirectDriverLoadingInfoLUNARG))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDirectDriverLoadingInfoLUNARG>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDirectDriverLoadingInfoLUNARG))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDirectDriverLoadingInfoLUNARG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDirectDriverLoadingInfoLUNARG),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDirectDriverLoadingInfoLUNARG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDirectDriverLoadingInfoLUNARG),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDirectDriverLoadingInfoLUNARG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDirectDriverLoadingInfoLUNARG),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_pfnGetInstanceProcAddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDirectDriverLoadingInfoLUNARG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pfnGetInstanceProcAddr) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDirectDriverLoadingInfoLUNARG),
                "::",
                stringify!(pfnGetInstanceProcAddr)
            )
        );
    }
    test_field_pfnGetInstanceProcAddr();
}
impl Default for VkDirectDriverLoadingInfoLUNARG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDirectDriverLoadingListLUNARG {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub mode: VkDirectDriverLoadingModeLUNARG,
    pub driverCount: u32,
    pub pDrivers: *const VkDirectDriverLoadingInfoLUNARG,
}
#[test]
fn bindgen_test_layout_VkDirectDriverLoadingListLUNARG() {
    assert_eq!(
        ::std::mem::size_of::<VkDirectDriverLoadingListLUNARG>(),
        32usize,
        concat!("Size of: ", stringify!(VkDirectDriverLoadingListLUNARG))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDirectDriverLoadingListLUNARG>(),
        8usize,
        concat!("Alignment of ", stringify!(VkDirectDriverLoadingListLUNARG))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDirectDriverLoadingListLUNARG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDirectDriverLoadingListLUNARG),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDirectDriverLoadingListLUNARG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDirectDriverLoadingListLUNARG),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDirectDriverLoadingListLUNARG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDirectDriverLoadingListLUNARG),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_driverCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDirectDriverLoadingListLUNARG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).driverCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDirectDriverLoadingListLUNARG),
                "::",
                stringify!(driverCount)
            )
        );
    }
    test_field_driverCount();
    fn test_field_pDrivers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDirectDriverLoadingListLUNARG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDrivers) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDirectDriverLoadingListLUNARG),
                "::",
                stringify!(pDrivers)
            )
        );
    }
    test_field_pDrivers();
}
impl Default for VkDirectDriverLoadingListLUNARG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderModuleIdentifier: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderModuleIdentifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderModuleIdentifier) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT),
                "::",
                stringify!(shaderModuleIdentifier)
            )
        );
    }
    test_field_shaderModuleIdentifier();
}
impl Default for VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderModuleIdentifierAlgorithmUUID: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderModuleIdentifierAlgorithmUUID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderModuleIdentifierAlgorithmUUID) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT),
                "::",
                stringify!(shaderModuleIdentifierAlgorithmUUID)
            )
        );
    }
    test_field_shaderModuleIdentifierAlgorithmUUID();
}
impl Default for VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineShaderStageModuleIdentifierCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub identifierSize: u32,
    pub pIdentifier: *const u8,
}
#[test]
fn bindgen_test_layout_VkPipelineShaderStageModuleIdentifierCreateInfoEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPipelineShaderStageModuleIdentifierCreateInfoEXT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPipelineShaderStageModuleIdentifierCreateInfoEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPipelineShaderStageModuleIdentifierCreateInfoEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPipelineShaderStageModuleIdentifierCreateInfoEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineShaderStageModuleIdentifierCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineShaderStageModuleIdentifierCreateInfoEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineShaderStageModuleIdentifierCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineShaderStageModuleIdentifierCreateInfoEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_identifierSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineShaderStageModuleIdentifierCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifierSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineShaderStageModuleIdentifierCreateInfoEXT),
                "::",
                stringify!(identifierSize)
            )
        );
    }
    test_field_identifierSize();
    fn test_field_pIdentifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPipelineShaderStageModuleIdentifierCreateInfoEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pIdentifier) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPipelineShaderStageModuleIdentifierCreateInfoEXT),
                "::",
                stringify!(pIdentifier)
            )
        );
    }
    test_field_pIdentifier();
}
impl Default for VkPipelineShaderStageModuleIdentifierCreateInfoEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkShaderModuleIdentifierEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub identifierSize: u32,
    pub identifier: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_VkShaderModuleIdentifierEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkShaderModuleIdentifierEXT>(),
        56usize,
        concat!("Size of: ", stringify!(VkShaderModuleIdentifierEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkShaderModuleIdentifierEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(VkShaderModuleIdentifierEXT))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderModuleIdentifierEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderModuleIdentifierEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderModuleIdentifierEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderModuleIdentifierEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_identifierSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderModuleIdentifierEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifierSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderModuleIdentifierEXT),
                "::",
                stringify!(identifierSize)
            )
        );
    }
    test_field_identifierSize();
    fn test_field_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkShaderModuleIdentifierEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkShaderModuleIdentifierEXT),
                "::",
                stringify!(identifier)
            )
        );
    }
    test_field_identifier();
}
impl Default for VkShaderModuleIdentifierEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetShaderModuleIdentifierEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        shaderModule: VkShaderModule,
        pIdentifier: *mut VkShaderModuleIdentifierEXT,
    ),
>;
pub type PFN_vkGetShaderModuleCreateInfoIdentifierEXT = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkShaderModuleCreateInfo,
        pIdentifier: *mut VkShaderModuleIdentifierEXT,
    ),
>;
extern "C" {
    pub fn vkGetShaderModuleIdentifierEXT(
        device: VkDevice,
        shaderModule: VkShaderModule,
        pIdentifier: *mut VkShaderModuleIdentifierEXT,
    );
}
extern "C" {
    pub fn vkGetShaderModuleCreateInfoIdentifierEXT(
        device: VkDevice,
        pCreateInfo: *const VkShaderModuleCreateInfo,
        pIdentifier: *mut VkShaderModuleIdentifierEXT,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkOpticalFlowSessionNV_T {
    _unused: [u8; 0],
}
pub type VkOpticalFlowSessionNV = *mut VkOpticalFlowSessionNV_T;
pub const VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV: VkOpticalFlowPerformanceLevelNV = 0;
pub const VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV: VkOpticalFlowPerformanceLevelNV = 1;
pub const VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV: VkOpticalFlowPerformanceLevelNV = 2;
pub const VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV: VkOpticalFlowPerformanceLevelNV = 3;
pub const VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MAX_ENUM_NV: VkOpticalFlowPerformanceLevelNV =
    2147483647;
pub type VkOpticalFlowPerformanceLevelNV = ::std::os::raw::c_int;
pub const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV: VkOpticalFlowSessionBindingPointNV = 0;
pub const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV: VkOpticalFlowSessionBindingPointNV = 1;
pub const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV: VkOpticalFlowSessionBindingPointNV =
    2;
pub const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV: VkOpticalFlowSessionBindingPointNV = 3;
pub const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV: VkOpticalFlowSessionBindingPointNV =
    4;
pub const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV:
    VkOpticalFlowSessionBindingPointNV = 5;
pub const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV: VkOpticalFlowSessionBindingPointNV = 6;
pub const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV:
    VkOpticalFlowSessionBindingPointNV = 7;
pub const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV: VkOpticalFlowSessionBindingPointNV =
    8;
pub const VK_OPTICAL_FLOW_SESSION_BINDING_POINT_MAX_ENUM_NV: VkOpticalFlowSessionBindingPointNV =
    2147483647;
pub type VkOpticalFlowSessionBindingPointNV = ::std::os::raw::c_int;
pub const VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV: VkOpticalFlowGridSizeFlagBitsNV = 0;
pub const VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV: VkOpticalFlowGridSizeFlagBitsNV = 1;
pub const VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV: VkOpticalFlowGridSizeFlagBitsNV = 2;
pub const VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV: VkOpticalFlowGridSizeFlagBitsNV = 4;
pub const VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV: VkOpticalFlowGridSizeFlagBitsNV = 8;
pub const VK_OPTICAL_FLOW_GRID_SIZE_FLAG_BITS_MAX_ENUM_NV: VkOpticalFlowGridSizeFlagBitsNV =
    2147483647;
pub type VkOpticalFlowGridSizeFlagBitsNV = ::std::os::raw::c_int;
pub type VkOpticalFlowGridSizeFlagsNV = VkFlags;
pub const VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV: VkOpticalFlowUsageFlagBitsNV = 0;
pub const VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV: VkOpticalFlowUsageFlagBitsNV = 1;
pub const VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV: VkOpticalFlowUsageFlagBitsNV = 2;
pub const VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV: VkOpticalFlowUsageFlagBitsNV = 4;
pub const VK_OPTICAL_FLOW_USAGE_COST_BIT_NV: VkOpticalFlowUsageFlagBitsNV = 8;
pub const VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV: VkOpticalFlowUsageFlagBitsNV = 16;
pub const VK_OPTICAL_FLOW_USAGE_FLAG_BITS_MAX_ENUM_NV: VkOpticalFlowUsageFlagBitsNV = 2147483647;
pub type VkOpticalFlowUsageFlagBitsNV = ::std::os::raw::c_int;
pub type VkOpticalFlowUsageFlagsNV = VkFlags;
pub const VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV: VkOpticalFlowSessionCreateFlagBitsNV =
    1;
pub const VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV: VkOpticalFlowSessionCreateFlagBitsNV =
    2;
pub const VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV:
    VkOpticalFlowSessionCreateFlagBitsNV = 4;
pub const VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV:
    VkOpticalFlowSessionCreateFlagBitsNV = 8;
pub const VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV:
    VkOpticalFlowSessionCreateFlagBitsNV = 16;
pub const VK_OPTICAL_FLOW_SESSION_CREATE_FLAG_BITS_MAX_ENUM_NV:
    VkOpticalFlowSessionCreateFlagBitsNV = 2147483647;
pub type VkOpticalFlowSessionCreateFlagBitsNV = ::std::os::raw::c_int;
pub type VkOpticalFlowSessionCreateFlagsNV = VkFlags;
pub const VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV: VkOpticalFlowExecuteFlagBitsNV = 1;
pub const VK_OPTICAL_FLOW_EXECUTE_FLAG_BITS_MAX_ENUM_NV: VkOpticalFlowExecuteFlagBitsNV =
    2147483647;
pub type VkOpticalFlowExecuteFlagBitsNV = ::std::os::raw::c_int;
pub type VkOpticalFlowExecuteFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceOpticalFlowFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub opticalFlow: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceOpticalFlowFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceOpticalFlowFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceOpticalFlowFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceOpticalFlowFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceOpticalFlowFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpticalFlowFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpticalFlowFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpticalFlowFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpticalFlowFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_opticalFlow() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpticalFlowFeaturesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opticalFlow) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpticalFlowFeaturesNV),
                "::",
                stringify!(opticalFlow)
            )
        );
    }
    test_field_opticalFlow();
}
impl Default for VkPhysicalDeviceOpticalFlowFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceOpticalFlowPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub supportedOutputGridSizes: VkOpticalFlowGridSizeFlagsNV,
    pub supportedHintGridSizes: VkOpticalFlowGridSizeFlagsNV,
    pub hintSupported: VkBool32,
    pub costSupported: VkBool32,
    pub bidirectionalFlowSupported: VkBool32,
    pub globalFlowSupported: VkBool32,
    pub minWidth: u32,
    pub minHeight: u32,
    pub maxWidth: u32,
    pub maxHeight: u32,
    pub maxNumRegionsOfInterest: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceOpticalFlowPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceOpticalFlowPropertiesNV>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceOpticalFlowPropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceOpticalFlowPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceOpticalFlowPropertiesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpticalFlowPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpticalFlowPropertiesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpticalFlowPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpticalFlowPropertiesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_supportedOutputGridSizes() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpticalFlowPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedOutputGridSizes) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpticalFlowPropertiesNV),
                "::",
                stringify!(supportedOutputGridSizes)
            )
        );
    }
    test_field_supportedOutputGridSizes();
    fn test_field_supportedHintGridSizes() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpticalFlowPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).supportedHintGridSizes) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpticalFlowPropertiesNV),
                "::",
                stringify!(supportedHintGridSizes)
            )
        );
    }
    test_field_supportedHintGridSizes();
    fn test_field_hintSupported() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpticalFlowPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hintSupported) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpticalFlowPropertiesNV),
                "::",
                stringify!(hintSupported)
            )
        );
    }
    test_field_hintSupported();
    fn test_field_costSupported() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpticalFlowPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).costSupported) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpticalFlowPropertiesNV),
                "::",
                stringify!(costSupported)
            )
        );
    }
    test_field_costSupported();
    fn test_field_bidirectionalFlowSupported() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpticalFlowPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bidirectionalFlowSupported) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpticalFlowPropertiesNV),
                "::",
                stringify!(bidirectionalFlowSupported)
            )
        );
    }
    test_field_bidirectionalFlowSupported();
    fn test_field_globalFlowSupported() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpticalFlowPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).globalFlowSupported) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpticalFlowPropertiesNV),
                "::",
                stringify!(globalFlowSupported)
            )
        );
    }
    test_field_globalFlowSupported();
    fn test_field_minWidth() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpticalFlowPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minWidth) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpticalFlowPropertiesNV),
                "::",
                stringify!(minWidth)
            )
        );
    }
    test_field_minWidth();
    fn test_field_minHeight() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpticalFlowPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minHeight) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpticalFlowPropertiesNV),
                "::",
                stringify!(minHeight)
            )
        );
    }
    test_field_minHeight();
    fn test_field_maxWidth() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpticalFlowPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxWidth) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpticalFlowPropertiesNV),
                "::",
                stringify!(maxWidth)
            )
        );
    }
    test_field_maxWidth();
    fn test_field_maxHeight() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpticalFlowPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxHeight) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpticalFlowPropertiesNV),
                "::",
                stringify!(maxHeight)
            )
        );
    }
    test_field_maxHeight();
    fn test_field_maxNumRegionsOfInterest() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceOpticalFlowPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxNumRegionsOfInterest) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceOpticalFlowPropertiesNV),
                "::",
                stringify!(maxNumRegionsOfInterest)
            )
        );
    }
    test_field_maxNumRegionsOfInterest();
}
impl Default for VkPhysicalDeviceOpticalFlowPropertiesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkOpticalFlowImageFormatInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub usage: VkOpticalFlowUsageFlagsNV,
}
#[test]
fn bindgen_test_layout_VkOpticalFlowImageFormatInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkOpticalFlowImageFormatInfoNV>(),
        24usize,
        concat!("Size of: ", stringify!(VkOpticalFlowImageFormatInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkOpticalFlowImageFormatInfoNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkOpticalFlowImageFormatInfoNV))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowImageFormatInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowImageFormatInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowImageFormatInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowImageFormatInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_usage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowImageFormatInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).usage) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowImageFormatInfoNV),
                "::",
                stringify!(usage)
            )
        );
    }
    test_field_usage();
}
impl Default for VkOpticalFlowImageFormatInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkOpticalFlowImageFormatPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub format: VkFormat,
}
#[test]
fn bindgen_test_layout_VkOpticalFlowImageFormatPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkOpticalFlowImageFormatPropertiesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkOpticalFlowImageFormatPropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkOpticalFlowImageFormatPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkOpticalFlowImageFormatPropertiesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkOpticalFlowImageFormatPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowImageFormatPropertiesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkOpticalFlowImageFormatPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowImageFormatPropertiesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkOpticalFlowImageFormatPropertiesNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowImageFormatPropertiesNV),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
}
impl Default for VkOpticalFlowImageFormatPropertiesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkOpticalFlowSessionCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub width: u32,
    pub height: u32,
    pub imageFormat: VkFormat,
    pub flowVectorFormat: VkFormat,
    pub costFormat: VkFormat,
    pub outputGridSize: VkOpticalFlowGridSizeFlagsNV,
    pub hintGridSize: VkOpticalFlowGridSizeFlagsNV,
    pub performanceLevel: VkOpticalFlowPerformanceLevelNV,
    pub flags: VkOpticalFlowSessionCreateFlagsNV,
}
#[test]
fn bindgen_test_layout_VkOpticalFlowSessionCreateInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkOpticalFlowSessionCreateInfoNV>(),
        56usize,
        concat!("Size of: ", stringify!(VkOpticalFlowSessionCreateInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkOpticalFlowSessionCreateInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkOpticalFlowSessionCreateInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowSessionCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowSessionCreateInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowSessionCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowSessionCreateInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowSessionCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowSessionCreateInfoNV),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowSessionCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowSessionCreateInfoNV),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_imageFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowSessionCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imageFormat) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowSessionCreateInfoNV),
                "::",
                stringify!(imageFormat)
            )
        );
    }
    test_field_imageFormat();
    fn test_field_flowVectorFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowSessionCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flowVectorFormat) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowSessionCreateInfoNV),
                "::",
                stringify!(flowVectorFormat)
            )
        );
    }
    test_field_flowVectorFormat();
    fn test_field_costFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowSessionCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).costFormat) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowSessionCreateInfoNV),
                "::",
                stringify!(costFormat)
            )
        );
    }
    test_field_costFormat();
    fn test_field_outputGridSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowSessionCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outputGridSize) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowSessionCreateInfoNV),
                "::",
                stringify!(outputGridSize)
            )
        );
    }
    test_field_outputGridSize();
    fn test_field_hintGridSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowSessionCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hintGridSize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowSessionCreateInfoNV),
                "::",
                stringify!(hintGridSize)
            )
        );
    }
    test_field_hintGridSize();
    fn test_field_performanceLevel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowSessionCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).performanceLevel) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowSessionCreateInfoNV),
                "::",
                stringify!(performanceLevel)
            )
        );
    }
    test_field_performanceLevel();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowSessionCreateInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowSessionCreateInfoNV),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for VkOpticalFlowSessionCreateInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkOpticalFlowSessionCreatePrivateDataInfoNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub id: u32,
    pub size: u32,
    pub pPrivateData: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkOpticalFlowSessionCreatePrivateDataInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkOpticalFlowSessionCreatePrivateDataInfoNV>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkOpticalFlowSessionCreatePrivateDataInfoNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkOpticalFlowSessionCreatePrivateDataInfoNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkOpticalFlowSessionCreatePrivateDataInfoNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkOpticalFlowSessionCreatePrivateDataInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowSessionCreatePrivateDataInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkOpticalFlowSessionCreatePrivateDataInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowSessionCreatePrivateDataInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkOpticalFlowSessionCreatePrivateDataInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowSessionCreatePrivateDataInfoNV),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkOpticalFlowSessionCreatePrivateDataInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowSessionCreatePrivateDataInfoNV),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_pPrivateData() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkOpticalFlowSessionCreatePrivateDataInfoNV>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pPrivateData) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowSessionCreatePrivateDataInfoNV),
                "::",
                stringify!(pPrivateData)
            )
        );
    }
    test_field_pPrivateData();
}
impl Default for VkOpticalFlowSessionCreatePrivateDataInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkOpticalFlowExecuteInfoNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub flags: VkOpticalFlowExecuteFlagsNV,
    pub regionCount: u32,
    pub pRegions: *const VkRect2D,
}
#[test]
fn bindgen_test_layout_VkOpticalFlowExecuteInfoNV() {
    assert_eq!(
        ::std::mem::size_of::<VkOpticalFlowExecuteInfoNV>(),
        32usize,
        concat!("Size of: ", stringify!(VkOpticalFlowExecuteInfoNV))
    );
    assert_eq!(
        ::std::mem::align_of::<VkOpticalFlowExecuteInfoNV>(),
        8usize,
        concat!("Alignment of ", stringify!(VkOpticalFlowExecuteInfoNV))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowExecuteInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowExecuteInfoNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowExecuteInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowExecuteInfoNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowExecuteInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowExecuteInfoNV),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_regionCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowExecuteInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regionCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowExecuteInfoNV),
                "::",
                stringify!(regionCount)
            )
        );
    }
    test_field_regionCount();
    fn test_field_pRegions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkOpticalFlowExecuteInfoNV>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pRegions) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkOpticalFlowExecuteInfoNV),
                "::",
                stringify!(pRegions)
            )
        );
    }
    test_field_pRegions();
}
impl Default for VkOpticalFlowExecuteInfoNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV = ::std::option::Option<
    unsafe extern "C" fn(
        physicalDevice: VkPhysicalDevice,
        pOpticalFlowImageFormatInfo: *const VkOpticalFlowImageFormatInfoNV,
        pFormatCount: *mut u32,
        pImageFormatProperties: *mut VkOpticalFlowImageFormatPropertiesNV,
    ) -> VkResult,
>;
pub type PFN_vkCreateOpticalFlowSessionNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkOpticalFlowSessionCreateInfoNV,
        pAllocator: *const VkAllocationCallbacks,
        pSession: *mut VkOpticalFlowSessionNV,
    ) -> VkResult,
>;
pub type PFN_vkDestroyOpticalFlowSessionNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        session: VkOpticalFlowSessionNV,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkBindOpticalFlowSessionImageNV = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        session: VkOpticalFlowSessionNV,
        bindingPoint: VkOpticalFlowSessionBindingPointNV,
        view: VkImageView,
        layout: VkImageLayout,
    ) -> VkResult,
>;
pub type PFN_vkCmdOpticalFlowExecuteNV = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        session: VkOpticalFlowSessionNV,
        pExecuteInfo: *const VkOpticalFlowExecuteInfoNV,
    ),
>;
extern "C" {
    pub fn vkGetPhysicalDeviceOpticalFlowImageFormatsNV(
        physicalDevice: VkPhysicalDevice,
        pOpticalFlowImageFormatInfo: *const VkOpticalFlowImageFormatInfoNV,
        pFormatCount: *mut u32,
        pImageFormatProperties: *mut VkOpticalFlowImageFormatPropertiesNV,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCreateOpticalFlowSessionNV(
        device: VkDevice,
        pCreateInfo: *const VkOpticalFlowSessionCreateInfoNV,
        pAllocator: *const VkAllocationCallbacks,
        pSession: *mut VkOpticalFlowSessionNV,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyOpticalFlowSessionNV(
        device: VkDevice,
        session: VkOpticalFlowSessionNV,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkBindOpticalFlowSessionImageNV(
        device: VkDevice,
        session: VkOpticalFlowSessionNV,
        bindingPoint: VkOpticalFlowSessionBindingPointNV,
        view: VkImageView,
        layout: VkImageLayout,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdOpticalFlowExecuteNV(
        commandBuffer: VkCommandBuffer,
        session: VkOpticalFlowSessionNV,
        pExecuteInfo: *const VkOpticalFlowExecuteInfoNV,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceLegacyDitheringFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub legacyDithering: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceLegacyDitheringFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceLegacyDitheringFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceLegacyDitheringFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceLegacyDitheringFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceLegacyDitheringFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceLegacyDitheringFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLegacyDitheringFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceLegacyDitheringFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLegacyDitheringFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_legacyDithering() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceLegacyDitheringFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).legacyDithering) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceLegacyDitheringFeaturesEXT),
                "::",
                stringify!(legacyDithering)
            )
        );
    }
    test_field_legacyDithering();
}
impl Default for VkPhysicalDeviceLegacyDitheringFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevicePipelineProtectedAccessFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub pipelineProtectedAccess: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePipelineProtectedAccessFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDevicePipelineProtectedAccessFeaturesEXT>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDevicePipelineProtectedAccessFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDevicePipelineProtectedAccessFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDevicePipelineProtectedAccessFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePipelineProtectedAccessFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineProtectedAccessFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePipelineProtectedAccessFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineProtectedAccessFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pipelineProtectedAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDevicePipelineProtectedAccessFeaturesEXT,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pipelineProtectedAccess) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDevicePipelineProtectedAccessFeaturesEXT),
                "::",
                stringify!(pipelineProtectedAccess)
            )
        );
    }
    test_field_pipelineProtectedAccess();
}
impl Default for VkPhysicalDevicePipelineProtectedAccessFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceTilePropertiesFeaturesQCOM {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub tileProperties: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceTilePropertiesFeaturesQCOM() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceTilePropertiesFeaturesQCOM>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceTilePropertiesFeaturesQCOM)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceTilePropertiesFeaturesQCOM>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceTilePropertiesFeaturesQCOM)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceTilePropertiesFeaturesQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTilePropertiesFeaturesQCOM),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceTilePropertiesFeaturesQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTilePropertiesFeaturesQCOM),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_tileProperties() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceTilePropertiesFeaturesQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tileProperties) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceTilePropertiesFeaturesQCOM),
                "::",
                stringify!(tileProperties)
            )
        );
    }
    test_field_tileProperties();
}
impl Default for VkPhysicalDeviceTilePropertiesFeaturesQCOM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkTilePropertiesQCOM {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub tileSize: VkExtent3D,
    pub apronSize: VkExtent2D,
    pub origin: VkOffset2D,
}
#[test]
fn bindgen_test_layout_VkTilePropertiesQCOM() {
    assert_eq!(
        ::std::mem::size_of::<VkTilePropertiesQCOM>(),
        48usize,
        concat!("Size of: ", stringify!(VkTilePropertiesQCOM))
    );
    assert_eq!(
        ::std::mem::align_of::<VkTilePropertiesQCOM>(),
        8usize,
        concat!("Alignment of ", stringify!(VkTilePropertiesQCOM))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTilePropertiesQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTilePropertiesQCOM),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTilePropertiesQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTilePropertiesQCOM),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_tileSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTilePropertiesQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tileSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTilePropertiesQCOM),
                "::",
                stringify!(tileSize)
            )
        );
    }
    test_field_tileSize();
    fn test_field_apronSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTilePropertiesQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).apronSize) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTilePropertiesQCOM),
                "::",
                stringify!(apronSize)
            )
        );
    }
    test_field_apronSize();
    fn test_field_origin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTilePropertiesQCOM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).origin) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTilePropertiesQCOM),
                "::",
                stringify!(origin)
            )
        );
    }
    test_field_origin();
}
impl Default for VkTilePropertiesQCOM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkGetFramebufferTilePropertiesQCOM = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        framebuffer: VkFramebuffer,
        pPropertiesCount: *mut u32,
        pProperties: *mut VkTilePropertiesQCOM,
    ) -> VkResult,
>;
pub type PFN_vkGetDynamicRenderingTilePropertiesQCOM = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pRenderingInfo: *const VkRenderingInfo,
        pProperties: *mut VkTilePropertiesQCOM,
    ) -> VkResult,
>;
extern "C" {
    pub fn vkGetFramebufferTilePropertiesQCOM(
        device: VkDevice,
        framebuffer: VkFramebuffer,
        pPropertiesCount: *mut u32,
        pProperties: *mut VkTilePropertiesQCOM,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetDynamicRenderingTilePropertiesQCOM(
        device: VkDevice,
        pRenderingInfo: *const VkRenderingInfo,
        pProperties: *mut VkTilePropertiesQCOM,
    ) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceAmigoProfilingFeaturesSEC {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub amigoProfiling: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceAmigoProfilingFeaturesSEC() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceAmigoProfilingFeaturesSEC>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceAmigoProfilingFeaturesSEC)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceAmigoProfilingFeaturesSEC>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceAmigoProfilingFeaturesSEC)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceAmigoProfilingFeaturesSEC>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAmigoProfilingFeaturesSEC),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceAmigoProfilingFeaturesSEC>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAmigoProfilingFeaturesSEC),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_amigoProfiling() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceAmigoProfilingFeaturesSEC>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).amigoProfiling) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAmigoProfilingFeaturesSEC),
                "::",
                stringify!(amigoProfiling)
            )
        );
    }
    test_field_amigoProfiling();
}
impl Default for VkPhysicalDeviceAmigoProfilingFeaturesSEC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAmigoProfilingSubmitInfoSEC {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub firstDrawTimestamp: u64,
    pub swapBufferTimestamp: u64,
}
#[test]
fn bindgen_test_layout_VkAmigoProfilingSubmitInfoSEC() {
    assert_eq!(
        ::std::mem::size_of::<VkAmigoProfilingSubmitInfoSEC>(),
        32usize,
        concat!("Size of: ", stringify!(VkAmigoProfilingSubmitInfoSEC))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAmigoProfilingSubmitInfoSEC>(),
        8usize,
        concat!("Alignment of ", stringify!(VkAmigoProfilingSubmitInfoSEC))
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAmigoProfilingSubmitInfoSEC>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAmigoProfilingSubmitInfoSEC),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAmigoProfilingSubmitInfoSEC>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAmigoProfilingSubmitInfoSEC),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_firstDrawTimestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAmigoProfilingSubmitInfoSEC>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstDrawTimestamp) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAmigoProfilingSubmitInfoSEC),
                "::",
                stringify!(firstDrawTimestamp)
            )
        );
    }
    test_field_firstDrawTimestamp();
    fn test_field_swapBufferTimestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkAmigoProfilingSubmitInfoSEC>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).swapBufferTimestamp) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAmigoProfilingSubmitInfoSEC),
                "::",
                stringify!(swapBufferTimestamp)
            )
        );
    }
    test_field_swapBufferTimestamp();
}
impl Default for VkAmigoProfilingSubmitInfoSEC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub multiviewPerViewViewports: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_multiviewPerViewViewports() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiviewPerViewViewports) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM),
                "::",
                stringify!(multiviewPerViewViewports)
            )
        );
    }
    test_field_multiviewPerViewViewports();
}
impl Default for VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV: VkRayTracingInvocationReorderModeNV = 0;
pub const VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV: VkRayTracingInvocationReorderModeNV =
    1;
pub const VK_RAY_TRACING_INVOCATION_REORDER_MODE_MAX_ENUM_NV: VkRayTracingInvocationReorderModeNV =
    2147483647;
pub type VkRayTracingInvocationReorderModeNV = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub rayTracingInvocationReorderReorderingHint: VkRayTracingInvocationReorderModeNV,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_rayTracingInvocationReorderReorderingHint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rayTracingInvocationReorderReorderingHint) as usize
                    - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV),
                "::",
                stringify!(rayTracingInvocationReorderReorderingHint)
            )
        );
    }
    test_field_rayTracingInvocationReorderReorderingHint();
}
impl Default for VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub rayTracingInvocationReorder: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_rayTracingInvocationReorder() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rayTracingInvocationReorder) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV),
                "::",
                stringify!(rayTracingInvocationReorder)
            )
        );
    }
    test_field_rayTracingInvocationReorder();
}
impl Default for VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderCoreBuiltins: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderCoreBuiltins() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderCoreBuiltins) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM),
                "::",
                stringify!(shaderCoreBuiltins)
            )
        );
    }
    test_field_shaderCoreBuiltins();
}
impl Default for VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderCoreMask: u64,
    pub shaderCoreCount: u32,
    pub shaderWarpsPerCore: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderCoreMask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderCoreMask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM),
                "::",
                stringify!(shaderCoreMask)
            )
        );
    }
    test_field_shaderCoreMask();
    fn test_field_shaderCoreCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderCoreCount) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM),
                "::",
                stringify!(shaderCoreCount)
            )
        );
    }
    test_field_shaderCoreCount();
    fn test_field_shaderWarpsPerCore() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderWarpsPerCore) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM),
                "::",
                stringify!(shaderWarpsPerCore)
            )
        );
    }
    test_field_shaderWarpsPerCore();
}
impl Default for VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR: VkBuildAccelerationStructureModeKHR = 0;
pub const VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR: VkBuildAccelerationStructureModeKHR = 1;
pub const VK_BUILD_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR: VkBuildAccelerationStructureModeKHR =
    2147483647;
pub type VkBuildAccelerationStructureModeKHR = ::std::os::raw::c_int;
pub const VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR:
    VkAccelerationStructureCreateFlagBitsKHR = 1;
pub const VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT:
    VkAccelerationStructureCreateFlagBitsKHR = 8;
pub const VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV: VkAccelerationStructureCreateFlagBitsKHR =
    4;
pub const VK_ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_MAX_ENUM_KHR:
    VkAccelerationStructureCreateFlagBitsKHR = 2147483647;
pub type VkAccelerationStructureCreateFlagBitsKHR = ::std::os::raw::c_int;
pub type VkAccelerationStructureCreateFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkAccelerationStructureBuildRangeInfoKHR {
    pub primitiveCount: u32,
    pub primitiveOffset: u32,
    pub firstVertex: u32,
    pub transformOffset: u32,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureBuildRangeInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureBuildRangeInfoKHR>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureBuildRangeInfoKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureBuildRangeInfoKHR>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureBuildRangeInfoKHR)
        )
    );
    fn test_field_primitiveCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildRangeInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).primitiveCount) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildRangeInfoKHR),
                "::",
                stringify!(primitiveCount)
            )
        );
    }
    test_field_primitiveCount();
    fn test_field_primitiveOffset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildRangeInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).primitiveOffset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildRangeInfoKHR),
                "::",
                stringify!(primitiveOffset)
            )
        );
    }
    test_field_primitiveOffset();
    fn test_field_firstVertex() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildRangeInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).firstVertex) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildRangeInfoKHR),
                "::",
                stringify!(firstVertex)
            )
        );
    }
    test_field_firstVertex();
    fn test_field_transformOffset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildRangeInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformOffset) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildRangeInfoKHR),
                "::",
                stringify!(transformOffset)
            )
        );
    }
    test_field_transformOffset();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureGeometryTrianglesDataKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub vertexFormat: VkFormat,
    pub vertexData: VkDeviceOrHostAddressConstKHR,
    pub vertexStride: VkDeviceSize,
    pub maxVertex: u32,
    pub indexType: VkIndexType,
    pub indexData: VkDeviceOrHostAddressConstKHR,
    pub transformData: VkDeviceOrHostAddressConstKHR,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureGeometryTrianglesDataKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureGeometryTrianglesDataKHR>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureGeometryTrianglesDataKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureGeometryTrianglesDataKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureGeometryTrianglesDataKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureGeometryTrianglesDataKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryTrianglesDataKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureGeometryTrianglesDataKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryTrianglesDataKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_vertexFormat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureGeometryTrianglesDataKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexFormat) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryTrianglesDataKHR),
                "::",
                stringify!(vertexFormat)
            )
        );
    }
    test_field_vertexFormat();
    fn test_field_vertexData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureGeometryTrianglesDataKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexData) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryTrianglesDataKHR),
                "::",
                stringify!(vertexData)
            )
        );
    }
    test_field_vertexData();
    fn test_field_vertexStride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureGeometryTrianglesDataKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vertexStride) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryTrianglesDataKHR),
                "::",
                stringify!(vertexStride)
            )
        );
    }
    test_field_vertexStride();
    fn test_field_maxVertex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureGeometryTrianglesDataKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxVertex) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryTrianglesDataKHR),
                "::",
                stringify!(maxVertex)
            )
        );
    }
    test_field_maxVertex();
    fn test_field_indexType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureGeometryTrianglesDataKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indexType) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryTrianglesDataKHR),
                "::",
                stringify!(indexType)
            )
        );
    }
    test_field_indexType();
    fn test_field_indexData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureGeometryTrianglesDataKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).indexData) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryTrianglesDataKHR),
                "::",
                stringify!(indexData)
            )
        );
    }
    test_field_indexData();
    fn test_field_transformData() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureGeometryTrianglesDataKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).transformData) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryTrianglesDataKHR),
                "::",
                stringify!(transformData)
            )
        );
    }
    test_field_transformData();
}
impl Default for VkAccelerationStructureGeometryTrianglesDataKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureGeometryAabbsDataKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub data: VkDeviceOrHostAddressConstKHR,
    pub stride: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureGeometryAabbsDataKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureGeometryAabbsDataKHR>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureGeometryAabbsDataKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureGeometryAabbsDataKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureGeometryAabbsDataKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureGeometryAabbsDataKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryAabbsDataKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureGeometryAabbsDataKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryAabbsDataKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureGeometryAabbsDataKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryAabbsDataKHR),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_stride() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureGeometryAabbsDataKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryAabbsDataKHR),
                "::",
                stringify!(stride)
            )
        );
    }
    test_field_stride();
}
impl Default for VkAccelerationStructureGeometryAabbsDataKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureGeometryInstancesDataKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub arrayOfPointers: VkBool32,
    pub data: VkDeviceOrHostAddressConstKHR,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureGeometryInstancesDataKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureGeometryInstancesDataKHR>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureGeometryInstancesDataKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureGeometryInstancesDataKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureGeometryInstancesDataKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureGeometryInstancesDataKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryInstancesDataKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureGeometryInstancesDataKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryInstancesDataKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_arrayOfPointers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureGeometryInstancesDataKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arrayOfPointers) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryInstancesDataKHR),
                "::",
                stringify!(arrayOfPointers)
            )
        );
    }
    test_field_arrayOfPointers();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkAccelerationStructureGeometryInstancesDataKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryInstancesDataKHR),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
impl Default for VkAccelerationStructureGeometryInstancesDataKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VkAccelerationStructureGeometryDataKHR {
    pub triangles: VkAccelerationStructureGeometryTrianglesDataKHR,
    pub aabbs: VkAccelerationStructureGeometryAabbsDataKHR,
    pub instances: VkAccelerationStructureGeometryInstancesDataKHR,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureGeometryDataKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureGeometryDataKHR>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureGeometryDataKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureGeometryDataKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureGeometryDataKHR)
        )
    );
    fn test_field_triangles() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureGeometryDataKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).triangles) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryDataKHR),
                "::",
                stringify!(triangles)
            )
        );
    }
    test_field_triangles();
    fn test_field_aabbs() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureGeometryDataKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aabbs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryDataKHR),
                "::",
                stringify!(aabbs)
            )
        );
    }
    test_field_aabbs();
    fn test_field_instances() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureGeometryDataKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).instances) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryDataKHR),
                "::",
                stringify!(instances)
            )
        );
    }
    test_field_instances();
}
impl Default for VkAccelerationStructureGeometryDataKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureGeometryKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub geometryType: VkGeometryTypeKHR,
    pub geometry: VkAccelerationStructureGeometryDataKHR,
    pub flags: VkGeometryFlagsKHR,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureGeometryKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureGeometryKHR>(),
        96usize,
        concat!("Size of: ", stringify!(VkAccelerationStructureGeometryKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureGeometryKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureGeometryKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureGeometryKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureGeometryKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_geometryType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureGeometryKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).geometryType) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryKHR),
                "::",
                stringify!(geometryType)
            )
        );
    }
    test_field_geometryType();
    fn test_field_geometry() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureGeometryKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).geometry) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryKHR),
                "::",
                stringify!(geometry)
            )
        );
    }
    test_field_geometry();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureGeometryKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureGeometryKHR),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
impl Default for VkAccelerationStructureGeometryKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkAccelerationStructureBuildGeometryInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub type_: VkAccelerationStructureTypeKHR,
    pub flags: VkBuildAccelerationStructureFlagsKHR,
    pub mode: VkBuildAccelerationStructureModeKHR,
    pub srcAccelerationStructure: VkAccelerationStructureKHR,
    pub dstAccelerationStructure: VkAccelerationStructureKHR,
    pub geometryCount: u32,
    pub pGeometries: *const VkAccelerationStructureGeometryKHR,
    pub ppGeometries: *const *const VkAccelerationStructureGeometryKHR,
    pub scratchData: VkDeviceOrHostAddressKHR,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureBuildGeometryInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureBuildGeometryInfoKHR>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureBuildGeometryInfoKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureBuildGeometryInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureBuildGeometryInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildGeometryInfoKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildGeometryInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildGeometryInfoKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildGeometryInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildGeometryInfoKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildGeometryInfoKHR),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildGeometryInfoKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildGeometryInfoKHR),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildGeometryInfoKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildGeometryInfoKHR),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_srcAccelerationStructure() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildGeometryInfoKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcAccelerationStructure) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildGeometryInfoKHR),
                "::",
                stringify!(srcAccelerationStructure)
            )
        );
    }
    test_field_srcAccelerationStructure();
    fn test_field_dstAccelerationStructure() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildGeometryInfoKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstAccelerationStructure) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildGeometryInfoKHR),
                "::",
                stringify!(dstAccelerationStructure)
            )
        );
    }
    test_field_dstAccelerationStructure();
    fn test_field_geometryCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildGeometryInfoKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).geometryCount) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildGeometryInfoKHR),
                "::",
                stringify!(geometryCount)
            )
        );
    }
    test_field_geometryCount();
    fn test_field_pGeometries() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildGeometryInfoKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pGeometries) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildGeometryInfoKHR),
                "::",
                stringify!(pGeometries)
            )
        );
    }
    test_field_pGeometries();
    fn test_field_ppGeometries() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildGeometryInfoKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ppGeometries) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildGeometryInfoKHR),
                "::",
                stringify!(ppGeometries)
            )
        );
    }
    test_field_ppGeometries();
    fn test_field_scratchData() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildGeometryInfoKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scratchData) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildGeometryInfoKHR),
                "::",
                stringify!(scratchData)
            )
        );
    }
    test_field_scratchData();
}
impl Default for VkAccelerationStructureBuildGeometryInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAccelerationStructureCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub createFlags: VkAccelerationStructureCreateFlagsKHR,
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
    pub type_: VkAccelerationStructureTypeKHR,
    pub deviceAddress: VkDeviceAddress,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureCreateInfoKHR>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureCreateInfoKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureCreateInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureCreateInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureCreateInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureCreateInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_createFlags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).createFlags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureCreateInfoKHR),
                "::",
                stringify!(createFlags)
            )
        );
    }
    test_field_createFlags();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureCreateInfoKHR),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureCreateInfoKHR),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureCreateInfoKHR),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureCreateInfoKHR),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_deviceAddress() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceAddress) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureCreateInfoKHR),
                "::",
                stringify!(deviceAddress)
            )
        );
    }
    test_field_deviceAddress();
}
impl Default for VkAccelerationStructureCreateInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkWriteDescriptorSetAccelerationStructureKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub accelerationStructureCount: u32,
    pub pAccelerationStructures: *const VkAccelerationStructureKHR,
}
#[test]
fn bindgen_test_layout_VkWriteDescriptorSetAccelerationStructureKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkWriteDescriptorSetAccelerationStructureKHR>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(VkWriteDescriptorSetAccelerationStructureKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkWriteDescriptorSetAccelerationStructureKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkWriteDescriptorSetAccelerationStructureKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkWriteDescriptorSetAccelerationStructureKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSetAccelerationStructureKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkWriteDescriptorSetAccelerationStructureKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSetAccelerationStructureKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_accelerationStructureCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkWriteDescriptorSetAccelerationStructureKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructureCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSetAccelerationStructureKHR),
                "::",
                stringify!(accelerationStructureCount)
            )
        );
    }
    test_field_accelerationStructureCount();
    fn test_field_pAccelerationStructures() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkWriteDescriptorSetAccelerationStructureKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pAccelerationStructures) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkWriteDescriptorSetAccelerationStructureKHR),
                "::",
                stringify!(pAccelerationStructures)
            )
        );
    }
    test_field_pAccelerationStructures();
}
impl Default for VkWriteDescriptorSetAccelerationStructureKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceAccelerationStructureFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub accelerationStructure: VkBool32,
    pub accelerationStructureCaptureReplay: VkBool32,
    pub accelerationStructureIndirectBuild: VkBool32,
    pub accelerationStructureHostCommands: VkBool32,
    pub descriptorBindingAccelerationStructureUpdateAfterBind: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceAccelerationStructureFeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceAccelerationStructureFeaturesKHR>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceAccelerationStructureFeaturesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceAccelerationStructureFeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceAccelerationStructureFeaturesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructureFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructureFeaturesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructureFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructureFeaturesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_accelerationStructure() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructureFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructure) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructureFeaturesKHR),
                "::",
                stringify!(accelerationStructure)
            )
        );
    }
    test_field_accelerationStructure();
    fn test_field_accelerationStructureCaptureReplay() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructureFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructureCaptureReplay) as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructureFeaturesKHR),
                "::",
                stringify!(accelerationStructureCaptureReplay)
            )
        );
    }
    test_field_accelerationStructureCaptureReplay();
    fn test_field_accelerationStructureIndirectBuild() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructureFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructureIndirectBuild) as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructureFeaturesKHR),
                "::",
                stringify!(accelerationStructureIndirectBuild)
            )
        );
    }
    test_field_accelerationStructureIndirectBuild();
    fn test_field_accelerationStructureHostCommands() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructureFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructureHostCommands) as usize
                    - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructureFeaturesKHR),
                "::",
                stringify!(accelerationStructureHostCommands)
            )
        );
    }
    test_field_accelerationStructureHostCommands();
    fn test_field_descriptorBindingAccelerationStructureUpdateAfterBind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructureFeaturesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descriptorBindingAccelerationStructureUpdateAfterBind)
                    as usize
                    - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructureFeaturesKHR),
                "::",
                stringify!(descriptorBindingAccelerationStructureUpdateAfterBind)
            )
        );
    }
    test_field_descriptorBindingAccelerationStructureUpdateAfterBind();
}
impl Default for VkPhysicalDeviceAccelerationStructureFeaturesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceAccelerationStructurePropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxGeometryCount: u64,
    pub maxInstanceCount: u64,
    pub maxPrimitiveCount: u64,
    pub maxPerStageDescriptorAccelerationStructures: u32,
    pub maxPerStageDescriptorUpdateAfterBindAccelerationStructures: u32,
    pub maxDescriptorSetAccelerationStructures: u32,
    pub maxDescriptorSetUpdateAfterBindAccelerationStructures: u32,
    pub minAccelerationStructureScratchOffsetAlignment: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceAccelerationStructurePropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceAccelerationStructurePropertiesKHR>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceAccelerationStructurePropertiesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceAccelerationStructurePropertiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceAccelerationStructurePropertiesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructurePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructurePropertiesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructurePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructurePropertiesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxGeometryCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructurePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxGeometryCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructurePropertiesKHR),
                "::",
                stringify!(maxGeometryCount)
            )
        );
    }
    test_field_maxGeometryCount();
    fn test_field_maxInstanceCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructurePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxInstanceCount) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructurePropertiesKHR),
                "::",
                stringify!(maxInstanceCount)
            )
        );
    }
    test_field_maxInstanceCount();
    fn test_field_maxPrimitiveCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructurePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPrimitiveCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructurePropertiesKHR),
                "::",
                stringify!(maxPrimitiveCount)
            )
        );
    }
    test_field_maxPrimitiveCount();
    fn test_field_maxPerStageDescriptorAccelerationStructures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructurePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPerStageDescriptorAccelerationStructures) as usize
                    - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructurePropertiesKHR),
                "::",
                stringify!(maxPerStageDescriptorAccelerationStructures)
            )
        );
    }
    test_field_maxPerStageDescriptorAccelerationStructures();
    fn test_field_maxPerStageDescriptorUpdateAfterBindAccelerationStructures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructurePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!(
                    (*ptr).maxPerStageDescriptorUpdateAfterBindAccelerationStructures
                ) as usize
                    - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructurePropertiesKHR),
                "::",
                stringify!(maxPerStageDescriptorUpdateAfterBindAccelerationStructures)
            )
        );
    }
    test_field_maxPerStageDescriptorUpdateAfterBindAccelerationStructures();
    fn test_field_maxDescriptorSetAccelerationStructures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructurePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetAccelerationStructures) as usize
                    - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructurePropertiesKHR),
                "::",
                stringify!(maxDescriptorSetAccelerationStructures)
            )
        );
    }
    test_field_maxDescriptorSetAccelerationStructures();
    fn test_field_maxDescriptorSetUpdateAfterBindAccelerationStructures() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructurePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxDescriptorSetUpdateAfterBindAccelerationStructures)
                    as usize
                    - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructurePropertiesKHR),
                "::",
                stringify!(maxDescriptorSetUpdateAfterBindAccelerationStructures)
            )
        );
    }
    test_field_maxDescriptorSetUpdateAfterBindAccelerationStructures();
    fn test_field_minAccelerationStructureScratchOffsetAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceAccelerationStructurePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minAccelerationStructureScratchOffsetAlignment) as usize
                    - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceAccelerationStructurePropertiesKHR),
                "::",
                stringify!(minAccelerationStructureScratchOffsetAlignment)
            )
        );
    }
    test_field_minAccelerationStructureScratchOffsetAlignment();
}
impl Default for VkPhysicalDeviceAccelerationStructurePropertiesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAccelerationStructureDeviceAddressInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub accelerationStructure: VkAccelerationStructureKHR,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureDeviceAddressInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureDeviceAddressInfoKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureDeviceAddressInfoKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureDeviceAddressInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureDeviceAddressInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureDeviceAddressInfoKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureDeviceAddressInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureDeviceAddressInfoKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureDeviceAddressInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_accelerationStructure() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureDeviceAddressInfoKHR>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructure) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureDeviceAddressInfoKHR),
                "::",
                stringify!(accelerationStructure)
            )
        );
    }
    test_field_accelerationStructure();
}
impl Default for VkAccelerationStructureDeviceAddressInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAccelerationStructureVersionInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pVersionData: *const u8,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureVersionInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureVersionInfoKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureVersionInfoKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureVersionInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureVersionInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureVersionInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureVersionInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureVersionInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureVersionInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_pVersionData() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureVersionInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pVersionData) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureVersionInfoKHR),
                "::",
                stringify!(pVersionData)
            )
        );
    }
    test_field_pVersionData();
}
impl Default for VkAccelerationStructureVersionInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyAccelerationStructureToMemoryInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub src: VkAccelerationStructureKHR,
    pub dst: VkDeviceOrHostAddressKHR,
    pub mode: VkCopyAccelerationStructureModeKHR,
}
#[test]
fn bindgen_test_layout_VkCopyAccelerationStructureToMemoryInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkCopyAccelerationStructureToMemoryInfoKHR>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkCopyAccelerationStructureToMemoryInfoKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkCopyAccelerationStructureToMemoryInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkCopyAccelerationStructureToMemoryInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyAccelerationStructureToMemoryInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyAccelerationStructureToMemoryInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyAccelerationStructureToMemoryInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyAccelerationStructureToMemoryInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_src() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyAccelerationStructureToMemoryInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyAccelerationStructureToMemoryInfoKHR),
                "::",
                stringify!(src)
            )
        );
    }
    test_field_src();
    fn test_field_dst() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyAccelerationStructureToMemoryInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyAccelerationStructureToMemoryInfoKHR),
                "::",
                stringify!(dst)
            )
        );
    }
    test_field_dst();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyAccelerationStructureToMemoryInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyAccelerationStructureToMemoryInfoKHR),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
}
impl Default for VkCopyAccelerationStructureToMemoryInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkCopyMemoryToAccelerationStructureInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub src: VkDeviceOrHostAddressConstKHR,
    pub dst: VkAccelerationStructureKHR,
    pub mode: VkCopyAccelerationStructureModeKHR,
}
#[test]
fn bindgen_test_layout_VkCopyMemoryToAccelerationStructureInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkCopyMemoryToAccelerationStructureInfoKHR>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkCopyMemoryToAccelerationStructureInfoKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkCopyMemoryToAccelerationStructureInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkCopyMemoryToAccelerationStructureInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyMemoryToAccelerationStructureInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryToAccelerationStructureInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyMemoryToAccelerationStructureInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryToAccelerationStructureInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_src() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyMemoryToAccelerationStructureInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryToAccelerationStructureInfoKHR),
                "::",
                stringify!(src)
            )
        );
    }
    test_field_src();
    fn test_field_dst() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyMemoryToAccelerationStructureInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryToAccelerationStructureInfoKHR),
                "::",
                stringify!(dst)
            )
        );
    }
    test_field_dst();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyMemoryToAccelerationStructureInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyMemoryToAccelerationStructureInfoKHR),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
}
impl Default for VkCopyMemoryToAccelerationStructureInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCopyAccelerationStructureInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub src: VkAccelerationStructureKHR,
    pub dst: VkAccelerationStructureKHR,
    pub mode: VkCopyAccelerationStructureModeKHR,
}
#[test]
fn bindgen_test_layout_VkCopyAccelerationStructureInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkCopyAccelerationStructureInfoKHR>(),
        40usize,
        concat!("Size of: ", stringify!(VkCopyAccelerationStructureInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkCopyAccelerationStructureInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkCopyAccelerationStructureInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyAccelerationStructureInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyAccelerationStructureInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyAccelerationStructureInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyAccelerationStructureInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_src() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyAccelerationStructureInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyAccelerationStructureInfoKHR),
                "::",
                stringify!(src)
            )
        );
    }
    test_field_src();
    fn test_field_dst() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyAccelerationStructureInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyAccelerationStructureInfoKHR),
                "::",
                stringify!(dst)
            )
        );
    }
    test_field_dst();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkCopyAccelerationStructureInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkCopyAccelerationStructureInfoKHR),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
}
impl Default for VkCopyAccelerationStructureInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkAccelerationStructureBuildSizesInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub accelerationStructureSize: VkDeviceSize,
    pub updateScratchSize: VkDeviceSize,
    pub buildScratchSize: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkAccelerationStructureBuildSizesInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkAccelerationStructureBuildSizesInfoKHR>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkAccelerationStructureBuildSizesInfoKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkAccelerationStructureBuildSizesInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkAccelerationStructureBuildSizesInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildSizesInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildSizesInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildSizesInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildSizesInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_accelerationStructureSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildSizesInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accelerationStructureSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildSizesInfoKHR),
                "::",
                stringify!(accelerationStructureSize)
            )
        );
    }
    test_field_accelerationStructureSize();
    fn test_field_updateScratchSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildSizesInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).updateScratchSize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildSizesInfoKHR),
                "::",
                stringify!(updateScratchSize)
            )
        );
    }
    test_field_updateScratchSize();
    fn test_field_buildScratchSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkAccelerationStructureBuildSizesInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buildScratchSize) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkAccelerationStructureBuildSizesInfoKHR),
                "::",
                stringify!(buildScratchSize)
            )
        );
    }
    test_field_buildScratchSize();
}
impl Default for VkAccelerationStructureBuildSizesInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PFN_vkCreateAccelerationStructureKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pCreateInfo: *const VkAccelerationStructureCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pAccelerationStructure: *mut VkAccelerationStructureKHR,
    ) -> VkResult,
>;
pub type PFN_vkDestroyAccelerationStructureKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        accelerationStructure: VkAccelerationStructureKHR,
        pAllocator: *const VkAllocationCallbacks,
    ),
>;
pub type PFN_vkCmdBuildAccelerationStructuresKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        infoCount: u32,
        pInfos: *const VkAccelerationStructureBuildGeometryInfoKHR,
        ppBuildRangeInfos: *const *const VkAccelerationStructureBuildRangeInfoKHR,
    ),
>;
pub type PFN_vkCmdBuildAccelerationStructuresIndirectKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        infoCount: u32,
        pInfos: *const VkAccelerationStructureBuildGeometryInfoKHR,
        pIndirectDeviceAddresses: *const VkDeviceAddress,
        pIndirectStrides: *const u32,
        ppMaxPrimitiveCounts: *const *const u32,
    ),
>;
pub type PFN_vkBuildAccelerationStructuresKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        infoCount: u32,
        pInfos: *const VkAccelerationStructureBuildGeometryInfoKHR,
        ppBuildRangeInfos: *const *const VkAccelerationStructureBuildRangeInfoKHR,
    ) -> VkResult,
>;
pub type PFN_vkCopyAccelerationStructureKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        pInfo: *const VkCopyAccelerationStructureInfoKHR,
    ) -> VkResult,
>;
pub type PFN_vkCopyAccelerationStructureToMemoryKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        pInfo: *const VkCopyAccelerationStructureToMemoryInfoKHR,
    ) -> VkResult,
>;
pub type PFN_vkCopyMemoryToAccelerationStructureKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        pInfo: *const VkCopyMemoryToAccelerationStructureInfoKHR,
    ) -> VkResult,
>;
pub type PFN_vkWriteAccelerationStructuresPropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        accelerationStructureCount: u32,
        pAccelerationStructures: *const VkAccelerationStructureKHR,
        queryType: VkQueryType,
        dataSize: usize,
        pData: *mut ::std::os::raw::c_void,
        stride: usize,
    ) -> VkResult,
>;
pub type PFN_vkCmdCopyAccelerationStructureKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pInfo: *const VkCopyAccelerationStructureInfoKHR,
    ),
>;
pub type PFN_vkCmdCopyAccelerationStructureToMemoryKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pInfo: *const VkCopyAccelerationStructureToMemoryInfoKHR,
    ),
>;
pub type PFN_vkCmdCopyMemoryToAccelerationStructureKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pInfo: *const VkCopyMemoryToAccelerationStructureInfoKHR,
    ),
>;
pub type PFN_vkGetAccelerationStructureDeviceAddressKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pInfo: *const VkAccelerationStructureDeviceAddressInfoKHR,
    ) -> VkDeviceAddress,
>;
pub type PFN_vkCmdWriteAccelerationStructuresPropertiesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        accelerationStructureCount: u32,
        pAccelerationStructures: *const VkAccelerationStructureKHR,
        queryType: VkQueryType,
        queryPool: VkQueryPool,
        firstQuery: u32,
    ),
>;
pub type PFN_vkGetDeviceAccelerationStructureCompatibilityKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pVersionInfo: *const VkAccelerationStructureVersionInfoKHR,
        pCompatibility: *mut VkAccelerationStructureCompatibilityKHR,
    ),
>;
pub type PFN_vkGetAccelerationStructureBuildSizesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        buildType: VkAccelerationStructureBuildTypeKHR,
        pBuildInfo: *const VkAccelerationStructureBuildGeometryInfoKHR,
        pMaxPrimitiveCounts: *const u32,
        pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR,
    ),
>;
extern "C" {
    pub fn vkCreateAccelerationStructureKHR(
        device: VkDevice,
        pCreateInfo: *const VkAccelerationStructureCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pAccelerationStructure: *mut VkAccelerationStructureKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkDestroyAccelerationStructureKHR(
        device: VkDevice,
        accelerationStructure: VkAccelerationStructureKHR,
        pAllocator: *const VkAllocationCallbacks,
    );
}
extern "C" {
    pub fn vkCmdBuildAccelerationStructuresKHR(
        commandBuffer: VkCommandBuffer,
        infoCount: u32,
        pInfos: *const VkAccelerationStructureBuildGeometryInfoKHR,
        ppBuildRangeInfos: *const *const VkAccelerationStructureBuildRangeInfoKHR,
    );
}
extern "C" {
    pub fn vkCmdBuildAccelerationStructuresIndirectKHR(
        commandBuffer: VkCommandBuffer,
        infoCount: u32,
        pInfos: *const VkAccelerationStructureBuildGeometryInfoKHR,
        pIndirectDeviceAddresses: *const VkDeviceAddress,
        pIndirectStrides: *const u32,
        ppMaxPrimitiveCounts: *const *const u32,
    );
}
extern "C" {
    pub fn vkBuildAccelerationStructuresKHR(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        infoCount: u32,
        pInfos: *const VkAccelerationStructureBuildGeometryInfoKHR,
        ppBuildRangeInfos: *const *const VkAccelerationStructureBuildRangeInfoKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCopyAccelerationStructureKHR(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        pInfo: *const VkCopyAccelerationStructureInfoKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCopyAccelerationStructureToMemoryKHR(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        pInfo: *const VkCopyAccelerationStructureToMemoryInfoKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCopyMemoryToAccelerationStructureKHR(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        pInfo: *const VkCopyMemoryToAccelerationStructureInfoKHR,
    ) -> VkResult;
}
extern "C" {
    pub fn vkWriteAccelerationStructuresPropertiesKHR(
        device: VkDevice,
        accelerationStructureCount: u32,
        pAccelerationStructures: *const VkAccelerationStructureKHR,
        queryType: VkQueryType,
        dataSize: usize,
        pData: *mut ::std::os::raw::c_void,
        stride: usize,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdCopyAccelerationStructureKHR(
        commandBuffer: VkCommandBuffer,
        pInfo: *const VkCopyAccelerationStructureInfoKHR,
    );
}
extern "C" {
    pub fn vkCmdCopyAccelerationStructureToMemoryKHR(
        commandBuffer: VkCommandBuffer,
        pInfo: *const VkCopyAccelerationStructureToMemoryInfoKHR,
    );
}
extern "C" {
    pub fn vkCmdCopyMemoryToAccelerationStructureKHR(
        commandBuffer: VkCommandBuffer,
        pInfo: *const VkCopyMemoryToAccelerationStructureInfoKHR,
    );
}
extern "C" {
    pub fn vkGetAccelerationStructureDeviceAddressKHR(
        device: VkDevice,
        pInfo: *const VkAccelerationStructureDeviceAddressInfoKHR,
    ) -> VkDeviceAddress;
}
extern "C" {
    pub fn vkCmdWriteAccelerationStructuresPropertiesKHR(
        commandBuffer: VkCommandBuffer,
        accelerationStructureCount: u32,
        pAccelerationStructures: *const VkAccelerationStructureKHR,
        queryType: VkQueryType,
        queryPool: VkQueryPool,
        firstQuery: u32,
    );
}
extern "C" {
    pub fn vkGetDeviceAccelerationStructureCompatibilityKHR(
        device: VkDevice,
        pVersionInfo: *const VkAccelerationStructureVersionInfoKHR,
        pCompatibility: *mut VkAccelerationStructureCompatibilityKHR,
    );
}
extern "C" {
    pub fn vkGetAccelerationStructureBuildSizesKHR(
        device: VkDevice,
        buildType: VkAccelerationStructureBuildTypeKHR,
        pBuildInfo: *const VkAccelerationStructureBuildGeometryInfoKHR,
        pMaxPrimitiveCounts: *const u32,
        pSizeInfo: *mut VkAccelerationStructureBuildSizesInfoKHR,
    );
}
pub const VK_SHADER_GROUP_SHADER_GENERAL_KHR: VkShaderGroupShaderKHR = 0;
pub const VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR: VkShaderGroupShaderKHR = 1;
pub const VK_SHADER_GROUP_SHADER_ANY_HIT_KHR: VkShaderGroupShaderKHR = 2;
pub const VK_SHADER_GROUP_SHADER_INTERSECTION_KHR: VkShaderGroupShaderKHR = 3;
pub const VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR: VkShaderGroupShaderKHR = 2147483647;
pub type VkShaderGroupShaderKHR = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRayTracingShaderGroupCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub type_: VkRayTracingShaderGroupTypeKHR,
    pub generalShader: u32,
    pub closestHitShader: u32,
    pub anyHitShader: u32,
    pub intersectionShader: u32,
    pub pShaderGroupCaptureReplayHandle: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkRayTracingShaderGroupCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkRayTracingShaderGroupCreateInfoKHR>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkRayTracingShaderGroupCreateInfoKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkRayTracingShaderGroupCreateInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRayTracingShaderGroupCreateInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingShaderGroupCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingShaderGroupCreateInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingShaderGroupCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingShaderGroupCreateInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingShaderGroupCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingShaderGroupCreateInfoKHR),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_generalShader() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingShaderGroupCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).generalShader) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingShaderGroupCreateInfoKHR),
                "::",
                stringify!(generalShader)
            )
        );
    }
    test_field_generalShader();
    fn test_field_closestHitShader() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingShaderGroupCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).closestHitShader) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingShaderGroupCreateInfoKHR),
                "::",
                stringify!(closestHitShader)
            )
        );
    }
    test_field_closestHitShader();
    fn test_field_anyHitShader() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingShaderGroupCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).anyHitShader) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingShaderGroupCreateInfoKHR),
                "::",
                stringify!(anyHitShader)
            )
        );
    }
    test_field_anyHitShader();
    fn test_field_intersectionShader() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingShaderGroupCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).intersectionShader) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingShaderGroupCreateInfoKHR),
                "::",
                stringify!(intersectionShader)
            )
        );
    }
    test_field_intersectionShader();
    fn test_field_pShaderGroupCaptureReplayHandle() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingShaderGroupCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pShaderGroupCaptureReplayHandle) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingShaderGroupCreateInfoKHR),
                "::",
                stringify!(pShaderGroupCaptureReplayHandle)
            )
        );
    }
    test_field_pShaderGroupCaptureReplayHandle();
}
impl Default for VkRayTracingShaderGroupCreateInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRayTracingPipelineInterfaceCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub maxPipelineRayPayloadSize: u32,
    pub maxPipelineRayHitAttributeSize: u32,
}
#[test]
fn bindgen_test_layout_VkRayTracingPipelineInterfaceCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkRayTracingPipelineInterfaceCreateInfoKHR>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(VkRayTracingPipelineInterfaceCreateInfoKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkRayTracingPipelineInterfaceCreateInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRayTracingPipelineInterfaceCreateInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingPipelineInterfaceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineInterfaceCreateInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingPipelineInterfaceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineInterfaceCreateInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxPipelineRayPayloadSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingPipelineInterfaceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPipelineRayPayloadSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineInterfaceCreateInfoKHR),
                "::",
                stringify!(maxPipelineRayPayloadSize)
            )
        );
    }
    test_field_maxPipelineRayPayloadSize();
    fn test_field_maxPipelineRayHitAttributeSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkRayTracingPipelineInterfaceCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPipelineRayHitAttributeSize) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineInterfaceCreateInfoKHR),
                "::",
                stringify!(maxPipelineRayHitAttributeSize)
            )
        );
    }
    test_field_maxPipelineRayHitAttributeSize();
}
impl Default for VkRayTracingPipelineInterfaceCreateInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRayTracingPipelineCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCreateFlags,
    pub stageCount: u32,
    pub pStages: *const VkPipelineShaderStageCreateInfo,
    pub groupCount: u32,
    pub pGroups: *const VkRayTracingShaderGroupCreateInfoKHR,
    pub maxPipelineRayRecursionDepth: u32,
    pub pLibraryInfo: *const VkPipelineLibraryCreateInfoKHR,
    pub pLibraryInterface: *const VkRayTracingPipelineInterfaceCreateInfoKHR,
    pub pDynamicState: *const VkPipelineDynamicStateCreateInfo,
    pub layout: VkPipelineLayout,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: i32,
}
#[test]
fn bindgen_test_layout_VkRayTracingPipelineCreateInfoKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkRayTracingPipelineCreateInfoKHR>(),
        104usize,
        concat!("Size of: ", stringify!(VkRayTracingPipelineCreateInfoKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkRayTracingPipelineCreateInfoKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkRayTracingPipelineCreateInfoKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoKHR),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_stageCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stageCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoKHR),
                "::",
                stringify!(stageCount)
            )
        );
    }
    test_field_stageCount();
    fn test_field_pStages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pStages) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoKHR),
                "::",
                stringify!(pStages)
            )
        );
    }
    test_field_pStages();
    fn test_field_groupCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).groupCount) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoKHR),
                "::",
                stringify!(groupCount)
            )
        );
    }
    test_field_groupCount();
    fn test_field_pGroups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pGroups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoKHR),
                "::",
                stringify!(pGroups)
            )
        );
    }
    test_field_pGroups();
    fn test_field_maxPipelineRayRecursionDepth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPipelineRayRecursionDepth) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoKHR),
                "::",
                stringify!(maxPipelineRayRecursionDepth)
            )
        );
    }
    test_field_maxPipelineRayRecursionDepth();
    fn test_field_pLibraryInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pLibraryInfo) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoKHR),
                "::",
                stringify!(pLibraryInfo)
            )
        );
    }
    test_field_pLibraryInfo();
    fn test_field_pLibraryInterface() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pLibraryInterface) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoKHR),
                "::",
                stringify!(pLibraryInterface)
            )
        );
    }
    test_field_pLibraryInterface();
    fn test_field_pDynamicState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pDynamicState) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoKHR),
                "::",
                stringify!(pDynamicState)
            )
        );
    }
    test_field_pDynamicState();
    fn test_field_layout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).layout) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoKHR),
                "::",
                stringify!(layout)
            )
        );
    }
    test_field_layout();
    fn test_field_basePipelineHandle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).basePipelineHandle) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoKHR),
                "::",
                stringify!(basePipelineHandle)
            )
        );
    }
    test_field_basePipelineHandle();
    fn test_field_basePipelineIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkRayTracingPipelineCreateInfoKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).basePipelineIndex) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkRayTracingPipelineCreateInfoKHR),
                "::",
                stringify!(basePipelineIndex)
            )
        );
    }
    test_field_basePipelineIndex();
}
impl Default for VkRayTracingPipelineCreateInfoKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceRayTracingPipelineFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub rayTracingPipeline: VkBool32,
    pub rayTracingPipelineShaderGroupHandleCaptureReplay: VkBool32,
    pub rayTracingPipelineShaderGroupHandleCaptureReplayMixed: VkBool32,
    pub rayTracingPipelineTraceRaysIndirect: VkBool32,
    pub rayTraversalPrimitiveCulling: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceRayTracingPipelineFeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceRayTracingPipelineFeaturesKHR>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceRayTracingPipelineFeaturesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceRayTracingPipelineFeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceRayTracingPipelineFeaturesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceRayTracingPipelineFeaturesKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelineFeaturesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceRayTracingPipelineFeaturesKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelineFeaturesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_rayTracingPipeline() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceRayTracingPipelineFeaturesKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rayTracingPipeline) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelineFeaturesKHR),
                "::",
                stringify!(rayTracingPipeline)
            )
        );
    }
    test_field_rayTracingPipeline();
    fn test_field_rayTracingPipelineShaderGroupHandleCaptureReplay() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceRayTracingPipelineFeaturesKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rayTracingPipelineShaderGroupHandleCaptureReplay)
                    as usize
                    - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelineFeaturesKHR),
                "::",
                stringify!(rayTracingPipelineShaderGroupHandleCaptureReplay)
            )
        );
    }
    test_field_rayTracingPipelineShaderGroupHandleCaptureReplay();
    fn test_field_rayTracingPipelineShaderGroupHandleCaptureReplayMixed() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceRayTracingPipelineFeaturesKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rayTracingPipelineShaderGroupHandleCaptureReplayMixed)
                    as usize
                    - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelineFeaturesKHR),
                "::",
                stringify!(rayTracingPipelineShaderGroupHandleCaptureReplayMixed)
            )
        );
    }
    test_field_rayTracingPipelineShaderGroupHandleCaptureReplayMixed();
    fn test_field_rayTracingPipelineTraceRaysIndirect() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceRayTracingPipelineFeaturesKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rayTracingPipelineTraceRaysIndirect) as usize
                    - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelineFeaturesKHR),
                "::",
                stringify!(rayTracingPipelineTraceRaysIndirect)
            )
        );
    }
    test_field_rayTracingPipelineTraceRaysIndirect();
    fn test_field_rayTraversalPrimitiveCulling() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < VkPhysicalDeviceRayTracingPipelineFeaturesKHR > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rayTraversalPrimitiveCulling) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelineFeaturesKHR),
                "::",
                stringify!(rayTraversalPrimitiveCulling)
            )
        );
    }
    test_field_rayTraversalPrimitiveCulling();
}
impl Default for VkPhysicalDeviceRayTracingPipelineFeaturesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceRayTracingPipelinePropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub shaderGroupHandleSize: u32,
    pub maxRayRecursionDepth: u32,
    pub maxShaderGroupStride: u32,
    pub shaderGroupBaseAlignment: u32,
    pub shaderGroupHandleCaptureReplaySize: u32,
    pub maxRayDispatchInvocationCount: u32,
    pub shaderGroupHandleAlignment: u32,
    pub maxRayHitAttributeSize: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceRayTracingPipelinePropertiesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceRayTracingPipelinePropertiesKHR>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceRayTracingPipelinePropertiesKHR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceRayTracingPipelinePropertiesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceRayTracingPipelinePropertiesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingPipelinePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelinePropertiesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingPipelinePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelinePropertiesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_shaderGroupHandleSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingPipelinePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderGroupHandleSize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelinePropertiesKHR),
                "::",
                stringify!(shaderGroupHandleSize)
            )
        );
    }
    test_field_shaderGroupHandleSize();
    fn test_field_maxRayRecursionDepth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingPipelinePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxRayRecursionDepth) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelinePropertiesKHR),
                "::",
                stringify!(maxRayRecursionDepth)
            )
        );
    }
    test_field_maxRayRecursionDepth();
    fn test_field_maxShaderGroupStride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingPipelinePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxShaderGroupStride) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelinePropertiesKHR),
                "::",
                stringify!(maxShaderGroupStride)
            )
        );
    }
    test_field_maxShaderGroupStride();
    fn test_field_shaderGroupBaseAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingPipelinePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderGroupBaseAlignment) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelinePropertiesKHR),
                "::",
                stringify!(shaderGroupBaseAlignment)
            )
        );
    }
    test_field_shaderGroupBaseAlignment();
    fn test_field_shaderGroupHandleCaptureReplaySize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingPipelinePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderGroupHandleCaptureReplaySize) as usize
                    - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelinePropertiesKHR),
                "::",
                stringify!(shaderGroupHandleCaptureReplaySize)
            )
        );
    }
    test_field_shaderGroupHandleCaptureReplaySize();
    fn test_field_maxRayDispatchInvocationCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingPipelinePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxRayDispatchInvocationCount) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelinePropertiesKHR),
                "::",
                stringify!(maxRayDispatchInvocationCount)
            )
        );
    }
    test_field_maxRayDispatchInvocationCount();
    fn test_field_shaderGroupHandleAlignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingPipelinePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shaderGroupHandleAlignment) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelinePropertiesKHR),
                "::",
                stringify!(shaderGroupHandleAlignment)
            )
        );
    }
    test_field_shaderGroupHandleAlignment();
    fn test_field_maxRayHitAttributeSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    VkPhysicalDeviceRayTracingPipelinePropertiesKHR,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxRayHitAttributeSize) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayTracingPipelinePropertiesKHR),
                "::",
                stringify!(maxRayHitAttributeSize)
            )
        );
    }
    test_field_maxRayHitAttributeSize();
}
impl Default for VkPhysicalDeviceRayTracingPipelinePropertiesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkStridedDeviceAddressRegionKHR {
    pub deviceAddress: VkDeviceAddress,
    pub stride: VkDeviceSize,
    pub size: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkStridedDeviceAddressRegionKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkStridedDeviceAddressRegionKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkStridedDeviceAddressRegionKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkStridedDeviceAddressRegionKHR>(),
        8usize,
        concat!("Alignment of ", stringify!(VkStridedDeviceAddressRegionKHR))
    );
    fn test_field_deviceAddress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkStridedDeviceAddressRegionKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).deviceAddress) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkStridedDeviceAddressRegionKHR),
                "::",
                stringify!(deviceAddress)
            )
        );
    }
    test_field_deviceAddress();
    fn test_field_stride() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkStridedDeviceAddressRegionKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkStridedDeviceAddressRegionKHR),
                "::",
                stringify!(stride)
            )
        );
    }
    test_field_stride();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkStridedDeviceAddressRegionKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkStridedDeviceAddressRegionKHR),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkTraceRaysIndirectCommandKHR {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
#[test]
fn bindgen_test_layout_VkTraceRaysIndirectCommandKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkTraceRaysIndirectCommandKHR>(),
        12usize,
        concat!("Size of: ", stringify!(VkTraceRaysIndirectCommandKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkTraceRaysIndirectCommandKHR>(),
        4usize,
        concat!("Alignment of ", stringify!(VkTraceRaysIndirectCommandKHR))
    );
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommandKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommandKHR),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommandKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommandKHR),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkTraceRaysIndirectCommandKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkTraceRaysIndirectCommandKHR),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
}
pub type PFN_vkCmdTraceRaysKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
        pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
        pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
        pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
        width: u32,
        height: u32,
        depth: u32,
    ),
>;
pub type PFN_vkCreateRayTracingPipelinesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        pipelineCache: VkPipelineCache,
        createInfoCount: u32,
        pCreateInfos: *const VkRayTracingPipelineCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult,
>;
pub type PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipeline: VkPipeline,
        firstGroup: u32,
        groupCount: u32,
        dataSize: usize,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult,
>;
pub type PFN_vkCmdTraceRaysIndirectKHR = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
        pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
        pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
        pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
        indirectDeviceAddress: VkDeviceAddress,
    ),
>;
pub type PFN_vkGetRayTracingShaderGroupStackSizeKHR = ::std::option::Option<
    unsafe extern "C" fn(
        device: VkDevice,
        pipeline: VkPipeline,
        group: u32,
        groupShader: VkShaderGroupShaderKHR,
    ) -> VkDeviceSize,
>;
pub type PFN_vkCmdSetRayTracingPipelineStackSizeKHR = ::std::option::Option<
    unsafe extern "C" fn(commandBuffer: VkCommandBuffer, pipelineStackSize: u32),
>;
extern "C" {
    pub fn vkCmdTraceRaysKHR(
        commandBuffer: VkCommandBuffer,
        pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
        pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
        pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
        pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
        width: u32,
        height: u32,
        depth: u32,
    );
}
extern "C" {
    pub fn vkCreateRayTracingPipelinesKHR(
        device: VkDevice,
        deferredOperation: VkDeferredOperationKHR,
        pipelineCache: VkPipelineCache,
        createInfoCount: u32,
        pCreateInfos: *const VkRayTracingPipelineCreateInfoKHR,
        pAllocator: *const VkAllocationCallbacks,
        pPipelines: *mut VkPipeline,
    ) -> VkResult;
}
extern "C" {
    pub fn vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(
        device: VkDevice,
        pipeline: VkPipeline,
        firstGroup: u32,
        groupCount: u32,
        dataSize: usize,
        pData: *mut ::std::os::raw::c_void,
    ) -> VkResult;
}
extern "C" {
    pub fn vkCmdTraceRaysIndirectKHR(
        commandBuffer: VkCommandBuffer,
        pRaygenShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
        pMissShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
        pHitShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
        pCallableShaderBindingTable: *const VkStridedDeviceAddressRegionKHR,
        indirectDeviceAddress: VkDeviceAddress,
    );
}
extern "C" {
    pub fn vkGetRayTracingShaderGroupStackSizeKHR(
        device: VkDevice,
        pipeline: VkPipeline,
        group: u32,
        groupShader: VkShaderGroupShaderKHR,
    ) -> VkDeviceSize;
}
extern "C" {
    pub fn vkCmdSetRayTracingPipelineStackSizeKHR(
        commandBuffer: VkCommandBuffer,
        pipelineStackSize: u32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceRayQueryFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub rayQuery: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceRayQueryFeaturesKHR() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceRayQueryFeaturesKHR>(),
        24usize,
        concat!("Size of: ", stringify!(VkPhysicalDeviceRayQueryFeaturesKHR))
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceRayQueryFeaturesKHR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceRayQueryFeaturesKHR)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRayQueryFeaturesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayQueryFeaturesKHR),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRayQueryFeaturesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayQueryFeaturesKHR),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_rayQuery() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceRayQueryFeaturesKHR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rayQuery) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceRayQueryFeaturesKHR),
                "::",
                stringify!(rayQuery)
            )
        );
    }
    test_field_rayQuery();
}
impl Default for VkPhysicalDeviceRayQueryFeaturesKHR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMeshShaderFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub taskShader: VkBool32,
    pub meshShader: VkBool32,
    pub multiviewMeshShader: VkBool32,
    pub primitiveFragmentShadingRateMeshShader: VkBool32,
    pub meshShaderQueries: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMeshShaderFeaturesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMeshShaderFeaturesEXT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMeshShaderFeaturesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMeshShaderFeaturesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMeshShaderFeaturesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderFeaturesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderFeaturesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_taskShader() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).taskShader) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderFeaturesEXT),
                "::",
                stringify!(taskShader)
            )
        );
    }
    test_field_taskShader();
    fn test_field_meshShader() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).meshShader) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderFeaturesEXT),
                "::",
                stringify!(meshShader)
            )
        );
    }
    test_field_meshShader();
    fn test_field_multiviewMeshShader() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multiviewMeshShader) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderFeaturesEXT),
                "::",
                stringify!(multiviewMeshShader)
            )
        );
    }
    test_field_multiviewMeshShader();
    fn test_field_primitiveFragmentShadingRateMeshShader() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).primitiveFragmentShadingRateMeshShader) as usize
                    - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderFeaturesEXT),
                "::",
                stringify!(primitiveFragmentShadingRateMeshShader)
            )
        );
    }
    test_field_primitiveFragmentShadingRateMeshShader();
    fn test_field_meshShaderQueries() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderFeaturesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).meshShaderQueries) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderFeaturesEXT),
                "::",
                stringify!(meshShaderQueries)
            )
        );
    }
    test_field_meshShaderQueries();
}
impl Default for VkPhysicalDeviceMeshShaderFeaturesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDeviceMeshShaderPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxTaskWorkGroupTotalCount: u32,
    pub maxTaskWorkGroupCount: [u32; 3usize],
    pub maxTaskWorkGroupInvocations: u32,
    pub maxTaskWorkGroupSize: [u32; 3usize],
    pub maxTaskPayloadSize: u32,
    pub maxTaskSharedMemorySize: u32,
    pub maxTaskPayloadAndSharedMemorySize: u32,
    pub maxMeshWorkGroupTotalCount: u32,
    pub maxMeshWorkGroupCount: [u32; 3usize],
    pub maxMeshWorkGroupInvocations: u32,
    pub maxMeshWorkGroupSize: [u32; 3usize],
    pub maxMeshSharedMemorySize: u32,
    pub maxMeshPayloadAndSharedMemorySize: u32,
    pub maxMeshOutputMemorySize: u32,
    pub maxMeshPayloadAndOutputMemorySize: u32,
    pub maxMeshOutputComponents: u32,
    pub maxMeshOutputVertices: u32,
    pub maxMeshOutputPrimitives: u32,
    pub maxMeshOutputLayers: u32,
    pub maxMeshMultiviewViewCount: u32,
    pub meshOutputPerVertexGranularity: u32,
    pub meshOutputPerPrimitiveGranularity: u32,
    pub maxPreferredTaskWorkGroupInvocations: u32,
    pub maxPreferredMeshWorkGroupInvocations: u32,
    pub prefersLocalInvocationVertexOutput: VkBool32,
    pub prefersLocalInvocationPrimitiveOutput: VkBool32,
    pub prefersCompactVertexOutput: VkBool32,
    pub prefersCompactPrimitiveOutput: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMeshShaderPropertiesEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkPhysicalDeviceMeshShaderPropertiesEXT>(),
        160usize,
        concat!(
            "Size of: ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VkPhysicalDeviceMeshShaderPropertiesEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT)
        )
    );
    fn test_field_sType() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(sType)
            )
        );
    }
    test_field_sType();
    fn test_field_pNext() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pNext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(pNext)
            )
        );
    }
    test_field_pNext();
    fn test_field_maxTaskWorkGroupTotalCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTaskWorkGroupTotalCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxTaskWorkGroupTotalCount)
            )
        );
    }
    test_field_maxTaskWorkGroupTotalCount();
    fn test_field_maxTaskWorkGroupCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTaskWorkGroupCount) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxTaskWorkGroupCount)
            )
        );
    }
    test_field_maxTaskWorkGroupCount();
    fn test_field_maxTaskWorkGroupInvocations() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTaskWorkGroupInvocations) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxTaskWorkGroupInvocations)
            )
        );
    }
    test_field_maxTaskWorkGroupInvocations();
    fn test_field_maxTaskWorkGroupSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTaskWorkGroupSize) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxTaskWorkGroupSize)
            )
        );
    }
    test_field_maxTaskWorkGroupSize();
    fn test_field_maxTaskPayloadSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTaskPayloadSize) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxTaskPayloadSize)
            )
        );
    }
    test_field_maxTaskPayloadSize();
    fn test_field_maxTaskSharedMemorySize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTaskSharedMemorySize) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxTaskSharedMemorySize)
            )
        );
    }
    test_field_maxTaskSharedMemorySize();
    fn test_field_maxTaskPayloadAndSharedMemorySize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxTaskPayloadAndSharedMemorySize) as usize
                    - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxTaskPayloadAndSharedMemorySize)
            )
        );
    }
    test_field_maxTaskPayloadAndSharedMemorySize();
    fn test_field_maxMeshWorkGroupTotalCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshWorkGroupTotalCount) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxMeshWorkGroupTotalCount)
            )
        );
    }
    test_field_maxMeshWorkGroupTotalCount();
    fn test_field_maxMeshWorkGroupCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshWorkGroupCount) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxMeshWorkGroupCount)
            )
        );
    }
    test_field_maxMeshWorkGroupCount();
    fn test_field_maxMeshWorkGroupInvocations() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshWorkGroupInvocations) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxMeshWorkGroupInvocations)
            )
        );
    }
    test_field_maxMeshWorkGroupInvocations();
    fn test_field_maxMeshWorkGroupSize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshWorkGroupSize) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxMeshWorkGroupSize)
            )
        );
    }
    test_field_maxMeshWorkGroupSize();
    fn test_field_maxMeshSharedMemorySize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshSharedMemorySize) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxMeshSharedMemorySize)
            )
        );
    }
    test_field_maxMeshSharedMemorySize();
    fn test_field_maxMeshPayloadAndSharedMemorySize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshPayloadAndSharedMemorySize) as usize
                    - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxMeshPayloadAndSharedMemorySize)
            )
        );
    }
    test_field_maxMeshPayloadAndSharedMemorySize();
    fn test_field_maxMeshOutputMemorySize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshOutputMemorySize) as usize - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxMeshOutputMemorySize)
            )
        );
    }
    test_field_maxMeshOutputMemorySize();
    fn test_field_maxMeshPayloadAndOutputMemorySize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshPayloadAndOutputMemorySize) as usize
                    - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxMeshPayloadAndOutputMemorySize)
            )
        );
    }
    test_field_maxMeshPayloadAndOutputMemorySize();
    fn test_field_maxMeshOutputComponents() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshOutputComponents) as usize - ptr as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxMeshOutputComponents)
            )
        );
    }
    test_field_maxMeshOutputComponents();
    fn test_field_maxMeshOutputVertices() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshOutputVertices) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxMeshOutputVertices)
            )
        );
    }
    test_field_maxMeshOutputVertices();
    fn test_field_maxMeshOutputPrimitives() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshOutputPrimitives) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxMeshOutputPrimitives)
            )
        );
    }
    test_field_maxMeshOutputPrimitives();
    fn test_field_maxMeshOutputLayers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshOutputLayers) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxMeshOutputLayers)
            )
        );
    }
    test_field_maxMeshOutputLayers();
    fn test_field_maxMeshMultiviewViewCount() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxMeshMultiviewViewCount) as usize - ptr as usize
            },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxMeshMultiviewViewCount)
            )
        );
    }
    test_field_maxMeshMultiviewViewCount();
    fn test_field_meshOutputPerVertexGranularity() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).meshOutputPerVertexGranularity) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(meshOutputPerVertexGranularity)
            )
        );
    }
    test_field_meshOutputPerVertexGranularity();
    fn test_field_meshOutputPerPrimitiveGranularity() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).meshOutputPerPrimitiveGranularity) as usize
                    - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(meshOutputPerPrimitiveGranularity)
            )
        );
    }
    test_field_meshOutputPerPrimitiveGranularity();
    fn test_field_maxPreferredTaskWorkGroupInvocations() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPreferredTaskWorkGroupInvocations) as usize
                    - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxPreferredTaskWorkGroupInvocations)
            )
        );
    }
    test_field_maxPreferredTaskWorkGroupInvocations();
    fn test_field_maxPreferredMeshWorkGroupInvocations() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxPreferredMeshWorkGroupInvocations) as usize
                    - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(maxPreferredMeshWorkGroupInvocations)
            )
        );
    }
    test_field_maxPreferredMeshWorkGroupInvocations();
    fn test_field_prefersLocalInvocationVertexOutput() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prefersLocalInvocationVertexOutput) as usize
                    - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(prefersLocalInvocationVertexOutput)
            )
        );
    }
    test_field_prefersLocalInvocationVertexOutput();
    fn test_field_prefersLocalInvocationPrimitiveOutput() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prefersLocalInvocationPrimitiveOutput) as usize
                    - ptr as usize
            },
            148usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(prefersLocalInvocationPrimitiveOutput)
            )
        );
    }
    test_field_prefersLocalInvocationPrimitiveOutput();
    fn test_field_prefersCompactVertexOutput() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prefersCompactVertexOutput) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(prefersCompactVertexOutput)
            )
        );
    }
    test_field_prefersCompactVertexOutput();
    fn test_field_prefersCompactPrimitiveOutput() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<VkPhysicalDeviceMeshShaderPropertiesEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prefersCompactPrimitiveOutput) as usize - ptr as usize
            },
            156usize,
            concat!(
                "Offset of field: ",
                stringify!(VkPhysicalDeviceMeshShaderPropertiesEXT),
                "::",
                stringify!(prefersCompactPrimitiveOutput)
            )
        );
    }
    test_field_prefersCompactPrimitiveOutput();
}
impl Default for VkPhysicalDeviceMeshShaderPropertiesEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct VkDrawMeshTasksIndirectCommandEXT {
    pub groupCountX: u32,
    pub groupCountY: u32,
    pub groupCountZ: u32,
}
#[test]
fn bindgen_test_layout_VkDrawMeshTasksIndirectCommandEXT() {
    assert_eq!(
        ::std::mem::size_of::<VkDrawMeshTasksIndirectCommandEXT>(),
        12usize,
        concat!("Size of: ", stringify!(VkDrawMeshTasksIndirectCommandEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<VkDrawMeshTasksIndirectCommandEXT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VkDrawMeshTasksIndirectCommandEXT)
        )
    );
    fn test_field_groupCountX() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrawMeshTasksIndirectCommandEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).groupCountX) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrawMeshTasksIndirectCommandEXT),
                "::",
                stringify!(groupCountX)
            )
        );
    }
    test_field_groupCountX();
    fn test_field_groupCountY() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrawMeshTasksIndirectCommandEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).groupCountY) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrawMeshTasksIndirectCommandEXT),
                "::",
                stringify!(groupCountY)
            )
        );
    }
    test_field_groupCountY();
    fn test_field_groupCountZ() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<VkDrawMeshTasksIndirectCommandEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).groupCountZ) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(VkDrawMeshTasksIndirectCommandEXT),
                "::",
                stringify!(groupCountZ)
            )
        );
    }
    test_field_groupCountZ();
}
pub type PFN_vkCmdDrawMeshTasksEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        groupCountX: u32,
        groupCountY: u32,
        groupCountZ: u32,
    ),
>;
pub type PFN_vkCmdDrawMeshTasksIndirectEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        drawCount: u32,
        stride: u32,
    ),
>;
pub type PFN_vkCmdDrawMeshTasksIndirectCountEXT = ::std::option::Option<
    unsafe extern "C" fn(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    ),
>;
extern "C" {
    pub fn vkCmdDrawMeshTasksEXT(
        commandBuffer: VkCommandBuffer,
        groupCountX: u32,
        groupCountY: u32,
        groupCountZ: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawMeshTasksIndirectEXT(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        drawCount: u32,
        stride: u32,
    );
}
extern "C" {
    pub fn vkCmdDrawMeshTasksIndirectCountEXT(
        commandBuffer: VkCommandBuffer,
        buffer: VkBuffer,
        offset: VkDeviceSize,
        countBuffer: VkBuffer,
        countBufferOffset: VkDeviceSize,
        maxDrawCount: u32,
        stride: u32,
    );
}
